<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python全栈系列章节更新（七）：爬虫解析库</title>
      <link href="/2019/12/10/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2019/12/10/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列举几个常用的python爬虫解析库</p><blockquote><p>正则表达式<br>Xpath<br>BeautifulSoup<br>pyquery<br>Scrapy的selector的用法</p></blockquote><a id="more"></a><h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos;     默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行</span><br><span class="line">&apos;^&apos;     匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r&quot;^a&quot;,&quot;\nabc\neee&quot;,flags=re.MULTILINE)</span><br><span class="line">&apos;$&apos;     匹配字符结尾， 若指定flags MULTILINE ,re.search(&apos;foo.$&apos;,&apos;foo1\nfoo2\n&apos;,re.MULTILINE).group() 会匹配到foo1</span><br><span class="line">&apos;*&apos;     匹配*号前的字符0次或多次， re.search(&apos;a*&apos;,&apos;aaaabac&apos;)  结果&apos;aaaa&apos;</span><br><span class="line">&apos;+&apos;     匹配前一个字符1次或多次，re.findall(&quot;ab+&quot;,&quot;ab+cd+abb+bba&quot;) 结果[&apos;ab&apos;, &apos;abb&apos;]</span><br><span class="line">&apos;?&apos;     匹配前一个字符1次或0次 ,re.search(&apos;b?&apos;,&apos;alex&apos;).group() 匹配b 0次</span><br><span class="line">&apos;&#123;m&#125;&apos;   匹配前一个字符m次 ,re.search(&apos;b&#123;3&#125;&apos;,&apos;alexbbbs&apos;).group()  匹配到&apos;bbb&apos;</span><br><span class="line">&apos;&#123;n,m&#125;&apos; 匹配前一个字符n到m次，re.findall(&quot;ab&#123;1,3&#125;&quot;,&quot;abb abc abbcbbb&quot;) 结果&apos;abb&apos;, &apos;ab&apos;, &apos;abb&apos;]</span><br><span class="line">&apos;|&apos;     匹配|左或|右的字符，re.search(&quot;abc|ABC&quot;,&quot;ABCBabcCD&quot;).group() 结果&apos;ABC&apos;</span><br><span class="line">&apos;(...)&apos; 分组匹配， re.search(&quot;(abc)&#123;2&#125;a(123|45)&quot;, &quot;abcabca456c&quot;).group() 结果为&apos;abcabca45&apos;</span><br><span class="line">&apos;[...]&apos; 用来表示一组字符，单独列出，比如匹配[amk]匹配a,m或k</span><br><span class="line"> </span><br><span class="line">&apos;\A&apos;    只从字符开头匹配，re.search(&quot;\Aabc&quot;,&quot;alexabc&quot;) 是匹配不到的，相当于re.match(&apos;abc&apos;,&quot;alexabc&quot;) 或^</span><br><span class="line">&apos;\Z&apos;    匹配字符结尾，同$</span><br><span class="line">&apos;\d&apos;    匹配数字0-9</span><br><span class="line">&apos;\D&apos;    匹配非数字</span><br><span class="line">&apos;\w&apos;    匹配[A-Za-z0-9],还包括下划线‘_’</span><br><span class="line">&apos;\W&apos;    匹配非[A-Za-z0-9]</span><br><span class="line">&apos;s&apos;     匹配空白字符、\t、\n、\r , re.search(&quot;\s+&quot;,&quot;ab\tc1\n3&quot;).group() 结果 &apos;\t&apos;</span><br><span class="line">&apos;(.*?)&apos; 贪婪匹配，用来获取目标字符</span><br><span class="line">&apos;.*?&apos;   非贪婪匹配，用来替换任意非目标字符</span><br></pre></td></tr></table></figure><p>常用方法：</p><blockquote><p>re.match()</p></blockquote><p>re.match()方法会从字符串的起始位置开始匹配正则表达式，如果匹配，就返回匹配成功的结果，一旦开头不匹配，直接返回None，整个匹配失败</p><blockquote><p>re.search()</p></blockquote><p>re.search()：扫描整个字符串，然后返回第一个成功匹配的结果</p><blockquote><p>re.findall()</p></blockquote><p>re.findall()：把所有匹配到的字符放到以列表中的元素返回，返回的列表中的每一个元素都是元组类型</p><blockquote><p>re.sub()</p></blockquote><p>re.sub(‘a’,’b’,content) ,即在content中，用b替换a的内容</p><blockquote><p>re.compile()</p></blockquote><p>compile()方法将正则表达式字符串编译成正则表达式对象，以便在后面的匹配中复用</p><blockquote><p>修饰符</p></blockquote><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.M</td><td>多行匹配</td></tr><tr><td>re.S</td><td>使.匹配包括换行在内的所有字符</td></tr></tbody></table><h2 id="2-xpath"><a href="#2-xpath" class="headerlink" title="2.xpath"></a>2.xpath</h2><p>1.导入相关库包<br>from lxml import etree<br>2.初始化<br>html = etree.HTML(response.text)<br>3.常用规则</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从根节点选取</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档的节点，而不考虑它们的位置</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><table><thead><tr><th>路径表达式</th><th>描述</th></tr></thead><tbody><tr><td>bookstore</td><td>选取 bookstore 元素的所有子节点</td></tr><tr><td>/bookstore</td><td>选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td>bookstore/book</td><td>选取属于 bookstore 的子元素的所有 book 元素</td></tr><tr><td>//book</td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td>bookstore//book</td><td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td></tr><tr><td>//@lang</td><td>选取名为 lang 的所有属性。</td></tr><tr><td>/bookstore/book[1]</td><td>选取属于 bookstore 子元素的第一个 book 元素。索引默认从1开始</td></tr><tr><td>/bookstore/book[last()]</td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td>/bookstore/book[last()-1]</td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td>/bookstore/book[position()&lt;3]</td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td>//title[@lang]</td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td>//title[@lang=’eng’]</td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td>/bookstore/book[price&gt;35.00]</td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td>/bookstore/book[price&gt;35.00]/title</td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><h2 id="3-pyquery"><a href="#3-pyquery" class="headerlink" title="3.pyquery"></a>3.pyquery</h2><blockquote><p>导入相关库包</p></blockquote><p>from pyquery import PyQuery as pq</p><blockquote><p>初始化工作</p></blockquote><p>doc = pq(html)字符串初始化<br>doc = pq(url)URL初始化<br>doc = pq(filename=””)文件初始化<br>print(doc(‘li’))</p><blockquote><p>css选择器</p></blockquote><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>id选择器</td><td>使用#</td></tr><tr><td>class选择器</td><td>使用.</td></tr><tr><td>标签选择器</td><td>直接使用标签，什么都不加</td></tr><tr><td>*</td><td>选择所有元素</td></tr><tr><td>p</td><td>选择所有p标签</td></tr><tr><td>div,p</td><td>选择所有的div和p标签（并集）</td></tr><tr><td>div p</td><td>选择div下的所有p标签（子集）</td></tr></tbody></table><blockquote><p>pyquery获取信息</p></blockquote><p>1.获取属性值：变量名.attr(属性名) 或者 变量名.attr.属性名<br>2.获取文本内容：变量名.text()<br>3.获取html： 变量名.html()<br>4.<font color=#ef4136>找寻某一特定标签：变量名.find(标签名).eq(n) n从0开始，表示find某标签，并选择第n个目标值</font></p><h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h3>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解析库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究密码加salt原理以及PHP防止SQL注入</title>
      <link href="/2019/12/08/%E6%B5%85%E8%B0%88%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%8E%9F%E7%90%86/"/>
      <url>/2019/12/08/%E6%B5%85%E8%B0%88%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，一些小网站，小公司对于用户的账号密码很大概率是对其进行散列处理。我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如某MD5密码破解网站），得到某用户的密码。</p><a id="more"></a><h3 id="1-加salt原理"><a href="#1-加salt原理" class="headerlink" title="1.加salt原理"></a>1.加salt原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：<font color=#5CACEE>当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，以确定密码是否正确。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的“佐料”被称作“Salt值”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。</p><h3 id="2-加密示例（以PHP为例，python同理调用hashlib库）"><a href="#2-加密示例（以PHP为例，python同理调用hashlib库）" class="headerlink" title="2.加密示例（以PHP为例，python同理调用hashlib库）"></a>2.加密示例（以PHP为例，python同理调用hashlib库）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">hash</span><span class="params">($a)</span> </span>&#123;</span></span><br><span class="line"><span class="php">    $salt=”Random_KUGBJVY”;  <span class="comment">//定义一个salt值，程序员规定下来的随机字符串</span></span></span><br><span class="line"><span class="php">    $b=$a.$salt;  <span class="comment">//把密码和salt连接,</span></span></span><br><span class="line"><span class="php">    $b=md5($b);  <span class="comment">//执行MD5散列</span></span></span><br><span class="line"><span class="php">    <span class="keyword">return</span> $b;  <span class="comment">//返回散列   </span></span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里的加salt处理方式有很多种，程序员按要求自定义，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$salt=”Random_KUGBJVY”;</span><br><span class="line">$b=$a.$salt;</span><br><span class="line">$b1=$salt.$a.$salt;</span><br><span class="line">$b2=$salt.md5($a.$salt);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>调用方式：$new_password=hash($_POST[password]);   //这里接受表单提交值，并进行加密</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户注册时：用户输入【账号】和【密码】（以及其他用户信息）；系统为用户生成【Salt值】；系统将【Salt值】和【用户密码】连接到一起；对连接后的值进行散列，得到【Hash值】；将【Hash值1】和【Salt值】分别放到数据库中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户登录时：用户输入【账号】和【密码】；系统通过用户名找到与之对应的【Hash值】和【Salt值】；系统将【Salt值】和【用户输入的密码】连接到一起；对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。<br><font color=#5CACEE>有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值</font></p><h3 id="3-php基本语法知识-参考FioraLove的GitHub"><a href="#3-php基本语法知识-参考FioraLove的GitHub" class="headerlink" title="3.php基本语法知识,参考FioraLove的GitHub"></a>3.php基本语法知识,<a href="https://github.com/FioraLove/HTML-CSS-JavaScript/blob/master/PHP/README.md" target="_blank" rel="noopener">参考FioraLove的GitHub</a></h3><blockquote><p>1.为什么要使用PDO：增加数据库连接扩展，是程序连接数据库的方法之一</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDO是PHP5新加入的一个重大功能，我们的数据库服务器为MySQL，所有的程序代码的数据库操作全是一mysql(）或者mysqli()函数来操作，当我们的数据库 需要更换时比如换成，SQL、SERVER、PostgreSQL、MS 等，我们不可能去修改所有的程序代码！所以就要用到PDO，PDO很好的帮我们解决了这个问题，使用PDO操作非常方便，只需要修改数据源格式，和加载相应的驱动文件到PHP.ini即可；</p><blockquote><p>2.PDO连接数据库`<a href="https://blog.csdn.net/jia_1418422386/article/details/80394840" target="_blank" rel="noopener">PDO(php data object)</a>连接MySQL</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    方式一：借由mysqli</span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span> </span></span><br><span class="line"><span class="php">        $servername = <span class="string">'localhost'</span>;</span></span><br><span class="line"><span class="php">        $username = <span class="string">'username'</span>;</span></span><br><span class="line"><span class="php">        $password = <span class="string">'password'</span>;</span></span><br><span class="line"><span class="php">        $db_name = <span class="string">'NMSL'</span>;</span></span><br><span class="line"><span class="php">        <span class="comment">// 创建连接</span></span></span><br><span class="line"><span class="php">        $conn = mysqli($servername, $username, $password,$db_name); </span></span><br><span class="line"><span class="php">        <span class="comment">// 检测连接</span></span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!$conn) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">die</span>(<span class="string">"Connection failed: "</span> . mysqli_error());</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"连接成功"</span>;</span></span><br><span class="line"><span class="php">    <span class="meta">?&gt;</span></span></span><br><span class="line">    方式二：PDO   </span><br><span class="line">    $DSN = 'mysql:host=localhost;dbname=demo;charset=utf-8';</span><br><span class="line">    $pdo = new PDO($DSN,'username','password');  // 表示已连接了数据库</span><br><span class="line"> ```   </span><br><span class="line">&gt;3.设置PDO在处理数据的过程中采用什么方式去处理</span><br><span class="line"> ```html</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    setAttribute()方法是设置部分属性，主要属性有：PDO::ATTR_CASE、PDO::ATTR_ERRMODE等，我们设置的是PDO::ATTR_CASE(使用关联索引获取数据)</span><br><span class="line">    </span><br><span class="line">    PDO::ATTR_CASE：强制列名为指定的大小写。他的$value可为：</span><br><span class="line">    </span><br><span class="line">    　　PDO::CASE_LOWER：强制列名小写。</span><br><span class="line">    </span><br><span class="line">    　　PDO::CASE_NATURAL：保留数据库驱动返回的列名。</span><br><span class="line">    </span><br><span class="line">    　　PDO::CASE_UPPER：强制列名大写。</span><br><span class="line">   </span><br><span class="line">    PDO::ATTR_ERRMODE：错误报告。他的$value可为：</span><br><span class="line">    </span><br><span class="line">    　　PDO::ERRMODE_SILENT： 仅设置错误代码。</span><br><span class="line">    </span><br><span class="line">    　　PDO::ERRMODE_WARNING: 引发 E_WARNING 错误</span><br><span class="line">    </span><br><span class="line">    　　PDO::ERRMODE_EXCEPTION: 抛出 exceptions 异常。</span><br><span class="line">    </span><br><span class="line">    PDO::ATTR_ORACLE_NULLS （在所有驱动中都可用，不仅限于Oracle）： 转换 NULL 和空字符串。他的$value可为：</span><br><span class="line">    </span><br><span class="line">    　　PDO::NULL_NATURAL: 不转换。</span><br><span class="line">    </span><br><span class="line">    　　PDO::NULL_EMPTY_STRING： 将空字符串转换成 NULL 。</span><br><span class="line">    </span><br><span class="line">    　　PDO::NULL_TO_STRING: 将 NULL 转换成空字符串。</span><br><span class="line">``` </span><br><span class="line">&gt; 4.数据库操作：exec(不返回数据集，即insert，update，delete)与query(仅执行带结果返回的，即select)方法</span><br><span class="line">```html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">    <span class="comment">/* 连接数据库*/</span></span></span><br><span class="line"><span class="php">    $DSN = <span class="string">'mysql:host=localhost;dbname=demo;charset=utf-8'</span>;</span></span><br><span class="line"><span class="php">    $pdo = <span class="keyword">new</span> PDO($DSN,<span class="string">'username'</span>,<span class="string">'password'</span>); </span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="comment">/*  删除 FRUIT 数据表中满足条件的所有行~exec方法 */</span></span></span><br><span class="line"><span class="php">    $count = $pdo-&gt;exec(<span class="string">"DELETE FROM fruit WHERE colour = 'red'"</span>);</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="comment">/* 返回被删除的行数 */</span></span></span><br><span class="line"><span class="php">    <span class="keyword">print</span>(<span class="string">"Deleted $count rows.\n"</span>);</span></span><br><span class="line"><span class="php">    <span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h3>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> salt </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兄弟萌！枯啦，要恰不了饭了</title>
      <link href="/2019/12/08/%E6%81%B0%E9%A5%AD%E5%8D%B1%E6%9C%BA/"/>
      <url>/2019/12/08/%E6%81%B0%E9%A5%AD%E5%8D%B1%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，怎么办？我要枯啦，要恰不了饭了，要吃红牌出场了</p><a id="more"></a><p>最近一直没有什么活干，每天就是混吃等死，建彬哥说也没有什么我能做的项目，呀！糟了呀，以前一直打趣说“你有你的好果子吃”，现在才明白过来，原来是我才没有好果子吃。<br>而且就目前的市场和我最近咸鱼，我也感觉我要直接吃红牌了，看不到生活的希望（55555。。。）<br>算了吧！！走一步算一步，做好心理准备，每天使劲多学一些，也不至于打包回家的时候那么狼狈，现在回想起来，15年做决定的时候是不是选对了？是当时脑瘫了？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS易忘点</title>
      <link href="/2019/12/06/html%E4%B8%8Ecss/"/>
      <url>/2019/12/06/html%E4%B8%8Ecss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HTML是网页内容的载体。<br>CSS样式是表现。<br>JavaScript是用来实现网页上的特效效果与交互。</p></blockquote><a id="more"></a><h3 id="1-postion属性"><a href="#1-postion属性" class="headerlink" title="1.postion属性"></a>1.postion属性</h3><blockquote><p>postion:relative是相对定位</p></blockquote><p>是相对于前面的容器定位的。这个时候不能用top left在定位,应该用margin。它可以随窗口大小变化。但大小仍然不会变。要是你设置成width:100%;height:100%;这样就会随着窗口变大变小</p><blockquote><p>postion:absolute是绝对定位</p></blockquote><p>是相对于浏览器的定位，释放自己的位置，以网页坐标原点做一个新的坐标，它不会随着窗口大小变化，只是固定在一个特定的坐标轴上<br>比如：position：absolute；left:20px;top:80px; 这个容器始终位于距离浏览器左20px,距离浏览器上80px的这个位置。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python全栈系列章节更新（六）：装饰器</title>
      <link href="/2019/12/05/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AD%EF%BC%89%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2019/12/05/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AD%EF%BC%89%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让爬虫像人一样打卡工作，工作还得有快有慢，wtf，想了半天，写个装饰器算了，也顺便复习下装饰器，也能基本能满足需求：<br>其实也可以使用<br><font color=#ef4136><br>1.轻量级的Python定时任务调度框架（<a href="https://www.cnblogs.com/Neeo/p/10435059.html" target="_blank" rel="noopener">APSchedule库</a>）<br>2.Linux的定时任务<br>3.文件数多，还要做监控和扩展之类的话，用 Flask 写一个服务，将 Apscheduler 和 Scrapyd 继承到服务中，这样就是一个完整的爬虫项目部署和调度管理平台了<br></font></p><a id="more"></a><p>装饰器原理：不修改已实现的功能代码块，不改变原函数调用方式，只对现有功能进行扩展</p><h2 id="装饰器案例"><a href="#装饰器案例" class="headerlink" title="装饰器案例"></a>装饰器案例</h2><p>举一个简单的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(func)</span>:</span>  <span class="comment"># 装饰器接受一个函数作为参数，并返回一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># (*args, **kwargs)表示带参数的装饰器</span></span><br><span class="line">        print(<span class="string">'call %s(): '</span> % func.__name__)  <span class="comment"># 魔法函数，返回函数名</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@test  # 运用@语法把装饰器放置在函数定义处</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    print(<span class="string">"%s:%s"</span>%(a,b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    now(<span class="string">"hello"</span>,<span class="string">"world"</span>)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :return</span></span><br><span class="line"><span class="string">    call now(): </span></span><br><span class="line"><span class="string">    hello:world </span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><h2 id="爬虫波动性工作装饰器函数"><a href="#爬虫波动性工作装饰器函数" class="headerlink" title="爬虫波动性工作装饰器函数"></a>爬虫波动性工作装饰器函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,datetime,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jobstatus</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    爬虫的工作状态装饰器</span></span><br><span class="line"><span class="string">    周一至周五</span></span><br><span class="line"><span class="string">    09:00-18:00</span></span><br><span class="line"><span class="string">    小时数是偶数</span></span><br><span class="line"><span class="string">    每分钟请求30次左右</span></span><br><span class="line"><span class="string">    小时数是奇数</span></span><br><span class="line"><span class="string">    每分钟请求10次左右</span></span><br><span class="line"><span class="string">    其余时间等待</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            week_now = datetime.datetime.now().weekday()</span><br><span class="line">            hour_now = datetime.datetime.now().hour  <span class="comment"># 14</span></span><br><span class="line">            <span class="comment"># 判断当前星期是否为工作日</span></span><br><span class="line">            <span class="keyword">if</span> week_now <span class="keyword">in</span> list(range(<span class="number">1</span>,<span class="number">6</span>)):</span><br><span class="line">            <span class="comment"># 判断当前时间是否为工作时间</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">9</span> &lt;= hour_now &lt;= <span class="number">18</span>:</span><br><span class="line">                    <span class="keyword">if</span> hour_now % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                        time.sleep(random.choice([<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line">                        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        time.sleep(random.choice([<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line">                        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#</span></span><br><span class="line">                    time.sleep(<span class="number">3600</span>*<span class="number">16</span>)</span><br><span class="line">            <span class="comment"># 休眠24小时</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                time.sleep(<span class="number">86400</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器 </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echarts</title>
      <link href="/2019/12/05/echarts/"/>
      <url>/2019/12/05/echarts/</url>
      
        <content type="html"><![CDATA[<p><font color=#ef4136>简而言之，百度Echarts真的是数据展示的神器，官方给出的实例就能够满足实际基本要求</font></p><blockquote><p>1.echarts创建实例<br>2.<br><img src="https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesecharts.JPG" style="height:300px"></p></blockquote><a id="more"></a><h3 id="1-引入ECharts"><a href="#1-引入ECharts" class="headerlink" title="1.引入ECharts"></a>1.引入ECharts</h3><p>通过标签方式直接引入构建好的 echarts 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 ECharts 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-为-ECharts-准备一个具备高宽的-DOM-容器"><a href="#2-为-ECharts-准备一个具备高宽的-DOM-容器" class="headerlink" title="2.为 ECharts 准备一个具备高宽的 DOM 容器"></a>2.为 ECharts 准备一个具备高宽的 DOM 容器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width: 600px;height:400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-echarts-init-方法初始化一个-echarts-实例并通过-setOption-方法生成一个简单的柱状图"><a href="#3-echarts-init-方法初始化一个-echarts-实例并通过-setOption-方法生成一个简单的柱状图" class="headerlink" title="3. echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图"></a>3. echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图</h3><p>完整案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ECharts<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 echarts.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width: 600px;height:400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main'</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 指定图表的配置项和数据</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> option = &#123;</span></span><br><span class="line">            title: &#123;</span><br><span class="line"><span class="actionscript">                text: <span class="string">'ECharts 入门示例'</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            tooltip: &#123;&#125;,</span><br><span class="line">            legend: &#123;</span><br><span class="line"><span class="actionscript">                data:[<span class="string">'销量'</span>]</span></span><br><span class="line">            &#125;,</span><br><span class="line">            xAxis: &#123;</span><br><span class="line"><span class="actionscript">                data: [<span class="string">"衬衫"</span>,<span class="string">"羊毛衫"</span>,<span class="string">"雪纺衫"</span>,<span class="string">"裤子"</span>,<span class="string">"高跟鞋"</span>,<span class="string">"袜子"</span>]</span></span><br><span class="line">            &#125;,</span><br><span class="line">            yAxis: &#123;&#125;,</span><br><span class="line">            series: [&#123;</span><br><span class="line"><span class="actionscript">                name: <span class="string">'销量'</span>,</span></span><br><span class="line"><span class="actionscript">                type: <span class="string">'bar'</span>,</span></span><br><span class="line">                data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 使用刚指定的配置项和数据显示图表。</span></span></span><br><span class="line"><span class="vbscript">        myChart.setOption(<span class="keyword">option</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-异步加载"><a href="#4-异步加载" class="headerlink" title="4.异步加载"></a>4.异步加载</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 ECharts 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pie"</span> <span class="attr">style</span>=<span class="string">"width: 600px;height:400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> myChart1 = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'pie'</span>));</span></span><br><span class="line">myChart1.showLoading();</span><br><span class="line"><span class="actionscript">setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">    myChart1.hideLoading();</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="comment">&lt;!---这里面进行数据绑定与实例化图表 --&gt;</span></span></span></span><br><span class="line">    myChart1.setOption(&#123;</span><br><span class="line">            series : [</span><br><span class="line">                &#123;</span><br><span class="line"><span class="actionscript">                    name: <span class="string">'访问来源'</span>,</span></span><br><span class="line"><span class="actionscript">                    type: <span class="string">'pie'</span>,</span></span><br><span class="line"><span class="actionscript">                    radius: <span class="string">'55%'</span>,</span></span><br><span class="line">                    data:[</span><br><span class="line"><span class="actionscript">                        &#123;value:<span class="number">235</span>, name:<span class="string">'视频广告'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                        &#123;value:<span class="number">274</span>, name:<span class="string">'联盟广告'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                        &#123;value:<span class="number">310</span>, name:<span class="string">'邮件营销'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                        &#123;value:<span class="number">335</span>, name:<span class="string">'直接访问'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                        &#123;value:<span class="number">400</span>, name:<span class="string">'搜索引擎'</span>&#125;</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,1000);    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-移动端自适应"><a href="#5-移动端自适应" class="headerlink" title="5.移动端自适应"></a>5.移动端自适应</h3><p>1.为Echarts准备一个具有宽高(有一个即可)的DOM，推荐使用bootstrap的栅栏系统来设置布局<br>2.大部分的组件和系列的left/right/top/bottom/width/height的定位方式</p><ul><li>绝对值，用number形式书写（已经固定写死了浏览器的像素）</li><li>百分比，表示占DOM容器的宽高的百分之多少，用string形式书写</li><li>位置描述，即center（水平居中），middle（垂直居中）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python全栈系列章节更新（五）：并发编程~多线程</title>
      <link href="/2019/12/04/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2019/12/04/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>线程顾名思义，就是一条流水线工作的过程（流水线的工作需要电源，电源就相当于cpu），而一条流水线必须属于一个车间，一个车间的工作过程是一个进程，车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一条流水线。<br>所以，<font color=#ef4136>进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位</font></p><blockquote><p>1.线程与进程的区别<br>2.为何会选择多线程<br>3.创建多线程的方式<br>4.线程对象的属性和方法<br>5.守护线程<br>6.线程池与进程池</p></blockquote><a id="more"></a><h3 id="1-线程与进程的区别"><a href="#1-线程与进程的区别" class="headerlink" title="1.线程与进程的区别"></a>1.线程与进程的区别</h3><p>1、每启动一个进程，进程内都至少有一个线程。</p><p>　　2、进程本身只是一个资源调度集合，并不能真正执行，进程内开的线程才是真正的运行单位。</p><p>　　3、一个进程内可以启动多个线程，同一进程内线程间共享资源。</p><p><font color=#ef4136>4、启动线程的开销远远小于开进程。</font></p><p>　　5、线程可以相当程度控制相同进程下的线程，进程只能控制其子进程。</p><p>　　6、对主线程的更改（取消、优先级更改等）可能会进程的其他线程的行为；对父进程的修改则不会影响子进程。</p><p>   7、进程之间是竞争关系，线程之间是协作关系 </p><h3 id="2-为何会选择多线程？"><a href="#2-为何会选择多线程？" class="headerlink" title="2.为何会选择多线程？"></a>2.为何会选择多线程？</h3><ol><li><p>同一个进程内的多个线程共享该进程内的地址资源</p></li><li><p>线程比进程更轻量级，线程比进程更容易创建可撤销</p></li></ol><h3 id="3-创建线程的方式"><a href="#3-创建线程的方式" class="headerlink" title="3.创建线程的方式"></a>3.创建线程的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">piao</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s piaoing'</span> % name)</span><br><span class="line">    time.sleep(random.randrange(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">    print(<span class="string">'%s piao end'</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = Thread(target=piao, args=(<span class="string">'egon'</span>, ))</span><br><span class="line">    t1.start()  <span class="comment"># 主线程向操作系统发信号，又开了一个线程</span></span><br><span class="line">    print(<span class="string">"主线程"</span>)   <span class="comment"># 执行角度看是主线程，从资源角度看是主进程</span></span><br><span class="line"><span class="comment"># 这个程序总体是一个进程、两个线程</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">egon piaoing</span></span><br><span class="line"><span class="string">主线程</span></span><br><span class="line"><span class="string">egon piao end</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="4-线程对象的属性和方法"><a href="#4-线程对象的属性和方法" class="headerlink" title="4.线程对象的属性和方法"></a>4.线程对象的属性和方法</h3><blockquote><p>4.1 Thread实例对象的方法</p></blockquote><p>isAlive():返回线程是否活动的<br>getName():返回线程名<br>setName():设置线程名</p><h3 id="5-守护线程"><a href="#5-守护线程" class="headerlink" title="5.守护线程"></a>5.守护线程</h3><p>守护线程守护主线程，等到主线程死了才会被销毁。在有其他线程的情况下，主线程代码运行完后，等其他非守护线程结束，守护线程才会死掉。</p><p>　　无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行。运行完毕的真正含义：<br><font color=#ef4136><br>　　1、对主进程来说，运行完毕指的是主进程代码运行完毕。</p><p>　　2、对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才能运行完毕。</font></p><h3 id="6-进程池和线程池"><a href="#6-进程池和线程池" class="headerlink" title="6.进程池和线程池"></a>6.进程池和线程池</h3><p>进程池和线程池的接口一模一样，用法也一样。池就是要对数目加以限制，保证机器一个可承受的范围，以一个健康的状态保证它的运行<br>基本方法：<br>1、submit(fn, <em>args, *</em>kwargs)<br>异步提交任务</p><p>2、map(func, *iterables, timeout=None, chunksize=1)<br>取代for循环submit的操作</p><p>3、shutdown(wait=True)<br>相当于进程池的pool.close()+pool.join()操作<br>wait=True，等待池内所有任务执行完毕回收完资源后才继续<br>wait=False，立即返回，并不会等待池内的任务执行完毕<br>但不管wait参数为何值，整个程序都会等到所有任务执行完毕<br>submit和map必须在shutdown之前</p><p>4、result(timeout=None)<br>取得结果</p><p>5、add_done_callback(fn)<br>回调函数</p><blockquote><p>进程池</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor,ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"name: %s pid: %s run"</span> % (name, os.getpid()))</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)    <span class="comment"># 指定进程池大小，最大进程数，如果不指定默认是CPU核数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="string">"""从始至终四个进程解决这10个任务，谁没事了接新任务"""</span></span><br><span class="line">        pool.submit(task, <span class="string">'egon%s'</span> %i)   <span class="comment"># 提交任务的方式————异步调用：提交完任务，不用在原地等任务执行拿到结果。</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"主进程"</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">name: egon0 pid: 12445 run</span></span><br><span class="line"><span class="string">name: egon1 pid: 12444 run</span></span><br><span class="line"><span class="string">name: egon2 pid: 12446 run</span></span><br><span class="line"><span class="string">name: egon3 pid: 12447 run</span></span><br><span class="line"><span class="string">主进程</span></span><br><span class="line"><span class="string">name: egon4 pid: 12445 run</span></span><br><span class="line"><span class="string">name: egon5 pid: 12444 run</span></span><br><span class="line"><span class="string">name: egon6 pid: 12446 run</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><blockquote><p>shutdown()方法的使用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor,ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"name: %s pid: %s run"</span> % (name, os.getpid()))</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)    <span class="comment"># 指定进程池大小，最大进程数，如果不指定默认是CPU核数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="string">"""从始至终四个进程解决这10个任务，谁没事了接新任务"""</span></span><br><span class="line">        pool.submit(task, <span class="string">'egon%s'</span> %i)   <span class="comment"># 提交任务的方式————异步调用：提交完任务，不用在原地等任务执行拿到结果。</span></span><br><span class="line"></span><br><span class="line">    pool.shutdown()   <span class="comment"># 把提交任务入口关闭，默认参数wait=True；同时还进行了pool.join()操作，等任务提交结束，再结束主进程</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"主进程"</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">name: egon0 pid: 12502 run</span></span><br><span class="line"><span class="string">name: egon1 pid: 12503 run</span></span><br><span class="line"><span class="string">....</span></span><br><span class="line"><span class="string">name: egon9 pid: 12505 run</span></span><br><span class="line"><span class="string">主进程</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句关于时间的讨论</title>
      <link href="/2019/12/04/thinkphp(%E4%BA%8C)/"/>
      <url>/2019/12/04/thinkphp(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p><font color=#ef4136>进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位</font></p><blockquote><p>1.oracle时间和日期的处理<br>2.mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写</p></blockquote><a id="more"></a><h3 id="1-oracle时间和日期的处理，详情请点击此处"><a href="#1-oracle时间和日期的处理，详情请点击此处" class="headerlink" title="1.oracle时间和日期的处理，详情请点击此处"></a>1.oracle时间和日期的处理，<a href="https://www.cnblogs.com/xuhai/p/9949464.html" target="_blank" rel="noopener">详情请点击此处</a></h3><blockquote><p>1.字符串转换为日期时分秒格式：to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’)</p></blockquote><p>select to_date(‘20180831154546’, ‘yyyy-mm-dd hh24:mi:ss’) from dual;<br>结果为：2018-08-31 15:45:46</p><blockquote><p>2.获取系统时间</p></blockquote><p>SELECT SYSDATE FROM  dual;  – 系统时间:2019-12-04 21:40:15</p><p>SELECT SYSTIMESTAMP FROM  dual;  – 当前系统时间戳:2019-12-04 21:40:41.328000 +08:00</p><blockquote><p>3.时间类型与字符串相互转换</p></blockquote><p>字符串转换为时间类型：to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’);</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符串转时间类型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">'2018-08-23 00:00:00'</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 时间类型转字符串</span></span><br><span class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_char(<span class="keyword">sysdate</span>,<span class="string">'yyyy-mm-dd'</span>) <span class="keyword">from</span> dual;</span><br><span class="line">``` </span><br><span class="line">&gt; 4.日期的加减</span><br><span class="line"></span><br><span class="line">如果时间要进行加减，和现在的时间或者某个目标时间进行比较。</span><br><span class="line"></span><br><span class="line">to_date(字符串, 'yyyy-mm-dd hh24:mi:ss')+1</span><br><span class="line"></span><br><span class="line">后面为1的时候就是加1天，2的时候就是加两天，如果加一个小时，就是为1/24，如果加一分钟，就是为1/24/60,...</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="comment">-- 案例：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">to_date</span>(<span class="string">'2019-02-18 23:59:00'</span>,<span class="string">'yyyy-mm-dd hh24-mi-ss'</span>)+<span class="number">1</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- 加一天 2019-02-19 23:59:00</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">to_date</span>(<span class="string">'2019-02-18 23:59:00'</span>,<span class="string">'yyyy-mm-dd hh24-mi-ss'</span>)+<span class="number">1</span>/<span class="number">24</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- 加一个小时 2019-02-19 00:59:00</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">to_date</span>(<span class="string">'2019-02-18 23:59:00'</span>,<span class="string">'yyyy-mm-dd hh24-mi-ss'</span>)+<span class="number">1</span>/<span class="number">24</span>/<span class="number">60</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- 加一分钟 2019-02-19 00:00:00</span></span><br></pre></td></tr></table></figure><h3 id="2-MySQL的时间与日期的处理"><a href="#2-MySQL的时间与日期的处理" class="headerlink" title="2.MySQL的时间与日期的处理"></a>2.MySQL的时间与日期的处理</h3><blockquote><p>mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写</p></blockquote><p>– 今天<br>SELECT 【想要的字段】 FROM 【表名】 WHERETO_DAYS(【时间字段名】) =TO_DAYS(now());</p><p>– 昨天<br>SELECT 【想要的字段】 FROM 【表名】 WHERE TO_DAYS( NOW( ) ) - TO_DAYS(【时间字段名】) = 1;</p><p>– 近七天<br>SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;=DATE(【时间字段名】);</p><p>– 本周内<br>SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now());</p><p>– 上一周<br>SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now())-1;</p><p>– 30天内 注意这个不是本月是从当天起向前推30天<br>SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;=DATE(【时间字段名】);</p><p>– 本月<br>SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) = DATE_FORMAT( CURDATE( ) , ‘%Y%m’ );</p><p>– 上一个月<br>SELECT 【想要的字段】 FROM 【表名】 WHERE PERIOD_DIFF( DATE_FORMAT( now( ) , ‘%Y%m’ ) , DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) ) =1;</p><p>– 本季度<br>SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(now());</p><p>– 上一季度<br>SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(DATE_SUB(now(),interval 1 QUARTER));</p><p>– 本年度<br>SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(NOW());</p><p>– 上一年度<br>SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(date_sub(now(),interval 1 YEAR)); </p><h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="- 未完待续。。。"></a>- 未完待续。。。</h3>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python全栈系列章节更新（四）：并发编程~多进程</title>
      <link href="/2019/12/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/"/>
      <url>/2019/12/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-进程与程序"><a href="#1-进程与程序" class="headerlink" title="1.进程与程序"></a>1.进程与程序</h2><p>程序仅仅是一堆代码，进程指的是程序的运行过程<br>注意：同一个程序执行两次，也是两个进程<br>进程：正在进行的一个过程，是一个任务，或者说是一个资源调度的集合。</p><h2 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2.并发与并行"></a>2.并发与并行</h2><p>无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真实干活的是cpu，cpu来做这些任务，而<font color=#1d953f>一个cpu同一时刻只能执行一个任务。</font><br><font color=#1d953f><br>　　一、并发：伪并行，即看起来多个进程像在同时运行。单个cpu+多道技术可实现并发。</p><p>　　二、并行：多个进程同时运行，只有具备多个cpu才能实现。</font><br><fancybox><img src="https://images2018.cnblogs.com/blog/1311506/201805/1311506-20180506164225499-509092524.png" alt="并发，并行，串行"></fancybox></p><h2 id="3-多进程的创建：Process类"><a href="#3-多进程的创建：Process类" class="headerlink" title="3.多进程的创建：Process类"></a>3.多进程的创建：Process类</h2><p><font color=#1d953f>注意：在windows中Process()必须放到# if __name__ == &#39;__main__&#39;:下</font><br>进程创建格式：target表示函数名，args=(参数一,参数二,…,)，参数最后一定要保留一个逗号<br>p = Process(target=task, args=(‘子进程1’,))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"%s is running"</span> % name)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"%s is done"</span> % name)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建进程    </span></span><br><span class="line">    p = Process(target=task, args=(<span class="string">'子进程1'</span>,))  <span class="comment"># 得到对象</span></span><br><span class="line">    <span class="comment"># 启动进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"这是主进程"</span>)</span><br></pre></td></tr></table></figure><h3 id="3-1-Process类的方法和属性介绍"><a href="#3-1-Process类的方法和属性介绍" class="headerlink" title="3.1 Process类的方法和属性介绍"></a>3.1 Process类的方法和属性介绍</h3><table><thead><tr><th>方法</th><th align="center">详解</th></tr></thead><tbody><tr><td>p.start()：</td><td align="center">启动进程，并调用该子进程中的p.run()</td></tr><tr><td>p.run():</td><td align="center">进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法</td></tr><tr><td>p.terminate():</td><td align="center">强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</td></tr><tr><td>p.is_alive():</td><td align="center">如果p仍然运行，返回True</td></tr><tr><td>p.join([timeout]):</td><td align="center">主线程等待p线程终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间</td></tr><tr><td>Process属性</td><td align="center">详解</td></tr><tr><td>p.daemon：</td><td align="center">默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置</td></tr><tr><td>p.name:</td><td align="center">进程的名称</td></tr><tr><td>p.pid：</td><td align="center">进程的pid</td></tr><tr><td>p.exitcode:</td><td align="center">进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</td></tr><tr><td>p.authkey:</td><td align="center">进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串</td></tr></tbody></table><h3 id="3-2-进程之间的内存空间是隔离的"><a href="#3-2-进程之间的内存空间是隔离的" class="headerlink" title="3.2 进程之间的内存空间是隔离的"></a>3.2 进程之间的内存空间是隔离的</h3><h3 id="3-3-Process对象的join方法"><a href="#3-3-Process对象的join方法" class="headerlink" title="3.3 Process对象的join方法"></a>3.3 Process对象的join方法</h3><ol><li><p>join方法：优先运行子进程，主进程卡在原地，子进程结束后，运行主进程后面的代码。案例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'%s is running, parent id is &lt;%s&gt;'</span> % (os.getpid(), os.getppid()))   <span class="comment"># 进程和父进程查看方式</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"%s is done, parent id is &lt;%s&gt;"</span> % (os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=task, )</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    p.join()   <span class="comment"># 优先运行子进程，主进程卡在原地</span></span><br><span class="line">    print(<span class="string">'主进程'</span>, os.getpid(), <span class="string">'pycharm ID'</span>, os.getppid())</span><br><span class="line">    print(p.pid)  <span class="comment"># 子进程运行完，变为僵尸进程，主进程仍能够查到子进程的pid，当主进程结束后，所有僵尸子进程将被丢掉。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">is running, parent id is &lt;827&gt;</span></span><br><span class="line"><span class="string">is done, parent id is &lt;827&gt;</span></span><br><span class="line"><span class="string">主进程 827 pycharm ID 504</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li><li><p>使用join方法实现并发执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name ,n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s is running'</span> % name)</span><br><span class="line">    time.sleep(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    p1 = Process(target=task, args=(<span class="string">"子进程1"</span>,<span class="number">5</span>,))</span><br><span class="line">    p2 = Process(target=task, args=(<span class="string">"子进程2"</span>,<span class="number">3</span>,))</span><br><span class="line">    p3 = Process(target=task, args=(<span class="string">"子进程3"</span>,<span class="number">2</span>,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    <span class="comment"># 再添加join函数前，主程序的执行输出次序是完全随机的，需要加join()保证主程序等到在子进程之后执行完成</span></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    <span class="comment"># 以上并非串行执行，实际是并发执行，只是约束了主程序要等在子程序后结束</span></span><br><span class="line">    <span class="comment"># print('主进程', os.getpid(), 'pycharm ID', os.getppid())</span></span><br><span class="line">    print(<span class="string">"主进程"</span>, (time.time()-start))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">子进程1 is running</span></span><br><span class="line"><span class="string">子进程2 is running</span></span><br><span class="line"><span class="string">子进程3 is running</span></span><br><span class="line"><span class="string">主进程 5.010260343551636   # 主程序只等了5秒，说明确实是并发执行</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li><li><p>使用join方法实现多进程串行执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(name ,n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=task, args=(<span class="string">"子进程1"</span>,<span class="number">5</span>))</span><br><span class="line">    p2 = Process(target=task, args=(<span class="string">"子进程2"</span>,<span class="number">3</span>))</span><br><span class="line">    p3 = Process(target=task, args=(<span class="string">"子进程3"</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># 串行执行</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.start()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.start()</span><br><span class="line">    p3.join()</span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure></li></ol><p>4.守护进程<br>主进程创建守护进程：<br>　　一：守护进程会在主进程代码执行结束后就终止，主进程代码运行结束，守护进程立即死亡</p><p>　　二：守护进程内无法再开启子进程,否则抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    p = Process(target=task, args=(&apos;子进程&apos;, ))</span><br><span class="line">    p.daemon=True    # 守护进程一定要在进程开启前,即p.start()开启前设置</span><br><span class="line">    p.start()</span><br><span class="line">    print(&quot;我是主进程&quot;)</span><br></pre></td></tr></table></figure><h2 id="4-互斥锁"><a href="#4-互斥锁" class="headerlink" title="4.互斥锁"></a>4.互斥锁</h2><p>进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,而共享带来的是竞争，竞争带来的结果就是错乱<br>互斥锁的原理：就是把并发改成穿行，降低了效率，但保证了数据安全不错乱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def task():</span><br><span class="line">    # 获得锁</span><br><span class="line">    lock.acquire()</span><br><span class="line">    ...</span><br><span class="line">    # 释放锁</span><br><span class="line">    lock.release()</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    lock = Lock()   # 只实例化一次，并传给子进程，要保证所有进程用同一把锁</span><br><span class="line">    for i in range(3):</span><br><span class="line">        p = Process(target=task, args=(&apos;进程%s&apos; % i, lock,))  # 传递给子进程的锁</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><h2 id="5-队列"><a href="#5-队列" class="headerlink" title="5.队列"></a>5.队列</h2><p>进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的</p><blockquote><p>队列的创建</p></blockquote><p>Queue（maxsize）：创建队列中允许的最大项数</p><blockquote><p>队列的主要方法</p></blockquote><p>q.put(value)方法用以插入数据到队列中。<br>q.get(value)方法可以从队列读取并且删除一个元素。<br>q.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。<br>q.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。<br>q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样<br>q.close():关闭队列<br>PS:使用q.get()从空队列中再取值时与使用q.put()在队列为满时继续插入数据，都会出现程序卡在原地的结果</p><blockquote><p>队列的使用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列中应该放消息，不应该放大文件大数据</span></span><br><span class="line"><span class="comment"># 队列可以不设置长度，但是队列是受制于内存大小的，不可能无限存放</span></span><br><span class="line">q = Queue(<span class="number">3</span>)  <span class="comment"># 指定队列大小</span></span><br><span class="line">q.put(<span class="string">'hello'</span>)</span><br><span class="line">q.put(&#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">q.put([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,])</span><br><span class="line"></span><br><span class="line">print(q.full())   <span class="comment"># 查看队列是否满了  # True</span></span><br><span class="line"><span class="comment"># q.put(123)    # 队列满了再往里面放时，被锁住，只能在原地卡着。</span></span><br><span class="line"></span><br><span class="line">print(q.get())  <span class="comment"># hello</span></span><br><span class="line">print(q.get())  <span class="comment"># &#123;'a':1&#125;</span></span><br><span class="line">print(q.get())  <span class="comment"># [3,3,3]</span></span><br><span class="line">print(q.empty())   <span class="comment"># 判断队列是否全部清空  # True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(q.get())   # 由于已经空了，程序也卡在原处</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python全栈系列章节更新（三）：数据库分批次处理和数据库通用连接函数</title>
      <link href="/2019/12/03/python%E7%9A%84executemany%E6%96%B9%E6%B3%95/"/>
      <url>/2019/12/03/python%E7%9A%84executemany%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据库分批次处理:execute,executemany<br>数据库通用连接函数</p></blockquote><a id="more"></a><h2 id="1-数据库通用连接函数（连接模块视实际数据库决定，大同小异）"><a href="#1-数据库通用连接函数（连接模块视实际数据库决定，大同小异）" class="headerlink" title="1.数据库通用连接函数（连接模块视实际数据库决定，大同小异）"></a>1.数据库通用连接函数（连接模块视实际数据库决定，大同小异）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DBUtils <span class="keyword">import</span> PooledDB</span><br><span class="line"><span class="keyword">import</span> pymssql</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sqlserverManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数，初始化连接</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server, user, password, database, table)</span>:</span></span><br><span class="line">        self.server = server</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.database = database</span><br><span class="line">        self.table = table</span><br><span class="line">        self.conn = <span class="literal">None</span></span><br><span class="line">        self.cursor = <span class="literal">None</span></span><br><span class="line">        self.maxconnections = <span class="number">15</span> <span class="comment"># 设置最大连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据到SQL server</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect_database</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.conn = PooledDB(creator=pymssql,</span><br><span class="line">                                 maxconnections=self.maxconnections,</span><br><span class="line">                                 server=self.server,</span><br><span class="line">                                 user=self.user,</span><br><span class="line">                                 password=self.password,</span><br><span class="line">                                 database=self.database,</span><br><span class="line">                                 charset=<span class="string">'utf8'</span>).connection()</span><br><span class="line">            <span class="comment"># 创建游标</span></span><br><span class="line">            self.cursor = self.conn.cursor()</span><br><span class="line">            print(<span class="string">"sql server had connected"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"the connect failed:"</span>, e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dbclose</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dbcommit</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self, sql)</span>:</span></span><br><span class="line">        print(<span class="string">"-----插入数据-----"</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'\033[1;31;0m\t4---插入更新失败，msg：\033[0m'</span>, e, sql.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">            self.conn.rollback()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="2-数据分批次处理"><a href="#2-数据分批次处理" class="headerlink" title="2.数据分批次处理"></a>2.数据分批次处理</h2><p>数据库分批次处理可以使用两种方法：execute()与executemany()方法</p><h3 id="2-1-executemany"><a href="#2-1-executemany" class="headerlink" title="2.1 executemany()"></a>2.1 executemany()</h3><p><font color=#f15a22>在使用executemany方法时，需要注意的几个问题：</font></p><blockquote><p>1.在写sql语句时，不管字段为什么类型，占位符统一使用%s,且不能加上引号。例如</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sql="<span class="keyword">insert</span> <span class="keyword">into</span> tablename (<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span> (%s,%s)<span class="string">"</span></span><br></pre></td></tr></table></figure><blockquote><p>2.添加的数据的格式必须为元组型列表或元组型元组:list[tuple(),tuple(),tuple()]或者tuple(tuple(),tuple(),tuple())例如</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">values</span>=[(<span class="number">1</span>,<span class="string">"zhangsan"</span>),(<span class="number">2</span>,<span class="string">"lisi"</span>)]</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">values</span>=((<span class="number">1</span>,<span class="string">"zhangsan"</span>),(<span class="number">2</span>,<span class="string">"lisi"</span>))</span><br></pre></td></tr></table></figure><blockquote><p>3.最后通过executemany插入</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cursor.executemany(sql,<span class="keyword">values</span>)</span><br><span class="line">cursor.commit()</span><br></pre></td></tr></table></figure><h3 id="2-2-execute"><a href="#2-2-execute" class="headerlink" title="2.2 execute()"></a>2.2 execute()</h3><p>execute()分批次处理的原理是：循环执行批量语句，然后在commit，如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    sql = "<span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span>(<span class="keyword">id</span>,grand) <span class="keyword">values</span>(i,i+<span class="number">10</span>)<span class="string">"</span></span><br><span class="line"><span class="string">    cursor.execute(sql)</span></span><br><span class="line"><span class="string"># 批量执行数据后，然后提交    </span></span><br><span class="line"><span class="string">cursor.commit()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库分批次处理 </tag>
            
            <tag> 数据库通用连接函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于数据库返回值的讨论</title>
      <link href="/2019/12/02/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E8%AE%A8%E8%AE%BA/"/>
      <url>/2019/12/02/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;每到深夜，打开音乐，带上耳机，周围很安静，只有到这个时候我才感觉到自己是一个学者，而此刻头脑中只有两件事罢了：1.记下今天所用到的知识 2.安安静静听歌<br>最近做一个python获取考勤数据的小脚本，一直没有怎么用到数据库，今天就来探讨一下获取数据库的返回值</p><blockquote><p>关于数据库返回值的讨论<br>python文件打开方式详解<br>fetchall(),fetchone()</p></blockquote><a id="more"></a><h2 id="1-关于数据库返回值的讨论"><a href="#1-关于数据库返回值的讨论" class="headerlink" title="1.关于数据库返回值的讨论"></a>1.关于数据库返回值的讨论</h2><h3 id="1-1-构造简单sql语句"><a href="#1-1-构造简单sql语句" class="headerlink" title="1.1.构造简单sql语句"></a>1.1.构造简单sql语句</h3><p>假设存在这样一个简单的数据库,获取每一行的数据，并保存为txt格式<br><fancybox><img src="https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesdatabase_resp.JPG" alt=""></fancybox></p><blockquote><p>构造sql语句</p></blockquote><p>select  * from dbo.userlist where user_serial&lt;100010</p><h3 id="1-2-python连接数据库（SQL-server）"><a href="#1-2-python连接数据库（SQL-server）" class="headerlink" title="1.2.python连接数据库（SQL server）"></a>1.2.python连接数据库（SQL server）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pymssql</span><br><span class="line"><span class="comment"># 获取考勤系统数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    server = <span class="string">""</span></span><br><span class="line">    user = <span class="string">""</span></span><br><span class="line">    password = <span class="string">""</span></span><br><span class="line">    database = <span class="string">""</span></span><br><span class="line">    conn = pymssql.connect(</span><br><span class="line">        server=server,</span><br><span class="line">        user=user,</span><br><span class="line">        password=password,</span><br><span class="line">        database=database</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 创建游标</span></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    <span class="comment"># 构造查询sql语句</span></span><br><span class="line">    sql =<span class="string">"select  * from dbo.kt_dev where user_serial&lt;100010"</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    numbers = cursor.fetchall()</span><br><span class="line">    print(numbers[<span class="number">0</span>])  <span class="comment"># 元组(100002, '0010014', '00101')</span></span><br><span class="line">    print(type(numbers[<span class="number">0</span>])) <span class="comment"># tuple元组类型</span></span><br><span class="line">    <span class="comment"># 元组访问方式与拼接</span></span><br><span class="line">    print(str(str(numbers[<span class="number">1</span>][<span class="number">0</span>]))+<span class="string">":"</span>+str(numbers[<span class="number">1</span>][<span class="number">1</span>]))  <span class="comment"># 100002:0010002</span></span><br><span class="line">    print(type(numbers))  <span class="comment"># list 列表</span></span><br><span class="line">    print(<span class="string">'总列表：'</span>,numbers)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    loan_count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 获取所有的查询数据(1.区别于fetchone() 2.fetchall/fetchone()的返回值均为元组型列表，即[(第一行数据),(第二行数据),...()])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test_demo.txt"</span>,<span class="string">'a+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">            f.write(str(number[<span class="number">0</span>])+<span class="string">"  "</span>+str(number[<span class="number">1</span>]) + <span class="string">"  "</span>+str(number[<span class="number">2</span>]+<span class="string">"\n"</span>)) <span class="comment"># 元组数据number=("考勤卡号”，"刷卡时间")</span></span><br><span class="line">            loan_count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 断开连接</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    print(<span class="string">"写入完成,共写入%d条数据！"</span> % loan_count)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    demo()</span><br></pre></td></tr></table></figure><p>数据库查询后返回的所有数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总列表： </span></span><br><span class="line">[(<span class="number">100002</span>, <span class="string">'0010014'</span>, <span class="string">'00101'</span>), (<span class="number">100002</span>, <span class="string">'0010002'</span>, <span class="string">'00101'</span>),..., (<span class="number">100006</span>, <span class="string">'0010014'</span>, <span class="string">'00101'</span>)]</span><br></pre></td></tr></table></figure><p>由上式案列可知：<br><font color=#ed1941><br>1.fetchall():表示返回查询到的所有数据；fetchone():表示返回查询到的第一行数据<br>2.python查询返回的所有数据类型为元组型列表，即[(),(),...()]<br>3.元组的访问方式为：元组名[&quot;index&quot;]<br></font></p><h2 id="2-python文件打开方式详解"><a href="#2-python文件打开方式详解" class="headerlink" title="2.python文件打开方式详解"></a>2.python文件打开方式详解</h2><table><thead><tr><th>打开方式</th><th align="center">详解</th></tr></thead><tbody><tr><td>b</td><td align="center">二进制模式。</td></tr><tr><td>+</td><td align="center">打开一个文件进行更新(可读可写)。</td></tr><tr><td>r</td><td align="center">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td>rb</td><td align="center">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td>r+</td><td align="center">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>rb+</td><td align="center">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td>w</td><td align="center">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb</td><td align="center">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>w+</td><td align="center">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td>wb+</td><td align="center">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td>a</td><td align="center">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>a+</td><td align="center">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>ab+</td><td align="center">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fetchall() </tag>
            
            <tag> fetchone() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python全栈系列章节更新（二）：常见库模块</title>
      <link href="/2019/11/29/python(%E4%BA%8C)%E5%B8%B8%E8%A7%81%E5%BA%93%E5%87%BD%E6%95%B0/"/>
      <url>/2019/11/29/python(%E4%BA%8C)%E5%B8%B8%E8%A7%81%E5%BA%93%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等</p><blockquote><p>1.time模块<br>2.DBUtils管理数据库连接池<br>3.ftplib模块<br>4.os模块<br>5.datetime模块</p></blockquote><a id="more"></a><h2 id="1-time模块"><a href="#1-time模块" class="headerlink" title="1.time模块"></a>1.time模块</h2><h3 id="Unix时间戳转与时间的转换"><a href="#Unix时间戳转与时间的转换" class="headerlink" title="Unix时间戳转与时间的转换"></a>Unix时间戳转与时间的转换</h3><blockquote><p>将时间戳转换成时间，首先需要将时间戳转换成localtime，再转换成时间的具体格式：</p></blockquote><p>利用localtime()函数将时间戳转化成localtime的格式<br>利用strftime()函数重新格式化时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 将时间戳转化为目标时间格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp_datatime</span><span class="params">(value)</span>:</span></span><br><span class="line">    format = <span class="string">'%Y-%m-%d %H:%M'</span></span><br><span class="line">    <span class="comment"># format = '%Y-%m-%d %H:%M:%S'</span></span><br><span class="line">    <span class="comment"># value 为时间戳值,如:1460073600.0</span></span><br><span class="line">    value = time.localtime(value)</span><br><span class="line">    dt = time.strftime(format, value)</span><br><span class="line">    <span class="keyword">return</span> dt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目标时间格式转化为时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datetime_timestamp</span><span class="params">(dt)</span>:</span></span><br><span class="line">    newTime = time.strptime(dt, <span class="string">'%Y-%m-%d %H:%M'</span>)</span><br><span class="line">    s = time.mktime(newTime)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = timestamp_datatime(<span class="number">1460073600.0</span>)</span><br><span class="line">    print(s)  <span class="comment"># 2016-04-08 08:00</span></span><br><span class="line">    d = datetime_timestamp(<span class="string">'2019-06-05 08:00'</span>)</span><br><span class="line">    print(d)  <span class="comment"># 1559692800.0</span></span><br></pre></td></tr></table></figure><h3 id="按指定的格式获取当前时间"><a href="#按指定的格式获取当前时间" class="headerlink" title="按指定的格式获取当前时间"></a>按指定的格式获取当前时间</h3><p>利用time()获取当前时间，再利用localtime()函数转换为localtime，最后利用strftime()函数重新格式化时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:UTF-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前时间</span></span><br><span class="line">time_now = int(time.time())</span><br><span class="line"><span class="comment">#转换成localtime</span></span><br><span class="line">time_local = time.localtime(time_now)</span><br><span class="line"><span class="comment">#转换成新的时间格式(2016-05-09 18:59:20),时间连接符号可改变</span></span><br><span class="line">dt = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time_local)</span><br><span class="line"></span><br><span class="line">print(dt)</span><br></pre></td></tr></table></figure><h2 id="2-DBUtils管理数据库连接池"><a href="#2-DBUtils管理数据库连接池" class="headerlink" title="2.DBUtils管理数据库连接池"></a>2.DBUtils管理数据库连接池</h2><p>当使用多线程，多进程将海量数据存入数据库时，每次执行一个sql的时候都单独建立一个mysql连接，执行完就close掉，很明显这样的问题在于，频繁连接，断开mysql，这样是相当消耗系统资源的，而且增加了mysql连接失败的几率，所以万一哪个线程没有连接成功 这个线程也over了。</p><h3 id="2-1-连接池原理"><a href="#2-1-连接池原理" class="headerlink" title="2.1 连接池原理"></a>2.1 连接池原理</h3><p><fancybox><img src="https://img-blog.csdn.net/20180816112104584?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vdWRheQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></fancybox><br>1.在程序创建连接的时候，可以从一个空闲的连接中获取，不需要重新初始化连接，提升获取连接的速度<br>2.关闭连接的时候，把连接放回连接池，而不是真正的关闭，所以可以减少频繁地打开和关闭连接</p><blockquote><p>安装DBUtils库</p></blockquote><p>pip install DBUtils</p><blockquote><p>参数解释</p></blockquote><table><thead><tr><th>参数</th><th align="center">详解</th></tr></thead><tbody><tr><td>creator,</td><td align="center"># 使用链接数据库的模块(必须：pymssql，pymysql，cx_oralce,…)</td></tr><tr><td>mincached=0,</td><td align="center"># 初始化时，链接池中至少创建的空闲的链接，0表示不创建</td></tr><tr><td>maxcached=0,</td><td align="center"># 链接池中最多闲置的链接，0和None不限制</td></tr><tr><td>maxshared=0,</td><td align="center"># 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用</td></tr><tr><td>maxconnections=0,</td><td align="center"># 连接池允许的最大连接数，0和None表示不限制连接数</td></tr><tr><td>blocking=False,</td><td align="center"># 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</td></tr><tr><td>maxusage=None,</td><td align="center"># 一个链接最多被重复使用的次数，None表示无限制</td></tr><tr><td>setsession=None,</td><td align="center"># 开始会话前执行的命令列表。如：[“set datestyle to …”, “set time zone …”]</td></tr><tr><td>reset=True,</td><td align="center"></td></tr><tr><td>failures=None,</td><td align="center"></td></tr><tr><td>ping=1,</td><td align="center"># ping MySQL服务端，检查是否服务可用</td></tr></tbody></table><blockquote><p>数据库设置(数据库连接模块不一样，其参数名也不同)</p></blockquote><p>如creator=pymysql：<br>host=&#39;localhost&#39;, port=3306,db=&#39;mydata&#39;,user=&quot;root&quot;,passwd=&quot;123456&quot;,charset=&#39;utf8&#39;</p><blockquote><p>数据库通用连接函数（连接模块视实际数据库决定）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DBUtils <span class="keyword">import</span> PooledDB</span><br><span class="line"><span class="keyword">import</span> pymssql</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sqlserverManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数，初始化连接</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server, user, password, database, table)</span>:</span></span><br><span class="line">        self.server = server</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.database = database</span><br><span class="line">        self.table = table</span><br><span class="line">        self.conn = <span class="literal">None</span></span><br><span class="line">        self.cursor = <span class="literal">None</span></span><br><span class="line">        self.maxconnections = <span class="number">15</span> <span class="comment"># 设置最大连接数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据到SQL server</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect_database</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.conn = PooledDB(creator=pymssql,</span><br><span class="line">                                 maxconnections=self.maxconnections,</span><br><span class="line">                                 server=self.server,</span><br><span class="line">                                 user=self.user,</span><br><span class="line">                                 password=self.password,</span><br><span class="line">                                 database=self.database,</span><br><span class="line">                                 charset=<span class="string">'utf8'</span>).connection()</span><br><span class="line">            <span class="comment"># 创建游标</span></span><br><span class="line">            self.cursor = self.conn.cursor()</span><br><span class="line">            print(<span class="string">"sql server had connected"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"the connect failed:"</span>, e)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dbclose</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dbcommit</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self, sql)</span>:</span></span><br><span class="line">        print(<span class="string">"-----插入数据-----"</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">'\033[1;31;0m\t4---插入更新失败，msg：\033[0m'</span>, e, sql.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">            self.conn.rollback()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="2-2-多线程（连接池）操作MySQL插入数据"><a href="#2-2-多线程（连接池）操作MySQL插入数据" class="headerlink" title="2.2 多线程（连接池）操作MySQL插入数据"></a>2.2 <a href="https://www.cnblogs.com/insane-Mr-Li/p/11634417.html" target="_blank" rel="noopener">多线程（连接池）操作MySQL插入数据</a></h3><blockquote><p>启动线程任务</p></blockquote><p>每调用一次插入函数就从连接池中取出一个链接操作,完成后关闭链接;<br>executemany 批量操作,减少 commit 次数,提升效率;</p><h2 id="3-ftplib操作ftp实现上传和下载的"><a href="#3-ftplib操作ftp实现上传和下载的" class="headerlink" title="3.ftplib操作ftp实现上传和下载的"></a>3.ftplib操作ftp实现上传和下载的</h2><p>ftplib模块是系统默认安装的，实现文件的上传与下载</p><h3 id="3-1-ftp登陆连接"><a href="#3-1-ftp登陆连接" class="headerlink" title="3.1 ftp登陆连接"></a>3.1 ftp登陆连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> ftplib <span class="keyword">import</span> FTP            <span class="comment">#加载ftp模块</span></span><br><span class="line">ftp=FTP()                         <span class="comment">#设置变量</span></span><br><span class="line">ftp.set_debuglevel(<span class="number">2</span>)             <span class="comment">#打开调试级别2，显示详细信息</span></span><br><span class="line">ftp.connect(<span class="string">"IP"</span>,<span class="string">"port"</span>)          <span class="comment">#连接的ftp sever和端口</span></span><br><span class="line">ftp.login(<span class="string">"user"</span>,<span class="string">"password"</span>)      <span class="comment">#连接的用户名，密码</span></span><br><span class="line">print(ftp.getwelcome())            <span class="comment">#打印出欢迎信息</span></span><br><span class="line"></span><br><span class="line">bufsize=<span class="number">1024</span>                      <span class="comment">#设置的缓冲区大小</span></span><br><span class="line">filename=<span class="string">"filename.txt"</span>           <span class="comment">#需要下载的文件</span></span><br><span class="line">file_handle=open(filename,<span class="string">"wb"</span>).write <span class="comment">#以写模式在本地打开文件</span></span><br><span class="line">ftp.retrbinaly(<span class="string">"RETR filename.txt"</span>,file_handle,bufsize) <span class="comment">#接收服务器上文件并写入本地文件</span></span><br><span class="line">ftp.set_debuglevel(<span class="number">0</span>)             <span class="comment">#关闭调试模式</span></span><br><span class="line">ftp.quit()                        <span class="comment">#退出ftp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># ftp相关命令操作</span></span><br><span class="line">ftp.cwd(pathname)                 <span class="comment">#设置FTP当前操作的路径</span></span><br><span class="line">ftp.dir()                         <span class="comment">#显示目录下所有目录信息</span></span><br><span class="line">ftp.nlst()                        <span class="comment">#获取目录下的文件</span></span><br><span class="line">ftp.mkd(pathname)                 <span class="comment">#新建远程目录</span></span><br><span class="line">ftp.pwd()                         <span class="comment">#返回当前所在位置</span></span><br><span class="line">ftp.rmd(dirname)                  <span class="comment">#删除远程目录</span></span><br><span class="line">ftp.delete(filename)              <span class="comment">#删除远程文件</span></span><br><span class="line">ftp.rename(fromname, toname)<span class="comment">#将fromname修改名称为toname。</span></span><br><span class="line">ftp.storbinary(<span class="string">"STOR filename.txt"</span>,file_content,bufsize)  <span class="comment">#上传目标文件</span></span><br><span class="line">ftp.retrbinary(<span class="string">"RETR filename.txt"</span>,file_content,bufsize)  <span class="comment">#下载FTP文件</span></span><br></pre></td></tr></table></figure><h3 id="3-2-ftp上传或下载文件-目录"><a href="#3-2-ftp上传或下载文件-目录" class="headerlink" title="3.2 ftp上传或下载文件/目录"></a>3.2 ftp上传或下载文件/目录</h3><h2 id="4-os模块"><a href="#4-os模块" class="headerlink" title="4.os模块"></a>4.os模块</h2><p>记下常用的os模块的操作指令</p><table><thead><tr><th>命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>os.getcwd()</td><td align="center">获取当前工作目录，即当前python脚本工作的目录路径,相当于shell的pwd</td></tr><tr><td>os.chdir(“dirname”)</td><td align="center">改变当前脚本工作目录；相当于shell下cd</td></tr><tr><td>os.curdir</td><td align="center">返回当前目录: (‘.’)</td></tr><tr><td>os.pardir</td><td align="center">获取当前目录的父目录字符串名：(‘..’)</td></tr><tr><td>os.makedirs(‘dirname1/dirname2’)</td><td align="center">可生成多层递归目录</td></tr><tr><td>os.removedirs(‘dirname1’)</td><td align="center">若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</td></tr><tr><td>os.mkdir(‘dirname’)</td><td align="center">生成单级目录；相当于shell中mkdir dirname</td></tr><tr><td>os.rmdir(‘dirname’)</td><td align="center">删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</td></tr><tr><td>os.listdir(‘dirname’)</td><td align="center">列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</td></tr><tr><td>os.remove()</td><td align="center">删除一个文件</td></tr><tr><td>os.rename(“oldname”,”newname”)</td><td align="center">重命名文件/目录</td></tr><tr><td>os.stat(‘path/filename’)</td><td align="center">获取文件/目录信息</td></tr><tr><td>os.name</td><td align="center">输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’</td></tr><tr><td>os.system(“执行的命令”)</td><td align="center">运行shell命令，直接显示,相当于直接在cmd命令中执行</td></tr><tr><td>os.environ</td><td align="center">获取系统环境变量</td></tr><tr><td>os.path.abspath(path)</td><td align="center">返回path规范化的绝对路径</td></tr><tr><td>os.path.split(path)</td><td align="center">将path分割成目录和文件名二元组返回</td></tr><tr><td>os.path.dirname(path)</td><td align="center">返回path的目录。其实就是os.path.split(path)的第一个元素</td></tr><tr><td>os.path.basename(path)</td><td align="center">返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</td></tr><tr><td>os.path.exists(path/file)</td><td align="center">如果路径或文件存在，返回True；如果path不存在，返回False</td></tr><tr><td>os.path.isabs(path)</td><td align="center">如果path是绝对路径，返回True</td></tr><tr><td>os.path.isfile(path)</td><td align="center">如果path是一个存在的文件，返回True。否则返回False</td></tr><tr><td>os.path.join(path1,path2,…,pathn)</td><td align="center">将多个路径组合后返回</td></tr></tbody></table><p>简要样例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.path.split(&quot;/Users/hqs/PycharmProjects/startMyPython3.0&quot;)             </span><br><span class="line">(&apos;/Users/hqs/PycharmProjects&apos;, &apos;startMyPython3.0&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; os.path.dirname(&apos;/Users/hqs/PycharmProjects/startMyPython3.0&apos;)</span><br><span class="line">&apos;/Users/hqs/PycharmProjects&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;os.system(&quot;ping 127.0.0.1&quot;)</span><br><span class="line">正在 Ping 127.0.0.1 具有 32 字节的数据:</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line"></span><br><span class="line">127.0.0.1 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 0ms，最长 = 0ms，平均 = 0ms</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;os.path.abspath(__file__) </span><br><span class="line">当前文件的绝对路径</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">当前文件的上一层目录的绝对路径</span><br><span class="line"></span><br><span class="line">os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">当前文件的上上层目录的绝对路径</span><br></pre></td></tr></table></figure><h2 id="5-datetime模块"><a href="#5-datetime模块" class="headerlink" title="5 datetime模块"></a>5 <a href="https://blog.csdn.net/qq_24753293/article/details/80954840" target="_blank" rel="noopener">datetime模块</a></h2><p>1.datetime.date：表示日期的类<br>2.datetime.datetime：表示日期时间的类<br>3.datetime.time：表示时间的类<br>4.datetime.timedelta：表示时间间隔，即两个时间点的间隔<br>5.datetime.tzinfo：时区的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;datetime.datetime.now()</span><br><span class="line">当前系统时间：datetime.datetime(2019, 12, 3, 20, 31, 10, 740869)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;datetime.datetime.now().year/month/day</span><br><span class="line">分别为：2019，12，3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;datetime.datetime.now().weekday()</span><br><span class="line">1 表示在第几周</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;time1 = datetime.datetime(2016, 10, 20)</span><br><span class="line">&gt;&gt;&gt;time2 = datetime.datetime(2015, 11, 2)</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;计算天数差值&quot;&quot;&quot;</span><br><span class="line">print(time1-time2).days</span><br><span class="line"> </span><br><span class="line">&quot;&quot;&quot;计算两个日期之间相隔的秒数&quot;&quot;&quot;</span><br><span class="line">print (time1-time2).total_seconds()</span><br><span class="line"></span><br><span class="line"># 获取当前时间,并转化为字符串型</span><br><span class="line">&gt;&gt;&gt;time_new = str(datetime.datetime.now().date())  # &apos;2019-12-4&apos;</span><br><span class="line"></span><br><span class="line"># 以当天的09：00为开始时间（时间戳格式）</span><br><span class="line">&gt;&gt;&gt;time_on = time.mktime(time.strptime(time_new+ &apos; 09:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))</span><br><span class="line"></span><br><span class="line"># 以当天的18：00为结束时间（时间戳格式）</span><br><span class="line">&gt;&gt;&gt;time_off = time.mktime(time.strptime(time_new+ &apos; 18:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))</span><br><span class="line"></span><br><span class="line"># 当前星期几</span><br><span class="line">&gt;&gt;&gt;week_now = datetime.datetime.now().weekday()</span><br><span class="line"></span><br><span class="line"># 当前时间</span><br><span class="line">&gt;&gt;&gt;time_now = datetime.datetime.now()  # datetime.datetime(2019, 12, 4, 14, 57, 48, 988520)</span><br><span class="line"></span><br><span class="line"># 当前第几小时（24小时制）</span><br><span class="line">&gt;&gt;&gt;hour_now = datetime.datetime.now().hour  # 14</span><br></pre></td></tr></table></figure><h2 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> time </tag>
            
            <tag> datetime </tag>
            
            <tag> DBUtils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术小白教你如何定位照片拍摄位置</title>
      <link href="/2019/11/28/%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D/"/>
      <url>/2019/11/28/%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。<font color=#c85d44>（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动）</font></p><a id="more"></a><h2 id="1-获取GPS信息"><a href="#1-获取GPS信息" class="headerlink" title="1.获取GPS信息"></a>1.获取GPS信息</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;将照片复制至电脑。点击照片，右键--“右键菜单”--“属性”--“详细信息”，下拉至“GPS”，将会看到经纬度信息。如下图所示：<br><fancybox><img src="https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagespostion.JPG" alt=""></fancybox></p><h2 id="2-经纬度计算方法"><a href="#2-经纬度计算方法" class="headerlink" title="2.经纬度计算方法"></a>2.经纬度计算方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到经纬度信息，<font color=#c85d44>是以度分秒的格式展示的（度分秒之间以“；”间隔），为了方便定位，我们需要将度分秒转换为度的格式。</font><br>计算方法：经纬度同理（本例为32；49；49.942932000005413）<br>经度：度+（分+秒/60）/60，即32+(49+49.9429/60)/60=32.8305;</p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>在<a href="http://www.gpsov.com/cn/main.php" target="_blank" rel="noopener">奥维地图</a>上将计算后的经纬度（以英文格式书写）代入其中，就可以获得地理位置信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 定位照片拍摄位置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（二）：Nginx的命令和配置文件</title>
      <link href="/2019/11/27/Nginx(%E4%BA%8C)/"/>
      <url>/2019/11/27/Nginx(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p><font size=5 color=#00ced1 size=5 face="黑体">与众不同的生活方式很累人呢，因为找不到借口</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在</p><blockquote><p><font size=4 color=#FF0000>本文要点：</font><br>1.理清概念<br>2.Linux下Nginx的常用命令<br>3.Nginx的基本配置文件nginx.conf<br>4.Nginx 配置实例-反向代理实例 1 </p></blockquote><a id="more"></a><h3 id="1-理清概念"><a href="#1-理清概念" class="headerlink" title="1.理清概念"></a>1.理清概念</h3><p>docker创建Nginx容器很简单：共享数据卷，外部访问端口映射<br>window下运行nginx，只需简单式一直点击“NEXT”安装，然后添加到环境变量即可<br><font color=#00ced1 size=5 face="黑体">在Linux下启动nginx相对比较麻烦，如果你采用其它两种方式，可以跳过本节，本节主要是介绍Linux下的运行命令</font><br>无论哪种方式启动Nginx，其核心的配置文件以及接下来的几个配置实例都是通用的</p><h3 id="2-Linux下Nginx的常用命令"><a href="#2-Linux下Nginx的常用命令" class="headerlink" title="2.Linux下Nginx的常用命令"></a>2.Linux下Nginx的常用命令</h3><p><a href="http://ahrilove.top/2019/11/10/docker容器虚拟技术/">先关闭防火墙或者是开放目标端口</a></p><blockquote><p>进入nginx目录中 </p></blockquote><p>cd  /usr/local/nginx/sbin (前面路径有可能不同，主要是nginx内的nginx/sbin路径)</p><blockquote><p>1、查看nginx版本号  </p></blockquote><p>./nginx -v </p><blockquote><p>2、启动nginx </p></blockquote><p>./nginx </p><blockquote><p>3、停止nginx  </p></blockquote><p>./nginx  -s  stop </p><blockquote><p>4、重新加载nginx  </p></blockquote><p>./nginx -s reload </p><h3 id="3-ginx的基本配置文件nginx-conf"><a href="#3-ginx的基本配置文件nginx-conf" class="headerlink" title="3.ginx的基本配置文件nginx.conf"></a>3.ginx的基本配置文件nginx.conf</h3><h4 id="3-1、nginx-配置文件位置"><a href="#3-1、nginx-配置文件位置" class="headerlink" title="3.1、nginx 配置文件位置"></a>3.1、nginx 配置文件位置</h4><p>cd /usr/local/nginx/conf/nginx.conf </p><h4 id="3-2、配置文件中的内容-包含三部分内容"><a href="#3-2、配置文件中的内容-包含三部分内容" class="headerlink" title="3.2、配置文件中的内容 包含三部分内容"></a>3.2、配置文件中的内容 包含三部分内容</h4><p>（1）全局块：配置服务器整体运行的配置指令 比如 worker_processes  1;处理并发数的配置 </p><p>（2）events 块：影响 Nginx 服务器与用户的网络连接 比如 worker_connections  1024; 支持的最大连接数为 1024 </p><p>（3）http 块 还包含两部分： http 全局块 server 块</p><h4 id="3-3-默认的nginx-conf"><a href="#3-3-默认的nginx-conf" class="headerlink" title="3.3 默认的nginx.conf"></a>3.3 默认的nginx.conf</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="string">worker_processes</span>  <span class="number">1</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="string">events</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">worker_connections</span>  <span class="number">1024</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">http</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">include</span>       <span class="string">mime.types;</span></span><br><span class="line">    <span class="string">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">sendfile</span>        <span class="string">on;</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="string">keepalive_timeout</span>  <span class="number">65</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">listen</span>       <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">            <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="number">404.</span><span class="string">md</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span></span><br><span class="line">        <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> <span class="string">&#123;</span></span><br><span class="line">            <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx's one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-Nginx-配置实例-反向代理实例-1"><a href="#4-Nginx-配置实例-反向代理实例-1" class="headerlink" title="4.Nginx 配置实例-反向代理实例 1"></a>4.Nginx 配置实例-反向代理实例 1</h3><h4 id="4-1、实现效果"><a href="#4-1、实现效果" class="headerlink" title="4.1、实现效果"></a>4.1、实现效果</h4><p>（1）打开浏览器，在浏览器地址栏输入地址 <a href="http://www.123.com，跳转到" target="_blank" rel="noopener">www.123.com，跳转到</a> liunx 系统 tomcat 主页 面中 </p><h4 id="4-2、准备工作"><a href="#4-2、准备工作" class="headerlink" title="4.2、准备工作"></a>4.2、准备工作</h4><p>（1）在 liunx 系统安装 tomcat，使用默认端口 8080 * tomcat 安装文件放到 liunx 系统中，解压 * 进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器 </p><p>（2）对外开放访问的端口<br>firewall-cmd --add-port=8080/tcp --permanent<br>firewall-cmd --reload </p><p>（3）查看已经开放的端口号<br>firewall-cmd –list-all </p><p>（4）在 windows 系统中通过浏览器访问 tomcat 服务器(linux_IP + tomcat_Port)</p><h4 id="4-3、访问过程分析"><a href="#4-3、访问过程分析" class="headerlink" title="4.3、访问过程分析"></a>4.3、访问过程分析</h4><blockquote><p>映射IP</p></blockquote><p>假设域名<a href="http://www.123.com映射的IP为Linux上的nginx的ip地址（比如我的是192.168.17.129:80）,nginx也相当于一个分发器，将请求发送至tomcat服务器" target="_blank" rel="noopener">www.123.com映射的IP为Linux上的nginx的ip地址（比如我的是192.168.17.129:80）,nginx也相当于一个分发器，将请求发送至tomcat服务器</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问过程分析</span><br><span class="line">windows端   ----------&gt;Nginx（linux_IP：80）------&gt;tomcat(127.0.0.1:8080)</span><br><span class="line">（假设访问www.123.com）</span><br></pre></td></tr></table></figure><blockquote><p>在 nginx 进行请求转发的配置（反向代理配置）</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server&#123;</span></span><br><span class="line">    <span class="string">listen</span> <span class="number">80</span><span class="string">;</span> <span class="comment"># 监听端口</span></span><br><span class="line">    <span class="string">server_name</span>   <span class="string">www.123.com;</span>  <span class="comment"># 配置域名</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">location</span> <span class="string">/&#123;</span></span><br><span class="line">        <span class="string">proxy_pass</span> <span class="attr">http://127.0.0.1:8080;</span>  <span class="comment"># 跳转到127.0.0.1：8080路径</span></span><br><span class="line">        <span class="string">index</span> <span class="string">index.html</span> <span class="string">index.htm</span> <span class="string">index.jsp;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>如上配置，我们监听 80 端口，访问域名为 <a href="http://www.123.com，不加端口号时默认为" target="_blank" rel="noopener">www.123.com，不加端口号时默认为</a> 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 <a href="http://www.123.com后，成功后直接跳转到tomcat主页" target="_blank" rel="noopener">www.123.com后，成功后直接跳转到tomcat主页</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> nginx.conf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（一）：基本概念</title>
      <link href="/2019/11/25/Nginx/"/>
      <url>/2019/11/25/Nginx/</url>
      
        <content type="html"><![CDATA[<p><font size=5 color=#00ced1 size=5 face="黑体">守住一方平安，尽力而为，问心无愧就好。</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。</p><blockquote><p><font size=4 color=#FF0000>本文要点：</font><br>正向代理<br>反向代理<br>负载均衡<br>动静分离<br>Nginx安装教程</p></blockquote><a id="more"></a><h2 id="1-正向代理"><a href="#1-正向代理" class="headerlink" title="1.正向代理"></a>1.正向代理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述这样的代理模式称为正向代理，正向代理最大的特点是<font size=#FF0000>客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</font>来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：<br><fancybox><img src="https://img2018.cnblogs.com/blog/1202586/201812/1202586-20181211123717325-1261206014.png" alt=""></fancybox><br><font size=#FF0000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址</font>，还有代理程序的端口。如图。<br><fancybox><img src="https://img2018.cnblogs.com/blog/1202586/201812/1202586-20181211121039404-1910765480.png" alt=""></fancybox><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结来说：正向代理，”它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正向代理的用途：<br>（1）访问原来无法访问的资源，如Google<br>（2） 可以做缓存，加速访问资源<br>（3）对客户端访问授权，上网进行认证<br>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h2 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2.反向代理"></a>2.反向代理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：<a href="http://tengine.taobao.org/。" target="_blank" rel="noopener">http://tengine.taobao.org/。</a><br><fancybox><img src="https://images2018.cnblogs.com/blog/1202586/201804/1202586-20180406175939873-925019958.png" alt="反向代理"></fancybox><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理的作用：<br>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网<br>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><h2 id="3-项目场景以及两者区别"><a href="#3-项目场景以及两者区别" class="headerlink" title="3.项目场景以及两者区别"></a>3.项目场景以及两者区别</h2><p>通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：<br><fancybox><img src="https://images2018.cnblogs.com/blog/1202586/201804/1202586-20180406180130452-1246060303.png" alt="反向代理"></fancybox><br>两者区别：<br><fancybox><img src="https://img2018.cnblogs.com/blog/1202586/201812/1202586-20181211122806997-940664368.png" alt="两者区别"></fancybox><br>图解：</p><p>在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息；</p><p>在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息；</p><p>实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了</p><h2 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4.负载均衡"></a>4.负载均衡</h2><p>我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p><p>　　这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。</p><p>　　请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。</p><p>　　所以，将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p><p>　　负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。<br><fancybox><img src="https://images2018.cnblogs.com/blog/1202586/201804/1202586-20180406180405961-333776342.png" alt=""></fancybox><br>Nginx支持的负载均衡调度算法方式如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</p><h2 id="5-动静分离"><a href="#5-动静分离" class="headerlink" title="5.动静分离"></a>5.动静分离</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 </p><h2 id="6-nginx安装"><a href="#6-nginx安装" class="headerlink" title="6.nginx安装"></a>6.nginx安装</h2><p><i class="fas fa-hand-point-right"></i><a href="https://www.cnblogs.com/wcwnina/p/8728430.html" target="_blank" rel="noopener">windows下安装与部署Nginx</a><br><i class="fas fa-hand-point-right"></i><a href="https://www.cnblogs.com/wcwnina/p/8728430.html" target="_blank" rel="noopener">Linux下安装与部署Nginx</a><br><i class="fas fa-hand-point-right"></i>以后都推荐再docker下安装各式各样的环境<a href="http://ahrilove.top/2019/11/10/docker容器虚拟技术/">Ubuntu+docker下安装与部署Nginx</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache </tag>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript篇章三：js数字，数组与日期</title>
      <link href="/2019/11/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%89/"/>
      <url>/2019/11/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><font size=5 color=#00ced1 size=5 face="黑体">关关雎鸠，在河之洲。窈窕淑女，君子好逑</font></p><blockquote><p><font size=4 color=#FF0000>本文要点：</font><br>1.数值方法<br>2.数组以及数组属性和方法<br>3.日期<br><fancybox><img src="http://hd.wallpaperswide.com/thumbs/shhh_woman-t2.jpg" alt="一日不读书，我浑身难受"></fancybox></p></blockquote><a id="more"></a><h2 id="1-数值方法"><a href="#1-数值方法" class="headerlink" title="1.数值方法"></a>1.数值方法</h2><blockquote><p>number.toString():将数值型转化为字符串型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">15</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(n));  <span class="comment">// 为字数值类型number</span></span><br><span class="line">a = n.toString();  <span class="comment">// a为字符串类型</span></span><br></pre></td></tr></table></figure><blockquote><p>toFixed(number) 返回保留指定小数位数的数值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">9.656</span>;</span><br><span class="line">x.toFixed(<span class="number">0</span>);           <span class="comment">// 返回 10</span></span><br><span class="line">x.toFixed(<span class="number">2</span>);           <span class="comment">// 返回 9.66</span></span><br><span class="line">x.toFixed(<span class="number">4</span>);           <span class="comment">// 返回 9.6560</span></span><br><span class="line">x.toFixed(<span class="number">6</span>);           <span class="comment">// 返回 9.656000</span></span><br></pre></td></tr></table></figure><blockquote><p>把变量转换为数值</p></blockquote><p>这三种 JavaScript 方法可用于将变量转换为数字：</p><ul><li>Number() 方法</li><li>parseFloat(string) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，则对其进行解析直到完整取出第一个数值，并返回首个数值，如果首字符不是数字则直接返回NaN</li><li>parseInt(string，radix) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，将字符串取出首个完整数值，并转化为指定radix进制，如果首字符不是数字，就直接返回NaN</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10.008"</span>);      <span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10.33"</span>);      <span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10 20 30"</span>);   <span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"10 years"</span>);   <span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"years 10"</span>);   <span class="comment">// 返回 NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"30"</span>,<span class="number">8</span>);       <span class="comment">// 返回24，将30转化为8进制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"10"</span>);         <span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"10.33"</span>);      <span class="comment">// 返回 10.33</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"10 20 30"</span>);   <span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"10 years"</span>);   <span class="comment">// 返回 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"years 10"</span>);   <span class="comment">// 返回 NaN</span></span><br></pre></td></tr></table></figure><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><blockquote><p>数组是一种特殊的变量，它能够一次存放一个以上的值。</p></blockquote><p>var cars=[“Saab”,”Volov”,”BMW”];</p><blockquote><p>访问数组元素：通过索引（从0开始，下标号）来引用某个数组元素</p></blockquote><p>var name=car[0]  访问数组值<br>var car[0] = “Benz”  修改数组值，即新数组为[“Benz”,”Volov”,”BMW”]</p><h3 id="数组属性和方法"><a href="#数组属性和方法" class="headerlink" title="数组属性和方法"></a>数组属性和方法</h3><ol><li><p>length:返回数组元素的数目</p></li><li><p>遍历数组元素：最安全是使用for循环</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits;</span><br><span class="line">fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(fruits[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向数组添加新元素的最佳方法是使用 push() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.push(<span class="string">"Lemon"</span>);                <span class="comment">// 向 fruits 添加一个新元素 (Lemon),并返回数组元素个数</span></span><br></pre></td></tr></table></figure></li><li><p>join() 方法也可将所有数组元素结合为一个字符串</p></li></ol><p>格式：数组名.join(“指定拼接符”)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>,<span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fruits.join(<span class="string">" * "</span>));</span><br><span class="line"><span class="comment">// Banana * Orange * Apple * Mango</span></span><br></pre></td></tr></table></figure><ol start="5"><li><p>pop()从数组中删除最后一个元素,并返回该值<br>var fruits = [“Banana”, “Orange”, “Apple”, “Mango”];<br>var x = fruits.pop();       // x 的值是 “Mango”</p></li><li><p>sort()方法以字母顺序对数组进行排序</p></li><li><p>reverse()反转数组中的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.sort();            <span class="comment">// 对 fruits 中的元素进行排序</span></span><br><span class="line">fruitS.reverse();         <span class="comment">// 对数组元素进行反转</span></span><br></pre></td></tr></table></figure></li><li><p>JavaScript的数组可以包含任意数据类型<br>创建方式一(推荐使用)：[1, 2, 3.14, ‘Hello’, null, true];<br>创建方式二：通过Array()函数实现b = new Array(1, 2, 3);</p></li></ol><h2 id="3-日期"><a href="#3-日期" class="headerlink" title="3.日期"></a>3.日期</h2><p>使用方法：<br>var d = new Date(); 获取系统时间<br>d.getDate()/d.getFullYear()…</p><table><thead><tr><th align="right">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="right">getDate()</td><td align="left">以数值返回天数（1-31）</td></tr><tr><td align="right">getDay()</td><td align="left">以数值获取周几（0-6）</td></tr><tr><td align="right">getFullYear()</td><td align="left">获取四位的年（yyyy）</td></tr><tr><td align="right">getHours()</td><td align="left">获取小时（0-23）</td></tr><tr><td align="right">getMilliseconds()</td><td align="left">获取毫秒（0-999）</td></tr><tr><td align="right">getMinutes()</td><td align="left">获取分（0-59）</td></tr><tr><td align="right">getMonth()</td><td align="left">获取月（0-11）</td></tr><tr><td align="right">getSeconds()</td><td align="left">获取秒（0-59）</td></tr><tr><td align="right">getTime()</td><td align="left">获取时间戳（从 1970 年 1 月 1 日至今）</td></tr></tbody></table><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象 </tag>
            
            <tag> 属性与方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript篇章二：js计算精度丢失</title>
      <link href="/2019/11/21/Javascript%E7%AF%87%E7%AB%A0%E4%BA%8C/"/>
      <url>/2019/11/21/Javascript%E7%AF%87%E7%AB%A0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><font color=#00ced1 size=5 face="黑体">若教眼底无离恨，不信人间有白头</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript中没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失。</p><blockquote><p><font size=4 color=#FF0000>本文要点：</font><br>1.js精确度丢失缘由<br>2.精确度丢失解决方案<br><fancybox><img src="http://hd.wallpaperswide.com/thumbs/tifa_lockhart_ff7-t2.jpg" alt="一日不读书，我浑身难受！！"></fancybox></p></blockquote><a id="more"></a><h2 id="js精确度丢失出现缘由"><a href="#js精确度丢失出现缘由" class="headerlink" title="js精确度丢失出现缘由"></a>js精确度丢失出现缘由</h2><blockquote><p>1.我们先看几个四舍五入的实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Number</span>(<span class="number">0.009</span>).toFixed(<span class="number">2</span>));  </span><br><span class="line">alert(<span class="built_in">Number</span>(<span class="number">162.295</span>).toFixed(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>按正常结果，应该分别弹出0.01和162.30。但实际测试结果却是在不同浏览器中得到的是不同的结果：<br>在ie6、7、8下得到0.00和162.30，第一个数截取不正确；<br>在firefox中得到0.01和162.29，第二个数截取不正确；<br>在opera下得到0.01和162.29，第二个数截取不正确</p><blockquote><p>2.再看有关于四则运算的实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">1</span>/<span class="number">3</span>);<span class="comment">//弹出: 0.3333333333333333  </span></span><br><span class="line">alert(<span class="number">0.1</span> + <span class="number">0.2</span>);<span class="comment">//弹出: 0.30000000000000004   </span></span><br><span class="line">alert(<span class="number">-0.09</span> - <span class="number">0.01</span>);<span class="comment">//弹出: -0.09999999999999999  </span></span><br><span class="line">alert(<span class="number">0.012345</span> * <span class="number">0.000001</span>);<span class="comment">//弹出: 1.2344999999999999e-8  </span></span><br><span class="line">alert(<span class="number">0.000001</span> / <span class="number">0.0001</span>);<span class="comment">//弹出: 0.009999999999999998</span></span><br></pre></td></tr></table></figure><p>按正常结果，除第一行外(因为其本身就不能除尽)，其他都应该要得到精确的结果，从弹出的结果我们却发现不是我们想要的正确结果。是因为没有转换成Number类型吗？我们转换成Number后再计算看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Number</span>(<span class="number">1</span>)/<span class="built_in">Number</span>(<span class="number">3</span>));<span class="comment">//弹出: 0.3333333333333333       </span></span><br><span class="line">alert(<span class="built_in">Number</span>(<span class="number">0.1</span>) + <span class="built_in">Number</span>(<span class="number">0.2</span>));<span class="comment">//弹出: 0.30000000000000004      </span></span><br><span class="line">alert(<span class="built_in">Number</span>(<span class="number">-0.09</span>) - <span class="built_in">Number</span>(<span class="number">0.01</span>));<span class="comment">//弹出: -0.09999999999999999     </span></span><br><span class="line">alert(<span class="built_in">Number</span>(<span class="number">0.012345</span>) * <span class="built_in">Number</span>(<span class="number">0.000001</span>));<span class="comment">//弹出: 1.2344999999999999e-8     </span></span><br><span class="line">alert(<span class="built_in">Number</span>(<span class="number">0.000001</span>) / <span class="built_in">Number</span>(<span class="number">0.0001</span>));<span class="comment">//弹出: 0.009999999999999998</span></span><br></pre></td></tr></table></figure><p>还是一样的结果，看来javascript默认把数字识别为number类型。为了验证这一点，我们用typeof弹出类型看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span>(<span class="number">1</span>));<span class="comment">//弹出: number  </span></span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="number">1</span>/<span class="number">3</span>));<span class="comment">//弹出: number  </span></span><br><span class="line">alert(<span class="keyword">typeof</span>(<span class="number">-0.09999999</span>));<span class="comment">//弹出: number</span></span><br></pre></td></tr></table></figure><blockquote><p>3.计算机原理</p></blockquote><p>回忆一下大学时学过的计算机原理，计算机执行的是二进制算术，当十进制数不能准确转换为二进制数时，这种精度误差就在所难免。从上述的推演过程我们知道，这种误差是难免的，c#的decimal和Java的BigDecimal之所以没有出现精度差异，只是因为在其内部作了相应处理，把这种精度差异给屏蔽掉了，而javascript是一种弱类型的脚本语言，本身并没有对计算精度做相应的处理，这就需要我们另外想办法处理了</p><h2 id="解决JS计算精确度丢失"><a href="#解决JS计算精确度丢失" class="headerlink" title="解决JS计算精确度丢失"></a>解决JS计算精确度丢失</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;创建calc.js文件，其调用方法参考&nbsp;&nbsp;<i class="far fa-hand-point-right"></i><a href="https://fioralove.github.io/2019/11/15/ThinkPHP/" target="_blank" rel="noopener">thinkphp项目调用Vue扩展函数方式</a></p><p><a href="https://www.cnblogs.com/wzl-learn/p/9790443.html" target="_blank" rel="noopener">参考文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.calc = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 千分位格式化函数</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; number         要格式化的数字</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; decimals       保留几位小数</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; dec_point      小数点符号</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; thousands_sep  千分位符号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    number_format(number, decimals, dec_point, thousands_sep) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">parseFloat</span>(number) == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">" - "</span>;</span><br><span class="line">        number = (number + <span class="string">''</span>).replace(<span class="regexp">/[^0-9+-Ee.]/g</span>, <span class="string">''</span>);</span><br><span class="line">        <span class="keyword">var</span> n = !<span class="built_in">isFinite</span>(+number) ? <span class="number">0</span> : +number,</span><br><span class="line">            decimals = (<span class="keyword">typeof</span> decimals === <span class="string">'undefined'</span>) ? <span class="number">2</span> : decimals,</span><br><span class="line">            prec = !<span class="built_in">isFinite</span>(+decimals) ? <span class="number">0</span> : <span class="built_in">Math</span>.abs(decimals),</span><br><span class="line">            sep = (<span class="keyword">typeof</span> thousands_sep === <span class="string">'undefined'</span>) ? <span class="string">','</span> : thousands_sep,</span><br><span class="line">            dec = (<span class="keyword">typeof</span> dec_point === <span class="string">'undefined'</span>) ? <span class="string">'.'</span> : dec_point,</span><br><span class="line">            s = <span class="string">''</span>,</span><br><span class="line">            toFixedFix = <span class="function"><span class="keyword">function</span> (<span class="params">n, prec</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> k = <span class="built_in">Math</span>.pow(<span class="number">10</span>, prec);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">''</span> + <span class="built_in">Math</span>.ceil(n * k) / k;</span><br><span class="line">            &#125;;</span><br><span class="line">     </span><br><span class="line">        s = (prec ? toFixedFix(n, prec) : <span class="string">''</span> + <span class="built_in">Math</span>.round(n)).split(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">var</span> re = <span class="regexp">/(-?\d+)(\d&#123;3&#125;)/</span>;</span><br><span class="line">        <span class="keyword">while</span> (re.test(s[<span class="number">0</span>])) &#123;</span><br><span class="line">            s[<span class="number">0</span>] = s[<span class="number">0</span>].replace(re, <span class="string">"$1"</span> + sep + <span class="string">"$2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> ((s[<span class="number">1</span>] || <span class="string">''</span>).length &lt; prec) &#123;</span><br><span class="line">            s[<span class="number">1</span>] = s[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">            s[<span class="number">1</span>] += <span class="keyword">new</span> <span class="built_in">Array</span>(prec - s[<span class="number">1</span>].length + <span class="number">1</span>).join(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.join(dec);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加法函数，用来得到精确的加法结果</span></span><br><span class="line"><span class="comment">     * 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。</span></span><br><span class="line"><span class="comment">     * 调用：accAdd(arg1,arg2)</span></span><br><span class="line"><span class="comment">     * 返回值：arg1加上arg2的精确结果</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    accAdd: <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> r1, r2, m, c;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r1 = arg1.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            r1 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r2 = arg2.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            r2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="built_in">Math</span>.abs(r1 - r2);</span><br><span class="line">        m = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(r1, r2));</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> cm = <span class="built_in">Math</span>.pow(<span class="number">10</span>, c);</span><br><span class="line">            <span class="keyword">if</span> (r1 &gt; r2) &#123;</span><br><span class="line">                arg1 = <span class="built_in">Number</span>(arg1.toString().replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">                arg2 = <span class="built_in">Number</span>(arg2.toString().replace(<span class="string">"."</span>, <span class="string">""</span>)) * cm;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arg1 = <span class="built_in">Number</span>(arg1.toString().replace(<span class="string">"."</span>, <span class="string">""</span>)) * cm;</span><br><span class="line">                arg2 = <span class="built_in">Number</span>(arg2.toString().replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arg1 = <span class="built_in">Number</span>(arg1.toString().replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">            arg2 = <span class="built_in">Number</span>(arg2.toString().replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (arg1 + arg2) / m;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减法函数，用来得到精确的减法结果</span></span><br><span class="line"><span class="comment">     * 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。</span></span><br><span class="line"><span class="comment">     * 调用：accSub(arg1,arg2)</span></span><br><span class="line"><span class="comment">     * 返回值：arg1加上arg2的精确结果</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    accSub: <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> r1, r2, m, n;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r1 = arg1.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            r1 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r2 = arg2.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            r2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = <span class="built_in">Math</span>.pow(<span class="number">10</span>, <span class="built_in">Math</span>.max(r1, r2)); <span class="comment">//last modify by deeka //动态控制精度长度</span></span><br><span class="line">        n = (r1 &gt;= r2) ? r1 : r2;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseFloat</span>(((arg1 * m - arg2 * m) / m).toFixed(n));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乘法函数，用来得到精确的乘法结果 </span></span><br><span class="line">    <span class="comment">//说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 </span></span><br><span class="line">    <span class="comment">//调用：accMul(arg1,arg2) </span></span><br><span class="line">    <span class="comment">//返回值：arg1乘以arg2的精确结果 </span></span><br><span class="line">    accMul: <span class="function"><span class="keyword">function</span>(<span class="params">arg1,arg2</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">var</span> m = <span class="number">0</span>,</span><br><span class="line">            s1 = arg1.toString(),</span><br><span class="line">            s2 = arg2.toString();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m += s1.split(<span class="string">"."</span>)[<span class="number">1</span>].length</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m += s2.split(<span class="string">"."</span>)[<span class="number">1</span>].length</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(s1.replace(<span class="string">"."</span>, <span class="string">""</span>)) * <span class="built_in">Number</span>(s2.replace(<span class="string">"."</span>, <span class="string">""</span>)) / <span class="built_in">Math</span>.pow(<span class="number">10</span>, m);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除法函数，用来得到精确的除法结果 </span></span><br><span class="line">    <span class="comment">//说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 </span></span><br><span class="line">    <span class="comment">//调用：accDiv(arg1,arg2) </span></span><br><span class="line">    <span class="comment">//返回值：arg1除以arg2的精确结果 </span></span><br><span class="line">    accDiv: <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = <span class="number">0</span>,</span><br><span class="line">            t2 = <span class="number">0</span>,</span><br><span class="line">            r1, r2;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1 = arg1.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2 = arg2.toString().split(<span class="string">"."</span>)[<span class="number">1</span>].length</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span>(<span class="built_in">Math</span>) &#123;</span><br><span class="line">            r1 = <span class="built_in">Number</span>(arg1.toString().replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">            r2 = <span class="built_in">Number</span>(arg2.toString().replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">            <span class="keyword">return</span> (r1 / r2) * pow(<span class="number">10</span>, t2 - t1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js精确度丢失 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript篇章四：快速入门</title>
      <link href="/2019/11/21/Javascript%E7%AF%87%E7%AB%A0%E5%9B%9B/"/>
      <url>/2019/11/21/Javascript%E7%AF%87%E7%AB%A0%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-条件判断以及prompt-方法"><a href="#1-条件判断以及prompt-方法" class="headerlink" title="1.条件判断以及prompt() 方法"></a>1.条件判断以及prompt() 方法</h3><p>多条件判断：if…else if…else if…else<br>prompt(text,defaultText)方法用于显示可提示用户进行输入的对话框（即输入数据）,参数一表示提示文本，参数二表示默认值<br>var name=prompt(“Please enter your name”,”ritian zhao”)</p><h3 id="2-循环"><a href="#2-循环" class="headerlink" title="2.循环"></a>2.循环</h3><ol><li>for(i=1;i&lt;=1000;i++){}</li></ol><p>2.for…in…</p><p>3.while(){} </p><h3 id="3-return终止函数"><a href="#3-return终止函数" class="headerlink" title="3. return终止函数"></a>3. return终止函数</h3><p>1.return后面的语句不执行<br>2.JavaScript里的return只能返回一个数值（区别于python可以返回多个）</p><h3 id="4-Map与Set运用"><a href="#4-Map与Set运用" class="headerlink" title="4.Map与Set运用"></a>4.Map与Set运用</h3><h4 id="Map是一组键值对的结构，具有很快的查找速度"><a href="#Map是一组键值对的结构，具有很快的查找速度" class="headerlink" title="Map是一组键值对的结构，具有很快的查找速度"></a>Map是一组键值对的结构，具有很快的查找速度</h4><p>举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure><p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p><p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure><blockquote><p>Map的方法（初始化Map需要一个二维数组，或者直接初始化一个空Map）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 67,获取值</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个key只能对应一个value，所以，多次对一个key放入value，map函数会把后面的值会把前面的值冲掉</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set()"></a>Set()</h4><blockquote><p>Set和Map类似，也是一组key的集合，但不存储value。</p></blockquote><p>由于key不能重复，所以，在Set中，没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">//一个Array含1, 2, 3</span></span><br></pre></td></tr></table></figure><blockquote><p>重复元素在Set中自动被过滤：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>1.不在任何函数内定义的变量就具有全局作用域，实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。<br>window.属性/window.方法<br>2.ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量<br>3.ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域</p><p>浏览器对象：window,navigator,screen,Location，document</p><blockquote><p>window对象不仅充当全局作用域，而且表示浏览器的窗口</p></blockquote><p>window.innerWidth和window.innerHeight<br>windows.outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高</p><blockquote><p>navigator对象表示浏览器信息</p></blockquote><p>navigator.appName：浏览器名称；<br>navigator.appVersion：浏览器版本；<br>navigator.language：浏览器设置的语言；<br>navigator.platform：操作系统类型；<br>navigator.userAgent：浏览器设定的User-Agent字符串</p><blockquote><p>screen表示屏幕信息</p></blockquote><p>screen.width：屏幕宽度，以像素为单位；<br>screen.height：屏幕高度，以像素为单位；<br>screen.colorDepth：返回颜色位数，如8、16、24。</p><blockquote><p>Location对象表示当前页面的URL信息</p></blockquote><p>location.protocol; // ‘http’<br>location.host; // ‘<a href="http://www.example.com&#39;" target="_blank" rel="noopener">www.example.com&#39;</a><br>location.port; // ‘8080’<br>location.pathname; // ‘/path/index.html’<br>location.search; // ‘?a=1&amp;b=2’<br>location.hash; // ‘TOP’<br>location.href 获取完整url<br>location.assign()：加载一个新页面，可以调用<br>location.reload()：如果要重新加载当前页面</p><blockquote><p>document对象表示当前页面</p></blockquote><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><blockquote><p>map/reduce函数，与python的map，reduce作用相同</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"><span class="comment">// 对于reduce函数：函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算</span></span><br><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><blockquote><p>instanceof关键字</p></blockquote><p>这个关键字的用法是：A instanceof B ，返回值为boolean类型。用来判断A是否是B的实例对象或者B子类的实例对象。如果是则返回true,否则返回false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Man是Person的子类</span></span><br><span class="line">p = <span class="keyword">new</span> Person() ; <span class="comment">//</span></span><br><span class="line">m = <span class="keyword">new</span> Man() ; </span><br><span class="line">a = <span class="keyword">new</span> Animal() ;</span><br><span class="line">m <span class="keyword">instanceof</span> Man <span class="comment">//返回true</span></span><br><span class="line">m <span class="keyword">instanceof</span> Animal<span class="comment">//返回false</span></span><br><span class="line">m <span class="keyword">instanceof</span> Person<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure><h4 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h4><p>文本框，对应的<input type="text">，用于输入文本；</p><p>口令框，对应的<input type="password">，用于输入口令；</p><p>单选框，对应的<input type="radio">，用于选择一项；</p><p>复选框，对应的<input type="checkbox">，用于选择多项；</p><p>下拉框，对应的<select>，用于选择一项；</p><p>隐藏文本，对应的<input type="hidden">，用户不可见，但表单提交时会把隐藏文本发送到服务器。</p><blockquote><p>获取值</p></blockquote><p>如果我们获得了一个<input>节点的引用，就可以直接调用value获得对应的用户输入值，使用样例：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量名.value可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="tuesday" value="2"&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">'monday'</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">'tuesday'</span>);</span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">tue.value; <span class="comment">// '2'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><blockquote><p>构造函数</p></blockquote><p>构造函数与普通函数的区别就是调用方式不同：普通函数是直接调用，而构造函数需要使用new关键字来调用<br>PS:构造函数的函数名一般默认首字母大写；构造函数里可以使用this;<a href="http://ahrilove.top/2019/12/03/python的executemany方法/">参考：本质与python的构造函数相同</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个对象per</span></span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(per);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript篇章一：JavaScript基本知识</title>
      <link href="/2019/11/20/Javascript%E7%AF%87%E7%AB%A0%E4%B8%80/"/>
      <url>/2019/11/20/Javascript%E7%AF%87%E7%AB%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的，一个前端项目必离不开HTML+CSS+JavaScript。</p><blockquote><p><font size=4 color=#FF0000>本文要点：</font><br>1.变量及数据类型<br>2.对象<br>3.javascript小知识点<br><fancybox><img src="http://hd.wallpaperswide.com/thumbs/pin_up_001-t2.jpg" alt="一日不读书，我浑身难受"></fancybox></p></blockquote><a id="more"></a><h3 id="1-变量及数据类型：JavaScript变量是数据值的容器"><a href="#1-变量及数据类型：JavaScript变量是数据值的容器" class="headerlink" title="1. 变量及数据类型：JavaScript变量是数据值的容器"></a>1. 变量及数据类型：JavaScript变量是数据值的容器</h3><p>变量修饰符：var,let,const<br>var car=”BMW”;<br>var age=18;</p><blockquote><p>JavaScript数据类型分为：数值、字符串值、数组、对象等等</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> length = <span class="number">7</span>;                             <span class="comment">// 数字</span></span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">"Gates"</span>;                      <span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> cars = [<span class="string">"Porsche"</span>, <span class="string">"Volvo"</span>, <span class="string">"BMW"</span>];         <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> x = &#123;<span class="attr">firstName</span>:<span class="string">"Bill"</span>, <span class="attr">lastName</span>:<span class="string">"Gates"</span>&#125;;    <span class="comment">// 对象</span></span><br></pre></td></tr></table></figure><h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h3><p>对象的值以名称:值对的方式来书写（名称和值由冒号分隔）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;  <span class="comment">//这里的person称为对象</span></span><br><span class="line">    firstName:<span class="string">"Bill"</span>,  <span class="comment">//  这是属性</span></span><br><span class="line">    lastName:<span class="string">"Gates"</span>, </span><br><span class="line">    age:<span class="number">62</span>, </span><br><span class="line">    eyeColor:<span class="string">"blue"</span>,</span><br><span class="line">    fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 这就是方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JavaScript中的this关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在函数定义中，this 引用该函数的“拥有者”。</span><br><span class="line"></span><br><span class="line">在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。</span><br><span class="line"></span><br><span class="line">换言之，this.firstName 的意思是 this 对象的 firstName 属性。</span><br></pre></td></tr></table></figure><blockquote><p>对象的访问方式：</p></blockquote><p>对象名.属性名 或者<br>对象名[“属性名”]</p><h4 id="案例：数据集构造"><a href="#案例：数据集构造" class="headerlink" title="案例：数据集构造"></a>案例：数据集构造</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> dimensions = [];  <span class="comment">//维度</span></span><br><span class="line"><span class="keyword">let</span> source = [];      <span class="comment">//数据集</span></span><br><span class="line"><span class="keyword">let</span> series = [];        <span class="comment">//图系列</span></span><br><span class="line"></span><br><span class="line">dimensions.push(<span class="string">"groupcus_name"</span>);</span><br><span class="line">dimensions.push(<span class="string">"剩余发出商品"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;response.Rows.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj[<span class="string">"groupcus_name"</span>] = response.Rows[i].groupcus_name;  <span class="comment">// 对象的调用方式obj["key_name"]或obj.key_name</span></span><br><span class="line">    obj[<span class="string">"剩余发出商品"</span>] = response.Rows[i].surplusp;</span><br><span class="line"></span><br><span class="line">    source.push(obj);   <span class="comment">// 记住push只适用于数组的元素添加，并返回数组元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-javascript小知识点"><a href="#3-javascript小知识点" class="headerlink" title="3.javascript小知识点"></a>3.javascript小知识点</h3><blockquote><p>函数语法</p></blockquote><p>function function_name(param1,param2,…){code}<br>PS:不使用 () 访问函数将返回函数声明而不是函数结果</p><blockquote><p>3.1 js字符串长度</p></blockquote><p>易混点：<br>JavaScript字符串长度：str.length<br>php的字符串长度：count(string)<br>python的字符串长度：len(string)<br>jQuery中的length：表示query对象中元素个数 $(“div”).siblings().length=&gt;表示div标签的兄弟节点元素个数</p><blockquote><p>3.2 使用\ 转义字符</p></blockquote><p>\n表示换行</p><blockquote><p>3.3 比较运算符与逻辑运算符</p></blockquote><p>&quot;==&quot;:表示值相等<br>&quot;===&quot;:表示值相等基础上，数据类型也相同<br>&amp;&amp; :表示与运算<br>|| :表示或运算<br>! : 表示非运算 </p><blockquote><p>str.slice(start，end)方法</p></blockquote><p>slice() 提取字符串的某个部分并在新字符串中返回被提取的部分(起始索引值为0，且满足左闭右开)。</p><p>该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。</p><blockquote><p>substring()方法</p></blockquote><p>substring() 类似于 slice()，不同之处在于 substring() 无法接受负的索引</p><blockquote><p>substr(start,length)</p></blockquote><p>第二个参数规定被提取部分的长度，如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。</p><blockquote><p>str.replace(a,b) 用b替换a</p></blockquote><p>&#39;hello java&#39;.replace(&#39;java&#39;,&#39;python&#39;)</p><blockquote><p>转换为大小写</p></blockquote><p>str.toUpperCase()<br>str.toLowerCase()</p><blockquote><p>str.trim(“指定字符”)</p></blockquote><p>trim() 方法删除字符串两端的空白符或指定字符</p><blockquote><p>str.split(“指定字符”) </p></blockquote><p>以指定字符切割字符串，返回数组的形式</p><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h3>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clone </tag>
            
            <tag> push </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memcached</title>
      <link href="/2019/11/20/Memcache/"/>
      <url>/2019/11/20/Memcache/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。<font color=#FF4500>适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session</font>等所有不是至关重要的数据(保存于内存中，关机后数据就会消失)</p><blockquote><p><font size=4 color=#FF0000>本文要点：</font><br>1.win，Linux安装memcached<br>2.docker创建memcached<br>3.测试并进入容器<br>4.telnet操作memcached<br>……<br><fancybox><img src="http://hd.wallpaperswide.com/thumbs/japanese_woman-t2.jpg" alt="浙江大学，冲！"></fancybox></p></blockquote><a id="more"></a><h2 id="1-安装memcached"><a href="#1-安装memcached" class="headerlink" title="1.安装memcached"></a>1.安装memcached</h2><p>&nbsp;&nbsp;&nbsp;Memcached是通过在内存里维护一个统一的巨大的hash表，memcached能存储各种各样的数据，包括图像、视频<font color=#FF4500>(但是极不推荐来保存二进制文件)</font>、文件、以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。<br><a href="https://blog.csdn.net/qq_41717874/article/details/89472198" target="_blank" rel="noopener">参考docker创建memecached容器</a><br><a href="https://www.cnblogs.com/b-ruce/p/5639223.html" target="_blank" rel="noopener">windows下ThinkPHP3.2.3使用memcache缓存</a></p><h2 id="2-创建memcached镜像"><a href="#2-创建memcached镜像" class="headerlink" title="2.创建memcached镜像"></a>2.创建memcached镜像</h2><p>docker run -di –name=”memcached” -m 256m -p 11211:11211 memcached:[tag]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d是启动一个守护进程；</span><br><span class="line">-m是分配给Memcache使用的内存数量，单位是MB；</span><br><span class="line">-u是运行Memcache的用户；</span><br><span class="line">-l是监听的服务器IP地址，可以有多个地址；</span><br><span class="line">-p是设置Memcache监听的端口，，最好是1024以上的端口；</span><br><span class="line">-c是最大运行的并发连接数，默认是1024；</span><br></pre></td></tr></table></figure><h2 id="3-测试并进入docker容器"><a href="#3-测试并进入docker容器" class="headerlink" title="3.测试并进入docker容器"></a>3.测试并进入docker容器</h2><blockquote><p>测试是否启动成功</p></blockquote><p>netstat -luntp|grep 11211或者docker ps</p><blockquote><p>安装telnet</p></blockquote><p>yum install -y telnet 或 sudo apt-get install telnet</p><blockquote><p>通过telnet方式连接memcached</p></blockquote><p>telnet 127.0.0.1 11211 或者使用 telnet ubuntu_ip docker_memcached_port</p><blockquote><p>设置值，age是key，0是标志位，900是生命周期，8代表所占字节数，回车之后的10是value</p></blockquote><p>set age 0 900 8<br>10</p><blockquote><p>获取值 </p></blockquote><p>get age</p><blockquote><p>退出</p></blockquote><p><del>exit</del><br>quit</p><h2 id="4-telnet操作memcached："><a href="#4-telnet操作memcached：" class="headerlink" title="4.telnet操作memcached："></a>4.telnet操作memcached：</h2><p>1.添加数据</p><ul><li>set语法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> set key flas(是否压缩,默认为0，不压缩) timeout value_length</span><br><span class="line">  value</span><br><span class="line">示例：</span><br><span class="line">  set username 0 60 7</span><br><span class="line">  zhiliao</span><br><span class="line">``` </span><br><span class="line">  </span><br><span class="line">+ add语法：</span><br></pre></td></tr></table></figure>add key flas(0) timeout value_length<br>value<br>示例：<br>add username 0 60 7<br>xiaotuo<pre><code>set和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。</code></pre></li></ul><p>2.获取数据：get key_name</p><p>3.删除数据：delete key_name</p><p>4.删除memcached所有数据：flush_all</p><h2 id="5-memcached安全性"><a href="#5-memcached安全性" class="headerlink" title="5. memcached安全性"></a>5. memcached安全性</h2><p>memcached的操作不需要任何用户名和密码，只需要知道memcached服务器的ip地址和端口号即可。因此memcached使用的时候尤其要注意他的安全性。这里提供两种安全的解决方案。分别来进行讲解：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.使用-l参数设置为只有本地可以连接：这种方式，就只能通过本机才能连接，别的机器都不能访问，可以达到最好的安全性。<br>&nbsp;&nbsp;&nbsp;&nbsp;2.使用防火墙，关闭11211端口，外面也不能访问</p><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memcached </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker开发环境系列部署</title>
      <link href="/2019/11/19/docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/11/19/docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p><font color=#00CD00>docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群</font></p><ul><li>搭建python3+django+mysql开发环境</li><li>Docker实现Nginx和Tomcat负载均衡<a id="more"></a></li></ul><h2 id="1-python3-Django-MySQL部署Django项目集群"><a href="#1-python3-Django-MySQL部署Django项目集群" class="headerlink" title="1.python3+Django+MySQL部署Django项目集群"></a>1.<a href="https://blog.csdn.net/geek_xiong/article/details/92721957" target="_blank" rel="noopener">python3+Django+MySQL部署Django项目集群</a></h2><h4 id="1-1-宿主机上创建工程目录site，并进入该目录"><a href="#1-1-宿主机上创建工程目录site，并进入该目录" class="headerlink" title="1.1 宿主机上创建工程目录site，并进入该目录"></a>1.1 宿主机上创建工程目录site，并进入该目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">项目目录结构：</span><br><span class="line">site</span><br><span class="line">    |__achievements</span><br><span class="line">    |__db</span><br><span class="line">    |__Dockerfile</span><br><span class="line">    |__doocker-compose.yml</span><br><span class="line">    |__requirements.txt</span><br></pre></td></tr></table></figure><h4 id="1-2-参考两篇优秀博文"><a href="#1-2-参考两篇优秀博文" class="headerlink" title="1.2 参考两篇优秀博文"></a>1.2 参考两篇优秀博文</h4><p><a href="https://blog.csdn.net/geek_xiong/article/details/92721957" target="_blank" rel="noopener">离未罔两|Docker—-搭建python3+django+mysql开发环境</a><br><a href="https://blog.csdn.net/qq_25639809/article/details/78958647" target="_blank" rel="noopener">冰凉的枷锁lax|Docker搭建Python+Django+mysql开发环境</a></p><h2 id="2-Docker实现Nginx和Tomcat负载均衡"><a href="#2-Docker实现Nginx和Tomcat负载均衡" class="headerlink" title="2. Docker实现Nginx和Tomcat负载均衡"></a>2. Docker实现Nginx和Tomcat负载均衡</h2><p><a href="https://blog.csdn.net/u014106644/article/details/83152366" target="_blank" rel="noopener">暗夜猎手-大魔王|使用docker搭建高并发网站架构实践2–Docker实现Nginx和Tomcat负载均衡</a><br><fancybox><img src="https://img-blog.csdn.net/20181018202515672?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQxMDY2NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></fancybox></p><p><a href="https://blog.csdn.net/bbwangj/article/details/81005982" target="_blank" rel="noopener">菲宇|Docker下Nginx+Tomcat实现负载均衡</a><br><fancybox><img src="https://img-blog.csdn.net/20181012094800471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jid2FuZ2o=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></fancybox></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> python+Django+MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模拟登录淘宝(Ⅰ)</title>
      <link href="/2019/11/18/requests%E5%BA%93%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E6%B7%98%E5%AE%9D(%E2%85%A0)/"/>
      <url>/2019/11/18/requests%E5%BA%93%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E6%B7%98%E5%AE%9D(%E2%85%A0)/</url>
      
        <content type="html"><![CDATA[<p>讲模拟登录淘宝之前，我们来回顾一下之前用requests库模拟登录GitHub和新浪微博的过程:<font color=#00CD00>这一类模拟登录是比较简单的登录，只需要在请求登录时将用户名和密码上传验证通过就成功了</font>，也就是说一步到位！而淘宝登录就比较复杂，为什么说复杂呢？因为淘宝登录涉及参数多且请求不止一次！</p><a id="more"></a><p><a href="https://blog.csdn.net/u014044812/article/details/99584382" target="_blank" rel="noopener">参考文章~裸睡的猪</a></p><pre>淘宝系列欲更新文章内容：    第一篇：Python模拟登录淘宝，详细讲解如何使用requests库登录淘宝pc端。    第二篇：淘宝自动登录2.0，新增Cookies序列化，教大家如何将cookies保存起来。    第三篇：Python爬取淘宝商品避孕套，教大家如何爬取淘宝pc端商品信息。    第四篇：Python分析2000款避孕套，教大家如何做数据分析得出结论。    ————————————————</pre><h4 id="1-淘宝登录流程"><a href="#1-淘宝登录流程" class="headerlink" title="1.淘宝登录流程"></a>1.淘宝登录流程</h4>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Requests </tag>
            
            <tag> POST请求 </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令总结</title>
      <link href="/2019/11/18/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/11/18/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>总结一下自己常用的git命令<br><fancybox><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1192836097,3318398259&fm=26&gp=0.jpg"></fancybox></p><a id="more"></a><ol><li><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”</p></li><li><p>git config –global user.name “Your Name”<br>git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</p></li><li><p>cd F: (打开F盘)<br>mkdir <name> (创建子目录)<br>pwd (显示当前目录)</p></li><li><p>git init (把这个目录变成Git可以管理的仓库)</p></li><li><p>git add <file></p></li><li><p>git commit -m “说明”</p></li><li><p>git status (仓库当前的状态)</p></li><li><p>git diff (查看不同)</p></li><li><p>git log [–pretty=oneline  {缩略版,可选}] (查看历史记录)</p></li><li><p>git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id)</p></li><li><p>git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本)</p></li><li><p>git diff HEAD – <file> (查看工作区和版本库里面最新版本的区别)</p></li><li><p>git checkout – <file> (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除)</p></li><li><p>git reset HEAD <file> (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本)</p></li><li><p>git rm (用于删除一个文件)</p></li><li><p>ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ (创建SSH Key)</p></li><li><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Bruce333/other.git (关联github远程库)</p></li><li><p>git push -u origin master/git push origin master<br>(推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改)</p></li><li><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Bruce333/other.git (克隆一个本地库)</p></li><li><p>git checkout -b dev<br>(创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支])</p></li><li><p>git branch (列出所有分支，当前分支前面会标一个*号)</p></li><li><p>git checkout master (切换到master分支)</p></li><li><p>git merge dev (合并指定分支到当前分支)</p></li><li><p>git branch -d dev (删除dev分支)</p></li><li><p>git log –graph (查看分支合并图)</p></li><li><p>git merge –no-ff -m “merge with no-ff” dev<br>(通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去)</p></li><li><p>git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作)</p></li><li><p>git stash list (查看工作现场) / git stash apply stash@{0} ()</p></li><li><p>git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除])</p></li><li><p>git branch -D <name> (强行删除一个没有被合并过的分支)</p></li><li><p>git remote (查看远程库的信息) / git remote -v (显示更详细的信息)</p></li><li><p>git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致)</p></li><li><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交</p></li><li><p>git pull<br>(把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，<br>用命令git branch –set-upstream branch-name origin/branch-name)</p></li><li><p>git tag <name> &lt;commit id 可无&gt;<br>(打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签)</p></li><li><p>git show <tagname> (查看标签信息)</p></li><li><p>git tag (查看所有标签)</p></li><li><p>git tag -a <tagname> -m “blablabla…” (指定标签信息)</p></li><li><p>git tag -s <tagname> -m “blablabla…” (用PGP签名标签)</p></li><li><p>git tag -d <name> (删除标签)</p></li><li><p>git push origin <tagname> (推送某个标签到远程)</p></li><li><p>git push origin –tags (一次性推送全部尚未推送到远程的本地标签)</p></li><li><p>git tag -d <tagname> (删除一个本地标签)</p></li><li><p>git push origin :refs/tags/<tagname> (删除一个远程标签)</p></li><li><p>git config –global color.ui true (让Git适当地显示不同的颜色)</p></li><li><p>忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理</p></li><li><p>git config –global alias.st status<br>(告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中)</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> git pull/push </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkPHP</title>
      <link href="/2019/11/15/ThinkPHP/"/>
      <url>/2019/11/15/ThinkPHP/</url>
      
        <content type="html"><![CDATA[<p>最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题</p><p>涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。</p><blockquote><p>js的push(),clone()<br>ThinkPHP的变量输出<br>memcached缓存机制<br>ThinkPHP通用项目结构</p></blockquote><a id="more"></a><p><a href="https://github.com/FioraLove/HTML-CSS-JavaScript/tree/master/ThinkPHP%203.2" target="_blank" rel="noopener">ThinkPHP3.2 笔记</a></p><h3 id="1-js的clone-与push函数的一些生活纠纷"><a href="#1-js的clone-与push函数的一些生活纠纷" class="headerlink" title="1.js的clone()与push函数的一些生活纠纷"></a>1.js的clone()与push函数的一些生活纠纷</h3><blockquote><p>push()函数：向数组的末尾添加一个或多个元素，并返回新的长度。返回值是把指定的值添加到数组后的新长度<br>语法：arrayObject.push(newelement1,newelement2,….)</p></blockquote><p>push() 方法可把它的参数顺序添加到 arrayObject（数组对象）的尾部。它直接修改 arrayObject，而不是创建一个新的数组，而是在原数组基础上修改。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能，该方法会改变数组的长度。</p><p>案例1：push()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"chd"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"sjb"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"sgx"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//输出原素组 ['chd','sjb','sgx']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.push(<span class="string">"badwoman"</span>));  <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure><p>PS:来了，push添加元素之后没有直接输出添加元素之后的数组，只显示了数组的个数（长度）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示push后的新数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"chd"</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"sjb"</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">"sgx"</span>;</span><br><span class="line">arr.push(<span class="string">'badwoman'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//输出结果为：['chd','sjb','sgx','badwoman']</span></span><br></pre></td></tr></table></figure><blockquote><p>js的clone()函数</p></blockquote><p>js对象之间的赋值，如果直接用”=”会发现来两个对象还是同一个对象，改变其中一个另外的一个也会做出对应的改变。为了解决这个问题，可以利用java里面的clone的原理。<br>假设有这样一个场景：当存在一个公共数组(对象型)时，一个需要加{“name”:”chd”,”age”:18}另一个需要在数组尾加上{“name”:”sgx”,”age”:108}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> commonCondition=[&#123;<span class="string">"id"</span>:<span class="number">15</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> a=&#123;<span class="string">"name"</span>:<span class="string">"chd"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b=&#123;<span class="string">"name"</span>:<span class="string">"sgx"</span>,<span class="string">"age"</span>:<span class="number">108</span>&#125;;</span><br><span class="line"><span class="comment">// 当我们利用a = commonCondition.push(a)时，此时原来的commonCondition也会跟着改变</span></span><br><span class="line"><span class="comment">// 赋值b = commonCondition.push(b)。此时，b中也会包含a的数据，此刻js的clone函数就出现了</span></span><br></pre></td></tr></table></figure><p>js的clone()函数源代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">Obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj == <span class="string">"object"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">                o = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">                    o = [];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.length; i &lt; len; i++) &#123;</span><br><span class="line">                        o.push(<span class="keyword">this</span>.clone(obj[i])); <span class="comment">// 有可能不要this</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o = &#123;&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> j <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                        o[j] = <span class="keyword">this</span>.clone(obj[j]);  <span class="comment">// 有可能不要this</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即此刻，我们才有如下最正确的式子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> new_a = clone(commonCondition);</span><br><span class="line">a = new_a.push(a);</span><br><span class="line"><span class="keyword">let</span> new_b = clone(commonCondition);</span><br><span class="line">b = new_b.push(b);</span><br></pre></td></tr></table></figure><h3 id="2-thinkphp项目调用Vue扩展函数方式"><a href="#2-thinkphp项目调用Vue扩展函数方式" class="headerlink" title="2. thinkphp项目调用Vue扩展函数方式"></a>2. thinkphp项目调用Vue扩展函数方式</h3><p>2.1 导入vue扩展包.js文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./cf.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.2 声明方法：新建一个与项目名同名的js文件，新增如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.prototype.项目名 = &#123;</span><br><span class="line">    // 这里表示扩展函数</span><br><span class="line">    函数名一:function(obj)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    函数名二:function(obj)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.3 调用方法：<del>Vue实例化名.</del>  项目名.函数名()<br><del>Vue实力化名即：let app = new Vue({})中的app</del>,经过测试后，调用方法为 项目名.函数名（）</p><h3 id="3-thinkPHP的变量输出知识-lt-函数名-变量名-gt-中的冒号-quot-quot-表示引用调用函数，获取变量值"><a href="#3-thinkPHP的变量输出知识-lt-函数名-变量名-gt-中的冒号-quot-quot-表示引用调用函数，获取变量值" class="headerlink" title="3.thinkPHP的变量输出知识&lt;{:函数名/变量名}&gt; 中的冒号&quot;:&quot;表示引用调用函数，获取变量值"></a>3.thinkPHP的变量输出知识&lt;{:函数名/变量名}&gt; 中的冒号&quot;:&quot;表示引用调用函数，获取变量值</h3><blockquote><p>&lt;{:U(query)}&gt;:URL生成<a href="http://serverName/projectName/当前模块/当前控制器/声明的方法" target="_blank" rel="noopener">http://serverName/projectName/当前模块/当前控制器/声明的方法</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认的模板标签为：在config.php文件下更改设置</span><br><span class="line">&apos;TMPL_L_DELIM&apos;=&gt;&apos;&lt;&#123;&apos;,</span><br><span class="line">&apos;TMPL_R_DELIM&apos;=&gt;&apos;&#125;&gt;&apos;,</span><br></pre></td></tr></table></figure><blockquote><p>&lt;{:I(‘name’,’chd’)}&gt;中的I方法获取自定义参数值，不存在时，自定义默认值</p></blockquote><p>I(‘get.name’); // 相当于 $_GET[‘name’]支持默认值：</p><p><font color=#f05b72>2019-12-8 新增：<br>查看thinkphp3.2手册存在变量输出方式二：<br>在模板（即HTML文件）中输出变量的方式很简单，只需要我们在控制器给模板变量赋值：<br></font></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$name = <span class="string">"ThinkPHP"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> $this-&gt;assign() 绑定，分配数据</span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> （'name',$name）参数一：表示要在模板中引用的变量名，在不加$符号时，也要使用引号括起来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;assign(<span class="string">'name'</span>,$name); </span><br><span class="line"><span class="keyword">$this</span>-&gt;display();  <span class="comment">// 将分配的数据在HTML页面展示</span></span><br></pre></td></tr></table></figure><p>然后再模板中使用（注意模板标签的{和$之间不能有任何的空格，否则标签无效,普通标签默认开始标记是{，结束标记是 }。也可以通过设置TMPL_L_DELIM和TMPL_R_DELIM进行更）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello,<span class="tag">&lt;<span class="name">&#123;$name&#125;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在模板编译后结果为：--&gt;</span></span><br><span class="line">Hello,<span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span>($name);<span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!--这样就在HTML页面显示为：--&gt;</span></span><br><span class="line">hello,ThinkPHP</span><br></pre></td></tr></table></figure><h3 id="4-ThinkPHP的memcached缓存机制"><a href="#4-ThinkPHP的memcached缓存机制" class="headerlink" title="4. ThinkPHP的memcached缓存机制"></a>4. ThinkPHP的memcached缓存机制</h3><blockquote><p>4.1 下载安装memcached，并启动其服务</p></blockquote><p> <a href="https://blog.csdn.net/qq_41717874/article/details/89472198" target="_blank" rel="noopener">参考docker创建memecached容器</a><br> <a href="https://www.cnblogs.com/b-ruce/p/5639223.html" target="_blank" rel="noopener">windows下ThinkPHP3.2.3使用memcache缓存</a></p><blockquote><p>4.2thinkphp3.2中其实已经加入了memcached缓存机制，只需要在Conf/config.php配置数据缓存类型即可使用Memcache:</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'DATA_CACHE_TYPE'</span> =&gt; <span class="string">'Memcache'</span>,  <span class="comment">// 数据缓存类型 </span></span><br><span class="line">    <span class="string">'MEMCACHE_HOST'</span>   =&gt; <span class="string">'tcp://127.0.0.1:11211'</span>, </span><br><span class="line">    <span class="string">'DATA_CACHE_TIME'</span> =&gt; <span class="string">'3600'</span></span><br><span class="line">    )</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-ThinkPHP项目模块结构，参考此文章"><a href="#5-ThinkPHP项目模块结构，参考此文章" class="headerlink" title="5.ThinkPHP项目模块结构，参考此文章"></a>5.ThinkPHP项目模块结构，<a href="https://www.cnblogs.com/xiaoliwang/p/7996540.html" target="_blank" rel="noopener">参考此文章</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">project项目名:</span><br><span class="line">    |---Application:应用模块</span><br><span class="line">        |Admin后台模块</span><br><span class="line">        |Home前台模块</span><br><span class="line">            |---Controller控制器</span><br><span class="line">                |---IndexController.class.php</span><br><span class="line">            |---Model模型</span><br><span class="line">                |---IndexModel.class.php</span><br><span class="line">            |---View视图</span><br><span class="line">                |---index.html</span><br><span class="line">        |Common公共配置模块（不能直接访问）</span><br><span class="line">        |Runtime缓存模块</span><br><span class="line">    |---Public静态资源文件</span><br><span class="line">    |---ThinkPHP框架</span><br><span class="line">    |---index.php：入口文件</span><br><span class="line">    |---favicon.ico：网站图标</span><br><span class="line">    |---.htaccess:Apache配置文件（重写URL，修改访问权限）</span><br></pre></td></tr></table></figure><h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h3>]]></content>
      
      
      <categories>
          
          <category> ThinkPHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> $.post() </tag>
            
            <tag> thinkPHP </tag>
            
            <tag> API </tag>
            
            <tag> Ajax </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON通常用于与服务端交换数据,在向服务器发送数据时一般是字符串</title>
      <link href="/2019/11/14/json/"/>
      <url>/2019/11/14/json/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;json语法规则</p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>大括号保存对象</li><li>中括号保存数组<br>PS:json键值对一定要用双引号包裹起来<a id="more"></a></li></ul><h2 id="1-Python的json规则"><a href="#1-Python的json规则" class="headerlink" title="1.Python的json规则"></a>1.Python的json规则</h2><p>python程序中的json有一点点区别于JavaScript中的json，它是通过对象和数组的组合来表示数据</p><blockquote><p>1.1 对象型数组</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它在JavaScript是使用花括号{}包裹起来的内容，数据结构为{key1:value1,key2:value2…}的键值对结构，key为对象的属性，value为对应的值。键名可以使用整数和字符串来表示，<br>所以，一个json对象跨用写作如下格式(对象型数组)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"chd"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">"sex"</span>: <span class="string">"man"</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Monica"</span>,</span><br><span class="line">  <span class="attr">"gender"</span>: <span class="string">"woman"</span>,</span><br><span class="line">  <span class="attr">"birthday"</span>: <span class="string">"1997-1-25"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><blockquote><p>调用方式:通过中括号加0索引，可以得到第一个字典元素，然后调用其键名即可得到相应的键值</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式一：中括号加键名<br>data[index][“键名”] =&gt; data[0][‘name’]，结果为‘chd’<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式二：get()方法传入键名，如果键名不存在，不会报错，会返回none（python中推荐使用）<br>data[index].get(‘键名’) =&gt; data[1].get(“birthday”),结果为”1997-1-25”</p><blockquote><p>1.2 键值对形式（类似于字典）</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"msg"</span>: <span class="string">"success"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"pig"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="string">"18"</span>,</span><br><span class="line">    <span class="attr">"sex"</span>: <span class="string">"man"</span>,</span><br><span class="line">    <span class="attr">"hometown"</span>: &#123;</span><br><span class="line">      <span class="attr">"province"</span>: <span class="string">"江西省"</span>,</span><br><span class="line">      <span class="attr">"city"</span>: <span class="string">"抚州市"</span>,</span><br><span class="line">      <span class="attr">"county"</span>: <span class="string">"崇仁县"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.3 需要注意到点</p></blockquote><p>JSON的键名和字符串都必须使用双引号引起来，而Python中单引号也可以表示为字符串，所以这是个比较容易犯的错误！<br>Python类型与JSON相互转换的时候到底是用load//dump还是用loads\dumps？<br>他们之间有什么区别？什么时候该加s什么时候不该加s？<br>这个我们可以通过查看源码找到答案：<br>不加s的方法入参多了一个fp表示filepath，最后多了一个写入文件的操作。<br>所以我们在记忆的时候可以这样记忆：<br><font color=#f05b72>加s表示转成字符串(str)，不加s表示转成文件。</font></p><h2 id="2-javascript中的json"><a href="#2-javascript中的json" class="headerlink" title="2.javascript中的json"></a>2.javascript中的json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stu = &#123;&quot;student&quot;:           //stu 对象包含student的key,值为一个数组</span><br><span class="line">            [                                     //数组的每一个值为一个具体的学生对象</span><br><span class="line">                &#123;&quot;name&quot;: &quot;Tom&quot;,&quot;Grade&quot;:1, &quot;age&quot;:11, &quot;gender&quot;: &quot;M&quot;&#125;,     //学生对象的键为名字,值为对应属性</span><br><span class="line">                &#123;&quot;name&quot;: &quot;Jerry&quot;, &quot;Grade&quot;:1, &quot;age&quot;:10, &quot;gender&quot;: &quot;M&quot;&#125;       //每个属性对应的是一个key,value对</span><br><span class="line">            ],</span><br><span class="line">            &quot;classroom&quot;: &#123;&quot;class1&quot;: &quot;room1&quot;, &quot;class2&quot;: &quot;room2&quot;&#125;         //对象的值,嵌套对象</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>json.parse()方法将数据转换为 JavaScript 对象</p></blockquote><blockquote><p>json.stringify() 方法将 JavaScript 对象转换为字符串。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json.parse() </tag>
            
            <tag> json.stringify() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库存储引擎与索引,视图</title>
      <link href="/2019/11/12/mysql(%E4%BA%8C)/"/>
      <url>/2019/11/12/mysql(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。</p><ul><li>索引概述</li><li>索引作用</li><li>视图</li><li>视图的操作</li></ul><a id="more"></a><h3 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1.索引概述"></a>1.索引概述</h3><p>索引在创建表的时候可以同时创建，也可以随时增加新的索引<br>创建新索引的语法为:<br>create [unique|fulltext|spatial] index index_name [using index_type] on table_name( col_name [(length)] [asc|desc])<br>删除索引： DROP INDEX index_name on table_name</p><h3 id="2-索引作用"><a href="#2-索引作用" class="headerlink" title="2.索引作用"></a>2.索引作用</h3><p>合理的创建索引是提高查询速度最有效的方式之一。<br>&nbsp;&nbsp;&nbsp;&nbsp;在没有建立索引的情况下，查询一条数据的过程是这样：<br>MySQL是从第一条记录开始查表，在某一个地方查到了匹配的数据，停止？NO，继续查询剩下的数据，直到查完整张表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在建立合适索引的情况下，查询一条数据的过程又是这样：<br>MySQL先根据索引快速到达一个位置去搜索数据文件，然后查出数据，而不必查看整张表的数据。<br>tips:<br><font color=#FF3030><br>1、索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。<br>2、索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。<br>3、通过创建唯一索引，可以保证某一列的值具有唯一性。</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*添加唯一索引：*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> unique_name(<span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*只添加唯一约束而不添加唯一索引：*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> unique_name <span class="keyword">UNIQUE</span>(<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure><p>因此，为了提高查询速度，合理建立索引是非常有必要的。</p><hr><table><thead><tr><th>类型</th><th align="center">描述</th></tr></thead><tbody><tr><td>普通索引</td><td align="center">基本的索引类型，允许定义索引的列中插入重复值和空值</td></tr><tr><td>唯一索引</td><td align="center">索引列值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一</td></tr><tr><td>主键索引</td><td align="center">特殊的唯一索引，不允许有空值</td></tr><tr><td>全文索引</td><td align="center">类型为FULLTEXT,支持值的全文查找，允许在索引列中插入重复值和空值</td></tr><tr><td>组合索引</td><td align="center">在表的多个字段组合上创建的索引</td></tr></tbody></table><h3 id="3-视图（5-0-1提供视图功能）"><a href="#3-视图（5-0-1提供视图功能）" class="headerlink" title="3.视图（5.0.1提供视图功能）"></a>3.视图（5.0.1提供视图功能）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;视图是一种虚拟存在的表，它存储的是查询语句，显示出来的是查询的结果；更直白的说就是当我们需要从表中查询一些信息时需要编写相关SQL语句，将这些SQL语句存储为视图，那么我们调用这些视图的时候就相当于执行了SQL语句，从而可以得到想要的结果<br>eg:创建视图并执行查询操作<br> create view view_name as select qty,price,qty*price as value from temp;</p><h4 id="视图有什么作用"><a href="#视图有什么作用" class="headerlink" title="视图有什么作用"></a>视图有什么作用</h4><blockquote><p>1.视图就像是一个封装了很多功能的函数，我们把一系列复杂的查询语句存储为一个视图，这样在需要频繁使用这些语句时不必反复编写，直接使用视图代替即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果要频繁获取表user的name和表goods的name。就应该使用以下sql语句：</span><br><span class="line">select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;</span><br><span class="line"></span><br><span class="line">但有了视图就不一样了，创建视图other。示例</span><br><span class="line">create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;</span><br><span class="line"></span><br><span class="line">创建好视图后，就可以这样获取user的name和goods的name：</span><br><span class="line"> select * from other;</span><br></pre></td></tr></table></figure><blockquote><p>2.对数据库进行重构但仍不会影响程序运行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假如因为某种需求，需要将user表拆成表usera和表userb，该两张表的结构如下：</span><br><span class="line">        测试表:usera有id，name，age字段</span><br><span class="line">        测试表:userb有id，name，sex字段</span><br><span class="line">这时如果程序端一直使用的sql语句是：select * from user;那就会报错提示该表不存在，这时要么去更改程序的查询语句要么就创建视图。显然，创建视图更简单，成本更低。</span><br><span class="line">以下sql语句创建视图：</span><br><span class="line">create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;</span><br><span class="line">以上假设name都是唯一的。</span><br><span class="line">这时程序端端使用的sql语句：select * from user;就不会报错。这就实现了更改数据库结构，而不用更改脚本程序的功能。</span><br></pre></td></tr></table></figure><h3 id="4-视图的操作"><a href="#4-视图的操作" class="headerlink" title="4.视图的操作"></a>4.视图的操作</h3><blockquote><p>4.1 创建或修改视图</p></blockquote><p>create [ or replace ] [ algorithm = { undefined | merge | temptable } ] view view_name [ (column_list) ] as select_statement [ with [ cascaded | local ] check option ]</p><ul><li>使用了OR REPLACE可以修改视图，或者直接就CREATE OR REPLACE 替换为ALTER 即变成修改语法；</li><li>UNDEFINED：未定义指定算法；MERGE：更新视图表数据的同时会更新真实表的数据（默认）；TEMPTABLE：只能查询不能更新；</li><li>CASCADED(默认)：必须满足所有针对该视图的所有视图的条件才可以更新；LOCAL：只需满足本视图的条件就可以更新；</li><li>WITH CHECK OPTION：需要满足相关的检查条件才能进行更新<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--常量视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> <span class="keyword">pi</span> <span class="keyword">as</span> <span class="keyword">select</span> <span class="number">3.1415926</span> <span class="keyword">as</span> <span class="keyword">pi</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--select中包含子查询</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> city_view <span class="keyword">as</span> <span class="keyword">select</span> (<span class="keyword">select</span> city <span class="keyword">from</span> city <span class="keyword">where</span> city_id=<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>4.2 查看当前数据库下所有视图 show full tables where table_type like ‘view’;</p></blockquote><h3 id="5-优化SQL语句一般步骤"><a href="#5-优化SQL语句一般步骤" class="headerlink" title="5.优化SQL语句一般步骤"></a>5.优化SQL语句一般步骤</h3><blockquote><p>5.1 通过show status 查看各语句的频率</p></blockquote><h3 id="6-数据库Leetcode"><a href="#6-数据库Leetcode" class="headerlink" title="6.数据库Leetcode"></a>6.数据库Leetcode</h3><p>1.求薪水第二高，不存在就返回null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ifnull</span>((<span class="keyword">select</span> <span class="keyword">distinct</span>(Salary) </span><br><span class="line"><span class="keyword">from</span> Employee </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span>),<span class="literal">null</span>) <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>超过5名学生的课(having用法)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">from</span> courses</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> student) &gt;= <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>DATEDIFF是两个日期的天数差集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Id <span class="keyword">as</span> newId</span><br><span class="line"><span class="keyword">from</span> Weather a <span class="keyword">left</span> <span class="keyword">join</span> Weather b </span><br><span class="line"><span class="keyword">on</span> <span class="keyword">datediff</span>(a.RecordDate,b.RecordDate)=<span class="number">1</span> <span class="keyword">where</span> a.Temperature&gt;b.Temperature</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
            <tag> MyISAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库(一)：DDL，DML，DCL</title>
      <link href="/2019/11/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/11/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。<br>今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：<a href="https://blog.csdn.net/gaoshuying/article/details/53410137" target="_blank" rel="noopener">跨用户访问数据表的方式</a><br><font color=#5CACEE>1.两个用户在同一个应用服务器上:select * from &#39;user_name&#39;&nbsp;.&nbsp;&#39;table_name&#39;;<br>2.两个用户不在同一个应用服务器上。。。<br><fancybox><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1573658629292&di=ed394bb8e9aadd1d0f439c0a4018a796&imgtype=0&src=http%3A%2F%2Fs11.51cto.com%2Fimages%2F201901%2F20%2Fdec97881d1e4071c6e51c2a30105835d.jpg" alt=""></fancybox><br></font></p><a id="more"></a><h3 id="1-启动服务"><a href="#1-启动服务" class="headerlink" title="1.启动服务"></a>1.启动服务</h3><p>net start 服务器名（Windows）<br>service start 服务器名（linux）</p><h3 id="2-登录与修改密码"><a href="#2-登录与修改密码" class="headerlink" title="2.登录与修改密码"></a>2.登录与修改密码</h3><table><thead><tr><th>命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>mysql -u root -p -h localhost</td><td align="center">登录MySQL（p表示密码；u表示用户名；h表示主机地址）</td></tr><tr><td>mysqladmin -u用户名 -p旧密码 password新密码</td><td align="center">修改用户名密码</td></tr></tbody></table><h3 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3.基本使用"></a>3.基本使用</h3><table><thead><tr><th>命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>show databases;</td><td align="center">用于显示所有的数据库</td></tr><tr><td>use 数据库名;</td><td align="center">使用目标数据库</td></tr><tr><td>select database()/version()/now()/user();</td><td align="center">显示当前连接的信息</td></tr><tr><td>show tables;</td><td align="center">用于显示选中数据库下的所有的表</td></tr><tr><td>desc table_Name;</td><td align="center">查看表结构</td></tr><tr><td>show create table table_name \G;</td><td align="center">查看到创建时的SQL语句及更多详细信息  \G使记录按照字段竖向排列，易于阅读</td></tr></tbody></table><p>创建数据库并指定编码格式:create database if not exists 数据库名 character set utf8;<br>删除数据库：drop database [if exists] 数据库名;</p><h3 id="4-DDL-amp-DML"><a href="#4-DDL-amp-DML" class="headerlink" title="4.DDL&amp;DML"></a>4.DDL&amp;DML</h3><p>DDL:数据定义语言仅对数据库，表，列，索引起作用（create、drop、alter）<br>DML:数据操纵语言仅对table中的具体数据起作用（select、insert、delete、update）</p><h3 id="5-DDL"><a href="#5-DDL" class="headerlink" title="5.DDL"></a>5.DDL</h3><blockquote><p>1.创建表</p></blockquote><pre>创建表    create table 表名(    ​  列名 数据类型  列级约束,    ​  列名 数据类型  列级约束    ​ )【表类型】【表字符集】【表注释】</pre>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建学生表，并设置表类型、字符集</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &apos;主键、学号&apos;,</span><br><span class="line">  `psd` VARCHAR(20) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;123456&apos; COMMENT &apos;密码&apos;,</span><br><span class="line">  `name` VARCHAR(30) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;匿名&apos; COMMENT &apos;学生姓名&apos;,</span><br><span class="line">  `sex` VARCHAR(2) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;男&apos; COMMENT &apos;性别&apos;,</span><br><span class="line">  `birsday` DATETIME DEFAULT NULL,</span><br><span class="line">  `email` VARCHAR(20) COLLATE utf8_estonian_ci DEFAULT NULL,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_estonian_ci</span><br></pre></td></tr></table></figure><ul><li><p><i class="fas fa-hand-point-right"></i> <a href="https://www.w3school.com.cn/sql/sql_datatypes.asp" target="_blank" rel="noopener">数据类型</a> </p></li><li><p>约束条件：<br>  not null<br>  unique<br>  primary key 主键名<br>  foreign key (Id_P) references  Persons(Id_P) :一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY<br>  default 默认值<br>  auto increment:在每次插入新记录时，自动地创建主键字段的值</p></li></ul><h4 id="5-1主键"><a href="#5-1主键" class="headerlink" title="5.1主键"></a>5.1主键</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用BIGINT，会占用更大的磁盘和内存空间，内存空间毕竟有限，无效的占用会导致更多的数据换入换出，额外增加了IO的压力，对性能是不利的。<br><font color=#FF4040>因此推荐自增主键使用int unsigned类型，但不建议使用bigint。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;所以，选取主键的一个基本原则是：<font color=#FF4040>不使用任何业务相关的字段作为主键,而应该使用INT UNSINGED自增或者GUID类型。主键也不应该允许NULL。可以使用多个列作为联合主键，但联合主键并不常用。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">    id INT UNSIGNED NOT NULL AUTO_INCREMENT primary key , /*数据类型 非空 自增 主码约束*/</span><br><span class="line">    name varchar(200)</span><br><span class="line">    /*主码，外码约束条件写法二：primary key(id) */           </span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>2.删除表：drop table table_name</p></blockquote><blockquote><p>3.修改表</p></blockquote><table><thead><tr><th>命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>修改表中列的数据类型</td><td align="center">alter table table_name modify 列名 column_definition</td></tr><tr><td>增加表字段</td><td align="center">alter table table_name add [column] 列名 column_definition</td></tr><tr><td>删除表字段表字段</td><td align="center">alter table table_name drop [column] 列名</td></tr><tr><td>表的字段改名</td><td align="center">alter table table_name change [column] old_col_name new_col_name</td></tr><tr><td>表字段改名同时也可修改字段类型</td><td align="center">alter table table_name change [column] old_col_name new_col_name column_definition</td></tr><tr><td>更改表名</td><td align="center">alter table table_name rename [to] new_tablename</td></tr></tbody></table><h3 id="6-DML语句"><a href="#6-DML语句" class="headerlink" title="6.DML语句"></a>6.DML语句</h3><table><thead><tr><th>命令</th><th align="center">含义</th></tr></thead><tbody><tr><td>插入数据</td><td align="center">insert into table_name ( field1, field2,…) values (value1,value2,….);</td></tr><tr><td>一次性插入多条数据</td><td align="center">insert into table_name ( field1, field2,…) values (value1,value2,..),(value1,value2,..)…;</td></tr><tr><td>更新记录</td><td align="center">update table_name set field1=value1，field2=value2，… [ WHERE CONDITION ]</td></tr><tr><td>删除某一项记录</td><td align="center">delete from table_name [WHERE CONDITION ]</td></tr><tr><td>排序和限制</td><td align="center">select * from table_name [ WHERE CONDITION ] [ order by field1 [ DESC\ASC ], field2 [ DESC\ASC], ..]</td></tr><tr><td>表连接</td><td align="center">select ename,deptname from emp1 left join dept on emp1.deptno=dept.deptno;</td></tr><tr><td>子查询</td><td align="center">关键字主要有in、not in、=、!=、exists、not exists,between and等等</td></tr></tbody></table><p>1.可以不用指定字段名称，但此时后面的values应该与表的字段顺序保持一致<br>2.对于某些字段允许空值、非空但是有指定的默认值、自增长等，这些字段在insert时如果没有指定value，那么将会右系统自动配置</p><h3 id="7-DCL语句"><a href="#7-DCL语句" class="headerlink" title="7.DCL语句"></a>7.<a href="https://blog.csdn.net/ywk_hax/article/details/83351552" target="_blank" rel="noopener">DCL语句</a></h3><blockquote><ol><li>创建数据库用户，并声明权限</li></ol></blockquote><p>创建操作数据库的专用用户，格式：<br>grant 权限 on 数据库名.数据表名 to 用户名@主机IP IDENTIFIED BY 密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">权限：ALL PRIVILEGES(所有权限),select,insert,update,delete,create,alter,drop</span><br><span class="line">主机IP： &apos;%&apos; 匹配所有主机，localhost</span><br><span class="line">表名： * 表示所有表</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>刷新权限</li></ol></blockquote><p>flush privileges</p><p><font color=#FF6347>这里向大家拓展一个知识点，那就是主机IP指的是该用户只能在对应的主机IP上进行登录。例如：假如user用户设置的主机IP为localhost，那么其他人就将无法从本地以外的地方使用user用户进行登录。</font></p><h3 id="8-查询记录"><a href="#8-查询记录" class="headerlink" title="8.查询记录"></a>8.查询记录</h3><blockquote><p>8.1 distinct 查询不重复的记录</p></blockquote><p>select distinct id from emp1; 加distinct关键字使得查出的结果中去掉了重复记录</p><blockquote><p>8.2 条件查询</p></blockquote><p>判断条件可以使用=、&gt;、&lt;、&gt;=、&lt;=、!=等等，同时多个条件还可以使用and、or等进行连接</p><blockquote><p>8.3 聚合</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select [ field1, field2,...,fieldn] fun_name from tablename [ where condition ] </span><br><span class="line"></span><br><span class="line">      [ group by field1, field2,..., fieldn  [ with rollup ] ]  [ having  condition ]</span><br><span class="line"></span><br><span class="line">参数说明：fun_name 聚合函数，表示要做的聚合操作，常用的有sum（求和）、count(*)（计数）、max、min等。</span><br><span class="line"></span><br><span class="line">        GROUP BY  表示对后面的字段进行分类聚合（也常叫分组）；</span><br><span class="line"></span><br><span class="line">        WITH ROLLUP 可选语法，在ORDER BY 语句内出现，表示是否对分类聚合后的结果进行再汇总；</span><br><span class="line"></span><br><span class="line">        HAVING 表示对分类后的结果再进行条件过滤；</span><br></pre></td></tr></table></figure><p><font color=#FF3030>同样是条件过滤，having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤。因此，为了提高聚合效率，一般先用where过滤不相干的记录后，在进行聚合，最后再用having进行二次过滤</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> gender，<span class="keyword">count</span>(gender) <span class="keyword">from</span> tab_teacher <span class="keyword">group</span> <span class="keyword">by</span> gender <span class="keyword">having</span> gender=<span class="string">"woman"</span>;</span><br><span class="line"><span class="comment">-- 含义为：按性别分组，查询出女老师人数的总数:先执行group by，再聚合函数，最后having筛选</span></span><br></pre></td></tr></table></figure><h3 id="9-注意要点"><a href="#9-注意要点" class="headerlink" title="9.注意要点"></a>9.注意要点</h3><blockquote><p>9.1 避免使用通配符“*”</p></blockquote><p>实际开发中，要避免使用通配符”*”（通配符代表所有字段），因为系统要先解析出所有的字段名，将其还原为真实的名字，然后再进行操作。如果记录数据库内容特别多，会影响效率。</p><blockquote><p>9.2 查询表的总记录数(推荐使用主键的方式查询)</p></blockquote><p>因为主键唯一，且不能为空,此时id总数则代表总记录数<br>select count(id) from table_teacher;</p><blockquote><p>9.3 别名的用法</p></blockquote><p>select count(id) as new_number from table_teacher;<br>或者使用别名来代替表的名字<br>select t.name,t.age from tab_teacher t;</p><blockquote><p>9.4 分页查询方式</p></blockquote><p>查询老师记录的前三条（从0位置开始找出3条）： limit后面有两个参数：第一个参数是起始位置，第二个参数是偏移量<br>select * from tab_teacher limit 0,3;</p><h3 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h3>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
            <tag> DDL </tag>
            
            <tag> DML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery学习</title>
      <link href="/2019/11/11/jquery/"/>
      <url>/2019/11/11/jquery/</url>
      
        <content type="html"><![CDATA[<p><font color=#00CD00>简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题</font><br><fancybox><img src="http://pic4.zhimg.com/v2-406e0657b46be0bb4b12ca3661c94397_b.jpg" width="60%"></fancybox></p><a id="more"></a><h3 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1. 选择器"></a>1. 选择器</h3><p>id选择器 $(“#div”)<br>    类选择器  $(“.div”)<br>    标签选择器 $(“div”)<br>    并集选择器 $(“selector1,selector2,…,selectN”)：使用逗号连接，以数组形式返回所有的合并元素<br>    后代选择器 $(“div p”):div标签下的p标签，包含子孙节点<br>    过滤选择器 $(“div:eq(n)”) :eq(index)获取给定索引值的元素  从0开始计数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:gt(index) 匹配所有大于给定索引值的元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:lt(index) 匹配所有小于给定索引值的元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:even      匹配所有索引值为偶数的元素，从 0 开始计数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:odd       匹配所有索引值为奇数的元素，从 0 开始计数<br>属性选择器 $(“div[attribute=”value”]”)   :匹配给定的属性是某个特定值的元素</p><p>表单的选择器:$(‘input:radio/checkbox/text/password/…’),即: type值为radio、checkbox、password等的input元素</p><p>筛选选择器 : $(‘div’).eq(n) 获取第n个元素 数值从0开始<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.first()获取第一个元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.last()获取最后一个元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.parent() 选择父亲元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.siblings()选择兄弟元素<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.find() 查找目标元素值 </p><p><font color=#00CD00>PS:注意筛选选择器与过滤选择器的函数位置</font></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Ajax </tag>
            
            <tag> CSS </tag>
            
            <tag> jQuery </tag>
            
            <tag> 选择器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python全栈系列章节更新（一）：基本数据类型</title>
      <link href="/2019/11/11/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/11/11/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等</p><blockquote><p>字符串：len(),split(),join()…<br>列表：append(),pop(),count()…<br>元组：与列表类似，不同之处在于元组的元素不能修改<br>字典：是另一种可变容器模型，且可存储任意类型对象</p></blockquote><ul><li><p>直接赋值：其实就是对象的引用（别名）。</p></li><li><p>浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。</p></li><li><p>深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</p><a id="more"></a><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.字符串</h3></li></ul><blockquote><p>zip()函数：将可迭代对象所包含的元素是由原列表元素组成的元组</p></blockquote><p>a = [a,b,c]  b = [1, 2, 3]<br>c = [x for x in zip(a,b)]<br>c = [(a, 1), (b, 2), (c, 3)]<br>结果为元祖型列表</p><blockquote><p>format():位置参数，参数索引从0开始，format里填写{}对应的参数值</p></blockquote><p>msg = “my name is {}, and age is {}”.format(‘chd’,18)<br>渲染结果：my name is chd, and age is 18</p><blockquote><p>str.index()字符串索引: 索引值从0开始,不存在就会报错</p></blockquote><p>s=’index’ s[0]=i<br>s.index(‘i’) = 0  : 查找目标字符串索引值</p><blockquote><p>str.find(‘目标字符串’)查找目标字符串,不存在就返回数值-1(推荐使用find)</p></blockquote><p>“i am iron man”.find(“man”) =&gt; 1</p><blockquote><p>移除指定字符串 str.strip()</p></blockquote><p>s = ‘  hello,world!  ‘<br>s.strip()<br>s.lstrip()<br>s.rstrip()<br>s2 = &#39;hello,world!&#39;<br>s2.strip(&#39;\ &#39;)</p><blockquote><p>len(str)字符串长度</p></blockquote><p>len(‘hello,world’) =&gt; 11</p><blockquote><p>str.replace(a,b)替换：在字符串str中，用b来替换a</p></blockquote><p>‘hello,world’.replace(‘o’,’a’) =&gt; ‘hella,warld’</p><blockquote><p>str[a:b:c] 切片操作(左闭右开)</p></blockquote><p>[a:b:c]：a表示为索引起始位置（索引以0开始）；b表示为索引结束位置；c表示为跳跃间隔<br>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; test=&quot;1234hello-world56789&quot;</span><br><span class="line">&gt;&gt;&gt; type(test)</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; test[:]</span><br><span class="line">&apos;1234hello-world56789&apos;</span><br><span class="line">&gt;&gt;&gt; test[0:1]</span><br><span class="line">&apos;1&apos;</span><br><span class="line">&gt;&gt;&gt; test[0:2]</span><br><span class="line">&apos;12&apos;</span><br><span class="line">&gt;&gt;&gt; test[0:5:2]</span><br><span class="line">&apos;13h&apos;</span><br><span class="line">&gt;&gt;&gt; test[0:5]</span><br><span class="line">&apos;1234h&apos;</span><br></pre></td></tr></table></figure><blockquote><p>string.capitalize()</p></blockquote><p>把字符串的第一个字符大写</p><blockquote><p>str.count(‘目标字符串’):</p></blockquote><p>返回 str 在 string 里面出现的次数</p><blockquote><p>“连接字符”.join(seq序列):返回 str 在 string 里面出现的次数</p></blockquote><p>以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</p><blockquote><p>str.lower()/upper() 将字符串全部转换为小写/大写</p></blockquote><p>“hello world”.lower()/upper() =&gt;”hello world” / “HELLO WORLD”</p><blockquote><p>str.split(指定字符串) 以指定字符串来分割目标字符串，以列表形式返回</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"http://www.baidu.com/python/image/123456.jpg"</span></span><br><span class="line"><span class="comment">#以“.” 进行分隔</span></span><br><span class="line">path =url.split(<span class="string">"."</span>)</span><br><span class="line">path1=[<span class="string">'http://www'</span>, <span class="string">'baidu'</span>, <span class="string">'com/python/image/123456'</span>, <span class="string">'jpg'</span>]</span><br></pre></td></tr></table></figure><p><font color=#ed1941>2019-11-28 新增：</font><br>当split的参数为空时，即string.split():表示以空格作为分割符，并将换行符也去掉</p><h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h3><blockquote><p>列表截取（索引从0开始，且满足左闭右开原则）与拼接:从右至左取值，则索引默认从-1开始</p></blockquote><p>L=[‘Google’, ‘Runoob’, ‘Taobao’]<br>L[2]=’Taobao’ L[-1]=’Taobao’</p><blockquote><p>列表函数和方法</p></blockquote><table><thead><tr><th>函数和方法</th><th align="center">描述</th></tr></thead><tbody><tr><td>len(list)</td><td align="center">列表元素个数</td></tr><tr><td>list(seq)</td><td align="center">将元组或字符串转换为列表</td></tr><tr><td>max/min(list)</td><td align="center">返回列表元素最大/最小值</td></tr><tr><td>list.append(obj)</td><td align="center">在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td align="center">统计某个元素在列表中出现的次数</td></tr><tr><td>list.extend(seq)</td><td align="center">在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td>list.index(obj)</td><td align="center">从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>list.insert(index, obj)</td><td align="center">将对象插入列表</td></tr><tr><td>list.pop([index=-1])</td><td align="center">移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.remove(obj)</td><td align="center">移除列表中某个值的第一个匹配项</td></tr><tr><td>list.reverse()</td><td align="center">反向列表中元素</td></tr><tr><td>list.sort( key=None, reverse=False)</td><td align="center">对原列表进行排序</td></tr></tbody></table><hr><font color=#ed1941>2019-12-2 新增：数组拆分：将一个含有m个数目的数组拆分成每n个一组，剩下的构成一个新数组</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将obj数组分割成每100个一组</span></span><br><span class="line">numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,...,<span class="number">10000</span>]</span><br><span class="line">number =[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(numbers), <span class="number">100</span>):</span><br><span class="line">    number.append(numbers[i:i + <span class="number">100</span>])</span><br></pre></td></tr></table></figure><h3 id="3-元组"><a href="#3-元组" class="headerlink" title="3.元组"></a>3.元组</h3><blockquote><p>3.1元组的创建</p></blockquote><p>元组使用小括号，而列表使用方括号，只需要在括号中添加元素，并使用逗号隔开即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="number">336</span>)</span><br></pre></td></tr></table></figure><blockquote><p>3.2 元组的访问使用下脚标索引来访问元组中的值，下标索引从0开始</p></blockquote><p>tup1[0] =&gt; &#39;a&#39; ,tup[1] =&gt; &#39;b&#39;</p><blockquote><p>3.3 元组的修改</p></blockquote><p>元组中的元素是不允许修改或删除的，但我们开始对其进行拼接组合<br>tuple(seq)：将列表转换为元组。</p><h3 id="4-字典-可变模型，可存储任意类型对象"><a href="#4-字典-可变模型，可存储任意类型对象" class="headerlink" title="4.字典:可变模型，可存储任意类型对象"></a>4.字典:可变模型，可存储任意类型对象</h3><blockquote><p>4.1字典的创建</p></blockquote><p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号&nbsp;&nbsp;,&nbsp;&nbsp;分割，整个字典包括在花括号 {}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure><p><font color=#EE9A49>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Alice'</span>: <span class="string">'2341'</span>, <span class="string">'Beth'</span>: <span class="string">'9102'</span>, <span class="string">'Cecil'</span>: <span class="string">'3258'</span>,<span class="number">9527</span>:<span class="string">'badwoman'</span>,<span class="number">6394</span>:<span class="number">998</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4.2 字典的访问</p></blockquote><p>访问方式：<br>字典名[&quot;键名&quot;] 或者<br>字典名.(&quot;键名&quot;,自定义数据)：当目标键名不存在时，使用自定义数据值作为默认值，注意此刻不会修改原字典</p><blockquote><p>4.3 字典的更新</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line"> </span><br><span class="line">dict[<span class="string">'Age'</span>] = <span class="number">8</span> <span class="comment"># 更新</span></span><br><span class="line">dict[<span class="string">'School'</span>] = <span class="string">"RUNOOB"</span> <span class="comment"># 添加 </span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>])</span><br><span class="line">print(<span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>])</span><br></pre></td></tr></table></figure><blockquote><p>4.4 内置函数和方法</p></blockquote><table><thead><tr><th>函数和方法</th><th align="center">描述</th></tr></thead><tbody><tr><td>cmp(dict1, dict2)</td><td align="center">比较字典元素值：如果两个字典的元素相同返回0，如果字典dict1大于字典dict2返回1，如果字典dict1小于字典dict2返回-1</td></tr><tr><td>len()</td><td align="center">计算字典元素个数，即键的总数</td></tr><tr><td>dict.items()</td><td align="center">将字典的键值一一对应组合成一个元组，以列表的形式返回值</td></tr><tr><td>dict.pop(key[,default])</td><td align="center">删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo=&#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">8</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>, <span class="string">'School'</span>: <span class="string">'RUNOOB'</span>&#125;</span><br><span class="line">demo.items() </span><br><span class="line"><span class="comment"># dict_items([('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')])</span></span><br><span class="line"></span><br><span class="line">a = [x <span class="keyword">for</span> x <span class="keyword">in</span> demo.items()]</span><br><span class="line">print(a)  <span class="comment"># a=[('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')]</span></span><br></pre></td></tr></table></figure><h3 id="python的直接赋值，浅拷贝和深拷贝"><a href="#python的直接赋值，浅拷贝和深拷贝" class="headerlink" title="python的直接赋值，浅拷贝和深拷贝"></a>python的直接赋值，浅拷贝和深拷贝</h3><ul><li><p>直接赋值：其实就是对象的引用（别名）。</p></li><li><p>浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。</p></li><li><p>深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</p></li></ul><p>解析：</p><ol><li>b = a 赋值引用，a与b都指向同一个对象，即共有同一块内存地址<br><fancybox><img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720931-7116-4AQC6.png"></fancybox></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">b = a   <span class="comment"># b = &#123;1: [1, 2, 3]&#125;</span></span><br><span class="line"><span class="comment"># 更新a的值</span></span><br><span class="line">a[<span class="number">1</span>]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">print(b)  <span class="comment"># b = &#123;1: [1, 2, 3, 4]&#125;</span></span><br><span class="line"><span class="comment"># 即直接赋值也属于浅拷贝，共用同样一块地址</span></span><br></pre></td></tr></table></figure><ol start="2"><li>b = a.copy():浅拷贝，a与b是一个独立的对象，但他们的子对象还是指向统一对象（是引用）<br><fancybox><img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720930-6827-Vtk4m.png" title="浅拷贝"></fancybox></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">print(a,b)  <span class="comment"># (&#123;1: [1, 2, 3]&#125;, &#123;1: [1, 2, 3]&#125;)</span></span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">4</span>)  <span class="comment"># 字典更新</span></span><br><span class="line">print(a, b)  <span class="comment">#(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>b = copy.deepcopy(a) 深拷贝：深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的,是两块独立的地址。<br><fancybox><img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720930-5882-BO4qO.png"></fancybox></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; c = copy.deepcopy(a)</span><br><span class="line">&gt;&gt;&gt; a, c</span><br><span class="line">(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;)</span><br><span class="line">&gt;&gt;&gt; a[1].append(5)</span><br><span class="line">&gt;&gt;&gt; a, c</span><br><span class="line">(&#123;1: [1, 2, 3, 4, 5]&#125;, &#123;1: [1, 2, 3, 4]&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 元组 </tag>
            
            <tag> 列表 </tag>
            
            <tag> 字典 </tag>
            
            <tag> 数值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker容器虚拟化技术</title>
      <link href="/2019/11/10/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/"/>
      <url>/2019/11/10/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><font color=#00CD00>简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等</font>，我会尽详细写出实际过程中遇到的各种各样的奇葩问题<br><fancybox><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1573382566146&di=7b10832832e7d3c37d3f4e2e84d45d5d&imgtype=jpg&src=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D859959778%2C1194286727%26fm%3D214%26gp%3D0.jpg" alt=""></fancybox></p><a id="more"></a><h3 id="1-docker适用环境"><a href="#1-docker适用环境" class="headerlink" title="1.docker适用环境"></a>1.docker适用环境</h3><p>其实docker本身也没有太多在Windows下花功夫。<font color=#00CD00>目前，docker仅支持Linux与Windows企业版、专业版、教育版。ps：家庭版不支持docker</font>,并且win10下可以安装<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows?tab=description" target="_blank" rel="noopener">docker-for-windows</a>,这个安装包是<br>专门适用于win10，安装简单，而对于win7/8则可以使用<a href="https://github.com/docker/toolbox/releases" target="_blank" rel="noopener">Docker Toolbox下载地址</a></p><h3 id="2-Windows下无法对docker容器进行端口访问（端口映射的问题）"><a href="#2-Windows下无法对docker容器进行端口访问（端口映射的问题）" class="headerlink" title="2.Windows下无法对docker容器进行端口访问（端口映射的问题）"></a>2.Windows下无法对docker容器进行端口访问（端口映射的问题）</h3><p>1.问题详情<br><br>&nbsp;&nbsp;&nbsp;在Windows10系统服务器中安装了docker和docker-compose<br><br>&nbsp;&nbsp;&nbsp;并尝试在其中运行Nginx服务，映射也做好<br><br>&nbsp;&nbsp;&nbsp;问题：在主机的浏览器中，打开localhost:port无法访问对应的Web服务。<br><br>2.问题解析<br><br>&nbsp;&nbsp;&nbsp;原因：docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows10。<br><br>3.解决办法<br><br>&nbsp;&nbsp;&nbsp;启动docker命令行窗口<br><br>&nbsp;&nbsp;&nbsp;输入命令:docker-machine ip default<br><br>&nbsp;&nbsp;&nbsp;Linux的ip地址，一般情况下这个地址是192.168.99.100<br><br>&nbsp;&nbsp;&nbsp;然后在Windows的浏览器中，输入 <a href="http://IP:port" target="_blank" rel="noopener">http://IP:port</a> 即可启用（<a href="http://192.168.99.100：8069）" target="_blank" rel="noopener">http://192.168.99.100：8069）</a><br></p><h3 id="3-docker与VMware不可兼容"><a href="#3-docker与VMware不可兼容" class="headerlink" title="3.docker与VMware不可兼容"></a>3.docker与VMware不可兼容</h3><p>&nbsp;&nbsp;&nbsp;在Windows下安装docker，第一步就是要打开Hyper-V(打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V),开启win自带的虚拟管理技术。但是若想要使用VMware，则必须关闭Hyper-V，鱼和熊掌不可兼得呀！(′д｀ )…彡…彡</p><h3 id="4-Windows：vmware与hyper-v不兼容-请移除hyper-v角色"><a href="#4-Windows：vmware与hyper-v不兼容-请移除hyper-v角色" class="headerlink" title="4.Windows：vmware与hyper-v不兼容,请移除hyper-v角色"></a>4.Windows：vmware与hyper-v不兼容,请移除hyper-v角色</h3><p>1、请移除hyper-v角色。<br>（1）以管理员身份（win + x）运行命令提示符；<br>（2）执行命令：bcdedit /set hypervisorlaunchtype off<br>（3）重启系统，运行vm即可。<br>2、如果想要恢复hyper启动：<br>&nbsp;&nbsp;&nbsp;bcdedit / set hypervisorlaunchtype auto</p><h3 id="5-docker-run后接-bin-sh和接-bin-bash的区别是什么："><a href="#5-docker-run后接-bin-sh和接-bin-bash的区别是什么：" class="headerlink" title="5.docker run后接/bin/sh和接/bin/bash的区别是什么："></a>5.docker run后接/bin/sh和接/bin/bash的区别是什么：</h3><p>比如我们要获取一个nginx镜像，同一镜像存在有不同的tags<br>&nbsp;&nbsp;&nbsp;/bin/sh命令仅适用于tags带alpine标签的： nginx:1.17-alpine；<br>&nbsp;&nbsp;&nbsp;/bin/bash命令仅适用于tags不带alpine标识的：nginx：laster，nginx:1.8…</p><h3 id="6-docker运行MySQL服务"><a href="#6-docker运行MySQL服务" class="headerlink" title="6.docker运行MySQL服务"></a>6.<a href="https://blog.csdn.net/siying8419/article/details/79670246" target="_blank" rel="noopener">docker运行MySQL服务</a></h3><blockquote><ol><li>拉取镜像<br>docker pull mysql:[tag]</li><li>创建并运行容器<br>docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql：5.6</li></ol></blockquote><p>ps: -p 表示指定访问端口<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e 设置环境变量，或者覆盖已存在的环境变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-d 表示以守护式方式来运行容器<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MYSQL_ROOT_PASSWORD=123456 声明MySQL的用户名为ROOT，密码为123456</p><blockquote><ol start="3"><li>查看容器是否启动<br>docker ps </li><li>启动容器<br>docker start container_id</li></ol></blockquote><blockquote><ol start="5"><li>进入容器内部,以命令行交互<br>docker exec -it container_id /bin/bash</li></ol></blockquote><blockquote><ol start="6"><li>登录MySQL<br>mysql -u root -p 然后在输入密码</li></ol></blockquote><blockquote><ol start="7"><li>成功表示已经成功登陆MySQL</li></ol></blockquote><h3 id="7-最强万能公式-数据卷挂载式创建容器"><a href="#7-最强万能公式-数据卷挂载式创建容器" class="headerlink" title="7.最强万能公式:数据卷挂载式创建容器"></a>7.最强万能公式:数据卷挂载式创建容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">守护式：docker run -di [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \--name=&quot;newNginx&quot;  -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw  nginx:1.15.7-alpine</span><br><span class="line">交互式：docker run -it [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \--name=&quot;newNginx&quot;  -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw  nginx:1.15.7-alpine</span><br><span class="line">含义：</span><br><span class="line">   a） 以-v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw 带rw(read,write)权限来将宿主机与容器进行数据卷挂载</span><br><span class="line">   b) docker run 以新容器名和端口号以及守护式或者交互式来创建容器</span><br></pre></td></tr></table></figure><h3 id="8-宿主机与docker容器权限纠纷"><a href="#8-宿主机与docker容器权限纠纷" class="headerlink" title="8.宿主机与docker容器权限纠纷"></a>8.宿主机与docker容器权限纠纷</h3><p>问题描述：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它来了！问题又出现了！哭啦。数据卷挂载时，即使声明了rw权限，在宿主机中创建文件，数据共享后，容器内能够具有正常的rw权限；但在容器内新建了文件后，宿主机就只有只读权限，无法修改文件内容。</p><p>解决方案：宿主机的权限不够<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在（7）式中的万能公式中添加：docker run ··· --privileged=true ···</p><h3 id="9-docker配置nginx的配置文件"><a href="#9-docker配置nginx的配置文件" class="headerlink" title="9.docker配置nginx的配置文件"></a>9.<a href="https://www.cnblogs.com/zfding/p/11429695.html" target="_blank" rel="noopener">docker配置nginx的配置文件</a></h3><p><del>命令：<code>docker run --name=&quot;dnmp_nginx&quot; -p 80:80 -v /home/docker-nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/docker-nginx/log:/var/log/nginx -v /home/docker-nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -di nginx:\[tags]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;第一个-v 表示将你本地的nginx.conf覆盖你要起启动的容器的nginx.conf文件，第二个表示将日志文件进行挂载，就是把nginx服务器的日志写到你docker宿主机的/home/docker-nginx/log/下面。第三个-v 表示的和第一个-v意思一样的<br>&nbsp;&nbsp;&nbsp;&nbsp;我个人更喜欢守护式映射的方式，麻烦的是需要自己准备好nginx.conf 和default.conf文件，我是直接从容器里面复制的，然后根据自己的需要改的</del></p><p>我都想把它杀了，部署nginx太多坑了，不过参考了<a href="https://blog.csdn.net/qierkang/article/details/92657302" target="_blank" rel="noopener">此博文</a>，最终解决了问题，解决方法：</p><blockquote><p>1.创建三个根目录根据情况创建：/docker/nginx/conf www logs</p></blockquote><p>docker run -d -p 80:80 --name=”nginx” --net host -v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/logs:/var/log/nginx nginx:1.17.5</p><blockquote><p>2.不对配置文件进行数据挂载即 </p></blockquote><p>-v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf 这个   </p><blockquote><p>3.进入容器 获取文件</p></blockquote><p>docker exec -it nginx /bin/bash </p><blockquote><p>4.cd /etc/nginx/ </p></blockquote><p>（这里主要获取配置文件路径的）,然后exit</p><blockquote><p>5.数据拷贝</p></blockquote><p>进入宿主机目录文件 cd /docker/nginx/conf/<br>将已经运行成功的容器的配置文件拷贝到宿主机的配置文件目录：docker cp 容器ID:/etc/nginx/nginx.conf .（ps：“.”表示拷贝到当前目录）</p><p>ps：文件copy成功后 把nginx容器先删除掉</p><blockquote><p>6.创建最终的nginx容器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -p 80:80 </span><br><span class="line">--name nginx </span><br><span class="line">[--net host] :再思考一下有没有必要写，使用–net = host时,它告诉容器使用主机网络堆栈.因此无法将端口暴露给主机,因为它是主机(就网络堆栈而言).</span><br><span class="line">-v /docker/nginx/www:/usr/share/nginx/html </span><br><span class="line">-v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</span><br><span class="line">-v /docker/nginx/logs:/var/log/nginx </span><br><span class="line">nginx:1.17.5</span><br><span class="line">ps:成功后就代表部署成功</span><br></pre></td></tr></table></figure><p><font color=#ef4136>2019-11-29 新增：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里宿主机的nginx.conf其实是挂载了一个文件，docker是不推荐这样使用的，可以尝试在宿主机上创建目录为：/docker/nginx/conf/nginx.conf/nginx.conf(当前conf文件是一个具体的配置文件，不是一个目录)，这样上式就不会出现docker warning</font>，结合<a href="https://blog.csdn.net/u014106644/article/details/83152366" target="_blank" rel="noopener">此篇文章</a> 。</p><p>PS：访问可能会403 因为/docker/nginx/www/ 里面没有index.html放进去就好了</p><blockquote><p>7.权限赋予</p></blockquote><p>挂载成功后，给宿主机上的www目录（或整个文件目录）增加权限，不然一直无法读写：<br>&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod -R 777 目标目录 ：给目标目录赋予最大管理员权限<br>&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod +/-rwx 文件名|目录  给文件或目录的赋予权限</p><h3 id="10-docker配置MySQL，redis教程等，请点击此处链接"><a href="#10-docker配置MySQL，redis教程等，请点击此处链接" class="headerlink" title="10.docker配置MySQL，redis教程等，请点击此处链接"></a>10.docker配置MySQL，redis教程等，<a href="https://pan.baidu.com/s/1nUE4pfe2wThYVGMEYqADXw" target="_blank" rel="noopener">请点击此处链接</a></h3><p>命令:<code>docker run -di -p 12345:3306 \--name=&quot;mysql&quot; -v /lnmp/mysql/conf:/etc/mysql/conf.d -v /lnmp/mysql/logs:/logs -v /lnmp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456:rw  mysql:5.6</code></p><p>命令说明：<br>-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。<br>--name mysql：运行服务名字<br>-v /lnmp/mysql/conf:/etc/mysql/conf.d ：将主机/lnmp/mysql录下的conf/my.cnf 挂载到容器的 /etc/mysql/conf.d<br>-v /lnmp/mysql/logs:/logs：将主机/lnmp/mysql目录下的 logs 目录挂载到容器的 /logs。<br>-v /lnmp/mysql/data:/var/lib/mysql ：将主机/lnmp/mysql目录下的data目录挂载到容器的 /var/lib/mysql<br>-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。<br>-d mysql:5.6 : 后台程序运行mysql5.6</p><h3 id="11-外部Windows如何访问docker内的容器"><a href="#11-外部Windows如何访问docker内的容器" class="headerlink" title="11.外部Windows如何访问docker内的容器"></a>11.外部Windows如何访问docker内的容器</h3><blockquote><p>1.基本架构：Windows，Dockers，Linux三者关系<br><fancybox><img src="https://images2018.cnblogs.com/blog/1228818/201805/1228818-20180510183714998-435698473.png" alt="Windows，Dockers，Linux三者关系"></fancybox></p></blockquote><blockquote><p>2.相关操作</p></blockquote><p>2.1 关闭Linux防火墙：systemctl stop firewalld.service</p><p>2.2 查看Linux，Docker的IP地址:ifconfig(区别于Windows的ipconfig命令)</p><p><fancybox><img src="https://cdn.jsdelivr.net/gh/FioraLove/CDN@1.2.2/docker.png" width="60%"></fancybox></p><p>2.3 Windows访问测试:</p><blockquote><p>思想：docker作为一个容器虚拟技术，创建并启动相关的容器服务，并把端口映射到Linux系统中。比如MySQL：docker启动MySQL服务后，并映射了一个外部访问的某端口（比如还是3306）<br>，则此刻Linux就具有了3306这个一个端口=&gt;外界访问方式应该是：访问虚拟机Linux上与之相绑定docker容器映射出的端口。</p></blockquote><p><fancybox><img src="https://cdn.jsdelivr.net/gh/FioraLove/CDN@1.2.2/test.JPG" height="60%"></fancybox><br><font color=#FF3030>2019-11-27 新增：</font><br>在 windows 系统中访问 linux 中 nginx，默认不能访问的，因为防火墙问题,即我们可以有两种解决方法<br>（1）关闭防火墙：参考上述相关操作<br>（2）开放访问的端口号，比如80端口，操作如下： </p><p>查看开放的端口号 </p><blockquote><p>firewall-cmd --list-all </p></blockquote><p>设置开放的端口号 </p><blockquote><p>firewall-cmd --add-service=http --permanent<br>firewall-cmd --add-port=80(或其它开放端口号)/tcp --permanent </p></blockquote><p>重启防火墙 </p><blockquote><p>firewall-cmd --reload </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> VMware </tag>
            
            <tag> images </tag>
            
            <tag> container </tag>
            
            <tag> Hyper-V </tag>
            
            <tag> Linux </tag>
            
            <tag> 交互式与守护式创建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2019/11/08/Vue/"/>
      <url>/2019/11/08/Vue/</url>
      
        <content type="html"><![CDATA[<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1573211421138&di=ed4a66a277a70944cfe8a99015bd8d2b&imgtype=0&src=http%3A%2F%2Fwww.igeekbar.com%2Figeekbar%2Fnetworks%2Fuploadimg%2Fa268122f-78c7-4f1b-ba31-a92f21ed1133.jpg" height="285px"><p>&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,有很好的数据双向绑定性。</p><a id="more"></a><h3 id="1-jQuery与Vue糅合使用"><a href="#1-jQuery与Vue糅合使用" class="headerlink" title="1.jQuery与Vue糅合使用"></a>1.jQuery与Vue糅合使用</h3><blockquote><p>1.jquery基本使用：先导入相关jQuery库包，然后按人类正常思维，就声明入口函数,然后在入口函数中书写逻辑代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">          ...  </span><br><span class="line">          ...</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但是，奇怪他个猪猪皮，即使不用声明入口函数，直接书写逻辑程序，经过多次测试，TM居然还可以正常使用</p><blockquote><p>2.jQuery+Vue(若想两者结合使用，则一定不能声明入口函数，否则Vue无法使用)<br>当你想测试Vue时，就会出现vue实例未声明的报错</p></blockquote><font color=#FF4040    ><p>&nbsp;&nbsp;1 Uncaught ReferenceError: vm is not defined<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at <anonymous>:1:1<br></font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rookie"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello fpx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello IG<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello kk<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pre</span>&gt;</span>total:&#123;&#123;number&#125;&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h6</span> <span class="attr">:class</span>=<span class="string">"&#123;box:isactive&#125;"</span>&gt;</span>this is new h6&amp;nbsp;&amp;nbsp;<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h5</span> <span class="attr">:class</span>=<span class="string">"[box1,box2,box3?'luko':'']"</span>&gt;</span>this is new h6&amp;nbsp;&amp;nbsp;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"please input number"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> @<span class="attr">keyup.enter</span>=<span class="string">"fn"</span>&gt;</span>按键盘enter键触发:&#123;&#123;msg&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"please click enter"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> @<span class="attr">keyup.13</span>=<span class="string">"greet(9527)"</span>&gt;</span>按键盘enter键触发&#123;&#123;message&#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log($(<span class="string">'p'</span>).length);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">                el:<span class="string">'#app'</span>,</span></span><br><span class="line">                data:&#123;</span><br><span class="line"><span class="javascript">                    number:$(<span class="string">'p'</span>).length,</span></span><br><span class="line"><span class="actionscript">                    isactive:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">                    box1:<span class="string">'moko'</span>,</span></span><br><span class="line"><span class="actionscript">                    box2:<span class="string">'boka'</span>,</span></span><br><span class="line"><span class="actionscript">                    box3:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">                    msg:<span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">                    message:<span class="string">''</span>,</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                methods:&#123;</span><br><span class="line">                    fn()&#123;</span><br><span class="line"><span class="actionscript">                        alert(<span class="keyword">this</span>.msg)</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    greet(hi)&#123;</span><br><span class="line"><span class="actionscript">                        alert(<span class="keyword">this</span>.message+hi)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            $(<span class="string">'h5'</span>).append(<span class="string">'&lt;b&gt;this is new plus increment&lt;/b&gt;'</span>);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">'h6'</span>).append(<span class="string">'&lt;br&gt; hello world'</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Vue的组件"><a href="#2-Vue的组件" class="headerlink" title="2.Vue的组件"></a>2.Vue的组件</h3><blockquote><p>1.组件创建方式分为全局组件与局部组件：</p></blockquote><p>&nbsp;&nbsp;&nbsp;全局组件：可以被多个APP进行调用,在APP实例外创建;定义一个名为 button-counter 的新组件:组件名称若使用驼峰原则，引用组件时需要全部小写，并且两个单词之间用“-”连接;若不使用驼峰原则时，直接使用原组件名</p><p>全局组件创建方式一：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.component('buttonCounter', &#123;</span><br><span class="line">    data: function () &#123;  // 1.组件可以有自己的data数据，组件中的data必须是一个方法，且这个方法内部必须返回一个对象才行，而实例中的data可以为一个对象</span><br><span class="line">        return &#123;</span><br><span class="line">        count: 0,</span><br><span class="line">        info: 'hello world'</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,</span><br><span class="line">      template: '<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"count++"</span>&gt;</span>&#123;&#123;message&#125;&#125; clicked me &#123;&#123; count &#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span>'</span><br><span class="line">      // 2. 全局组件有template属性 </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>全局组件创建方式二：调用公共模板对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script&gt;</span><br><span class="line">        let project=&#123;</span><br><span class="line">            template:&apos;&apos;,</span><br><span class="line">            data:function()&#123;  // 组件中的data必须是一个方法</span><br><span class="line">                return &#123;</span><br><span class="line">                info:&apos;hello world&apos;,</span><br><span class="line">                message:&apos;badwoman&apos;      </span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;&#125;</span><br><span class="line">           ...</span><br><span class="line">            &#125;</span><br><span class="line">        Vue.component(&apos;组件名&apos;,project);     </span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt; </span><br><span class="line">       </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### 3. vue的props属性传值</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;!--父组件，可以在引用子组件的时候，通过属性绑定（v:bind）的形式，把需要传递给子组件的数据</span><br><span class="line">        传递到子组件内部--&gt;</span><br><span class="line">        &lt;com1 :parentmsg=&quot;msg&quot;&gt;</span><br><span class="line">        &lt;/com1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &apos;#app&apos;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                msg: &apos;123父组件中的数据&apos; </span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">            components:&#123;</span><br><span class="line">                &apos;com1&apos;:&#123;</span><br><span class="line">                    //子组件中，默认无法访问到父组件中的data和methods</span><br><span class="line">                    template: &apos;&lt;h1 @click=&quot;change&quot;&gt; 这是子组件 &#123;&#123;parentmsg&#125;&#125;&lt;/h1&gt;&apos;,</span><br><span class="line">                    //注意，组件中的所有props中的数据都是通过父组件传递给子组件的</span><br><span class="line">                    //propes中的数据是只可读</span><br><span class="line">                    props: [&apos;parentmsg&apos;] ,// 把父组件传递过来的parentmsg属性， 数组中，定义一下，这样才能用这个数据,</span><br><span class="line">                    //注意子组件中的data数据，并不是通过父组件传递过来的，而是子组件字有的，比如：子组件通过Ajax请求回来的值，可以放到data中</span><br><span class="line">                    //data中的数据可读可写</span><br><span class="line">                    data()&#123;</span><br><span class="line">                        return &#123;</span><br><span class="line">                            title: &apos;123&apos;,</span><br><span class="line">                            content: &apos;qqq&apos;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    methods: &#123;</span><br><span class="line">                        change()&#123;</span><br><span class="line">                            this.parentmsg=&apos;被修改&apos;   // 这里不推荐使用此方法修改传递参数值，会一直报出vue warning</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><font  color=#080808>注意：重要的来了，必须理解┗|｀O′|┛ 嗷~~<br>创建格式：Vue.component('组件名',{ /* ..组件的模板对象.. */ })<br>&nbsp;&nbsp;&nbsp;组件的第一个参数为组件名，而第二个参数是以对象的形式去描述一个组件。组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项</font><p><font color=#FF4040    >2019-12-9 新增：</font></p><h3 id="4-vue实例中的method方法抽象说明"><a href="#4-vue实例中的method方法抽象说明" class="headerlink" title="4.vue实例中的method方法抽象说明"></a>4.vue实例中的method方法抽象说明</h3><p>假设在HTML中有这样一个语句：调用methods里面的方法时，假如有返回值时，直接在&lt;!–￼5–&gt;里面展示，注意区分@click=”methodName”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>&#123;&#123;test(2)&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    <span class="comment">&lt;!---这里是调用methods里面的test()方法：判断参数的数据类型 ---&gt;</span></span><br><span class="line">    el:"#app",</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        test(hi) &#123;</span><br><span class="line">            arr = typeof(hi);</span><br><span class="line">            switch (arr) &#123;</span><br><span class="line">                case "string":</span><br><span class="line">                    return "this type is string";</span><br><span class="line">                case "number":</span><br><span class="line">                    console.log("good");</span><br><span class="line">                    if (hi<span class="tag">&lt;<span class="name">=10</span> &amp;&amp; <span class="attr">hi</span>%<span class="attr">2</span>===<span class="string">0)</span> &#123;</span></span><br><span class="line"><span class="tag">                        <span class="attr">return</span> <span class="attr">hi</span>;</span></span><br><span class="line"><span class="tag">                    &#125;</span></span><br><span class="line"><span class="tag">                    <span class="attr">else</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">return</span>("不满足条件");</span></span><br><span class="line"><span class="tag">                <span class="attr">case</span> "<span class="attr">object</span>"<span class="attr">:</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">return</span>("<span class="attr">this</span> <span class="attr">type</span> <span class="attr">is</span> <span class="attr">object</span>");</span></span><br><span class="line"><span class="tag">            &#125;</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">    </span></span><br><span class="line"><span class="tag">&#125;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Jquery </tag>
            
            <tag> component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python文件读read()、readline()、readlines()对比</title>
      <link href="/2019/11/07/python%E7%9A%84read_readlines_readline/"/>
      <url>/2019/11/07/python%E7%9A%84read_readlines_readline/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;read():读取整个文件，将文件内容放到一个字符串变量中<br><br>&nbsp;&nbsp;&nbsp;readline():每次读取一整行，包括换行符，并将其作为字符串返回<br><br>&nbsp;&nbsp;&nbsp;readline():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素）<br></p><a id="more"></a><h2 id="1-readline-示例："><a href="#1-readline-示例：" class="headerlink" title="1.readline()示例："></a>1.readline()示例：</h2><p>假设需求是读取一个多行的all_term.txt文件，并列出每一个单词<br>all_term.txt文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new fallout chernobyl social impact chernobyl disast</span><br><span class="line">david r marpl st martin press cloth</span><br><span class="line">rnobyl social impact chernobyl disast</span><br><span class="line">david r marpl st martin piano</span><br></pre></td></tr></table></figure><p>程序源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    obj = []</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'all_term.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>,errors=<span class="string">"ignore"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            myStr = f.readline()  <span class="comment"># 表示一次读取一行</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> myStr:</span><br><span class="line">                <span class="comment"># 读到数据最后跳出，结束循环。数据的最后也就是读不到数据了，mystr为空的时候</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 指定字符串来分割目标字符串，以列表形式返回</span></span><br><span class="line">            new_list = myStr.split()</span><br><span class="line">            <span class="comment"># 表示将拆分好的每一行重新拼接成一个完整的数组</span></span><br><span class="line">            obj += new_list</span><br><span class="line">        print(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>readline()表示读取一整行，那如果一个文件有多行数据，使用readline()函数是不是一直重复读取第一行？<br>其实不然，使用with open()打开文件后，第一个readline()读取第一行（也包括换行符），第二个读取第二行,…,第n个读取第n行数据，这是由系统机制判定的。<br>下面我列举一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""all_term.txt:</span></span><br><span class="line"><span class="string">new fallout chernobyl social impact chernobyl disast</span></span><br><span class="line"><span class="string">david r marpl st martin press cloth</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">new fallout chernobyl social impact chernobyl disast</span></span><br><span class="line"><span class="string">david r marpl st martin press cloth</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'all_term.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    a = f.readline().replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">    b = f.readline().replace(<span class="string">"\n"</span>, <span class="string">""</span>)</span><br><span class="line">print(<span class="string">"a:"</span>, a)</span><br><span class="line">print(<span class="string">"b:"</span>, b)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">结果为：</span></span><br><span class="line"><span class="string">a: new fallout chernobyl social impact chernobyl disast</span></span><br><span class="line"><span class="string">b: david r marpl st martin press cloth</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>根据结果可以得出结论：</p><p>1.第一个readline()读取第一行（也包括换行符），第二个读取第二行，……</p><p>2.上面是我们经常看到的按行遍历一个文件方法，你可能已经注意到我在代码中写的if not myStr:部分。当readline读取到为空的时候，意味着读到了文件的结束。这个时候，问题就在这里，很多人会想，是不是遇到一个空行，也会被认为是文件的结束呢？<br>事实上，文件的空白行并不会返回一个空行。因为在每一行的末尾还有一个或者多个分隔符，因此“空白行”至少会有一个换行符或者系统使用的其他符号。所以，即使文件中真的包含一个“空白行”，读入的行也不是空的，这就意味着在真实遍历读取到文件结束之前，程序实际上是不会停止的</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> read() - readline() - readlines() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主体设置知识点</title>
      <link href="/2019/10/26/Hexo%E4%B8%BB%E4%BD%93%E8%AE%BE%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/10/26/Hexo%E4%B8%BB%E4%BD%93%E8%AE%BE%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p><fancybox><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572260590229&di=c342004ec7897ef8697bd65876b3b9c5&imgtype=0&src=http%3A%2F%2F02imgmini.eastday.com%2Fmobile%2F20180822%2F20180822234333_351cde5dc9236b7836296868f06a44b4_2.jpeg" width="80%"></fancybox><br>介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法</p><a id="more"></a><h4 id="1-Hexo创建文章、标签、分类的Front-matter方法-Ⅰ-nbsp-nbsp-Front-matter-Ⅱ"><a href="#1-Hexo创建文章、标签、分类的Front-matter方法-Ⅰ-nbsp-nbsp-Front-matter-Ⅱ" class="headerlink" title="1.Hexo创建文章、标签、分类的Front-matter方法 Ⅰ&nbsp;&nbsp; Front-matter Ⅱ"></a>1.<a href="https://www.jianshu.com/p/6e4af897a3f0" target="_blank" rel="noopener">Hexo创建文章、标签、分类的Front-matter方法 Ⅰ</a>&nbsp;&nbsp; <a href="https://xaoxuu.com/wiki/material-x/pages/index.html#Front-matter" target="_blank" rel="noopener">Front-matter Ⅱ</a></h4><p>Front-matter 是md文件最上方以 — 分隔的区域，用于指定个别文件的变量<br></p><blockquote><p>其实Front-matter就是在\Hexo\source_posts下的.md文件中书写文章标题，上传时间，分类名，标签名等等</p></blockquote><table><thead><tr><th align="center">字段</th><th align="center">含义</th><th align="center">值类型</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">layout</td><td align="center">布局模版</td><td align="center">String</td><td align="center">-</td></tr><tr><td align="center">title</td><td align="center">标题</td><td align="center">String</td><td align="center">-</td></tr><tr><td align="center">date</td><td align="center">创建时间</td><td align="center">Date</td><td align="center">文件创建时间</td></tr><tr><td align="center">description</td><td align="center">页面描述、摘要</td><td align="center">String</td><td align="center">-</td></tr><tr><td align="center">cover</td><td align="center">是否显示封面</td><td align="center">Bool</td><td align="center">true</td></tr></tbody></table><h4 id="2-Makedown标题页的写法"><a href="#2-Makedown标题页的写法" class="headerlink" title="2.Makedown标题页的写法"></a>2.Makedown标题页的写法</h4><pre>    ---    layout: 页面布局（配合主题文档使用）    title: 文章名称    date: 文章日期    comments: 文章是否开启评论    photos: 文章封面图（仅部分主题支持）    tags:       - 文章标签一      - 文章标签二    categories: # 文章分类（文章分类等级）                - 父分类                - 子分类                - 孙分类    description: 文章描述，即要在首页显示的摘要（仅部分主题支持）    ---    这里是摘要       <!-- more -->        这里是正文    注意：description 和 <!-- more --> 方式显示摘要二选一即可，部分主题不支持description，    每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档</pre><h4 id="3-md文件的基本写法"><a href="#3-md文件的基本写法" class="headerlink" title="3.md文件的基本写法"></a>3.md文件的基本写法</h4><blockquote><p>3.1. ``` 代码段 ``` : 表示以原格式展示代码片段。比如</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">    ......</span><br><span class="line">     //鼠标进入的时候,其他的li标签透明度：0.5</span><br><span class="line">    $(&quot;.wrap li&quot;).hover(function() &#123;</span><br><span class="line">        $(this).siblings().stop().fadeTo(400, 0.5);  //.stop():停止所有在指定元素上正在运行的动画。</span><br><span class="line">    &#125;, function() &#123;</span><br><span class="line">        // 鼠标离开，其他li 透明度改为 1</span><br><span class="line">        $(this).siblings().stop().fadeTo(400, 1);</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log($(&apos;.attr a&apos;).prop(&apos;href&apos;));</span><br><span class="line">    console.log($(&apos;.attr a&apos;).prop(&apos;title&apos;));</span><br><span class="line">    console.log($(&apos;input:checkbox&apos;).attr(&apos;id&apos;));</span><br><span class="line">    console.log($(&apos;.office p:eq(0)&apos;).scrollTop());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>3.2. &lt;img src=”url” width=” “&gt;</p></blockquote><p>&nbsp;&nbsp;&nbsp;表示在md文件中展示图片，若不想破坏图片原格式，就只需要写width或者height其中一个，另一个会自适应变化</p><blockquote><p>3.3. 文本修饰:粗体，斜体…</p></blockquote><p>&nbsp;&nbsp;&nbsp;粗体文本用两个*或_包含，斜体文本用一个_包含</p><blockquote><p>3.4. 表格(注意其格式)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><blockquote><p>3.5. <a href="https://www.114la.com/other/rgb.htm" target="_blank" rel="noopener">颜色RGB</a>和字体以及背景颜色</p></blockquote><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"Tahoma"</span>&gt;</span></span>这是一串Tahoma字体<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span></span>这是一串黑体字<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span></span>这是一串微软雅黑<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span></span>这是一串华文彩云<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ced1</span> <span class="attr">size</span>=<span class="string">7</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span></span>背景色+字体+字的size<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#00ffff</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span></span>颜色设置<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">gray</span> <span class="attr">size</span>=<span class="string">72</span>&gt;</span></span>灰色处理<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">#bfe1f1</span>&gt;</span></span>背景色是：#bfe1f1<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3</span><br></pre></td></tr></table></figure><p><font face="Tahoma">这是一串Tahoma字体</font><br/><br><font face="黑体">这是一串黑体字</font><br/><br><font face="微软雅黑">这是一串微软雅黑</font><br/><br><font face="STCAIYUN">这是一串华文彩云</font><br/><br><font color=#00ced1 size=7 face="黑体">背景色+字体+字的size</font><br/><br><font color=#00ffff size=72>颜色设置</font><br/><br><font color=gray size=72>灰色处理</font><br/></p><blockquote><p>3.6. 转义字符</p></blockquote><p>&lt;br&gt; : 换行<br><br>\ : 转义字符，原生字符，不加修饰<br><br>&amp;nbsp; : 空格</p><blockquote><p>3.7 每一篇博文设置图片</p></blockquote><p>只需要在文章前面配置 photos 关键字即可，若没有这种配置，可以选择在正文插入图片，然后使用 <!-- more --> 将图片显示在摘要里</p><blockquote><p>3.8 图片可点击设置，单独出现</p></blockquote><p>&lt;fancybox&gt;图片设置&lt;/fancybox&gt;</p><h4 id="4-Hexo的搜索search功能设置"><a href="#4-Hexo的搜索search功能设置" class="headerlink" title="4.Hexo的搜索search功能设置"></a>4.Hexo的搜索search功能设置</h4><p>问题描述：</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的博客中点击search，输入相关关键字后，点击查询到的相关文章，会出现404错误</p></blockquote><p>解决方法：</p><blockquote><p>1.检查是否安装文档要求正确的安装了依赖包。<br>2.检查根目录配置文件是否有search字段冲突（我的根目录配置文件中没有search字段）。<br>3.检查我们的主题（我使用的是<a href="https://xaoxuu.com/wiki/material-x/index.html" target="_blank" rel="noopener">Material X主题</a>）的配置文件是否开启search功能</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索配置</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  service:</span> <span class="string">hexo</span></span><br><span class="line">  <span class="comment"># google</span></span><br><span class="line"><span class="attr">  google_api_key:</span></span><br><span class="line"><span class="attr">  google_engine_id:</span></span><br><span class="line">  <span class="comment"># algolia</span></span><br><span class="line"><span class="attr">  algolia_app_id:</span></span><br><span class="line"><span class="attr">  algolia_api_key:</span></span><br><span class="line"><span class="attr">  algolia_index_name:</span></span><br><span class="line">  <span class="comment"># azure</span></span><br><span class="line"><span class="attr">  azure_service_name:</span></span><br><span class="line"><span class="attr">  azure_index_name:</span></span><br><span class="line"><span class="attr">  azure_query_key:</span></span><br><span class="line">  <span class="comment"># baidu</span></span><br><span class="line"><span class="attr">  baidu_api_id:</span></span><br></pre></td></tr></table></figure><blockquote><p>4.这是最容易忽略的，但往往也是问题出现的源头，请检查根目录配置文件中的链接是否正确，如：</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">https://fioralove.github.io</span></span><br><span class="line"><span class="comment"># 这里似乎存在一个bug，推荐填写GitHub Page的访问地址，不要使用自己在阿里云以及其它的域名注册服务商所提供的地址</span></span><br><span class="line"><span class="comment"># 比如我在阿里云所注册的https:AhriLove.top，填上依旧会出现404错误</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h4 id="封面轮播图"><a href="#封面轮播图" class="headerlink" title="封面轮播图"></a>封面轮播图</h4><p>封面幻灯片轮播图片怎么引入本地的照片？？<br>修改主题下_config.yml文件，里面有个banner改一下，多加几行即可</p>]]></content>
      
      
      <categories>
          
          <category> 博客Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> front-matter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2019/10/25/hello-world/"/>
      <url>/2019/10/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><fancybox><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1573382292526&di=0009d867e1bde90c696eb40e0fd840e4&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D3010013829%2C2497003625%26fm%3D214%26gp%3D0.jpg" alt=""></fancybox></p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初次见面，请多关照</title>
      <link href="/2019/10/20/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2_%E8%AF%B7%E5%A4%9A%E5%85%B3%E7%85%A7/"/>
      <url>/2019/10/20/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2_%E8%AF%B7%E5%A4%9A%E5%85%B3%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示</p><a id="more"></a><p>大家好–^^__^^–，我叫陈浩东<br></p><p><img src="https://cdn.jsdelivr.net/gh/FioraLove/CDN@1.1/5d4d2f1ba61c7.jpg" width="30%"><br></p><p>&nbsp;&nbsp;&nbsp;<code>作为GP-12线,滚齿磨齿操作员</code>，目前正学习清洗包装流程、磨齿、滚齿、齿轮生产工艺以及安全生产。&nbsp;&nbsp;&nbsp;对网站开发的有关知识几乎为零，这也是我搭建好自己的不完全博客之后写的第一篇博客，刚开始搭建博客的时候自己也是网上各种百度，由于自己属于小白那种，历经了千辛万苦才弄好，所以借这个机会会一直坚持下去分析自己的知识，一起走向成功的彼岸！</p>]]></content>
      
      
      <categories>
          
          <category> 博客Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Page </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
