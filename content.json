{"meta":{"title":"AhriLove","subtitle":null,"description":null,"author":"AhriLove","url":"https://ahrilove.top","root":"/"},"pages":[{"title":"","date":"2021-09-25T03:32:27.997Z","updated":"2020-02-21T07:13:24.000Z","comments":true,"path":"404.html","permalink":"https://ahrilove.top/404.html","excerpt":"","text":"404 Not Found .pic{ font-family: \"微软雅黑\", \"黑体\"; color: hotpink; margin-top: 9em; font-size: 1.5em; text-align: center; } .text1{ font-size: 0.5em; } div img{ width: 13em; } body{ background-image: url(\"https://cdn.jsdelivr.net/gh/FioraLove/Images/490f902a7fc0830d060c174ca40f1455.jpg\"); background-attachment: fixed; background-size: auto; background-repeat: no-repeat; background-position: center; } 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 别点了，真的一滴也没有了！！!真滴"},{"title":"","date":"2021-09-25T03:32:27.998Z","updated":"2020-07-07T13:07:18.000Z","comments":true,"path":"about/index.html","permalink":"https://ahrilove.top/about/index.html","excerpt":"","text":"君の名は .container { margin: 0 auto; } .content { max-width: 800px; margin: 0 auto; } .content img { max-width: 100%; } @media (max-width: 900px) { .content { max-width: 100%; margin: 20px; } } 我一路向北，离开有你的季节 慢慢的写，好好的活 起笔： 人们常说，心中有梦，不怕天涯路远，眼里有情，何惧秋风寒呢！一直向前拼命走着，也时刻在做着虚幻的梦，不肯醒来。当时光偷换了年华，光阴在疯长，一切却如同昨日云烟，转瞬即逝，刹那的一念起，缘起缘灭，转身的一瞬间，便是沧海桑田，那些青春年少的时光曾经飘荡在云端上的梦，与我隔着那样遥远的距离。 蓦然回首这半生走过的足迹，层层叠叠于时光的转角处，虽已模糊不清，却依旧感慨万千。角落里的花，悄然绽放，无需观众，也同样精彩。一直认为，一个真正内心富有的人，不需要太张扬的个性，看重浮华名利的背后，鲜花和掌声再多么热情，也和价值无关。 时间可以改变一切，比如年轮，容貌，却无法改变一个人思乡情结。离别故乡多年，漂泊在外的脚步疲惫不堪，乡愁也日益浓郁。时常独自站在深夜里，举目眺望深邃的夜空，遥望故乡的方向，一幕幕的往事总会浮现在眼前。故乡的一草一木，一屋一舍，亲人们的笑脸和嘱托，儿时的时光总能勾起深深的回忆。 随着年轮的增长，岁月的叠加，我被时光无情的隔在了这头。如今，童年的玩伴早已长大，昔日嬉戏玩耍的画面早已被光阴无情的掩埋，成了名副其实的沙漏。 记得上次回故乡的时候，路上遇到了邻里的大叔一下子愣住了。以前一口气能扛几十个麻袋粮食都面不改色的大叔，硬朗的身板，如今已经驼背了，走路蹒跚，满脸皱纹，鬓角斑白，面对面的时候我们似乎都愣在原地，一时间名字在嘴边却说不出来了。迟疑了片刻才缓过神来，热情的打起了招呼。大叔憨厚的笑声依旧爽朗，拉住我的手亲切的问候着，眼神里却带着些许的生疏和感动。 2019-6-5 : 今天我毕业啦 我们只是老师送走的其中一届，但是老师们却是我们的唯一一批 多希望有一天突然惊醒，发现自己在高三的一节课上睡着了，现在经历的一切都是一场梦，桌上满是你的口水。你告诉同桌，说做了个好长的梦。同桌骂你白痴，叫你好好听课。你看着窗外的球场，一切都那么熟悉，一切还充满希望... 大学似乎是中了单身魔咒，1号楼东 111寝室，简直不能再邪乎了，但也可以叫做龙潭，因为我们寝室目前已经出了两条龙，他们都在各自的领域取得了不小的成就，努力向他们靠拢。我的大学室友：胡某，张先生，家义123，周队，还有我自己陈某... 这是我们大一冬天的合照，好像是因为寝管阿姨叫每一个寝室都拍一张，发在寝室管理群里... 这就是我们最后离校最后几天，一起合照 2019-12-25 : 人的身体究竟有多脆弱？ &nbsp;&nbsp;&nbsp;&nbsp;之前公司的玻璃坏了，今天有人来维修，真是奇了猪猪皮，在印象中玻璃有怎么重？？？我看那两个二十多岁师傅在安装的时候很吃力，就去帮他们一起装，因为在四楼，所以说格外注意，生怕出一点点安全事故。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在安装时候，手不小心卡在玻璃与墙棱角处，一点点擦伤贼痛，火辣辣的痛，皮肤神经这么敏感？？但是又不能叫他们挪开，不然玻璃会掉下去。我一直都在锻炼身体，腹肌，胸肌等等，现在跑个二公里，都不会怎么累，一点点的擦伤就很痛，这就让我人的身体究竟有多脆弱？一点点小小的风寒就会头昏脑胀。生物高等进化后的充分条件？相对于其它生物，开发了大脑，但身体健壮性却每况愈下。 【转载知乎一个小文章】 2020再给自己定一个小目标：依旧每天锻炼身体，肉体成圣，找回大学时六块腹肌的我。你看我整不整死小日本儿鬼子就完事了 2020-1-17 : 兄弟萌！诸葛大力~我爱了。我承认我下贱，我馋她 诸葛大力（成果饰演）,《爱情公寓5》里她是胡一菲的学生，超级学霸。胡一菲是这么介绍诸葛大力的：2000年发生过三件大事，‘千年虫’，‘悉尼奥运’和‘诸葛大力’的诞生，诸葛大力外号‘别人家的孩子’，从小甩开同龄人几百条街，她是集体照里的小不点，却是同学眼中的巨人，她到处实习，精通各种专业技能，上天入地，无所不能，她是老师的骄傲，学校的荣光。 成果饰演的爱情公寓里的诸葛大力，简直好看的离谱，可以说她把这个人物角色塑造的十分完美，简直是胡一菲+诺澜+婉瑜的综合体 一眼，提神醒脑 两眼，永不疲劳 三眼，长生不老 可攻可萌可文艺日系颜 2020-4-24 : 新手机iPhone SE2 数码圈“尼斯湖水怪”三大未解之谜：华为的石墨烯电池，小米的冲击高端，苹果的 iPhone SE 二代，有人一等就是两年呢…… 库克绝壁是老营销了，想割iPhone6，6s用户的韭菜了。不能说 SE2 究竟有多好，但绝对算得上一本Apple的历史书。 &nbsp;&nbsp;&nbsp; 它是苹果对于非全面屏时代的收官之作，也是给这个经典设计画上的完美句号。 如果你喜欢这个相册，那么你可能也喜欢: Hi-Si ？？？ 英雄联盟 const dp = new DPlayer({ container: document.getElementById('dplayer'), autoplay: false, theme: '#FADFA3', loop: true, lang: 'zh-cn', screenshot: true, hotkey: true, preload: 'metadata', // 左上角展示的logo logo: 'https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesaaa.png', volume: 0.5, mutex: true, video: { url:\"https://api.dogecloud.com/player/get.mp4?vcode=5ac682e6f8231991&userId=17&ext=.mp4\", defaultQuality: 0, pic: 'https://cdn.jsdelivr.net/gh/FioraLove/Images/531-bigskin-1.jpg', thumbnails: 'https://cdn.jsdelivr.net/gh/FioraLove/Images/531-bigskin-1.jpg', type: 'auto', }, // 字幕 subtitle: { url: 'https://s-sh-17-dplayercdn.oss.dogecdn.com/hikarunara.vtt', type: 'webvtt', fontSize: '20px', bottom: '8%', color: '#b7daff', }, // 弹幕 danmaku: { /* * 这是另一个博主搭建的弹幕池 * api: 'https://dplayer.moerats.com * id: '9E2E3368B56CDBB45 * */ id: '9E2E3368B56CDBB4', api: 'https://api.prprpr.me/dplayer/', token: 'tokendemo', maximum: 1000, /* * addition:其实可以直接读取一个由弹幕组成的json * */ addition: ['https://s-sh-17-dplayercdn.oss.dogecdn.com/1678963.json'], user: 'AhriLove', bottom: '15%', unlimited: true, }, contextmenu: [ { text: '二次作者', link: 'https://ahriLove.top' } ], highlight: [ { time: 20, text: '这是第 20 秒', }, { time: 120, text: '这是 2 分钟', }, ], });"},{"title":"所有分类","date":"2021-09-25T03:32:27.998Z","updated":"2019-10-25T13:05:50.000Z","comments":true,"path":"categories/index.html","permalink":"https://ahrilove.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-25T03:32:28.000Z","updated":"2020-02-25T08:30:24.000Z","comments":true,"path":"feiyan2020/index.html","permalink":"https://ahrilove.top/feiyan2020/index.html","excerpt":"","text":"全国新型冠状病毒实时分布图 body { height: 100vh; margin: 0; padding: 0; overflow: hidden; } h2 { text-align:center; margin: 20px 20px 0 20px; color: #0822B5; } h3 { text-align:center; margin: 20px 20px 0 20px; color: #0822B5; } a { color: #178b50; text-decoration: none; } a:hover { color: #d81d1b; text-decoration: none; } iframe { overflow:hidden; margin: 20px 0 0 0; border: none; } .iframeBox{ margin: auto; width: 59vh; height:80vh; } AhriLove's Blog丨新冠肺炎实时疫情图（数据来源：腾讯新闻） 相关链接：武汉新型冠状病毒防疫信息收集平台 丨 2019-nCoV 疫情信息导航"},{"title":"我的朋友们","date":"2021-09-25T03:32:28.000Z","updated":"2020-01-08T00:52:56.000Z","comments":true,"path":"friends/index.html","permalink":"https://ahrilove.top/friends/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;欢迎大家留言分享自己发掘的优秀博文、微信文章、GitHub开源项目、二次元、摄影、运动、读书、影视…-留言请告诉我你的名称、主页、头像、标签或者简介哦～-如果想定制你的卡片颜色，也可以留言告诉我哦～（十六进制颜色码，如：#FF0000）"},{"title":"","date":"2021-09-25T03:32:27.999Z","updated":"2019-12-06T14:22:22.000Z","comments":true,"path":"cv/index.html","permalink":"https://ahrilove.top/cv/index.html","excerpt":"","text":"AhriLove'S BLOG | OFFER document.onkeydown = function () { if (window.event && window.event.keyCode == 123) { event.keyCode = 0; event.returnValue = false; return false; } }; 您的浏览器不支持audio标签，无法播放音乐！ 自称：陈某（师从盛建彬） 籍贯：中国 | 四川 | 绵阳 （俺木拆里斯） 生辰：1997（98年是真滴牛批，玩不过她，5555） 兴趣爱好：健身 | 编程 | 土味 | 钓鱼 技能 | Skill HTML/CSS/JS 35% PHP 10% 数据分析/爬虫 52% PYTHON 75% SQL 38% PS/剪辑 45% 简介 | Introduction ● 学历：高中文凭 ● 现况：脑瘫前端 | 学js逆向爬虫中 | 学习后端方向； ● 目标：不脑瘫前端 | 全栈 | 专升本，完成大学学业； ● 博客：只有能被明日的我们所铭记，今日才有意义（--源计划·艾希）； ● 兴趣：先打一拳，打的时候再把问题问遍（-- 源计划·蔚） ● 其他：虽然我学历低，但是在努力学习中！ 联系我 | Contact me Copyright © 2019 AhriLove'S BLOG. All rights reserved. if ('addEventListener' in window) { window.addEventListener('load', function () { document.body.className = document.body.className.replace(/\\bis-loading\\b/, ''); }); document.body.className += (navigator.userAgent.match(/(MSIE|rv:11\\.0)/) ? ' is-ie' : ''); } uniform mat4 uProjection; uniform mat4 uModelview; uniform vec3 uResolution; uniform vec3 uOffset; uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start attribute vec3 aPosition; attribute vec3 aEuler; attribute vec2 aMisc; //x:size, y:fade varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; void main(void) { // Projection is based on vertical angle vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0); gl_Position = uProjection * pos; gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5; pposition = pos.xyz; psize = aMisc.x; pdist = length(pos.xyz); palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z); vec3 elrsn = sin(aEuler); vec3 elrcs = cos(aEuler); mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, elrcs.x, elrsn.x, 0.0, -elrsn.x, elrcs.x ); mat3 roty = mat3( elrcs.y, 0.0, -elrsn.y, 0.0, 1.0, 0.0, elrsn.y, 0.0, elrcs.y ); mat3 rotz = mat3( elrcs.z, elrsn.z, 0.0, -elrsn.z, elrcs.z, 0.0, 0.0, 0.0, 1.0 ); mat3 rotmat = rotx * roty * rotz; normal = rotmat[2]; mat3 trrotm = mat3( rotmat[0][0], rotmat[1][0], rotmat[2][0], rotmat[0][1], rotmat[1][1], rotmat[2][1], rotmat[0][2], rotmat[1][2], rotmat[2][2] ); normX = trrotm[0]; normY = trrotm[1]; normZ = trrotm[2]; const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237); float tmpdfs = dot(lit, normal); if(tmpdfs < 0.0) { normal = -normal; tmpdfs = dot(lit, normal); } diffuse = 0.4 + tmpdfs; vec3 eyev = normalize(-pos.xyz); if(dot(eyev, normal) > 0.0) { vec3 hv = normalize(eyev + lit); specular = pow(max(dot(hv, normal), 0.0), 20.0); } else { specular = 0.0; } rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0); rstop = pow(rstop, 0.5); //-0.69315 = ln(0.5) distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y)); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start const vec3 fadeCol = vec3(0.08, 0.03, 0.06); varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; float ellipse(vec2 p, vec2 o, vec2 r) { vec2 lp = (p - o) / r; return length(lp) - 1.0; } void main(void) { vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0; vec3 d = vec3(0.0, 0.0, -1.0); float nd = normZ.z; //dot(-normZ, d); if(abs(nd) < 0.0001) discard; float np = dot(normZ, p); vec3 tp = p + d * np / nd; vec2 coord = vec2(dot(normX, tp), dot(normY, tp)); //angle = 15 degree const float flwrsn = 0.258819045102521; const float flwrcs = 0.965925826289068; mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs); vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm; float r; if(flwrp.x < 0.0) { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5); } else { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5); } if(r > rstop) discard; vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r); float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35)); col *= vec3(1.0, grady, grady); col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3)); col = col * diffuse + specular; col = mix(fadeCol, col, distancefade); float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0; alpha = smoothstep(0.0, 1.0, alpha) * palpha; gl_FragColor = vec4(col * 0.5, alpha); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec2 uTimes; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec3 col; float c; vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0); c = exp(-pow(length(tmpv) * 1.8, 2.0)); col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c); gl_FragColor = vec4(col * 0.5, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; uniform vec4 uBlurDir; //dir(x, y), stride(z, w) varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta); col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta); gl_FragColor = col / 5.0; } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_FragColor = texture2D(uSrc, texCoord); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform sampler2D uBloom; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 srccol = texture2D(uSrc, texCoord) * 2.0; vec4 bloomcol = texture2D(uBloom, texCoord); vec4 col; col = srccol + bloomcol * (vec4(1.0) + srccol); col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5); col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2) gl_FragColor = vec4(col.rgb, 1.0); gl_FragColor.a = 1.0; }"},{"title":"","date":"2021-09-25T03:32:28.001Z","updated":"2019-12-06T05:56:18.000Z","comments":true,"path":"mylist/index.html","permalink":"https://ahrilove.top/mylist/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;我从来不记在辞典上已经印有的东西。我的记忆力是运用来记忆书本上还没有的东西。 ——爱因斯坦&nbsp;&nbsp;在这主题页中我将分享自己收集的一些资料以及文档 优秀博客或文章 链接 RGB颜色对照表 https://www.114la.com/other/rgb.htm 比较柔和的配色表 https://www.geticsen.cn/Index/article/content/151.html Hexo的ico图标 http://www.wapadd.cn/icons/awesome/index.htm bilibili视频收藏 https://space.bilibili.com/215893581/favlist git详细教程 https://blog.csdn.net/u011535541/article/details/83379151 Django2.0详细资料文档 https://pan.baidu.com/s/1ppN8GSDdOdcd3ew0e7SxMQ 开发书籍电子版大全 https://pan.baidu.com/s/1HJtB9EieaMZPU0fSK2kgkQ docker详情mindmanage https://pan.baidu.com/s/1nUE4pfe2wThYVGMEYqADXw 网络用语大全~小鸡词典 https://jikipedia.com/ Vue-Devtools最简单的配置，有手就行 https://blog.csdn.net/weixin_38654336/article/details/80790698 Jetbrains全家桶注册码 http://www.medeming.com/ 阿里中间件团队博客 http://jm.taobao.org/ font-awesome ico小图标 https://fontawesome.com/icons?d=gallery&amp;m=free 亲测可用：navicat premium12 破解教程 https://blog.csdn.net/u013162035/article/details/89456708 小马视频码云仓库 https://gitee.com/komavideo/projects 服务端高并发分布式架构演进之路(天猫) https://segmentfault.com/a/1190000018626163 看完这篇还不了解Nginx，那我就哭了！ https://www.cnblogs.com/wcwnina/p/8728391.html#!comments Nginx笔记一 http://www.edrawsoft.cn/viewer/public/s/e194d338895116 Nginx安装配置笔记二（完整版） 链接：https://pan.baidu.com/s/1bTVdjwFl-kyd93C2GksZQQ 提取码：63x6 将table转变为Makedown,CSV,json,sql,yaml,html,excle https://tableconvert.com/"},{"title":"逆水行舟用力撑，一篙松劲退千寻","date":"2021-09-25T03:32:28.002Z","updated":"2020-11-10T07:41:50.000Z","comments":true,"path":"plan/index.html","permalink":"https://ahrilove.top/plan/index.html","excerpt":"","text":"Daily PLAN 2019-12-16 summarize: 最近很迷茫，不知道在干什么，总结一下自己用到的知识，与此对比，查漏补缺：1.Python2.html,css,javascript3.jQuery4.PHP,ThinkPHP5.Vue6.Bootstrap7.Echarts8.git,hexo9.SQl:mysql,oracle,Memcached,redis10.docker11.Ubuntu&amp;&amp;Linux 2020-11-10 知识归纳，文档整理 jQuery的文档整理 Vue官方文档整理 Python爬虫 java复习 CSDN"},{"title":"","date":"2021-09-25T03:32:28.001Z","updated":"2019-12-06T12:22:20.000Z","comments":true,"path":"game/index.html","permalink":"https://ahrilove.top/game/index.html","excerpt":"","text":"轻松一刻 body{ background-image:url(http://pic1.win4000.com/wallpaper/2019-09-20/5d84387f09a52.jpg); } 开始 简单 简单 入门 阿三 外星人 仙人"},{"title":"所有标签","date":"2021-09-25T03:32:28.003Z","updated":"2019-10-25T13:06:24.000Z","comments":true,"path":"tags/index.html","permalink":"https://ahrilove.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java(八)：Java异常处理机制的补充","slug":"Java系列章节更新(八)","date":"2021-10-08T16:00:00.000Z","updated":"2021-12-04T00:48:03.483Z","comments":true,"path":"2021/10/09/Java系列章节更新(八)/","link":"","permalink":"https://ahrilove.top/2021/10/09/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E5%85%AB)/","excerpt":"本章内容: 1.异常的产生过程解析2.异常的处理3.异常的注意事项4.自定义异常","text":"本章内容: 1.异常的产生过程解析2.异常的处理3.异常的注意事项4.自定义异常 1.异常的产生过程解析异常产生的原理（示意图）：Ⅰ. jvm的getElement方法把异常对象抛给main方法Ⅱ. main方法没有异常的处理逻辑会继续把对象抛给JVM 2.异常的处理异常的处理常涉及到五个关键字： throw关键字作用：可以使用throw关键字在指定方法中抛出指定的异常使用格式：throw new xxxException(“异常的产生原因”)注意： throw关键字必须写在方法的内部 throw关键字后边new的对象必须是Exception或者其子类对象（参考Exception类的常见情况） throw关键字后边创建的是RuntimeException或者其子类对象时，我们可以交给jvm处理（jvm会中断程序）。throw关键字后边若是编译异常，要么throws，要么try catch。 12345678910111213141516171819package com.Alibaba;public class ExceptionDemo &#123; public static int getElement(int[] array,int index)&#123; if(index&lt;0 || index&gt;array.length-1)&#123; throw new ArrayIndexOutOfBoundsException(\"索引值超过数组范围\"); &#125;else if (array == null)&#123; throw new NullPointerException(\"数组不能为空\"); &#125; return array[index]; &#125; public static void main(String[] args) &#123; int[] aa = null; int[] cc = &#123;1,2,3&#125;;// int bb = getElement(aa,1);// System.out.println(bb); System.out.println(getElement(cc,3)); &#125;&#125; throws关键字throws关键字:异常处理的第一种方式,交给别人处理 作用: 当方法内部抛出异常对象的时候,那么我们就必须处理这个异常对象 可以使用throws关键字处理异常对象,会把异常对象声明抛出给方法的调用者处理(自己不处理,给别人处理),最终交给JVM处理–&gt;中断处理 使用格式:在方法声明时使用 12345修饰符 返回值类型 方法名(参数列表) throws AAAExcepiton,BBBExcepiton...&#123; // 有几个异常就写几个 throw new AAAExcepiton(&quot;产生原因&quot;); throw new BBBExcepiton(&quot;产生原因&quot;); ...&#125; 注意:1.throws关键字必须写在方法声明处2.throws关键字后边声明的异常必须是Exception或者是Exception的子类3.方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常：如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可4.调用了一个声明抛出异常的方法,我们就必须的处理声明的异常：要么继续使用throws声明抛出,交给方法的调用者处理,最终交给JVM;要么try…catch自己处理异常，（参考下列实例代码11-13行） 1234567891011121314151617181920212223242526272829303132333435363738394041package com.bytedance.demo01.Exception;import java.io.FileNotFoundException;import java.io.IOException;public class Demo05Throws &#123; /* FileNotFoundException extends IOException extends Excepiton 如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可 */ //public static void main(String[] args) throws FileNotFoundException,IOException &#123; //public static void main(String[] args) throws IOException &#123; public static void main(String[] args) throws Exception &#123; readFile(\"c:\\\\a.tx\"); System.out.println(\"后续代码\"); &#125; /* 定义一个方法,对传递的文件路径进行合法性判断 如果路径不是\"c:\\\\a.txt\",那么我们就抛出文件找不到异常对象,告知方法的调用者 注意: FileNotFoundException是编译异常,抛出了编译异常,就必须处理这个异常 可以使用throws继续声明抛出FileNotFoundException这个异常对象,让方法的调用者处理 */ public static void readFile(String fileName) throws FileNotFoundException,IOException&#123; if(!fileName.equals(\"c:\\\\a.txt\"))&#123; throw new FileNotFoundException(\"传递的文件路径不是c:\\\\a.txt\"); &#125; /* 如果传递的路径,不是.txt结尾 那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对 */ if(!fileName.endsWith(\".txt\"))&#123; throw new IOException(\"文件的后缀名不对\"); &#125; System.out.println(\"路径没有问题,读取文件\"); &#125;&#125; try…catch 关键字try…catch:异常处理的第二种方式,自己处理异常格式: 123456789try&#123; 可能产生异常的代码&#125;catch(定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 异常的处理逻辑,异常异常对象之后,怎么处理异常对象 一般在工作中,会把异常的信息记录到一个日志中&#125;...catch(异常类名 变量名)&#123;&#125; 注意:1.try中可能会抛出多个异常对象,那么就可以使用多个catch来处理这些异常对象2.如果try中产生了异常,那么就会执行catch中的异常处理逻辑,执行完毕catch中的处理逻辑,继续执行try…catch之后的代码。如果try中没有产生异常,那么就不会执行catch中异常的处理逻辑,执行完try中的代码,继续执行try…catch之后的代码 举例说明： 123456789101112131415161718192021222324252627282930public class Demo01TryCatch &#123; public static void main(String[] args) &#123; try&#123; //可能产生异常的代码 readFile(\"d:\\\\a.tx\"); System.out.println(\"资源释放\"); &#125;catch (IOException e)&#123;//try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象 //异常的处理逻辑,异常异常对象之后,怎么处理异常对象 System.out.println(\"catch - 传递的文件后缀不是.txt\"); // throwable类出来try catch中的异常 System.out.println(e.getMessage()); System.out.println(e.toString()); e.printStackTrace(); &#125; System.out.println(\"程序后续代码\"); &#125; /* 如果传递的路径,不是.txt结尾 那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对 */ public static void readFile(String fileName) throws IOException &#123; if(!fileName.endsWith(\".txt\"))&#123; throw new IOException(\"文件的后缀名不对\"); &#125; System.out.println(\"路径没有问题,读取文件\"); &#125;&#125; Throwable类Throwable 类是 Java 语言中所有错误或异常的超类（终极父类）。 try…catch代码块处理异常时可以使用的Throwable类中定义了3个异常处理的方法： String getMessage() 返回此 throwable 的简短描述。 String toString() 返回此 throwable 的详细消息字符串。 void printStackTrace() JVM打印异常对象,默认此方法,打印的异常信息是最全面的 finally关键字finally代码块格式: 123456789101112try&#123; 可能产生异常的代码&#125;catch(定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 异常的处理逻辑,异常异常对象之后,怎么处理异常对象 一般在工作中,会把异常的信息记录到一个日志中&#125;...catch(异常类名 变量名)&#123;&#125;finally&#123; 无论是否出现异常都会执行&#125; 注意:1.finally不能单独使用,必须和try一起使用2.finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO) 举例说明： 12345678910111213141516171819202122232425262728import java.io.IOException;public class Demo02TryCatchFinally &#123; public static void main(String[] args) &#123; try &#123; //可能会产生异常的代码 readFile(\"c:\\\\a.tx\"); &#125; catch (IOException e) &#123; //异常的处理逻辑 e.printStackTrace(); &#125; finally &#123; //无论是否出现异常,都会执行 System.out.println(\"资源释放\"); &#125; &#125; /* 如果传递的路径,不是.txt结尾 那么我们就抛出IO异常对象,告知方法的调用者,文件的后缀名不对 */ public static void readFile(String fileName) throws IOException &#123; if(!fileName.endsWith(\".txt\"))&#123; throw new IOException(\"文件的后缀名不对\"); &#125; System.out.println(\"路径没有问题,读取文件\"); &#125;&#125; 3.异常的注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。(Exception类是IO异常，Runtime异常，error错误的父类) 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 4.自定义异常 为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类。比如自定义一个业务逻辑异常: RegisterException：一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。（编译异常一定要throws或者try catch处理） 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。（运行期的异常RuntimeException可以不用处理，直接交给JVM处理-中断程序）格式：1234public class XXXExcepiton extends Exception（编译异常） | RuntimeException&#123; 添加一个空参数的构造方法 添加一个带异常信息的构造方法&#125; 举例说明：定义一个登陆异常类RegisterException： 123456789101112131415package com.alibaba;public class RegisterException extends /*Exception*/ RuntimeException&#123; //添加一个空参数的构造方法 public RegisterException()&#123; super(); &#125; /* 添加一个带异常信息的构造方法 查看源码发现,所有的异常类都会有一个带异常信息的构造方法,方法内部会调用父类带异常信息的构造方法,让父类来处理这个异常信息 */ public RegisterException(String message)&#123; super(message); &#125;&#125; 注意事项: 自定义异常类一般都是以Exception结尾,说明该类是一个异常类 自定义异常类,必须的继承Exception或者RuntimeException 继承Exception:那么自定义的异常类就是一个编译期异常,如果方法内部抛出了编译期异常,就必须处理这个异常,要么throws,要么try…catch 继承RuntimeException:那么自定义的异常类就是一个运行期异常,无需处理,交给虚拟机处理(中断处理) 自定义异常的练习 需求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Scanner;/* 分析: 1.使用数组保存已经注册过的用户名(数据库) 2.使用Scanner获取用户输入的注册的用户名(前端,页面) 3.定义一个方法,对用户输入的中注册的用户名进行判断 遍历存储已经注册过用户名的数组,获取每一个用户名 使用获取到的用户名和用户输入的用户名比较 true: 用户名已经存在,抛出RegisterException异常,告知用户\"亲，该用户名已经被注册\"; false: 继续遍历比较 如果循环结束了,还没有找到重复的用户名,提示用户\"恭喜您,注册成功!\"; */public class Demo02RegisterException &#123; // 1.使用数组保存已经注册过的用户名(数据库) static String[] usernames = &#123;\"张三\",\"李四\",\"王五\"&#125;; public static void main(String[] args) &#123; //2.使用Scanner获取用户输入的注册的用户名(前端,页面) Scanner sc = new Scanner(System.in); System.out.println(\"请输入您要注册的用户名:\"); String username = sc.next(); checkUsername(username); &#125; //3.定义一个方法,对用户输入的中注册的用户名进行判断 public static void checkUsername(String username) &#123; //遍历存储已经注册过用户名的数组,获取每一个用户名 for (String name : usernames) &#123; //使用获取到的用户名和用户输入的用户名比较 if(name.equals(username))&#123; //true:用户名已经存在,抛出RegisterException异常,告知用户\"亲，该用户名已经被注册\"; throw new RegisterException(\"亲，该用户名已经被注册\");//抛出运行期异常,无需处理,交给JVM处理,中断处理 &#125; &#125; //如果循环结束了,还没有找到重复的用户名,提示用户\"恭喜您,注册成功!\"; System.out.println(\"恭喜您,注册成功!\"); &#125;&#125; 参考文章 Java的throw与throws关键字区别","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（七）：面向对象高级特性","slug":"Java系列章节更新(七)","date":"2021-10-07T16:00:00.000Z","updated":"2021-12-04T00:47:46.434Z","comments":true,"path":"2021/10/08/Java系列章节更新(七)/","link":"","permalink":"https://ahrilove.top/2021/10/08/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%B8%83)/","excerpt":"本章内容： 1.继承的概念与实现2.super关键词3.多态4.instanceof运算符5.final关键字","text":"本章内容： 1.继承的概念与实现2.super关键词3.多态4.instanceof运算符5.final关键字","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（六）：继承与多态","slug":"Java系列章节更新(六)","date":"2021-10-05T16:00:00.000Z","updated":"2022-01-07T06:52:52.583Z","comments":true,"path":"2021/10/06/Java系列章节更新(六)/","link":"","permalink":"https://ahrilove.top/2021/10/06/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E5%85%AD)/","excerpt":"本章内容： 1.继承的概念与实现2.super关键词3.多态4.instanceof运算符5.final关键字6.static关键字","text":"本章内容： 1.继承的概念与实现2.super关键词3.多态4.instanceof运算符5.final关键字6.static关键字 1.继承的概念与实现继承是类与类之间的关系，是一个很简单很直观的概念，与现实世界中的继承（例如儿子继承父亲财产）类似。 继承可以理解为一个类从另一个类获取方法和属性的过程。如果类B继承于类A，那么B就拥有A的方法和属性。 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 继承的特点： Java是单继承语言：一个类的直接父类只能有唯一一个 Java语言可以多级继承：父类也可以继承父类的父类 一个父类可以拥有多个子类：兄弟子类 继承使用extend关键字 子类可以覆盖父类的方法 子类可以继承父类除private以为的所有的成员 继承实例： 12345678910111213141516171819202122class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // 此处省略setter与getter&#125;class Student extends Person &#123; // 不要重复定义name和age字段/方法，只需要定义新增score字段/方法: private String category; public Student(String name, int age, String category) &#123; super(name, age); this.category = category; &#125; // 此处省略setter与getter&#125; 2.super关键字super关键字与this类似，this用来表示当前类的实例，super用来表示父类 super关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName实际上，这里使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段 12345class Student extends Person &#123; public String hello() &#123; return \"Hello, \" + super.name; &#125;&#125; 在继承时，如果父类存在构造函数，在这个时候，就必须使用super,其正确写法应为(牢记)： 123456789101112131415161718192021222324252627282930313233public class OOP &#123; public static void main(String[] args) &#123; // 实例s为Person的子类Student类的实例 Student s = new Student(\"gz\",18,10010,100); System.out.println(s.getAge()); System.out.println(s.grand); &#125;&#125;class Person &#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // 此处省略setter与getter&#125;class Student extends Person&#123; protected int grand; public Student(String name, int age, int grand) &#123; super(name, age); // 自动调用父类的构造方法Person(name, age) this.grand = grand; // 这是新构建的字段 &#125; @Override // Override重写，方法名，参数，返回值类型完全相同 public int getAge()&#123; return this.grand; &#125;&#125; 继承小结： Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类 子类无法访问父类的private字段或者private方法，为了让子类可以访问父类的字段，我们需要把private改为protected 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的 3.多态在继承关系中，子类如果与父类的方法名完全相同（方法名相同，参数相同，子类方法的返回值必须小于等于父类的返回值范围（推荐：子类和父类方法的返回值类型相同）），被称为重写（Override，这里要区别于Overload是方法名相同，但各自的参数不同） 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Person p = new Student(); p.run(); // 应该打印Person.run还是Student.run? &#125;&#125;class Person &#123; // class中的方法不要写static public void run() &#123; System.out.println(\"Person.run\"); &#125;&#125;// Student类继承Person类class Student extends Person &#123; @Override // 这是重写符号,将子类的run方法进行重写，增加新的功能 public void run() &#123; System.out.println(\"Student.run\"); &#125;&#125; 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如： 1234567891011121314class Person &#123; protected String name; public String hello() &#123; return \"Hello, \" + name; &#125;&#125;class Student extends Person &#123; @Override public String hello() &#123; // 调用父类的hello()方法: return super.hello() + \"!\"; &#125;&#125; 小结：区分子类方法中变量名的三种访问方式： 局部变量：直接写成员变量名 本类的成员变量：this.成员变量名 父类的成员变量：super.成员变量名 4.instanceof运算符多态性带来了一个问题，就是如何判断一个变量所实际引用的对象的类型。Java使用instanceof操作符，用来判断一个变量所引用的对象的实际类型，注意是它引用的对象的类型，不是变量的类型 实例：obj instanceof ClassName ，可以直白理解为 实例obj是ClassName类或是其子类？ 12345678910111213141516171819202122232425262728293031323334public final class Demo&#123; public static void main(String[] args) &#123; // 引用 People 类的实例 People obj = new People(); if(obj instanceof Object)&#123; // Person实例的obj是Object类的子类 System.out.println(&quot;我是一个对象&quot;); &#125; if(obj instanceof People)&#123; // obj等于Person类 System.out.println(&quot;我是人类&quot;); &#125; if(obj instanceof Teacher)&#123; // obj是Teacher类的父类，判断语句为错误 System.out.println(&quot;我是一名教师&quot;); &#125; System.out.println(&quot;-----------&quot;); // 分界线 // 引用 Teacher 类的实例 obj = new Teacher(); if(obj instanceof Object)&#123; System.out.println(&quot;我是一个对象&quot;); &#125; if(obj instanceof People)&#123; System.out.println(&quot;我是人类&quot;); &#125; if(obj instanceof Teacher)&#123; System.out.println(&quot;我是一名教师&quot;); &#125; if(obj instanceof President)&#123; System.out.println(&quot;我是校长&quot;); &#125; &#125;&#125;class People&#123; &#125;class Teacher extends People&#123; &#125;class President extends Teacher&#123; &#125; 运行结果：我是一个对象我是人类 我是一个对象我是人类我是一名教师 可以看出，如果变量引用的是当前类或它的子类的实例，instanceof 返回true，否则返回false。 5.final关键字在 Java 中，声明类、变量和方法时，可使用关键字final来修饰。final所修饰的数据具有“终态”的特征，表示“最终的”意思。具体规定如下： final修饰的类不能被继承 final修饰的方法不能被子类重写 final修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次 final修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用 final修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person &#123; protected String name; public final String hello() &#123; return \"Hello, \" + name; &#125;&#125;class Student extends Person &#123; // compile error: 不允许覆写 @Override public String hello() &#123; &#125;&#125; 2020-3-9 新增：在父子类的继承关系中，如果成员变量重名，则创建子类访问对象时，访问有两种方法： 通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找父类 通过成员方法访问成员变量：该方法属于谁，就优先用谁，没有向上找父类 12345678910111213141516171819202122232425262728293031323334353637package com.Alibaba;public class extendsField &#123; public static void main(String[] args) &#123; Fu fu = new Fu(); Zi zi = new Zi();// 实例化两个对象 /* * 当父类和子类都具有num这个成员变量时 * 等号左边是谁，优先用谁 * */ System.out.println(zi.num); // 20 System.out.println(\"======\"); zi.methodZi(); // 20：这个方法是子类的，优先使用子类的 zi.methodFu(); // 10：这个方法实在父类中定义的 &#125;&#125;// 创建父类class Fu&#123; public int num = 10; public int numFu = 100; public void methodFu()&#123; System.out.println(\"这是父类方法\"); // 优先使用本类中的num System.out.println(num); // 10 &#125;&#125;// 创建子类class Zi extends Fu&#123; public int num = 20; public int numFu = 100; public void methodZi()&#123; System.out.println(\"这是子类方法\"); // 优先使用本类中的成员变量 System.out.println(num); // 20 &#125;&#125; 6.static关键字关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 在一个类中，有变量和方法，而变量有成员变量，静态变量；而方法有成员方法和静态方法之分(只要带static关键字就代表静态变量或方法) 如何区分我们什么时候使用static关键字呢？ 从上述图中我们可以看出在学生类中，我们new三个学生对象，每一个对象除了姓名，年龄，学号不同之外，每一个学生对象的所在教室完全一样。对于姓名，年龄，学号来说，每一个对象都有自己独立的数据。但对于所在的教室来说，这应该是多个对象共享同一份数据才对。一旦使用了static关键字，那么这样的内容不在属于对象自己，而是属于类的，所以凡是本类的对象，都共享同一份。 我们来实现这个图片展示的功能（以标准的类的创建方式）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class staticDemo &#123; public static void main(String[] args) &#123; // 静态static常量赋初值(类名称.变量名) Student1.room = \"101教室\"; Student1 one = new Student1(\"郭靖\", 20); System.out.println(\"one的姓名：\" + one.getName()); System.out.println(\"one的年龄：\" + one.getAge()); System.out.println(\"one的教室：\" + Student1.room); System.out.println(\"============\"); Student1 two = new Student1(\"黄蓉\", 18); System.out.println(\"two的姓名：\" + two.getName()); System.out.println(\"two的年龄：\" + two.getAge()); System.out.println(\"two的教室：\" + Student1.room); myMethod() // 本类中的静态方法直接调用 &#125; // 本类中的静态方法，调用时可以省略类名称，直接调用 public static void myMethod() &#123; System.out.println(\"自己的方法！\"); &#125;&#125;class Student1 &#123; private int id; // 学号 private String name; // 姓名 private int age; // 年龄 static String room; // 所在教室 private static int idCounter = 0; // 学号计数器，每当new了一个新对象的时候，计数器++ public Student1() &#123; this.id = ++idCounter; &#125; public Student1(String name, int age) &#123; this.name = name; this.age = age; this.id = ++idCounter; &#125; // 省略此处的setter与getter&#125; 静态变量 静态变量：static 数据类型 变量名 （static int numberID） 比如说，基础班新班开班，学员报到。现在想为每一位新来报到的同学编学号（sid），从第一名同学开始，sid为 1，以此类推。学号必须是唯一的，连续的，并且与班级的人数相符，这样以便知道，要分配给下一名新同学的学 号是多少。这样我们就需要一个变量，与单独的每一个学生对象无关，而是与整个班级同学数量有关 12345678910111213141516171819202122232425262728293031public class staticDemo &#123; public static void main(String[] args) &#123; Student1 s1 = new Student1(\"迪丽热巴\",18); Student1 s2 = new Student1(\"古力娜扎\",20); Student1 s3 = new Student1(\"马尔扎哈\",33); s1.show(); // Student : name=迪丽热巴, age=18, 学生编号=1 s2.show(); // Student : name=古力娜扎, age=20, 学生编号=2 s3.show(); // Student : name=马尔扎哈, age=33, 学生编号=3 &#125;&#125;class Student1&#123; // 成员变量 private String name; private int age; private int id; // 静态变量，记录学生数量，分配学号 public static int numberNo = 0; public Student1(String name,int age)&#123; this.name = name; this.age = age; // 表示每创建一个Student1对象，id就会自动加一 this.id = ++ numberNo; &#125; // 打印属性值 public void show() &#123; System.out.println(\"Student : name=\"+this.name+\", age=\"+this.age+\", 学生编号=\"+this.id); &#125;&#125; 静态方法 使用格式：修饰符 static 返回值类型 方法名 (参数列表){ 执行语句代码块 } 被static修饰的成员建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.bytedance;public class staticDemo &#123; public static void main(String[] args) &#123; MyClass obj = new MyClass(); // 首先创建对象 obj.num = 18; MyClass.numStatic = 20; // 创建对象之后，然后才能使用没有static关键字的内容 obj.method(); // 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 obj.methodStatic(); // 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名” MyClass.methodStatic(); // 正确，推荐 // 对于本类当中的静态方法，可以省略类名称 myMethod(); staticDemo.myMethod(); // 对于本类中的静态方法，myMethod()与staticDemo.myMethod()完全等效，可以省略类名称 &#125; public static void myMethod() &#123; System.out.println(\"自己的方法！\"); &#125;&#125;class MyClass &#123; int num; // 成员变量 static int numStatic; // 静态变量 // 成员方法 public void method() &#123; System.out.println(\"这是一个成员方法。\"); // 成员方法可以访问成员变量 System.out.println(num); // 成员方法可以访问静态变量 System.out.println(numStatic); &#125; // 静态方法 public static void methodStatic() &#123; System.out.println(\"这是一个静态方法。\"); // 静态方法可以访问静态变量 System.out.println(numStatic); // 静态不能直接访问非静态【重点】 // System.out.println(num); // 错误写法！ // 静态方法中不能使用this关键字。 // System.out.println(this); // 错误写法！ &#125;&#125; 总结：一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。 如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它 无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。静态变量\\：类名称.静态变量静态方法\\：类名称.静态方法() 静态常量赋初始值的方法：类名称.静态变量名 = 初始值 注意事项： 静态方法只能访问静态成员，实例方法可以访问静态和实例成员。反之，成员方法可以直接访问类变量或静态方法原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。“先人不知道后人，但是后人知道先人。” 静态方法当中不能用this。原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。 对于本类当中的静态方法，调用时可以省略类名称 关于静态变量和静态方法的总结： 一个类的静态方法只能访问静态变量 一个类的静态方法不能够直接调用非静态方法 如访问控制权限允许，静态变量和静态方法也可以通过对象来访问，但是不被推荐 静态方法中不存在当前对象，因而不能使用this，当然也不能使用super 静态方法不能被非静态方法覆盖 构造方法不允许声明为static的 局部变量不能使用static修饰 参考文献 静态方法类名访问，只允许访问静态成员","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（五）：类与对象","slug":"Java系列章节更新(五)","date":"2021-10-04T16:00:00.000Z","updated":"2022-01-07T09:48:08.978Z","comments":true,"path":"2021/10/05/Java系列章节更新(五)/","link":"","permalink":"https://ahrilove.top/2021/10/05/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%BA%94)/","excerpt":"本章内容： 1.类与实例2.方法3.构造方法★★4.方法重载Overload5.对象6.抽象类7.接口8.package包","text":"本章内容： 1.类与实例2.方法3.构造方法★★4.方法重载Overload5.对象6.抽象类7.接口8.package包 1.类与实例现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance） 类必须先定义才能使用。类是创建对象的模板，创建对象也叫类的实例化。instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同，完整语法为： 123456789101112[public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123; // 定义属性部分 &lt;property_type&gt;&lt;property1&gt;; &lt;property_type&gt;&lt;property2&gt;; &lt;property_type&gt;&lt;property3&gt;; … // 定义方法部分 function1(); function2(); function3(); …&#125; 提示：上述语法中，中括号“[]”中的部分表示可以省略，竖线“|”表示“或关系”，例如 abstract|final，说明可以使用abstract或final关键字，但是两个关键字不能同时出现 对实例的说明： public：表示“共有”的意思。如果使用public修饰，则可以被其他类和程序访问。每个Java程序的主类都必须是public类，作为公共工具供其他类和程序使用的类应定义为public类 abstract：如果类被abstract修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用abstract修饰的方法）和具体方法（没有使用abstract修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类） final：如果类被final修饰，则不允许被继承 class：声明类的关键字 class_name：类的名称 extends：表示继承其他类 implements：表示实现某些接口 property_type：表示成员变量的类型 property：表示成员变量名称 function()：表示成员方法名称 2.方法方法method是一段用来完成特定功能的代码块，类似于其它语言中的函数function。方法用于定义该类或该类的实例的行为特征和功能实现。 12345public class Test &#123; [public|private|protected][static]&lt;void|return_type&gt;&lt;method_name&gt;([paramList]) &#123; // 方法体 &#125;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。return作用：1. 返回值 2.结束程序运行 各修饰符含义如下： public、private、protected：表示成员方法的访问权限 static：表示限定该成员方法为静态方法 final：表示限定该成员方法不能被重写或重载 abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类 方法的参数有实参和形参之分，我们现在深入思考一下，方法中可以传递什么类型的值 基本数据类型：整型，字符型，浮点型，布尔型 1public static void test(int a, char b, double c, float d, boolean e)&#123;&#125; 引用数据类型：字符串，接口 1public static void test(String a)&#123;&#125; 数组类型传递： 1public static void test(int[] a, char[] b, double[] c,...)&#123;&#125; class类类型传递： 123456789101112public static void test(employee a,employee b)&#123;&#125;...class employee&#123; private int id; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 总结：基本数据类型、引用类型在内存中的存储方式： 基本数据类型：存放在栈内存中。用完就消失 引用类型：在栈内存中存放引用堆内存的地址，在堆内存中存储类、对象、数组等。当没用引用指向堆内存中的类、对象、数组时，由 GC回收机制不定期自动清理 3.构造方法构造方法是专门用来创建对象的方法，通过关键字new来创建对象，就是在调用构造方法格式：public 类名称(参数类型 变量名称){方法体} 注意事项： 构造方法的名称必须和所在的类名称完全一样，就连大小写也一样 构造方法不要写返回值类型，连void都不要写 构造方法不能return一个具体的返回值 123456789101112131415161718192021222324252627282930313233public class OOP &#123; public static void main(String[] args) &#123; // 在通过new操作符调用的时候，构造方法的参数数量、位置和类型一一对应 Person p = new Person(\"chd\",18,10086); System.out.println(p.getAge()); // 调用实例对象的属性 System.out.println(p.tel); System.out.println(p.getAge()); System.out.println(p.getName()); &#125;&#125;class Person &#123; // 这个不能省略，用以声明变量 private String name; private int age; public int tel; // 这就是Java的构造方法，类似于python的def __init__函数 public Person(String name, int age,int tel) &#123; this.name = name; this.age = age; this.tel = tel; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 多构造方法 可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name) &#123; this.name = name; this.age = 12; &#125; public Person() &#123; &#125;&#125; 如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person() 4.Overload方法重载这种方法名相同，但各自的参数不同（即参数数目不同，参数数据类型不同），称为方法重载（Overload）。注意：方法重载的返回值类型通常都是相同的。 1234567891011121314151617class Hello &#123; public void hello() &#123; System.out.println(\"Hello, world!\"); &#125; public void hello(String name) &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; public void hello(String name, int age) &#123; if (age &lt; 18) &#123; System.out.println(\"Hi, \" + name + \"!\"); &#125; else &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; &#125;&#125; 说明： 声明为final的方法不能被重载。 声明为static的方法不能被重载，但是能够被再次声明。 5.对象对象创建方式：类名 对象名 = new 类名() Java虚拟机在创建一个对象时都包含以下步骤： 给对象分配内存。 将对象的实例变量自动初始化为其变量类型的默认值。 初始化对象，给实例变量赋予正确的初始值。 注意：每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由Java虚拟机自带的垃圾回收机制处理。 匿名对象 通过前面的知识我们已经了解到了，每次new都相当于开辟了一个新的对象，并开辟了一个新的物理内存空间。如果一个对象只需要使用唯一的一次，就可以使用匿名对象，匿名对象还可以作为实际参数传递。 12345678910111213141516171819public class Person &#123; public String name; // 姓名 public int age; // 年龄 // 定义构造方法，为属性初始化 public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // 获取信息的方法 public void tell() &#123; System.out.println(\"姓名：\" + name + \"，年龄：\" + age); &#125; public static void main(String[] args) &#123; new Person(\"张三\", 30).tell(); // 匿名对象 =&gt; 姓名：张三，年龄：30 &#125;&#125; 6.抽象类由于多态的存在，每个子类都可以覆写父类的方法，例如： 12345678910111213class Person &#123; public void run() &#123; … &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; … &#125;&#125;class Teacher extends Person &#123; @Override public void run() &#123; … &#125;&#125; 定义：抽象类：抽象方法所在的类，必须是抽象类才行，在class前写上abstract即可抽象方法：就是在方法强加上abstract关键字，然后去掉大括号，直接分号结束 使用方法： 不能直接创建new抽象类对象 必须用一个子类来继承抽象父类 子类必须覆盖重写抽象父类当中的所有抽象方法 创建子类实例对象进行使用如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。1234567891011121314151617181920212223242526272829public class OOP&#123; public static void main(String[] args) &#123; /* *这里值得值得注意：用abstract修饰的类就是抽象类。我们无法实例化一个抽象类 */ Person p = new Student(); // 第四点：创建子类实例对象 p.age = 18; p.run(); &#125;&#125;// 抽象类不仅要在类名前加abstract，也要在抽象方法名前加abstract// Person类用abstract修饰的，表示为抽象类，我们无法实例化抽象类abstract class Person&#123; protected int age; public abstract void run();&#125;// Student类继承Person类，并将父类的run方法进行重写class Student extends Person&#123; @Override public void run()&#123; System.out.println(super.age); // super指代父类 System.out.println(this.age); &#125;&#125; 小结： 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范； 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法； 抽象类无法被实例化（即className 变量名 = new className()） 7.接口含义如果一个抽象类没有字段或者说没有属性，所有方法全部都是抽象方法【抽象方法：修饰符 abstract 返回值类型 方法名()】，就可以把该抽象类改写为接口：interface 123456// 抽象类abstract class Person &#123; public abstract void run(); public abstract String getName(); public abstract String getName();&#125; 在Java中，可以使用interface可以声明一个接口： 1234interface Person&#123; void run(); String getName();&#125; 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样） 实现方式当一个具体的class去实现一个interface时，需要使用implements关键字 1234567891011121314151617class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + \" run\"); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; 类实现多接口在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface 123class Student implements Person, Hello &#123; // 实现了两个interface ...&#125; 接口继承一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 12345678interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125; 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 8.package包12345678910程序目录结构：package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 使用import导入相关包 方式一：import 包名.某一类名 方式二：import 包名.*","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（四）：Java核心类","slug":"Java系列章节更新(四)","date":"2021-10-03T16:00:00.000Z","updated":"2022-01-05T06:38:44.218Z","comments":true,"path":"2021/10/04/Java系列章节更新(四)/","link":"","permalink":"https://ahrilove.top/2021/10/04/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E5%9B%9B)/","excerpt":"本章内容： 1.包装类2.enum枚举类型3.常用工具类4.异常处理机制5.Java集合6.日期与时间","text":"本章内容： 1.包装类2.enum枚举类型3.常用工具类4.异常处理机制5.Java集合6.日期与时间 1. 包装类 映射关系 基本类型===&gt; 对应的引用类型boolean ===&gt; java.lang.Booleanbyte ===&gt; java.lang.Byteshort ===&gt; java.lang.Shortint ===&gt; java.lang.Integerlong ===&gt; java.lang.Longfloat ===&gt; java.lang.Floatdouble ===&gt; java.lang.Doublechar ===&gt; java.lang.Character 包装类的实际运用(以int和integer为例) int和integer类之间的转换：在实际转换时，使用Integer类的构造方法和Integer类内部的intValue方法实现这些类型之间的相互转换 1234567int n=5;Integer n1=new Integer(n);System.out.println(&quot;int类型转换为integer类：&quot;+n1);Integer i=new Integer(50);int i1 = i.intValue();System.out.println(&quot;integer类转换为int类型：&quot;+i1); Integer类内部的常用方法（Integer类的主要方法有：parseInt方法和toString方法） 123456789101112//parseInt方法： 数字字符串类型转成int类型String ss=&quot;123&quot;;int ii = Integer.parseInt(ss);System.out.println(&quot;字符类型转成整型：&quot;+ii);// parseInt(String s ,int radix)的目的是求&quot;radix&quot;进制数&quot;s&quot;的十进制数是多少System.out.println(Integer.parseInt(&quot;444&quot;,16);); // 表示16进制的0x444的十进制是多少//toString方法：int类型转成数字字符串类型int ii2=123;String ss2 = Integer.toString(ii2);System.out.println(&quot;int类型转成数字字符串类型:&quot;+ss); 拓： equals() 比较的是两个对象的值（内容）是否相同。 == 比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等 3.enum枚举类1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) &#123; System.out.println(\"Work at home!\"); &#125; else &#123; System.out.println(\"Work at office!\"); &#125; &#125;&#125;enum Weekday &#123; SUN, MON, TUE, WED, THU, FRI, SAT;&#125; 4.常用工具类Math：数学计算Math.abs()求绝对值Math.max/min()Math.pow(a,b)计算a的次方Math.sqrt()计算开方Math.exp()计算e的次方Math.PI数学常量PIMath.E数学常量eMath.random()生成随机[0,1)的数 Random：随机数123456789101112// 创建Random实例对象Random r = new Random(seed); // 种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系r.nextInt(); // 2071575453,每次都不一样r.nextInt(100); // 54,生成一个随机[0,100)的随机整数r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的doubleRandom rand =new Random(25); // 预设种子数int i=rand.nextInt(100);System.out.println(i); 初始化时25并没有起直接作用（注意：不是没有起作用）,rand.nextInt(100);中的100是随机数的上限,产生的随机数为0-100的整数,不包括100 对于种子相同的Random对象，生成的随机数序列是一样的。 123456789101112131415161718192021Random ran1 = new Random(10);System.out.println(\"使用种子为10的Random对象生成[0,10)内随机整数序列: \");for (int i = 0; i &lt; 10; i++) &#123; System.out.print(ran1.nextInt(10) + \" \"); &#125;System.out.println();Random ran2 = new Random(10);System.out.println(\"使用另一个种子为10的Random对象生成[0,10)内随机整数序列: \");for (int i = 0; i &lt; 10; i++) &#123; System.out.print(ran2.nextInt(10) + \" \"); &#125;/** * 输出结果为： * * 使用种子为10的Random对象生成[0,10)内随机整数序列: * 3 0 3 0 6 6 7 8 1 4 * 使用另一个种子为10的Random对象生成[0,10)内随机整数序列: * 3 0 3 0 6 6 7 8 1 4 **/ BigDecimal大数类float和double只能用来做科学计算或者是工程计算，在商业计算中我们要用 java.math.BigDecimal（大数类的运算效率肯定不如原生类型效率高，代价比较昂贵，需要结合具体的场景来使用）大数类的传入的值必须为字符串类型 123456789101112BigDecimal a=new BigDecimal (&quot;4.5&quot;);BigDecimal b=new BigDecimal (&quot;1.5&quot;);a.add(b) // 6.0add(BigDecimal value)：加法，求两个BigDecimal类型数据的和。subtract(BigDecimal value)：减法，求两个BigDecimal类型数据的差。multiply(BigDecimal value)：乘法，求两个BigDecimal类型数据的积。divide(BigDecimal divisor)：除法，求两个BigDecimal类型数据的商。remainder(BigDecimal divisor)：求余数，求BigDecimal类型数据除以divisor的余数。max(BigDecimal value)：最大数，求两个BigDecimal类型数据的最大值。min(BigDecimal value)：最小数，求两个BigDecimal类型数据的最小值。abs()：绝对值，求BigDecimal类型数据的绝对值。negate()：相反数，求BigDecimal类型数据的相反数。 5.异常处理机制在Java中，凡是可能抛出异常的语句，都可以用try ... catch捕获。把可能发生异常的语句放在try { … }中，然后使用catch捕获对应的Exception及其子类。 在使用try…catch捕获处理异常时需要注意： 不要过度使用异常，不能使用异常处理机制来代替正常的流程控制语句 异常捕获时，一定要先捕获小异常，再捕获大异常。否则小异常将无法被捕获 避免出现庞大的try块 避免使用catch(Exception e){} 不要忽略异常 Exception类的常用的几种情况：系统IO异常/运行异常 IOException有：EOFException文件已结束异常FileNotFoundException文件未找到异常 RuntimeException有：IndexOutOfBoundsException索引越界异常；ArrayIndexOutOfBoundsException数组索引越界异常；ArithmeticException算数条件异常，譬如:整数除零等；NullPointerException空指针异常；NegativeArraySizeException数组长度为负异常；ArrayStoreException数组存储异常，当向数组中存放非数组声明类型对象时抛出；SecurityException违背安全原则异常；IllegalArgumentException非法参数异常；ClassCastException类型强制转换异常。ReflectiveOperationException有：ClassNotFoundException找不到类异常；NoSuchMethodException方法未找到异常；NoSuchFieldException找不到属性异常。 错误类Error：一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。所以不应该试图使用catch块来捕捉Error和不能在throws子句中声明该方法可能抛出Error及其任何子类 多catch语句 多catch语句:简单来说，多个catch语句只有一个能被执行 可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 finally语句 无论是否有异常发生，程序语句最终都要执行 1234567891011121314public class HelloWorld&#123; public static void main(String[] args) &#123; try &#123; process1(); process2(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"Bad encoding\"); &#125; catch (IOException e) &#123; System.out.println(\"IO error\"); &#125; finally &#123; System.out.println(\"END\"); &#125; &#125;&#125; 6.集合 collection接口 Java的集合与数组都是为了处理一类数据，但Java数组也存在很大的缺陷： 数组初始化后大小不可变； 数组只能按索引顺序存取。 Java集合类型分为Collection和Map，它们是Java集合的根接口，这两个接口又包含了一些子接口或实现类。Java的java.util包的collection主要提供了以下三种类型的集合： List接口：一种有序列表的集合，允许存储重复的元素，具体实现的类有ArrayList集合，LinkedList集合，Vector集合； Set接口：一种保证没有重复元素的集合，且没有索引（不能使用普通的for循环遍历集合），具体实现的类有TreeSet集合，HashSet集合，LinkedHashSet集合； Map：一种通过键值（key-value）查找的映射表集合。 List接口创建List： 12345List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 只能放入String类型List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); // 只能放入Integer类型List&lt;Character&gt; list2 = new ArrayList&lt;&gt;(); // 只能放入Character类型拓展：根据给定的元素快速创建ListList&lt;Integer&gt; list3 = List.of(1, 2, 5); collection接口的List接口的共性方法： 12345在末尾或指定索引添加一个元素：add([index], E)删除指定索引处的元素值或指定的元素：remove(index) 或 remove(Object)获取指定索引的元素（不支持负索引）：get(index)更改指定索引对元素（不支持负索引）：set(index, element)获取List大小（包含元素的个数）：size() List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 ArrayList集合 对于ArrayList来说，有一个尖括号代表泛型（泛型：也就是装在集合中的所有元素，全部都是统一的什么类型。注意，泛型只能是引用数据类型，不能是基本类型） java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 创建ArrayList： 123ArrayList&lt;String&gt; sites = new ArrayList&lt;&gt;();ArrayList&lt;Integer&gt; bite = new ArrayList&lt;&gt;();ArrayList&lt;Float&gt; byd = new ArrayList&lt;&gt;(); ArrayList的常用方法 除了之前提到的共性方法之外，ArrayList还具有如下方法 方法 描述 addAll() 添加集合中的所有元素到arraylist中 clear() 删除集合所有元素 contains() 判断目标元素是否存在 indexOf() 返回目标元素的索引值，不存在返回-1 isEmpty() 判断有序数组是否为空 subList(start, end) 有序数组截取，满足左闭右开，不支持负索引 set(index, element) 对指定位置对元素进行更新 sort(type) 对动态数组进行排序（Comparator.naturalOrder()升序；Comparator.reverseOrder()降序） toArray() 将arraylist转换为静态数组 toString() 将arraylist转换为字符串 forEach((x)-&gt;{…}) 动态数组遍历，跟for-each循环不同 LinkedList集合 java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 创建LinkedList 1234// 引入 LinkedList 类import java.util.LinkedList;// 创建LinkedList类LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); 常用方法 方法 描述 addFirst() 指定元素插入此列表的开头 addLast() 指定元素插入此列表的结尾 getFirst() 返回列表第一个元素 getLast() 返回列表最后一个元素 removeFirst() 移除列表第一个元素 removeLast() 移除列表最后一个元素 pop()/push() 移除或添加列表第一个元素 indexOf() 判断目标元素是否存在 isEmpty() 判断是否为空列表 Set接口Set接口中元素无序，允许有null值，并且会以某种规则保证存入的元素不出现重复。HashSet不是线程安全对，若多个线程同时修改HashSet，其结果并不能保证安全的。 HashSet HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 创建HashSet 1234567891011public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"cba\"); //遍历 for (String name : set) &#123; System.out.println(name); &#125; &#125;&#125; 常用方法 HashSet的常用方法此处不会仔细描述，常用到的方法：add,remove,clear,contains,size LinkedHashSet 我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(\"bbb\"); set.add(\"aaa\"); set.add(\"abc\"); set.add(\"bbc\"); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;结果：bbbaaaabcbbc Map接口collection接口的Map接口的共性方法： 12345map.put(key,value):在末尾添加一组键值对map.get(key):通过指定的key值获取相应的value值map.containerKey(key):查询某个Key是否存在map.containerValue(value):查询某个value是否存在map.size():获取Map中键值对的元素个数 HashMap 前面已经讲解了List接口下的ArrayList类，接下来我们开始了解Map接口的HashMap类（Map&lt;K, V&gt;是一种键-值映射表，Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。） 创建HashMap类 123456789101112// Map&lt;键Key的引用数据类型, 值Value的引用数据类型&gt; map = new HashMap&lt;&gt;();Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();// 遍历输出 key 和 valuefor (Integer i : Sites.keySet()) &#123; System.out.println(\"key: \" + i + \" value: \" + Sites.get(i));&#125;// 遍历返回所有 value 值for(String value: Sites.values()) &#123; // 输出每一个value System.out.print(value + \", \");&#125; 常用方法 方法 描述 put(k, v) 添加键值对 get(k) 获取key对应的value remove(key) 删除key对应的键值对 clear() 清空map size() 获取map大小 关于HashMap的小结： 对Map来说，要遍历key可以使用for-each循环遍历Map实例的keySet()方法返回的Set集合，它包含不重复的key的集合 同时遍历key和value可以使用for-each循环遍历Map对象的entrySet()集合，它包含每一个key-value映射 Iterator迭代器接口collection接口下有各种各样的集合，不同的集合存储方式不同，相应的集合取值方式也不同，这时就需要Iterator迭代器接口了。我们要始终坚持使用迭代器Iterator来访问List。Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。 Iterator对象有两个方法：boolean hasNext()判断是否有下一个元素，E next()返回下一个元素。因此，使用Iterator遍历List代码如下： 123456789public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\"); for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125; 童鞋可能觉得使用Iterator访问List的代码比使用索引更复杂。但是，要记住，通过Iterator遍历List永远是最高效的方式。并且，由于Iterator遍历是如此常用，所以，Java的for each循环本身就可以帮我们使用Iterator遍历 12345678public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\"); for (String s : list) &#123; System.out.println(s); &#125; &#125;&#125; 6.日期与时间类我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API： 定义在java.util这个包里面，主要包括Date、Calendar和TimeZone这几个类(这里面有很多方法已经过时，废弃了，会报出warning)； 新的API是在Java 8引入的，定义在java.time这个包里面，主要包括LocalDateTime、ZonedDateTime、ZoneId等（推荐使用这个API） Date类Date类目前已经过时废弃了很多方法，仅推荐getTime()方法:把日期对象转换成对应的时间毫秒值 123Date date = new Date();// 1586141801899(十三位数，毫秒级，与js的时间戳相同)System.out.println(date.getTime()); CalendarCalendar可以用于获取并设置年、月、日、时、分、秒，它和Date比，主要多了一个可以做简单的日期和时间运算的功能 概念 日历我们都见过,java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式 Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法 根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法 get方法用来获取指定字段的值，代码使用演示： 12345678910111213141516import java.util.Calendar;public class CalendarUtil &#123; public static void main(String[] args) &#123; // 创建Calendar对象 Calendar cal = Calendar.getInstance(); // 设置年 int year = cal.get(Calendar.YEAR); // 设置月 int month = cal.get(Calendar.MONTH) + 1; // 设置日 int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年4月6日 &#125; &#125; set方法用来设置指定字段的值，代码使用演示： 123456789import java.util.Calendar;public class Demo07CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, 2020); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日 &#125;&#125; add方法 add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 123456789101112import java.util.Calendar;public class Demo08CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日 // 使用add方法 cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天 cal.add(Calendar.YEAR, -3); // 减3年 System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; &#125;&#125; getTime方法 Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910import java.util.Calendar;import java.util.Date;public class Demo09CalendarMethod &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); Date date = cal.getTime(); System.out.println(date); // Tue Jan 16 16:03:09 CST 2018 &#125;&#125; 小贴士：西方星期的开始为周日，中国为周一。在Calendar类中，月份的表示是以0-11代表1-12月。日期是有大小关系的，时间靠后，时间越大。 从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有： 本地日期和时间：LocalDateTime，LocalDate，LocalTime； 带时区的日期和时间：ZonedDateTime； 时刻：Instant； 时区：ZoneId，ZoneOffset； 时间间隔：Duration。 以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。 和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。 此外，新API修正了旧API不合理的常量设计： Month的范围用1~12表示1月到12月；Week的范围用1~7表示周一到周日。最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H/h 时 m 分 s 秒 format方法 format方法是将Date对象格式化为字符串 123456789101112131415import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; // 获取当前的日期对象 Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat(\"\"yyyy-MM-dd HH:mm:ss\"\"); String str = df.format(date); System.out.println(str); // 2020-04-06 10:23:54 &#125;&#125; parse方法 使用parse方法的代码为：把目标String转换成相应的Date对象 123456789101112import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd HH:mm:ss\"); String input = \"2015-11-11 22:18:18\" ; System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 参考文章 JAVA中的Random() 异常处理机制 File类的操作大全","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java(三)：流程控制","slug":"Java系列章节更新(三)","date":"2021-10-02T16:00:00.000Z","updated":"2022-01-04T06:23:54.032Z","comments":true,"path":"2021/10/03/Java系列章节更新(三)/","link":"","permalink":"https://ahrilove.top/2021/10/03/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%B8%89)/","excerpt":"本章内容： 1.if判断2.switch语句3.while循环4.do-while循环5.for循环与for-each循环6.break与continue","text":"本章内容： 1.if判断2.switch语句3.while循环4.do-while循环5.for循环与for-each循环6.break与continue 1.if判断if语句的基本语法是： 123456789if (条件) &#123; // 条件一满足时执行&#125;else if(条件) &#123; // 条件二满足时执行&#125;else&#123; // 条件不满足时执行&#125; 拓：浮点数相等判断。浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱 1234567891011public class Main &#123; public static void main(String[] args) &#123; double x = 1 - 9.0 / 10; // 利用Math的绝对值之差 if (Math.abs(x - 0.1) &lt; 0.00001) &#123; System.out.println(\"x is 0.1\"); &#125; else &#123; System.out.println(\"x is NOT 0.1\"); &#125; &#125;&#125; 2.switch语句1234567891011121314switch (option) &#123; case 3: ... break; case 2: ... break; case 1: ... break; default: ... break;&#125; 3.while循环while循环在每次循环开始前，首先判断条件是否成立。如果计算结果为true，就把循环体内的语句执行一遍，如果计算结果为false，那就直接跳到while循环的末尾，继续往下执行。 1234567891011public class Main &#123; public static void main(String[] args) &#123; int sum = 0; // 累加的和，初始化为0 int n = 1; while (n &lt;= 100) &#123; // 循环条件是n &lt;= 100 sum = sum + n; // 把n累加到sum中 n ++; // n自身加1 &#125; System.out.println(sum); // 5050 &#125;&#125; while循环是先判断循环条件，再循环，因此，有可能一次循环都不做。 4.do…while循环在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是： 123do &#123; 执行循环语句&#125; while (条件表达式); 可见，do while循环会至少循环一次。 5.for循环12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; int sum = 0; for (int i=0; i&lt;ns.length; i++) &#123; System.out.println(\"i = \" + i + \", ns[i] = \" + ns[i]); sum = sum + ns[i]; &#125; System.out.println(\"sum = \" + sum); &#125;&#125;/*i = 0, ns[i] = 1i = 1, ns[i] = 4i = 2, ns[i] = 9i = 3, ns[i] = 16i = 4, ns[i] = 25sum = 55*/ for-each循环本质上为增强for循环：用来遍历集合与数组，它是普通for循环语句的特殊简化版。但是，如果你希望使用数组的索引，那么增强版的 for 循环无法做到。 12345678910格式：for(集合/数组的数据类型 变量名：集合名/数组名)&#123; 执行语句&#125;int[] arrayDemo = &#123;1, 2, 4, 7, 9, 192, 100&#125;;for(int x: arrayDemo)&#123; System.out.print(x + &quot;, &quot;);&#125;// 结果为：1, 2, 4, 7, 9, 192, 100 6.break与continuebreak：会跳出整个循环，也就是整个循环都不会执行了。存在多层循环时，会直接退出至最外层循环。continue：提前结束本次循环，直接继续执行下次循环。存在多层循环时，只会提前结束本次循环所在的循环体。","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（二）：数据类型","slug":"Java系列章节更新(二)","date":"2021-10-01T16:00:00.000Z","updated":"2022-01-05T06:40:04.036Z","comments":true,"path":"2021/10/02/Java系列章节更新(二)/","link":"","permalink":"https://ahrilove.top/2021/10/02/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%BA%8C)/","excerpt":"本章内容： 1.数据类型分类2.基本数据类型3.字符串String4.数组Array","text":"本章内容： 1.数据类型分类2.基本数据类型3.字符串String4.数组Array 1.数据类型在Java中，变量分为两种：基本类型的变量和引用类型的变量 基本数据类型（基本数据类型是CPU可以直接进行运算的类型）： 整数类型：byte、short、int(默认)、long 浮点数类型：float、double(默认) 字符类型：char 布尔类型：true、false(默认) 引用数据类型： 类：class 数组：Array 字符串：String 接口：Interface 注意点： char类型使用单引号&#39;，且仅有一个字符，要和双引号&quot;的字符串类型区分开 float类型有效数字最长为7位，有效数字长度包括了整数部分和小数部分，float的后缀要加F/f，标志着它是float类型 double类型有效数字最长为15位，与 float 类型一样，double 后面也带有标志“D”或“d” 不带任何标志的浮点型数据，系统默认是 double 类型 一个值要能被真正看作 float，它必须以 f（或 F）后缓结束；否则，会被当作double值。对double值来说，d（或D）后缀是可选的 2.基本数据类型Java语言内置了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 对字符型的说明字符类型：字符char是基本数据类型，一个char保存一个Unicode字符 12char c1 = &apos;A&apos;;char c2 = &apos;中&apos;; 要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可： 12int n1 = &apos;A&apos;; // 字母“A”的Unicodde编码是65int n2 = &apos;中&apos;; // 汉字“中”的Unicode编码是20013 字符串类型：和char类型不同，字符串类型String是引用类型，常常使用双引号包裹起来 1234String s = &quot;&quot;; // 空字符串，包含0个字符String s1 = &quot;A&quot;; // 包含一个字符String s2 = &quot;ABC&quot;; // 包含3个字符String s3 = &quot;中文 ABC&quot;; // 包含6个字符，其中有一个空格 数据类型转换 自动类型转换 当满足这两种条件时，将会执行自动转换： 两种数据类型彼此兼容 目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据） 在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。转换规则如下： 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int。 强制类型转换 所以当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换，会造成精度丢失。其语法格式如下： (type)variableName 在强制类型转换中，如果是将浮点类型的值转换为整数，直接去掉小数点后边的所有数字；而如果是整数类型强制转换为浮点类型时，将在小数点后面补零。 不同数据类型之间计算规则：不同的数据类型运算，从前往后计算，如果是整型，正常的10进制计算，遇到字符转成10进制的ascii码值计算，一旦遇到字符串就直接拼接字符，后面都默认为字符串，就没必要转化 3.字符串String在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用”…”来表示一个字符串。 创建字符串 12345创建字符串最简单方式：String str = &quot;Badwoman&quot;;通过类的方式创建：String str = new String(&quot;Badwoman&quot;); 注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了 字符串相关方法 字符串比较：比较字符串的内容是否相同。必须使用equals()方法而不能用== str1.equals(str2):判断两个字符串的是否相同,如果两个字符串具有相同的字符、长度和大小写，它返回true，否则返回false str1.equalsIgnoreCase(str2):与equals用法相同，但不区分大小写 str1.compareTo(str2):用于按字典顺序比较两个字符串的大小（基于各个字符的Unicode值），如果按字典顺序str1位于str2参数之前，比较结果为一个负整数；如果str1位于str2之后，比较结果为一个正整数；如果两个字符串相等，则结果为0 字符索引查找字符串.indexOf(“目标字符或字符串”)：返回指定字符在字符串中第一次出现的索引，如果此字符串中没有这样的字符，则返回 -1 判断以什么开头结尾字符串.startsWith(“目标字符串”):判断是否以目标字符串开头字符串.endsWith(“目标字符串”):判断是否以目标字符串结尾 字符串的截取字符串.substring(起始索引，结束索引)：截取目标字符串，索引从0开始，左闭右开 去掉首尾空白字符字符串.trim()字符串.strip():也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除(基于Java11+) 替换字符串 字符串.replace(a,b):返回一个新字符串，用字符b替换所有的字符a，全局替换 字符串.replaceFirst(a,b):返回一个新字符串，用字符b替换第一个子字符串字符a 字符串.replaceAll(a,b):返回一个新字符串，用字符b替换所有的字符a，全局替换 拼接字符串拼接字符串使用静态方法String.join,它用指定的字符串连接字符串数组 12String arr = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; 字符串大小写str.toLowerCase()：将字符串转换为小写str.toUpperCase()：将字符串转换为大写 判断字符串是否为空str.isEmpty() 检测字符串是否匹配给定的正则表达式str.matches(String regex) 1234567891011public class Test &#123; public static void main(String args[]) &#123; String Str = new String(&quot;www.runoob.com&quot;); System.out.println(Str.matches(&quot;(.*)runoob(.*)&quot;)); // true System.out.println(Str.matches(&quot;(.*)google(.*)&quot;)); // false System.out.println(Str.matches(&quot;www(.*)&quot;)); // true &#125;&#125; 基本类型与字符串类型之间的相互转换要把任意基本类型或引用类型转换为字符串，可以使用静态方法String.valueOf() 1234String.valueOf(123); // &quot;123&quot;String.valueOf(45.67); // &quot;45.67&quot;String.valueOf(true); // &quot;true&quot;String.valueOf(new Object()); // 类似java.lang.Object@636be97c 是否包含子字符串字符串.contains(“目标字符串”)：返回结果true 或者 false 分割字符串按指定字符（串）或正则去分割某个字符串，结果以字符串数组形式返回，记住：返回结果是数组，数组无法直接打印 语法：str.split(String sign) 或 str.split(String sign,int limit) str为需要分割的目标字符串。 sign为指定的分割符，可以是任意字符串。 limit表示分割后生成的字符串的限制个数，如果不指定，则表示不限制，直到将整个目标字符串完全分割为止。 123String s = \"hello world java!!!\";String[] aa = s.split(\" \");System.out.println(aa[2]); 返回字符串长度字符串.length()：无论是字母、数字、还是汉字，每个字符的长度都为一 charAt()返回指定索引处的char值 转换为字符串 .toString()将目标数据类型转换为字符串 4.数组Array 声明数组变量 首先必须声明数组变量，才能在程序中使用数组，下面是声明数组变量的语法： 123dataType[] arrayRefVar; // 首选的方法或dataType arrayRefVar[]; // 效果相同，但不是首选方法 创建一维数组 12345678910111213public class Main &#123; public static void main(String[] args) &#123; // 数组的创建方式一 int[] grades = new int[3]; grades[0] = 98; grades[1] = 96; grades[2] = 99; // 数组的创建方式二 int[] grades = &#123;98, 96, 99&#125;; System.out.println(Arrays.toString(grades)); // 直接打印数组 &#125;&#125; 创建二维数组 创建语法： 123type[][] arrayName = new type[][]&#123;值 1,值 2,值 3,…,值 n&#125;; // 在定义时初始化type[][] arrayName = new type[size1][size2]; // 给定空间，在赋值type[][] arrayName = new type[size][]; // 数组第二维长度为空，可变化 Java的数组有几个特点： 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。 可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;。 可以用数组变量.length 获取数组大小 几点说明： 上面讲的是静态数组。静态数组一旦被声明，它的容量就固定了，不容改变。所以在声明数组时，一定要考虑数组的最大容量，防止容量不够的现象。 如果想在运行程序时改变容量，就需要用到数组列表(ArrayList，也称动态数组)或向量(Vector)。 正是由于静态数组容量固定的缺点，实际开发中使用频率不高，被 ArrayList 或 Vector 代替，因为实际开发中经常需要向数组中添加或删除元素，而它的容量不好预估。 Arrays工具类（了解） Arrays类是一个工具类，其中包含了数组操作的很多方法。这个Arrays类里均为static修饰的方法（static 修饰的方法可以直接通过类名调用），可以直接通过 Arrays.xxx的形式调用方法 Arrays.equals(arrayA, arrayB)：数组相等的条件不仅要求数组元素的个数必须相等，而且要求对应位置的元素也相等 Arrays.fill(array,value)：用同一种目标元素填充满数组，填充多个会被覆盖掉 Arrays.toString(array)：Java中数组无法直接被打印出来，需要转换成字符串 参考文章 python的列表List与python的数组的区别：","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（一）：程序基础","slug":"Java系列章节更新(一)","date":"2021-09-30T16:00:00.000Z","updated":"2022-01-07T06:50:22.802Z","comments":true,"path":"2021/10/01/Java系列章节更新(一)/","link":"","permalink":"https://ahrilove.top/2021/10/01/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%B8%80)/","excerpt":"Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 1.Java基础结构2.命名规范与注释3.常量4.变量5.访问修饰符6.运算符","text":"Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 1.Java基础结构2.命名规范与注释3.常量4.变量5.访问修饰符6.运算符 1.Java基础结构123456// 类名与Java文件名相同public class Hello &#123; public static void main(String[] args) &#123; // 方法名是main，main方法表示为入口文件 // 方法代码... &#125; // 方法定义结束&#125; PS：我们注意到public除了可以修饰class外，也可以修饰方法。而关键字static是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 2.命名规范与注释命名规则：包含数字，字母，下划线与$符号（不能以数字开头；不能为关键字）命名规范：类名（大驼峰原则），方法名与变量名（小驼峰原则） ① 包名: 多单词组成时所有字母都小写:xxxyyyzzz② 类名、接口名: 多单词组成时，所有单词的首字母大写:XxxYyyZzz③ 变量名、方法名: 多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写: xxxYyyZzz④ 常量名:所有字母都大写。多单词时每个单词用下划线连接:XXX_YYY_zzz 补充：【python的命名规范】 单行注释：\\\\多行注释：\\* content *\\从Java 13开始，字符串可以用&quot;&quot;&quot;...&quot;&quot;&quot;表示多行字符串（Text Blocks） 3.常量常量是指在程序的整个运行过程中值保持不变的量。在这里要注意常量和常量值是不同的概念，常量值是常量的具体和直观的表现形式，常量是形式化的表现。通常在程序中既可以直接使用常量值，也可以使用常量。 下面我们来系统地认识一下 Java 中的常量值，以及定义常量的方法 常量值 整型常量值 Java 的整型常量值主要有如下3种形式： 二进制数形式：0b101、0b1001 十进制数形式：如 54、-67、0 八进制数形式：表示以0开头，如 0125 表示十进制数 85，-013 表示十进制数 -11。 十六进制数形式：表示以0x或0X开头，如 0x100表示十进制数256，-0x16表示十进制数-22。 整型（int）常量 默认在内存中占 32 位，是具有整数类型的值，当运算过程中所需值超过 32 位长度时，可以把它表示为长整型（long）数值。长整型类型则要在数字后面加 L 或 l， 如 697L，表示一个长整型数，它在内存中占 64 位。 实型常量值 Java 的实型常量值主要有如下两种形式： 十进制数形式：由数字和小数点组成，且必须有小数点，如 12.34、-98.0。 科学记数法形式：如 1.75e5 或 32&amp;E3，其中 e 或 E 之前必须有数字，且 e 或 E 之后的数字必须为整数。 布尔型常量值 Java 的布尔型常量只有两个值，即 false（假）和 true（真）。 字符型和字符串常量值 Java 的字符型常量值是用单引号引起来的一个字符，如 ‘e’、E’。需要注意的是，Java 字符串常量值中的单引号和双引号不可混用。双引号用来表示字符串，像 “11”、”d” 等都是表示单个字符的字符串。 定义常量 常量不同于常量值，它可以在程序中用符号来代替常量值使用，因此在使用前必须先定义，即在声明常量的同时要赋予一个初始值。 定义常量(通常大写)的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。 注意： 变量可重新赋值，等号是赋值语句，不是数学意义的等号。 常量在初始化后不可重新赋值，使用常量便于理解程序意图。 Java 语言使用 final 关键字来定义一个常量（常量有三种类型：静态常量、成员常量和局部常量。），其语法：final dataType variableName = value 12345678910public class HelloWorld &#123; // 静态常量 public static final double PI = 3.14; // 声明成员常量 final int y = 10; public static void main(String[] args) &#123; // 声明局部常量 final double x = 3.3; &#125;&#125; 4.变量变量声明和赋值Java 语言是强类型（Strongly Typed）语言，强类型包含以下两方面的含义： 所有的变量必须先声明、后使用。 指定类型的变量只能接受类型与之匹配的值 基本语法：DataType identifier=value; 或者 DataType identifier; 初始化变量是指为变量指定一个明确的初始值。初始化变量有两种方式：一种是声明时直接赋值，一种是先声明、后赋值另外，多个同类型的变量可以同时定义或者初始化，但是多个变量中间要使用逗号分隔，声明结束时用分号分隔 12345678910char usersex='女'; // 直接赋值String username; // 先声明username =\"琪琪\"; // 后赋值String username,address,phone,tel; // 同时声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量int a1 = 1, a2 = 2, a3 = 2; // 同时初始化多个变量System.out.println(a1 + a2 + a3); 变量作用域变量的作用域规定了变量所能使用的范围，只有在作用域范围内变量才能被使用。根据变量声明地点的不同，变量的作用域也不同。 根据作用域的不同，一般将变量分为不同的类型：成员变量和局部变量 成员变量 Java 的成员变量有两种，分别是全局变量(实例变量)和静态变量（类变量）。定义在方法体和语句块之外，不属于任何一个方法，作用域是整个类。 名称 修饰 访问 生命周期 全局变量（实例变量） 无 static 修饰 对象名.变量名 只要对象被当作引用，实例变量就将存在 静态变量（类变量） 用 static 修饰 类名.变量名或对象名.变量名 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 12345678910111213141516171819202122package bytedance.com;public class BasicTest &#123; public static void main(String[] args) &#123; // 创建类的对象 DataClass dc = new DataClass(); // 对象名.变量名调用实例变量（全局变量） System.out.println(dc.name); System.out.println(dc.age); // 类名.变量名调用静态变量（类变量） System.out.println(DataClass.website); System.out.println(DataClass.URL); &#125;&#125; class DataClass &#123; String name; // 成员变量、实例变量 int age; // 成员变量、实例变量 static final String website = \"C语言中文网\"; // 成员变量、静态变量(类变量) static String URL = \"http://c.biancheng.net\"; // 成员变量、静态变量(类变量)&#125; 静态变量与实例变量的区别如下： 1）静态变量 运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。 在类的内部，可以在任何方法内直接访问静态变量。 在其他类中，可以通过类名访问该类中的静态变量。 2）实例变量 每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。 在类的内部，可以在非静态方法中直接访问实例变量。 在本类的静态方法或其他类中则需要通过类的实例对象进行访问。 局部变量 局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种： 方法参数变量（形参）：在整个方法内有效 方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效 代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效 方法局部变量 1234567891011public class Test2 &#123; public static void main(String[] args) &#123; int a = 7; if (5 &gt; 3) &#123; int s = 3; // 声明一个 int 类型的局部变量 System.out.println(\"s=\" + s); System.out.println(\"a=\" + a); &#125; System.out.println(\"a=\" + a); &#125;&#125; 方法参数变量 12345678public class Test3 &#123; public static void testFun(int n) &#123; System.out.println(\"n=\" + n); &#125; public static void main(String[] args) &#123; testFun(3); &#125;&#125; 代码块局部变量 代码块局部变量常用于try-catch代码块中，成为异常处理参数变量。 异常处理参数变量的作用域是在异常处理块中，该变量是将异常处理参数传递给异常处理块，与方法参数变量类似 123456789101112public class Test4 &#123; public static void test() &#123; try &#123; System.out.println(\"Hello!Exception!\"); &#125; catch (Exception e) &#123; // 异常处理块，参数为 Exception 类型 e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; test(); &#125;&#125; 5.访问修饰符 作用域 本类 本包范围内 子孙类（只代表其他包中的子孙类） 其他包 public 可以 可以 可以 可以 protected 可以 可以 可以 不可以 default 可以 可以 不可以 不可以 private 可以 不可以 不可以 不可以 同一package可以理解为在同一个村庄 public 可以理解为无论是否在一个村，谁都可以访问 protected 可以理解为，只有自己一个村的邻居和子女，以及远嫁出去的子女可以访问 default 可以理解为，只有自己同村的可以范围，如果子女和自己是同村，也可以使用。如果子女远嫁出去，不在自己的村庄了，很抱歉，远水解不了近渴，远亲不如近邻。 private 可以理解为，私有财产不可侵犯，有些事情，除了自己，绝不能让其他人访问，例如银行密码。 6.运算符 数学运算符 加减乘除：+ - * /取余：%自增，自建：++ -- 123456int a = 12;System.out.println(-a); // 12int b = a++;System.out.println(b); // 12b = ++a;System.out.println(b); // 14 上述代码第 2 行是 -a，是把 a 变量取反，结果输出是 -12。第 4 行代码是先把 a 赋值给 b 变量再加一，即先赋值后++，因此输出结果是 12。第 6 行代码是把 a 加一，然后把 a 赋值给 b 变量，即先 ++ 后赋值，因此输出结果是 14。 关系运算符 运算符 说明 举例 &gt; 大于 a &gt; 4.2 &gt;= 大于等于 3.4 &gt;= b &lt; 小于 1.5 &lt; 9 &lt;= 小于等于 6 &lt;= 1 == 等于 2 == 2 != 不等于 2 != 2 位运算符 运算符 说明 举例 &amp; 与 1 &amp; 4 ｜ 或 2 ｜ 5 ^ 异或 2 ^ 3 ~ 非 ~5 &lt;&lt; 左移 5 &lt;&lt; 3 &gt;&gt; 右移 6 &gt;&gt; 1 逻辑运算符 运算符 说明 举例 &amp;&amp; 与 true &amp;&amp; false ｜｜ 或 (3 &gt; 1) ｜｜ (2 == 1) ! 非 !true 条件运算符 condition ? x1 : x2condition为一个boolean值，根据condition，取x1或x2的值 参考文章 java中不同数据类型的运算","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"docker基础和常见问题解决方案","slug":"docker容器虚拟技术(Ⅳ)","date":"2021-07-22T16:00:00.000Z","updated":"2021-08-25T05:59:24.000Z","comments":true,"path":"2021/07/23/docker容器虚拟技术(Ⅳ)/","link":"","permalink":"https://ahrilove.top/2021/07/23/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF(%E2%85%A3)/","excerpt":"1.docker基础知识2.docker环境变量配置问题","text":"1.docker基础知识2.docker环境变量配置问题 1.docker基础知识 Docker的三个概念： Image(镜像) Container(容器) Repository(仓库) Image： 可以看做一个特殊的文件系统除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变 Container： 容器 (container) 的定义和镜像 (image) 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层 Repository： Docker 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务。Docker Registry (仓库注册服务器)就是这样的服务。有时候会把仓库 (Repository) 和仓库注册服务器 (Registry) 混为一谈，并不严格区分。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。 ps：通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签 常用的cmd指令 1234567891011121314151617181920212223242526docker search 镜像名 搜索镜像docker pull 镜像名:版本号(版本号即tags)docker images 查看镜像docker info 集群概览信息docker info | grep Node 查看节点个数docker info | grep Memory查看各个机器内存使用情况docker ps 查看正在运行的容器docker ps -a 列出所有状态的容器docker inspect 容器id Node：宿主机的信息 env:启动参数环境变量docker exec -ti 容器iddocker restart|stop|start 容器iddocker events 事件查看docker export/loaddocker logsdocker network维护网络节点docker network lsdocker network ls | grep overlaydocker network inspect vlan1142 查看此vlan下各个容器网络信息docker rm 删除容器docker rm -f 强制删除docker rmi 删除镜像docker tag 给镜像打tagdocker top 显示进程docker volume 将容器的文件和目录挂载到宿主机上 2.docker环境变量配置问题当我们安装【dockers for desktop】时，会默认安装到C盘，并需要用户设置系统环境变量（以Windows为例） 找到docker.exe的文件目录，系统环境变量Path新增一行 C:\\Program Files\\Docker\\Docker\\resources 若没有的话，则会报错：在win10中安装完Docker for Windows Installer.exe，打开cmd命令行编辑器，运行“docker –version”，显示“不是内部或外部命令，也不是可运行的程序 或批处理文件”。使用PowerShell更出现“无法将“docker”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，”等信息 找到com.docker.cli.exe的文件目录，系统环境变量Path新增一行 C:\\Program Files\\Docker\\Docker\\resources\\bin 若没有的话，则会报错：exec: “com.docker.cli”: executable file not found in %PATH% ，需要在系统环境变量加上docker的bin路径就行了","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"计算机基础","slug":"计算机基础与算法(二)","date":"2021-07-16T16:00:00.000Z","updated":"2021-08-28T05:47:04.000Z","comments":true,"path":"2021/07/17/计算机基础与算法(二)/","link":"","permalink":"https://ahrilove.top/2021/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%AE%97%E6%B3%95(%E4%BA%8C)/","excerpt":"1.端口占用","text":"1.端口占用 1.端口占用开发时经常遇到端口被占用的情况，这个时候我们就需要找出被占用端口的程序，然后结束它。 windows 1234567891011121314# 端口占用解决方案# 查找所有运行的端口netstat -ano# 查看被占用端口(8080)对应的PID(进程ID)netstat -ano|findstr &quot;8080&quot;# 查看指定PID的进程tasklist|findstr &quot;9088&quot;# 结束进程# 强制（/F参数）杀死 pid 为 9088 的所有进程包括子进程（/T参数）taskkill /T /F /PID 9088 linux 12345678910# 端口占用解决方案# 查看端口的使用情况netstat -tln | grep 8880# 查看端口被那个进程占用 lsof -i :8880# 结束进程sudo kill -9 PID","categories":[{"name":"计算机基础与算法","slug":"计算机基础与算法","permalink":"https://ahrilove.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"时间与空间复杂度","slug":"计算机基础与算法(一)","date":"2021-04-22T16:00:00.000Z","updated":"2021-08-28T05:43:12.000Z","comments":true,"path":"2021/04/23/计算机基础与算法(一)/","link":"","permalink":"https://ahrilove.top/2021/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%AE%97%E6%B3%95(%E4%B8%80)/","excerpt":"算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别 1.基本初等函数2.时间复杂度3.空间复杂度","text":"算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别 1.基本初等函数2.时间复杂度3.空间复杂度 1.基本初等函数学习算法前，我们也必须回顾之前的数学知识，算法会涉及到基本初等函数的增量对比 幂函数、指数函数、对数函数、三角函数、反三角函数。初等函数指由基本初等函数经过有限次的四则运算与有限次的函数复合步骤所构成，并可用一个数学式子表示的函数。 衡量不同算法之间的优劣呢？主要还是从算法所占用的「时间」和「空间」两个维度去考量。 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。 2.时间复杂度T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度可以浅显地理解为循环体中的循环执行次数 常见的时间复杂度量级有： 常数阶O(1) 对数阶O(logN) 线性阶O(n) 线性对数阶O(nlogN) 平方阶O(n²) 立方阶O(n³) K次方阶O(n^k) 指数阶(2^n)上面从上至下依次的时间复杂度越来越大，执行的效率越来越低 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 线性阶O(n) 12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。 对数阶O(logN) 12345int i = 1;while(i&lt;n)&#123; i = i * 2;&#125; 从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn) 线性对数阶O(nlogN) 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。 12345678for(m=1; m&lt;n; m++)&#123; i = 1; while(i&lt;n) &#123; i = i * 2; &#125;&#125; 平方阶O(n²) 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。举例： 12345678for(x=1; i&lt;=n; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125; 这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的n改成m，即： 12345678let m = 6, n=6;for(let x=1; x&lt;=m; x++)&#123; for(let i=1; i&lt;=n; i++) &#123; console.log(\"当前的行列式为：[\"+x+\",\"+i+\"]\"); &#125;&#125; 那它的时间复杂度就变成了 O(m*n) 3.空间复杂度既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。 空间复杂度比较常用的有：O(1)、O(n)、O(n²)","categories":[{"name":"计算机基础与算法","slug":"计算机基础与算法","permalink":"https://ahrilove.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"复杂度","slug":"复杂度","permalink":"https://ahrilove.top/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Redis主从复制","slug":"Redis系列章节更新(三)","date":"2021-04-16T16:00:00.000Z","updated":"2021-04-17T06:58:24.000Z","comments":true,"path":"2021/04/17/Redis系列章节更新(三)/","link":"","permalink":"https://ahrilove.top/2021/04/17/Redis%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%B8%89)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主数据库可以进行读写操作，当写操作导致数据发生变化时会自动将数据同步给从数据库。而一般情况下，从数据库是只读的，并接收主数据库同步过来的数据。 一个主数据库可以有多个从数据库。 1.Redis主从复制原理2.Redis复制同步原理3.Redis哨兵模式4.Redis的雪崩、穿透、击穿","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主数据库可以进行读写操作，当写操作导致数据发生变化时会自动将数据同步给从数据库。而一般情况下，从数据库是只读的，并接收主数据库同步过来的数据。 一个主数据库可以有多个从数据库。 1.Redis主从复制原理2.Redis复制同步原理3.Redis哨兵模式4.Redis的雪崩、穿透、击穿 1.Redis主从复制原理 配从(库)不配主(库)：即每新创建一个redis服务时，默认都是master主机 从机设置方式: slaveof 主库IP 主库端口 主写从读、读写分离：从机是无法进行写操作的，会出现错误提示 主断从待命：主机宕机后，从机保持不变，原地待命；主机宕机恢复后，一切恢复正常，从机自动连接主机，恢复主从复制 从断重新连：从机宕机后，主机的replication的从机连接数减一，其余从机保持不变；从机恢复后，与主机，其余从机都没有任意关系，形如一台新创建的redis服务，需要使用slaveof 主库IP 主库端口，重新设置主从关系 从机上位：当主机宕机且恢复时间很久时，若需要将从机升级为主机： Ⅰ. 主从关系切断指令 slaveof no one Ⅱ. 其余从机不需要一个个都切断与已宕机主机的主从关系，只需要将目标从机切断主从关系，它就会自动升级为主机，接下来把其余的从机使用slaveof 目标从机的ip 目标从机的端口指令，就会自动建立其余从机与目标从机的主从关系 拓展：从机宕机后，从机跟master断开联系，必须重新设置主从关系，除非写进配置文件 一台主机配多台从机，一台从机再配多台从机，从而实现了庞大的集群架构。同时也减轻了一台主机的压力，缺点是增加了服务器间的延迟 2.Redis复制同步原理 全量复制 slave启动成功连接到master后会发送一个sync命令；Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步；slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。只要是重新连接master,一次完全同步（全量复制)将被自动执行 增量复制 Master将新的所有收集到的修改命令依次传给slave,完成同步 3.Redis哨兵模式 哨兵模式原理 从机上位的自动版。Redis提供了哨兵的命令，哨兵命令是一个独立的进程，哨兵通过发送命令，来监控主从服务器的运行状态，如果检测到master故障了根据投票数自动将某一个slave转换master，然后通过消息订阅模式通知其它slave，让它们切换主机。然而，一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多哨兵进行监控 哨兵模式搭建 创建 redis_sentinel.conf 文件 12345sentinel monitor dc-redis 127.0.0.1 6379 1- 127.0.0.1 指定监控主机的ip地址- 6379 指定监控主机的端口号- 1 得到哨兵的投票数(当哨兵投票数大于或者等于此数时切换主从关系) 新开窗口，启动哨兵：redis-sentinel redis_sentinel.conf 小结： 查看主从复制关系命令：info replication 设置主从关系命令：slaveof 主机ip 主机port 开启哨兵模式命令：./redis-sentinel sentinel.conf 主从复制原则：开始是全量复制，之后是增量复制 哨兵模式三大任务：监控，提醒，自动故障迁移 切断主从关系：slaveof no one Redis的主从复制最大的缺点就是延迟，主机负责写，从机负责备份，这个过程有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，从机器数量的增加也会使这个问题更加严重 4.Redis的雪崩、穿透、击穿 缓存雪崩 含义：在同一时间段，大量的key失效，导致请求全部打到数据库，有可能搞垮数据库，使整个服务瘫痪。 使缓存集中失效的原因： 1、redis服务器挂掉了。 2、对缓存数据设置了相同的过期时间，导致某时间段内缓存集中失效。 如何解决缓存集中失效： 1、针对原因1，可以实现redis的高可用，Redis Cluster 或者 Redis Sentinel(哨兵) 等方案。 2、针对原因2，设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期。 缓存穿透 指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库，一般是指恶意攻击者 解决方案： 1、对于像ID为负数的非法请求直接过滤掉，采用布隆过滤器(Bloom Filter)。 2、针对在数据库中找不到记录的，我们仍然将该空数据存入缓存中，当然一般会设置一个较短的过期时间。 3、接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id &lt;=0的直接拦截 缓存击穿 表示某个key的缓存非常热门，有很高的并发一直在访问，如果该缓存失效，那同时会走数据库，压垮数据库 缓存击穿与缓存雪崩的区别是这里针对的是某一热门key缓存，而雪崩针对的是大量缓存的集中失效。 解决方案： 1、让该热门key的缓存永不过期。 2、使用互斥锁，通过redis的setnx实现互斥锁","categories":[{"name":"Redis","slug":"Redis","permalink":"https://ahrilove.top/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://ahrilove.top/tags/Redis/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Redis配置","slug":"Redis系列章节更新(二)","date":"2021-04-09T16:00:00.000Z","updated":"2021-04-17T02:13:16.000Z","comments":true,"path":"2021/04/10/Redis系列章节更新(二)/","link":"","permalink":"https://ahrilove.top/2021/04/10/Redis%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%BA%8C)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Redis的使用过程，除了知道对Redis五种数据类型的操作方法之外，最主要额就是对redis.conf进行配置了,下面整理出redis.conf中常见的一些配置介绍。 1.Redis默认配置2.基本数据类型3.redis的事务4.redis的订阅与发布","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Redis的使用过程，除了知道对Redis五种数据类型的操作方法之外，最主要额就是对redis.conf进行配置了,下面整理出redis.conf中常见的一些配置介绍。 1.Redis默认配置2.基本数据类型3.redis的事务4.redis的订阅与发布 1.Redis默认配置解读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114redis默认配置解读:1: Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no 2: 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid 3: 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 4: 绑定的主机地址 bind 127.0.0.1 5: 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 6: 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose 7: 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout 8: 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 16 9: 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 10: 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes 11: 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb 12: 指定本地数据库存放目录 dir ./ 13: 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt; 14: 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt; 15: 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared 16: 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 128 17: 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt; 18: 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no 19: 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof 20: 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 21: 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no 22: 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap 23: 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 24: Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 25: 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 26: 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 27: 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes 28: 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 29: 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes 30: 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf 2. Redis配置文件 redis.conf存放位置 Redis的安装根目录下(linux：/opt/redis-5.0.2)，Redis在启动时会加载这个配置文件，在运行时按照配置进行工作。 这个文件有时候我们会拿出来，单独存放在某一个位置，启动的时候必须明确指定使用哪个配置文件，此文件才会生效 redis的网络相关配置 bind:绑定IP地址，参考Redis 配置文件中bind参数 p: 端口配置，默认为6379 tcp-keepalive：TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。如果设置为0，则不会进行保活检测 Redis的常规配置 loglevel：日志级别，开发阶段可以设置成debug，生产阶段通常设置为notice或者warning logfile：指定日志文件名，如果不指定，Redis只进行标准输出。要保证日志文件所在的目录必须存在，文件可以不存在。还要在redis启动时指定所使用的配置文件，否则配置不起作用 databases：配置Redis数据库的个数，默认是16个 Redis的安全配置 requirepass：配置Redis的访问密码。默认不配置密码，即访问不需要密码验证。此配置项需要在protected-mode=yes时起作用。使用密码登录客户端：redis-cli -h ip -p 6379 -a pwd Redis的持久化策略 redis提供持久化策略，在适当的时机采用适当手段把内存中的数据持久化到磁盘中，每次redis服务启动时，都可以把磁盘上的数据再次加载内存中使用 RDB策略 在指定时间间隔内，redis服务执行指定次数的写操作，会自动触发一次持久化操作。RDB策略是redis默认的持久化策略，redis服务开启时这种持久化策略就已经默认开启了。 1234567save &lt;seconds&gt; &lt;changes&gt;Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改 AOF策略 采用操作日志来记录进行每一次写操作，每次redis服务启动时，都会重新执行一遍操作日志中的指令。效率低下，redis默认不开启AOF功能 小结：RDB策略不可避免的会遗漏一部分数据，而AOF策略是为了弥补RDB策略，它是根据日志文件的写操作来实现持久化策略的，即会一直往日志文件中写入，因此效率低下，但其数据相对安全。根据数据的特点来决定开启哪种持久化策略。 Redis 需要手动开启AOF持久化方式，AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。 关于Redis持久化的使用：若只打算用Redis 做缓存，可以关闭持久化。若打算使用Redis 的持久化，建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。 AOF与RDB模式可以同时启用，这并不冲突。如果AOF是可用的，那Redis启动时将自动加载AOF，这个文件能够提供更好的持久性保障。 3.redis的事务事务：把一组数据库命令放在一起执行，保证操作原子性，要么同时成功，要么同时失败。Redis的事务：允许把一组redis命令放在一起，把命令进行序列化，然后一起执行，保证部分原子性。 redis的事务常用的命令： multi：用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列，开启成功返回OK 123multiset k1 v1set k2 v2 exec：用来执行事务队列中所有的命令,即 redis的事务只能保证部分原子性： 如果一组命令中，在压入事务队列过程中发生错误的命令，则本事务中所有的命令都不执行，能够保证事务的原子性。 12345multiset k3 v3seta kk vv (不存在seta命令，事务直接不执行)set k4 v4exec 如果一组命令中，在压入队列过程中正常，但是在执行事务队列命令时发生了错误，则只会影响发生错误的命令，不会影响其它命令的执行，不能够保证事务的原子性。 12345multiset k3 v3incr k3set k4 v4exec discard：清除所有已经压入队列中的命令，并且结束整个事务，之后不需要使用exec命令 1234multiset k5 v5 set k6 v6discard watch：监控某一个键，当事务在执行过程中，此键代码的值发生变化，则本事务放弃执行；否则，正常执行。 当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的。如果被监控的key值在本事务外有修改时，则本事务所有指令都不会被执行。Watch命令相当于关系型数据库中的乐观锁 1234567891011121314id balance versionupdate table set balance=balance-dept,version=version+1where id=xxxx and version=100set balance 100set balance2 1000set version 1watch versionmultidecrby balance 50incrby balance2 50exec unwatch：清除所有先前为一个事务监控的键。如果在watch命令之后你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令 123456watch versionunwachmultidecrby balance 50incrby balance2 50exec 4.redis的订阅与发布redis的消息订阅不专门学习，目前在市面上比较主流的消息队列中间件主要有，Kafka、ActiveMQ、RabbitMQ、RocketMQ 等这几种","categories":[{"name":"Redis","slug":"Redis","permalink":"https://ahrilove.top/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://ahrilove.top/tags/Redis/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"vue-cli的开发生产打包部署","slug":"Vue(六)","date":"2021-03-23T16:00:00.000Z","updated":"2021-08-28T06:05:56.000Z","comments":true,"path":"2021/03/24/Vue(六)/","link":"","permalink":"https://ahrilove.top/2021/03/24/Vue(%E5%85%AD)/","excerpt":"1.引入第三方js，css文件2.前后分离的环境部署☆☆☆","text":"1.引入第三方js，css文件2.前后分离的环境部署☆☆☆ 1.引入第三方js，css文件vue-cli不同于之前的单页面的vue，它更倾向于一个项目快速开发，受约束的地方很多，没有以前在HTML页面中引入vue.js自定义开发那般灵活。 全局引用js，css文件 index.html是主页面，直接在index.html中引入,此时所有的组件中都会加载引用的第三方文件注意：这时就会存在一个问题，假如有些组件不会使用jQuery，但也会加载出来，十分消耗性能 js 1&lt;script type=\"text/javascript\" src=\"./static/mui.min.js\" &gt;&lt;/script&gt; css 1&lt;link rel=\"stylesheet\" href=\"static/mui.min.css\" /&gt; 局部组件引用js，css文件:在单页面中用import方法导入,只在当前组件内有效（记得要加scoped） css文件 123456&lt;style scoped&gt; @import \"../assets/css/DPlayer.min.css\"; h3&#123; text-align: center; &#125;&lt;/style&gt; js文件 某些第三方的js库会导出一些对象或方法给其它js调用执行，比如(DPlayer的DPlayer对象，clipboard里的ClipboardJS对象)，只有导出后才能使用，否则会报错对象不存在的错误 12import DPlayer from &quot;../assets/js/DPlayer.min.js&quot;;import ClipboardJS from &apos;../assets/js/clipboard.min.js&apos; 在入口文件mian.js中引入css 123456789101112131415import 'static/css/main.css'import Vue from 'vue'import './plugins/axios'import App from './App.vue'import router from './router'import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.config.productionTip = false;Vue.use(ElementUI);new Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount('#app') 这样就可以直接使用了 2.前后分离的环境部署前后分离概念 Django： Web框架，框架的作用在于处理request和 response，提供api，其他的不是框架所关心的内容。 Vue: 前端框架。 Nginx: Web代理服务器。处理静态文件的发送。动态请求则交予uWSGI处理。 uWSGI: 一个基于自有的uwsgi协议、WSGI协议和http协议的web网关。处理动态请求，将处理的结果回发给Nginx。 关于vue项目部署必需要考虑如下问题： 路由模式:hash(default),history api接口是否会有跨域问题 这里技术选型为history，必须详细看懂开发与生产环境部署 本地开发环境 router目录下的index.js 当为本地开发环境时，需要注释掉base 12345const router = new VueRouter(&#123; routes, mode: 'history', // history表示去掉锚点，默认mode : 'hash' // base: process.env.BASE_URL,&#125;) vue.config.js文件（处理路由与跨域问题） 123456789101112131415161718192021222324252627282930module.exports = &#123; /** * 开发环境路由设置 */ publicPath: '/', // 这个是在测试路由为‘history’时，动态参数匹配params模式时才会使用 devServer: &#123; // port: 8000, // 配置开发环境运行端口号 // 配置代理，解决跨域请求后台数据的问题 proxy: &#123; '/migus':&#123; target: 'https://m.music.migu.cn/', // target host ws: true, // proxy websockets changeOrigin: true, // needed for virtual hosted sites pathRewrite: &#123; '^/migus': '' // rewrite path &#125; &#125;, '/tophub':&#123; target: 'https://www.tophub.fun:8888/', ws: true, changeOrigin: true, pathRewrite: &#123; '^/tophub': '' &#125; &#125; &#125; &#125;&#125; 当为本地开发环境时：publicPath必须为 / 123module.exports = &#123; publicPath: '/', // 这个是在测试路由为‘history’时，动态参数匹配params模式时才会使用&#125; 开发环境的跨域问题利用devServer的Proxy可以轻松解决。比如此时的/migus代理，其原api假如是：https://m.music.migu.cn/v1/api/comment ,设置代理后，axios访问api时，便是 migus/v1/api/comment 生产环境部署 开启router目录下的index.js的base属性 12345const router = new VueRouter(&#123; routes, mode: 'history', // history表示去掉锚点，默认mode : 'hash' base: process.env.BASE_URL&#125;) 开启vue.config.js里的publicPath 1234567/** * 生产环境打包设置 */publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/test/&apos; : &apos;/&apos;,outputDir: &apos;dist/test&apos;,assetsDir: &apos;static&apos;,productionSourceMap: false, // 关闭map文件 为什么这里使用 /test/，而不是使用之前的 ./ 这是因为我们设置的路由关系.我们的路由有多级目录，比如 /tools/json 二级目录 /nmsl/hidden/source 三级目录 打包好了的文件保存路径为：dist/test目录（包含js，css，html等），注意：此时的二级目录打包的test，在nginx中也会涉及到 解决生产环境下的跨域问题 生产环境的访问api处理与本地开发同理。比如此时的/migus代理，其原api假如是：https://m.music.migu.cn/v1/api/comment ,设置代理后，axios访问api时，便是 migus/v1/api/comment 不同的是：生产环境的跨域处理是在nginx中设置反向代理的。 nginx的生产环境设置：nginx.conf 123456789location /migus &#123; rewrite ^/migus/(.*)$ /$1 break; proxy_pass https://m.music.migu.cn/;&#125;location /tophub &#123; rewrite ^/tophub/(.*)$ /$1 break; proxy_pass https://www.tophub.fun:8888/;&#125; 进入到 /usr/local/nginx/sbin目录下，测试配置文件是否正确 项目打包性能优化参考文章 完整打包部署实例 vue.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990let webpack = require(&apos;webpack&apos;);// 是否为生产环境const isProduction = process.env.NODE_ENV !== &apos;development&apos;;// gzip压缩const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;)module.exports = &#123; /** * 生产环境打包设置 */ // publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/test/&apos; : &apos;/&apos;, // outputDir: &apos;dist/test&apos;, // assetsDir: &apos;static&apos;, // productionSourceMap: false, // 关闭map文件 /** * 开发环境路由设置 */ publicPath: &apos;/&apos;, // 这个是在测试路由为‘history’时，动态参数匹配params模式时才会使用 // 开发环境跨域处理 devServer: &#123; // port: 8000, // 配置开发环境运行端口号 // //配置代理，解决跨域请求后台数据的问题 proxy: &#123; &apos;/migus&apos;:&#123; target: &apos;https://m.music.migu.cn/&apos;, // target host ws: true, // proxy websockets changeOrigin: true, // needed for virtual hosted sites pathRewrite: &#123; &apos;^/migus&apos;: &apos;&apos; // rewrite path &#125; &#125;, &apos;/tophub&apos;:&#123; target: &apos;https://www.tophub.fun:8888/&apos;, ws: true, changeOrigin: true, pathRewrite: &#123; &apos;^/tophub&apos;: &apos;&apos; &#125; &#125; &#125; &#125;, // gzip压缩 configureWebpack: config =&gt; &#123; // 生产环境相关配置 if (isProduction) &#123; //gzip压缩 const productionGzipExtensions = [&apos;html&apos;, &apos;js&apos;, &apos;css&apos;] config.plugins.push( new CompressionWebpackPlugin(&#123; filename: &apos;[path].gz[query]&apos;, algorithm: &apos;gzip&apos;, test: new RegExp( &apos;\\\\.(&apos; + productionGzipExtensions.join(&apos;|&apos;) + &apos;)$&apos; ), threshold: 10240, // 只有大小大于该值的资源会被处理 10240 minRatio: 0.8, // 只有压缩率小于这个值的资源才会被处理 deleteOriginalAssets: false // 删除原文件 &#125;) ) &#125; &#125;, chainWebpack: config =&gt; &#123; config.plugin(&apos;provide&apos;).use(webpack.ProvidePlugin, [&#123; $: &apos;jquery&apos;, jquery: &apos;jquery&apos;, jQuery: &apos;jquery&apos;, &apos;window.jQuery&apos;: &apos;jquery&apos; &#125;]) // ============压缩图片 start============ config.module .rule(&apos;images&apos;) .use(&apos;image-webpack-loader&apos;) .loader(&apos;image-webpack-loader&apos;) .options(&#123; bypassOnDebug: true &#125;) .end() // ============压缩图片 end============ &#125;, configureWebpack:&#123; externals: &#123; &apos;vue&apos;: &apos;Vue&apos;, &apos;element-ui&apos;: &apos;ELEMENT&apos;, &apos;axios&apos;: &apos;axios&apos;, &#125; &#125;&#125; nginx.conf 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576user root;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; proxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=imgcache:100m inactive=1d max_size=1g; # 开启gzip gzip on; # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩 gzip_min_length 1k; # gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明 gzip_comp_level 2; # 进行压缩的文件类型。javascript有多种形式，后面的图片压缩不需要的可以自行删除 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; # 是否在http header中添加Vary: Accept-Encoding，建议开启 gzip_vary on; # 设置压缩所需要的缓冲区大小 gzip_buffers 4 16k; # 虚拟主机1，用于找到vue页面 server &#123; listen 80; server_name 127.0.0.1; location / &#123; root /data/wwwroot/front/; index index.html index.htm; # 这一条参数确保vue页面刷新时候，不会出现404页面（注意这里的/test/） try_files $uri $uri/ /test/index.html; &#125; # 处理生产环境的跨域问题 location /migus &#123; rewrite ^/migus/(.*)$ /$1 break; proxy_pass https://m.music.migu.cn/; &#125; location /tophub &#123; rewrite ^/tophub/(.*)$ /$1 break; proxy_pass https://www.tophub.fun:8888/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; # 虚拟主机2，用于反向代理，找到django server &#123; listen 8000; # 向外映射的端口，通过此8000端口，其它电脑可访问Django的api接口：http:主机ip:8000/api接口 server_name 127.0.0.1; location / &#123; uwsgi_pass 101.37.152.63:8080; include /usr/local/nginx/conf/uwsgi_params; &#125; &#125;&#125; ps：101.37.152.63:8080为Django的运行ip（不过我使用的是云服务器0.0.0.0:8080） 参考文章 vue-cli项目前后分离开发生产环境部署","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/categories/Vue/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://ahrilove.top/tags/vue-cli/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Redis基础","slug":"Redis系列章节更新(一)","date":"2021-03-03T16:00:00.000Z","updated":"2021-08-28T05:58:50.000Z","comments":true,"path":"2021/03/04/Redis系列章节更新(一)/","link":"","permalink":"https://ahrilove.top/2021/03/04/Redis%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E4%B8%80)/","excerpt":"REmote DIctionary Server(Redis) 是一个key-value存储系统，是跨平台的非关系型数据库 1.Redis命令2.基本数据类型","text":"REmote DIctionary Server(Redis) 是一个key-value存储系统，是跨平台的非关系型数据库 1.Redis命令2.基本数据类型 1.Redis命令Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。 Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型 Redis服务（Redis服务端-Linux端）启动： redis-server 前台启动，即以命令行模式启动 redis-server &amp; 后台启动，即以守护进程模式启动 redis-server redis.conf &amp; :根据配置文件启动,如果修改了redis的配置文件redis.conf，必须在启动时指定配置文件，否则修改无效！ ps -ef|grep redis 在Linux下查看redis成功启动下的进程ID 客户端启动基本命令 终端并输入命令 redis-cli，该命令会连接本地的 redis 服务。执行 PING 命令，该命令用于检测 redis 服务是否启动 script12345$ redis-cliredis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG 远程服务上执行命令 script1redis-cli -h host -p port -a password Redis时候会有中文乱码,要在 redis-cli 后面加上 –raw script1redis-cli --raw Redis认证 当我们的redis设置密码后，再次登陆后我们需要输入密码 script1auth &lt;password&gt; 获取信息 获取信息的指令为info,可在后面接多种关键词 script1234567891011121314151617# 获取所有信息info# 获取服务端信息info server# 获取内存信息info memory# 获取主从信息info Replication# 获取当前连接数info clients# 查看redis最大连接数config get maxclients 数据库的切换 Select 命令用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值,不能超过15，因为总共只有16个数据库 script12345678# 选择目标实例select index# 清空当前连接的数据库(慎用)flushdb# 清空所有数据库（慎用）flushall 查询当前连接数据库键总数 dbsize Client List 用于返回所有连接到服务器的客户端信息和统计数据 Config config实现对redis服务器的配置文件相关操作 1234config [GET, SET, RESETSTAT, REWRITE] parameter# 查看所有的配置参数config get * Time 一个包含两个字符串的列表： 第一个字符串是当前时间(秒级)，而第二个字符串是当前这一秒钟已经逝去的微秒数。 redis查看版本号 1234567# 查看服务端版本redis-server -v redis-server --version# 查看客户端版本redis-cli -v redis-cli --version 关闭redis服务 12345# 关闭redis默认配置下的服务redis-cli shutdown# 经由redis-cli客户端来关闭redis服务端redis-cli -h ip -p port -a password shutdown 2.基本全局指令 命令 描述 del key 删除目标key（被删除成功，命令执行后输出(int)1，否则0） exists key 判断key是否存在 expire key seconds 为key设置过期时间，以秒计 keys pattern 查找所有符合给定模式( pattern)的key，(keys * 表示所有key) move key db 将当前数据库的 key 移动到给定的数据库 db 当中 persist key 移除key的过期时间，key将持久保持 pttl key 以毫秒为单位返回 key 的剩余的过期时间 ttl key 以秒为单位返回 key 的剩余的过期时间 randomkey 从当前数据库中随机返回一个 key rename key newkey 修改 key 的名称 type key 返回 key 所储存的值的类型 3.基本数据类型 类型 简介 特性 场景 String 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 String字符串下表列出常用的Redis字符串命令 命令 描述 SET key value 设置指定 key 的值 GET key 获取指定 key 的值 getrange key start end 字符串的截取，索引默认从0开始，满足闭区间 mget key1 [keyN] 获取所有(一个或多个)给定 key 的值 strlen key 返回字符串值的长度(不存在时返回0) mset key value [key value …] 同时设置一个或多个 key-value 对 Setex key seconds value 为指定的key设置值及其过期时间。若key存在，将会替换旧的值 Psetex key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间 incr key 将 key 中储存的数字值增一 incrby key increment 将 key 所储存的值加上自定义的增量值(increment) incrbyfloat key increment 将 key 所储存的值加上给定的浮点增量值 decr key 将key中储存的数字值减一 decrby key decrement key 所储存的值减去给定的减量值(decrement) append key value 如果key已经存在并且是一个字符串，将指定的value追加到该key原来值（value）的末尾,相当于字符串的拼接 ——————————————————————————————————————– Hash哈希Redis hash是一个string类型的field（字段）和value（值）的映射表，hash 特别适合用于存储对象。Redis 中每个 hash 可以存储 23^2 - 1 键值对（40多亿） 命令 描述 hdel key field1 [valueN] 删除一个或多个哈希表字段 hexists key field 查看哈希表key中，指定的字段是否存在 hget key field 获取存储在hash中指定字段的值 hgetall key 获取在哈希表中指定key的所有字段和值 hkeys key 获取存储在hash中指定字段的值 hincrby key filed increment 哈希表 key 中的指定字段的整数值加上增量 increment hincrbyfloat key filed increment 哈希表 key 中的指定字段的浮点值加上增量 increment hset key field 将哈希表key中的字段field的值设为value hmset key fieldN valueN 同时将多个 field-value (域-值)对设置到哈希表 key 中 hkeys key 获取所有哈希表中的字段 hlen key 获取哈希表中字段的数量 hmget key filed [fieldN] 获取所有给定字段的值 hvals key 获取hash所有的值 List列表Redis列表是简单的字符串列表，按照插入顺序排序，元素可以重复，可以从列表的头部或尾部插入数据 命令 描述 llen key 获取列表长度 lindex key index 通过索引获取列表元素，起始索引为0，也支持负索引，形如python rpush key val1，val2 将一个或多个值插入到列表的尾部，如果列表不存在，自动创建空列表 lpush key val1，val2 将一个或多个值插入到列表的头部，如果列表不存在，自动创建空列表 rpop key 移除列表的最后一个元素，并返回该元素 lpop key 移除列表的第一个元素，并返回该元素 Lrange key start end 列表截取，起始索引为0，为闭区间 blpop key timeout 移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 brpop key timeout 移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 Set集合Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 命令 描述 Scard key 获取集合中元素数量 Smembers key 获取集合中所有成员 Sadd key memberN 向集合中添加一个或多个元素 Sdiff key1 keyN 返回第一个集合中独有的元素，不存在则视为空集 Sinter key1 keyN 返回给定集合的交集 Sunion key1 keyN 返回给定集合的并集 Sdiffstore newKey key1 keyN 将给定集合之间的差集存储在指定的newKey集合中。如果指定的集合key已存在，则会被覆盖 Sinterstore newKey key1 keyN 将给定集合之间的交集存储在指定的newKey集合中。如果指定的集合key已存在，则会被覆盖 Sunionstore newKey key1 keyN 将给定集合之间的并集存储在指定的newKey集合中。如果指定的集合key已存在，则会被覆盖 Sorted-Set有序集合Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1) 命令 描述 Zcard key 获取有序集合中成员数 Zscore key member 获取指定成员的分数 Zadd key scoreN valueN 将一个或多个成员元素及其分数值加入到有序集合(分数值可以是整数值或双精度浮点数) Zcount key min max 计算有序集合中指定分数区间的成员数量 Zincrby key increment member 对有序集合中指定成员的分数加上增量increment Zrange key start stop [WITHSCORES] 返回有序集中，指定区间内的成员或与分数,起始索引为0，接受负索引，满足闭区间，升序 Zrevrange key start stop [WITHSCORES] 返回有序集中，指定区间内的成员或与分数,起始索引为0，接受负索引，满足闭区间，降序 Zrevrangebyscore key max min [WITHSCORES] 返回有序集中指定分数区间内的所有的成员，倒序 Zrangebyscore key min max [WITHSCORES] 返回有序集中指定分数区间内的所有的成员，升序 Zunionstore 计算给定的一个或多个有序集的并集，并存储在新的 key 中 拓展： Zunionstore详细使用说明 语法： 12Zunionstore destination numkeys key [keyN] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] destination:新有序集合 numkeys：表示参与计算的有序集合数目 key [keyN]：表示参与计算的有序集合 WEIGHTS：权重。要一一对应，一个权重对应一个有序集合，要使用权重乘以对应集合的分数score AGGREGATE：指定并集的结果集的聚合方式，默认为sum 简要描述：用权重乘以对应有序集合的分数，然后根据成员分类，同一类新的分数进行聚合函数处理","categories":[{"name":"Redis","slug":"Redis","permalink":"https://ahrilove.top/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://ahrilove.top/tags/Redis/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"vue-cli基础","slug":"Vue(五)","date":"2021-02-02T16:00:00.000Z","updated":"2021-08-30T11:06:12.000Z","comments":true,"path":"2021/02/03/Vue(五)/","link":"","permalink":"https://ahrilove.top/2021/02/03/Vue(%E4%BA%94)/","excerpt":"本章主要探究vue-cli的基础概念，vue-cli是vue官方提供的脚手架工具。脚手架工具简单讲就是自动将项目需要的环境、依赖等信息都配置好。 本文要点： 1.vue-cli的安装部署2.vue-cli补充点","text":"本章主要探究vue-cli的基础概念，vue-cli是vue官方提供的脚手架工具。脚手架工具简单讲就是自动将项目需要的环境、依赖等信息都配置好。 本文要点： 1.vue-cli的安装部署2.vue-cli补充点 1.vue-cli安装教程介绍Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统。有三个组件： CLI：@vue/cli 全局安装的 npm 包，提供了终端里的vue命令（如：vue create 、vue serve 、vue ui 等命令） CLI服务：@vue/cli-service是一个开发环境依赖。构建于 webpack 和 webpack-dev-server 之上（提供 如：serve、build 和 inspect 命令） CLI 插件：给Vue 项目提供可选功能的 npm 包 （如： Babel/TypeScript 转译、ESLint 集成、unit和 e2e测试 等） 安装 全局安装过旧版本的 vue-cli(1.x 或 2.x)要先卸载它，否则跳过此步： 1npm uninstall vue-cli -g //或者 yarn global remove vue-cli Vue CLI 3或4 的安装需要 nodeJs (推荐使用较新的版本) 123456789【命令行查看版本号】node -vnpm -v【升级npm（可选操作）】npm install -g npm【修改为淘宝镜像（可选操作）】npm config set registry &quot;https://registry.npm.taobao.org&quot; 安装@vue/cli（Vue CLI 3的包名称由 vue-cli 改成了 @vue/cli） 12npm install -g @vue/cli yarn global add @vue/cli 检查vue版本：vue -V npm安装时-S -D作用及区别 -S：即save（保存）包名会被注册在package.json的dependencies里面，在生产环境下这个包的依赖依然存在 -D：dev（生产）包名会被注册在package.json的devDependencies里面，仅在开发环境下存在的包用-D，如babel，sass-loader这些解析器 啥也不写：包名不会进入package.json里面，因此别人不知道你安装了这个包 但是npm install axios 也不存在后缀，经测试会在vue-cli安装在package.json的dependencies里面 12345node执行目标js文件1. 进入到目标文件路径2. 执行命令 node 文件名.jse.g,: C:\\Users\\CHD\\Desktop&gt;node hello.js 使用 vue create 搭建新项目 ↑/↓键表示移动，Space键表示选中 vue ui 图形化界面操作 2.vue-cli补充点 1.关于VUE.JS 使用axios数据请求时数据绑定时 报错 TypeError: Cannot set property ‘xxxx’ of undefined 的解决办法 data在里面做了定义 123456789&lt;script&gt;export default &#123; data()&#123; return &#123; info:&#123;name:\"\"&#125; &#125; &#125;&#125;&lt;/script&gt; 在方法里面进行赋值 用 this.info = repos.data 数据可以请求到，但是会报错 TypeError: Cannot set property ‘listgroup’ of undefined 主要原因是：在 then的内部不能使用Vue的实例化的this, 因为在内部 this 没有被绑定在then的内部，console.log(this)，输出undefined 解决办法: 在请求axios外面定义一下 let vm = this内部用：vm.info = response.data 2.Vue中使用v-for给img中的src属性赋值 在学习Vue的时候，使用v-for获取Vue data中的数据 123456&lt;!--img标签中src属性使用&#123;&#123;&#125;&#125;获取，报错。--&gt;&lt;div id=\"app\"&gt; &lt;div v-for=\"book in list\"&gt; &lt;img src=\"&#123;&#123;book.bookImg&#125;&#125;\"&gt; //并不会读取到 &lt;/div&gt;&lt;/div&gt; 错误之处在于：属性值数据绑定应该用v-bind，应该写成v-bind:src=””或者:src=”” 12345&lt;div id=\"app\"&gt; &lt;div v-for=\"book in list\"&gt; &lt;img v-bind:src=\"book.bookImg\"&gt; //ok &lt;/div&gt;&lt;/div&gt; 3.vue-cli引入assets下图片路径找不到问题: 123456&lt;img :src=&quot;imgsrc2&quot;&gt;export default&#123; data()&#123; imgsrc2: require(&apos;../assets/logo4.png&apos;) &#125;&#125; 4.vue如何获取并操作DOM元素 在之前，我们使用js操作DOM元素：直接给相应的元素加id,然后再document.getElementById(“id”);获取，然后设置相应属性或样式 但在vue中，要在mounted中使用，因为只有在执行mounted的时候，vue已经渲染了dom节点，这个时候是可以获取dom节点的，vue中尽量不去操作dom元素，选用ref操作属性获取 123&lt;button ref=&quot;btn&quot;&gt;获取ref&lt;/button&gt; this.$refs.btn.style.backgroundColor=&quot;#ff0000&quot; 此时再去调试时，又会出现大致意思是说不能设置属性背景颜色，因为它没有定义错误 $refs获取当前点击元素 分析：根据this.$refs.list.style.bottom = bottom可以知道本意是想获取子组件的DOM根元素，然后对这个元素的css属性bottom设置一个值，但是由于this.$refs.list只是获取到组件，并不能获取到子组件里面的DOM，这就是出错的原因 解决方法：通过$el选项获取到子组件的DOM，也就是改写成：this.$refs.list.$el.style.bottom = bottom，即this.$refs.list.$el可以获取到子组件的DOM $event.target 123456789101112131415161718191. 先设置函数&lt;button @click=&quot;getInfo($event)&quot;&gt;测试&lt;/button&gt;get_info:function(el)&#123; // 获取当前点击元素的属性值 // let a = parseInt(el.target.dataset.item); let a = parseInt(el.target.getAttribute(&quot;data-item&quot;)); let b = (this.chapter_arr[a][&quot;images_url&quot;]).split(&quot;&apos;&quot;); if(b.length&lt;=1)&#123; this.rows = JSON.parse(this.chapter_arr[a][&quot;images_url&quot;]); &#125;else&#123; let arr = []; for (let index = 1; index &lt; b.length; index+=2)&#123; // 由于数据库数据结构设置错误，导致无法使用json arr.push(b[index]); &#125; this.rows = arr; &#125;&#125; el.target.dataset 这种el.target.dataset获取自定义的属性值，比如设置的data-url值，而且设置自定义的属性值的规范写法必须是 data-XXXX， 获取自定义的属性值的规范写法必须是 el.target.dataset.XXXX 5.vue-cli的axios解决跨域问题 在主目录的vue.config.js文件中，写入如下内容： 123456789101112131415161718module.exports = &#123; // publicPath: './' // 编译时使用 publicPath: '/', // 这个是在测试路由为‘history’时，动态参数匹配params模式时才会使用 devServer: &#123; // port: 8000, // 配置开发环境运行端口号,不配置时，系统自动使用默认端口号 // proxy配置代理，解决跨域请求后台数据的问题 proxy: &#123; '/migu':&#123; target: 'https://m.music.migu.cn/', // target host ws: true, // proxy websockets changeOrigin: true, // needed for virtual hosted sites pathRewrite: &#123; '^/migu': '' // rewrite path &#125; &#125; &#125; &#125;&#125; 6.vue-cli中使用axios 安装其他插件的时候，可以直接在main.js中引入并 Vue.use()，但是 axios 并不能 use，为了解决这个问题，有三种开发思路 只能每个需要发送请求的组件中即时引入。e.g.,在Home.vue中需要使用axios，因此在Home组件中的script中引入“import axios from ‘axios’ ” 修改原型链 123* 首先在 main.js 中引入 axios ==&gt; import axios from &apos;axios&apos; 这时候如果在其它的组件中，是无法使用 axios 命令的* 所以我们将 axios 改写为 Vue 的原型属性 ==&gt; Vue.prototype.$http= axios* 然后再目标组件中使用 this.$http 来调用axios 结合 Vuex，封装一个action 参考文章 vue cli3.0快速搭建项目详解（强烈推荐） npm安装时-S -D作用及区别","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/categories/Vue/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://ahrilove.top/tags/vue-cli/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"PHP（二）：ThinkPHP","slug":"php(二)","date":"2020-12-06T16:00:00.000Z","updated":"2020-12-09T10:59:02.000Z","comments":true,"path":"2020/12/07/php(二)/","link":"","permalink":"https://ahrilove.top/2020/12/07/php(%E4%BA%8C)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言，同js一样是弱类型语言 1.常见问题","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言，同js一样是弱类型语言 1.常见问题 1. 常见问题 控制器方法骆驼写法，在使用小写下划线访问时不能自动转换？ 操作方法不能自动转换 只能你自己定义路由： eg：版本是5.1，控制器是UserDb，方法是helloWorld，通过user_db/hello_world访问,无法找到helloWorld方法，只能通过user_db/helloWorld方法访问","categories":[{"name":"PHP","slug":"PHP","permalink":"https://ahrilove.top/categories/PHP/"}],"tags":[{"name":"php","slug":"php","permalink":"https://ahrilove.top/tags/php/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"PHP（一）：基础知识","slug":"php(一)","date":"2020-12-03T16:00:00.000Z","updated":"2021-05-06T06:32:08.000Z","comments":true,"path":"2020/12/04/php(一)/","link":"","permalink":"https://ahrilove.top/2020/12/04/php(%E4%B8%80)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言，同js一样是弱类型语言 1.变量2.数据类型详解3.函数4.基本函数","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言，同js一样是弱类型语言 1.变量2.数据类型详解3.函数4.基本函数 1. 变量变量命名 变量以 $ 符号开始，后面跟着变量的名称 变量名必须以字母或者下划线字符开始，且只能包含字母数字字符以及下划线（A-z、0-9 和 _ ） 变量名不能包含空格，是区分大小写的（$y 和 $Y 是两个不同的变量） PHP的语句以 ; 结尾，不同于Python使用缩进，PHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来 基本数据类型 String（字符串） Integer（整型） Float（浮点型） Boolean（布尔型） Array（数组） Object（对象） NULL（空值） JS对象的创建与访问 1234567891011//方式一(通过内置构造函数创建后添加属性)let obj = &#123;&#125;;obj.name = 'Lucy'; //通过点添加属性obj['sex'] = 'female'; //通过[]添加属性//方式二(通过json格式直接创建添加属性)let objects = &#123;'name':'lily','sex':'female'&#125;;//js对象可通过'.'和'[]'访问属性console.log(obj.name);console.log(obj['name']); PHP对象的创建于访问 12345678910111213class Demo &#123; public $one = 1; protected $two = 2; private $three = 3; static $four = 4; public function showAllProperties() &#123; foreach ($this as $key=&gt;$value) &#123; echo \"&lt;br&gt;$key ：$value\"; //可输出所有非静态属性 &#125; &#125;&#125;$demo = new Demo();$demo-&gt;showAllProperties(); php运算符 比较运算符 松散比较：使用两个等号 == 比较，只比较值，不比较类型 严格比较：用三个等号 === 比较，除了比较值，也比较类型 逻辑运算符 逻辑与：and 或者 &amp;&amp; 逻辑或：or 或者 || 逻辑非： ！ 三元运算符：(expr1) ? (expr2) : (expr3) 赋值运算符 x = y x = y 左操作数被设置为右侧表达式的值 x += y x = x + y 加 x -= y x = x - y 减 x *= y x = x * y 乘 x /= y x = x / y 除 x %= y x = x % y 取余 a .= b a = a . b 连接两个字符串 2.数据类型详解字符串 并置运算符 (.) ：用于把两个字符串值连接,拼接起来 strlen($str) ：返回字符串的长度 strpos(字符串，查找目标值) 返回目标字符第一次出现的索引位置：如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。 trim(字符串，指定字符串) :移除字符串两侧的空白字符和其他字符 substr_count(字符串，目标字符串)：查找目标字符在字符串中的出现次数 strtoupper()/strtolower() ：大小写转化 str_replace(字符一，字符二，字符串)：表示用字符二替换字符一，并且不会改变原字符串 更多字符内置函数 数组在 PHP 中，有三种类型的数组： 数值数组:带有数字 ID 键的数组 关联数组:带有指定的键的数组，每个键关联一个值 多维数组:包含一个或多个数组的数组 PHP的基本数组内建函数：https://www.runoob.com/php/php-ref-array.html 数值数组 数值数组创建方式： 123456方式一：$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);方式二：$cars[0]=&quot;Volvo&quot;;$cars[1]=&quot;BMW&quot;;$cars[2]=&quot;Toyota&quot;; 数组的长度：count($array) 关联数组：使用您分配给数组的指定的键的数组 12345678这里有两种创建关联数组的方法：$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);or:$age[&apos;Peter&apos;]=&quot;35&quot;;$age[&apos;Ben&apos;]=&quot;37&quot;;$age[&apos;Joe&apos;]=&quot;43&quot;; 遍历数组: 12345678910111213141516foreach(数组变量名 as 变量一 =&gt; 变量二)&#123; // 每次循环执行的语句 变量一代表当前正在访问的数据的索引值 变量二代表当前正在访问的数据value&#125;eg：$card = array( &quot;age&quot;=&gt;18, &quot;Steve&quot;=&gt;&quot;37&quot;, &quot;Elon&quot;=&gt;&quot;43&quot;, &quot;name&quot; =&gt; &quot;chd&quot; );foreach ($card as $index=&gt;$value)&#123; // php中的连接符号为&apos;.&apos;,也仅有这一种拼接符号，连&quot;+&quot;都不是连接符，会报错 echo $index.&quot; =&gt; &quot;.$value.&quot;&lt;br&gt;&quot;; &#125; PHP多维数组: array()数组中还存在数组array() 12345678910111213141516$cars = array( array(&quot;Volvo&quot;,22,18), array(&quot;BMW&quot;,15,13), array(&quot;Saab&quot;,5,2), array(&quot;Land Rover&quot;,17,15), &quot;cards&quot; =&gt;array( &quot;age&quot;=&gt;18, &quot;Steve&quot;=&gt;&quot;37&quot;, &quot;Elon&quot;=&gt;&quot;43&quot;, &quot;name&quot; =&gt; &quot;chd&quot;, &quot;gender&quot;=&gt;&quot;man&quot; ) );获取行数：count($cars)获取列数：count($cars[0])获取关联数组：$cars[&quot;cards&quot;] 3. 函数PHP 函数准则： 函数的名称应该提示出它的功能 函数名称以字母或下划线开头（不能以数字开头） 12345678创建 PHP 函数，函数是通过调用函数来执行的，语法：&lt;?php function functionName($var1,$var2,...)&#123; // 要执行的代码(若想使用全局变量，任然需要使用global关键字，才能使用) &#125;?&gt;//函数的调用$some = functionName(($var1,$var2,...) 4. 基本函数date()函数Date()函数：date(时间戳的格式，规定时间戳)更多date函数：https://www.runoob.com/php/php-date.html 1234567891011121314时间戳的格式： d - 表示月里的某天（01-31） m - 表示月（01-12） Y - 表示年（四位数） 1 - 表示周里的某天 h - 带有首位零的 12 小时小时格式 i - 带有首位零的分钟 s - 带有首位零的秒（00 -59） a - 小写的午前和午后（am 或 pm）其他字符，比如 &quot;/&quot;, &quot;.&quot; 或 &quot;-&quot; 也可被插入字符中，以增加其他格式。 $s_date = date(&apos;Y-m-d&apos;,strtotime(&apos;-6 days&apos;)); //表示在获取当前时间的基础上减去六天的时间，日期格式为Y-m-d $e_date = date(&apos;Y-m-d&apos;); // 表示获取当前的时间年月日 $e_date = date(&apos;Y-m-d H:i:s&apos;); // 表示获取当前具体的时间 $e_date = date(&apos;Y-m-d&apos;, strtotime (&quot;+1 day&quot;, strtotime(&apos;2017-11-11&apos;))); // 表示将某一个字符串时间转换为目标时间格式 json函数 json_encode 语法： json_encode(value, options) 对变量进行 JSON 编码（e.g., json.dumps），字符串化 参数 value: 要编码的值。该函数只对 UTF-8 编码的数据有效。 options:二进制掩码(JSON_UNESCAPED_UNICODE 选项，禁止中文被编码，形如ensure_ascii=False) 1234&lt;?php $arr = array(&apos;a&apos; =&gt; 1, &apos;b&apos; =&gt; 2, &apos;c&apos; =&gt; 3, &apos;d&apos; =&gt; 4, &apos;e&apos; =&gt; 5); echo json_encode($arr); // &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;?&gt; json_decode 语法：json_decode ($json_string ,$assoc = false , $depth , $options) 对 JSON 格式的字符串进行解码（e.g., json.loads），转换为 PHP 变量。还原化 参数 json_string: 待解码的 JSON 字符串，必须是 UTF-8 编码数据 assoc: 当该参数为 TRUE 时，将返回数组，FALSE 时返回对象。 depth: 整数类型的参数，它指定递归深度 options: 二进制掩码，目前只支持 JSON_BIGINT_AS_STRING 。 12345678910111213141516171819202122&lt;?php $json = &apos;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&apos;; var_dump(json_decode($json)); var_dump(json_decode($json, true));?&gt;执行结果object(stdClass)#1 (5) &#123; [&quot;a&quot;] =&gt; int(1) [&quot;b&quot;] =&gt; int(2) [&quot;c&quot;] =&gt; int(3) [&quot;d&quot;] =&gt; int(4) [&quot;e&quot;] =&gt; int(5)&#125;array(5) &#123; [&quot;a&quot;] =&gt; int(1) [&quot;b&quot;] =&gt; int(2) [&quot;c&quot;] =&gt; int(3) [&quot;d&quot;] =&gt; int(4) [&quot;e&quot;] =&gt; int(5)&#125; json_last_error：返回最后发生的错误","categories":[{"name":"PHP","slug":"PHP","permalink":"https://ahrilove.top/categories/PHP/"}],"tags":[],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Linux（一）:基本命令","slug":"Linux(Ⅰ)","date":"2020-11-22T16:00:00.000Z","updated":"2021-07-30T08:53:54.000Z","comments":true,"path":"2020/11/23/Linux(Ⅰ)/","link":"","permalink":"https://ahrilove.top/2020/11/23/Linux(%E2%85%A0)/","excerpt":"与众不同的生活方式很累人呢，因为找不到借口 本文要点：1.Tmux会话终端2.linux查看端口占用3.linux系统中退出vim编辑器4.linux获取外网地址","text":"与众不同的生活方式很累人呢，因为找不到借口 本文要点：1.Tmux会话终端2.linux查看端口占用3.linux系统中退出vim编辑器4.linux获取外网地址 1. Tmux使用前言在日常开发中，我们可能需要同时打开好几个项目，这时我们就可以使用tmux建立对应的几个窗口，每个窗口对应不同的项目。同时，每个窗口可以划分了不同的窗格，一个窗格用于在编译目录下进行编译，一个窗格用于在生成执行文件的路劲下进行测试，一个窗格用于编辑代码，并且有些窗口有设置了不同的环境变量。但是一旦关机，tmux的这个会话就没有了。关闭ssh连接后，我们开启的运行程序也会随之强制关闭。 安装script12345678# Ubuntu 或 Debian$ sudo apt-get install tmux# CentOS 或 Fedora$ sudo yum install tmux# Mac$ brew install tmux 会话管理 tmux ls：查看当前所有的会话 tmux new -s ：新建会话 同时选中 Ctrl+b，释放后，按住 d键 ：从目标会话退出，回到shell主控制台 tmux kill-session：用于杀死某个会话 tmux attach：用于重新接入某个已存在的会话 script1234567891011# 使用会话编号$ tmux kill-session -t 0# 使用会话名称$ tmux kill-session -t &lt;session-name&gt;# 使用会话编号$ tmux attach -t 0# 使用会话名称$ tmux attach -t &lt;session-name&gt; ps：Ctrl+d 是强制退出，并删除会话,谨慎使用 2. linux查看端口占用 查找被占用的端口 netstat -tln：查看端口使用情况 netstat -tln | grep 8000：仅检查目标端口使用情况 查看端口属于哪个程序？端口被哪个进程占用 lsof -i: port ：安装 yum install lsof 123# 检查结果COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 20804 root 36u IPv6 35452317 0t0 TCP *:pcsync-https (LISTEN) 杀掉占用端口的进程 根据pid杀掉 kill -9 进程id 3. linux系统中退出vim编辑器 保存退出 按键盘左上角的“ESC”，左下角的插入状态不见了，然后这时，输入“冒号”，即:(不含双引号)，在下方会出现冒号，等待输入命令，输入wq 正常退出 正常退出有个前提条件是：打开的文本文件在内容上没有被改动过。按了ESC后再输入“冒号”，在输入命令时，直接输入“q”。 不保存退出 很多时候打开了文件或者修改了一些地方，才发现错了，需要不保存退出。先按ESC，再输入“冒号”，在输入命令时，直接输入“q!”。 强制退出 不太常用的操作，先按ESC，再按“冒号”，在输入命令时，直接输入“!”，退出后，会有提示！ 注意：Linux 命令都要小写！ 4.Linux获取外网地址目前获取ip的方法中，ifconfig和ipconfig获取函数得到的都是内网ip。有时候需要获取外网ip，目前通用的做法，是向外部服务器发送请求，解析外部服务器响应，从而得到的自己的外网ip。 script123456# linux 获取外网ip地址curl httpbin.org/ip#&#123;# \"origin\": \"***.***.***.63\"#&#125;","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ahrilove.top/tags/Linux/"}]},{"title":"关于如何养成Django女皇的那件事（Ⅴ）","slug":"Django系列章节更新（五）","date":"2020-08-27T16:00:00.000Z","updated":"2021-11-02T02:03:28.427Z","comments":true,"path":"2020/08/28/Django系列章节更新（五）/","link":"","permalink":"https://ahrilove.top/2020/08/28/Django%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.Django的缓存机制2.Django实现文件下载","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.Django的缓存机制2.Django实现文件下载 1.Django的缓存机制☆☆☆ 为什么我们需要缓存？ 对于现在的动态网站来讲，所有的界面展示都是通过客户端请求服务端，服务端再去请求数据库，然后将请求到的数据渲染后返回给客户端。用户每次访问页面都需要去请求数据库，如果同时有多个人访问的话，对于我们的数据库的压力是相当大的。 所以我们会想，对于不是经常变更的数据，或者不需要实时更新展示的数据，我们可以将数据存放在缓存中，用户下次需要数据的时候，服务端直接从缓存中拿到数据返回给用户即可，不需要每次都去数据库查询，这样会大大降低数据库的压力，提升用户访问速度。 Django的drf提供的缓存机制有两种解决方案： drf-extensions缓存 安装：pip install drf-extensions(目前不支持Django&gt;=3.1) drf-extensions组件内部提供了DRF的本地内存方式的缓存方式，本地内存方式缓存在项目重启后则会消失 使用装饰器方式@cache_response 要求：它适用于继承了rest_framework.views.APIView的类，且需要返回一个rest_framework.response.Response的实例 123456789from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framwork_extensions.cache.decorator import cache_responseclass GoodListView(APIView): @cache_response() def get(self, request, format=None): goods = Goods.objects.all()[:10] goods_serializer = GoodListSerializer1(goods, many=True) return Response(goods_serializer.data) 使用CacheResponseMixin 使用redis缓存（Django-redis） 安装redis 在配置缓存前要先安装好 Redis ,安装成功后，确定启动了 Redis 服务，在 cmd 命令行中输入 redis-cli 就能进入到 Redis 命令行。（前提要把 Redis 的安装目录配置到环境变量，在安装过程有添加环境变量的选项，勾上即可） 安装：pip install django-redis settings.py 文件中配置redis 12345678910CACHES = &#123; \"default\": &#123; \"BACKEND\": \"django_redis.cache.RedisCache\", \"LOCATION\": \"redis://127.0.0.1:6379\", \"OPTIONS\": &#123; \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", # \"PASSWORD\": \"password\" # 如果存在密码，需要设置密码 &#125; &#125;&#125; 依赖说明 drf-extensions的缓存方法是基于本地的, 如果在配置中配置了基于redis，则缓存方案自动切换为redis方案 2.Django实现文件下载 利用FileResponse功能实现 安装： from django.http import HttpResponse, FileResponse 参看CSDN文章~Django实现下载文件 利用StreamingHttpResponse原生功能实现 12345678910111213141516171819202122232425262728293031323334353637from django.http import HttpResponse, StreamingHttpResponsedef deal_zip(req): # 判断下载文件是否存在 file_path = \"static/images/workflow-吴爱平.zip\" if not os.path.isfile(file_path): return HttpResponse(\"Sorry but Not Found the File\") def file_iterator(file_path, chunk_size=512): \"\"\" 文件生成器,防止文件过大，导致内存溢出 :param file_path: 文件绝对路径 :param chunk_size: 块大小 :return: 生成器 \"\"\" with open(file_path, mode='rb') as f: while True: c = f.read(chunk_size) if c: yield c else: break try: # 设置响应头 # StreamingHttpResponse将文件内容进行流式传输，数据量大可以用这个方法（.pdf,.mp3,.mp4等等什么样格式的文件都可以下载） response = StreamingHttpResponse(file_iterator(file_path)) # 以流的形式下载文件,这样可以实现任意格式的文件下载 response['Content-Type'] = 'application/octet-stream' # Content-Disposition就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名 response['Content-Disposition'] = 'attachment;filename=&#123;file_name&#125;&#123;format&#125;'.format( file_name=\"workflow-吴爱平\", format=\".zip\") except Exception as e: return HttpResponse(\"Sorry but Not Found the File:\" + str(e)) # 在这里千万记得return,否则不会出现下载 return response 参考网站 DRF 配置 Redis 缓存 DRF缓存 Python操作Redis","categories":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/tags/Django/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"关于如何养成Django女皇的那件事（Ⅳ）","slug":"Django系列章节更新（四）","date":"2020-08-27T16:00:00.000Z","updated":"2021-02-18T02:34:48.000Z","comments":true,"path":"2020/08/28/Django系列章节更新（四）/","link":"","permalink":"https://ahrilove.top/2020/08/28/Django%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.为什么Django中无法像平常一样使用with open 读取静态文件2.Django实现下载文件功能3.django非前后分离实现从html页面表单获取输入的数据","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.为什么Django中无法像平常一样使用with open 读取静态文件2.Django实现下载文件功能3.django非前后分离实现从html页面表单获取输入的数据 1.为什么Django中无法像平常一样使用with open 读取静态文件☆☆☆ 一般情况下读取文件：使用with open来打开文件，读取完毕后会自动关闭。文件的相对路径与绝对路径的写法： . 表示文件的当前文件目录 .. 表示文件的上一级目录 在Django中读取静态文件完全不同，这是因为框架本身的设计，我们先复习一下之前Django存在多个APP时静态文件的配置 我们的项目有两个 app，分别是 myapp 和 userapp，这样我们的静态文件会分为三部分： 1231、公共部分（比如全站都会使用的css、jquery、背景图等）2、myapp 使用的静态文件3、userapp 使用的静态文件 在settings.py文件中 12345678910111213在 settings.py 中这样设置（三者必不可少）：STATIC_URL = &apos;/static/&apos;STATIC_ROOT = os.path.join(BASE_DIR, &apos;static&apos;)# 我们的静态文件分开三个部分# 这里我们设为三个路径STATICFILES_DIRS = [ # myproject为主项目的公共静态文件 os.path.join(BASE_DIR, &apos;myproject&apos;, &apos;static&apos;), # myapp下的专属静态文件 os.path.join(BASE_DIR, &apos;myapp&apos;, &apos;static&apos;), os.path.join(BASE_DIR, &apos;userapp&apos;, &apos;static&apos;),] 静态文件加载 注意到，每个 app 中的 static 文件夹内都在包含一个和 app 名称一样的文件夹，在该文件夹内在分别放置各自 css、js、image 等文件夹。 这样做的好处是在部署项目时，执行完 python manage.py collectstatic 命令之后,静态文件被收集到 STATIC_ROOT 之后依旧是根据 app 分开的：执行collectstatic命令后，最终把静态文件统一集中在主目录下的static文件夹下 PS: 静态文件加载时，都会先去static目录下寻找，如果不存在就继续向下一级，在各个APP的static目录下寻找，一直执行，直到找到为止。 所以我们使用with open访问静态文件就应该为：先访问主static文件，再去APP下寻找 12with open(&apos;static/loveword/js/encrypt.js&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: resource1 = f.read() 程序说明，middleware目录下的douyin_parse.py文件想要使用with open读取encrypt.js文件（正常逻辑说是将encrypt文件放在同一目录下，直接就可以读取，但，但是，经过很久的爬坑，发现始终无法读取，一直会报错），Django中只能使用先访问主static文件，再去APP下寻找的方法才能访问到静态文件 2.Django实现下载文件功能 urls.py 123urlpatterns = [ path(&apos;api/deal_zip&apos;, views.deal_zip),] views.py 1234567891011121314151617181920212223242526272829303132333435def deal_zip(req): # 判断下载文件是否存在 file_path = &quot;static/images/workflow.zip&quot; if not os.path.isfile(file_path): return HttpResponse(&quot;Sorry but Not Found the File&quot;) def file_iterator(file_path, chunk_size=512): &quot;&quot;&quot; 文件生成器,防止文件过大，导致内存溢出 :param file_path: 文件绝对路径 :param chunk_size: 块大小 :return: 生成器 &quot;&quot;&quot; with open(file_path, mode=&apos;rb&apos;) as f: while True: c = f.read(chunk_size) if c: yield c else: break try: # 设置响应头 # StreamingHttpResponse将文件内容进行流式传输，数据量大可以用这个方法（.pdf,.mp3,.mp4等等什么样格式的文件都可以下载） response = StreamingHttpResponse(file_iterator(file_path)) # 以流的形式下载文件,这样可以实现任意格式的文件下载 response[&apos;Content-Type&apos;] = &apos;application/octet-stream&apos; # Content-Disposition就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名 response[&apos;Content-Disposition&apos;] = &apos;attachment;filename=&#123;file_name&#125;&#123;format&#125;&apos;.format( file_name=&quot;workflow&quot;, format=&quot;.zip&quot;) except Exception as e: return HttpResponse(&quot;Sorry but Not Found the File:&quot; + str(e)) # 在这里千万记得return,否则不会出现下载 return response 具体如何实现：用户点击 “下载” 按钮后，就开始下载？ 实现起来很简单，用一个a标签，href属性值为Django的url路径，点击a标签后，就会自动下载 1&lt;h3&gt;&lt;span&gt;下载地址：&lt;/span&gt;&lt;a href=\"/api/deal_zip\"&gt;&lt;button&gt;下载&lt;/button&gt;&lt;/a&gt;&lt;/h3&gt; 3.django非前后分离实现从html页面表单获取输入的数据参考网址： https://blog.csdn.net/weixin_43424969/article/details/84377955 4.django-rest-framework解析请求参数过程详解 request.POST request.GET request.data request.method request.path(表示提交请求页面完整地址的字符串， 不包括域名，如 “/api/music”) request.body（是byte类型，需要使用decode解码成字符串） request.META(包含了所有本次HTTP请求的Header信息)","categories":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/tags/Django/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"关于如何养成Django女皇的那件事（Ⅲ）","slug":"Django系列章节更新（三）","date":"2020-07-31T16:00:00.000Z","updated":"2020-10-20T01:48:58.000Z","comments":true,"path":"2020/08/01/Django系列章节更新（三）/","link":"","permalink":"https://ahrilove.top/2020/08/01/Django%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.API频率限制2.models模型中的过滤器详解3.APPEND_SLASH路由设置4.drf的三大认证（认证，权限，频率）","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.API频率限制2.models模型中的过滤器详解3.APPEND_SLASH路由设置4.drf的三大认证（认证，权限，频率） 1.API频率限制当我们使用api时，为了应对一些爬虫，往往会对api接口访问频率进行限制，官方文档 官方是给出两种方法：用户自定义访问频率，官方给定的访问频率 通用访问频率:drf框架下的throttle在主settings.py中设置访问频率，但通用访问频率一旦设置，每一个使用官方其配置的api接口都必须遵守这个通用访问频率 throttle配置到settings.py中 123456789101112# REST_FRAMEWORK配置文件REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle' ), 'DEFAULT_THROTTLE_RATES': &#123; 'anon': '3/minute', # 未认证用户每分钟访问次数 'user': '10/minute', # 认证用户每分钟访问次数 'limit': '5/minute' # 自定义的访问频率 &#125;&#125; The rate descriptions used in DEFAULT_THROTTLE_RATES may include second, minute, hour or day as the throttle period. 限制规则与限速的类。未登录情况下限速，通过IP地址；登录情况下通过session或token来判断 设置到视图views.py中的接口 1234567891011121314from rest_framework.response import Responsefrom rest_framework.throttling import UserRateThrottle, AnonRateThrottlefrom rest_framework.views import APIViewclass ExampleView(APIView): # throttle_classes = [UserRateThrottle] # 限制登录用户的访问频率 throttle_classes = [AnonRateThrottle] # 限制匿名用户访问频率 # throttle_classes = [] # 空列表表示不限制任何用户的访问频率 def get(self, request, format=None): content = &#123; 'status': 'request was permitted' &#125; return Response(content) 2.models模型中的过滤器详解官方文档：QuerySet API reference 查询集：表示从数据库获取的对象集合，查询集可以有多个过滤器，过滤器就是一个函数（方法），基于所给参数限制查询集结果从sql角度来说，查询集和select等价，过滤器和where等价. 查询集特点： 惰性执行：创建查询集不会带来任何的数据访问，直到调用数据（要用滴时候）时，才会访问数据 直接访问数据的情况（直接向数据库拿）：迭代/序列化/与if合用 返回查询集的方法称为过滤器 我们很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作。 在Django API中，我们可以使用filter() 方法对数据进行过滤，类似于SQL中的where查询条件 返回一堆数据集的过滤器 方法 说明 .all() 返回查询集中的所有的对象（形如Publisher.objects.all()） .filter() 返回符合条件的数据集，相当于where .order_by() 排序 .row(sql) 执行原生查询 .values() 返回查询集中具体的字段名，（Category.objects.all().values(‘id’, ‘name’) 就表示返回Category表的id，name字段） PS：关于对.values()的说明：values()并不是像sql里的select field1,field2,…一样可以自由选择目标字段。它受制于序列化函数中的fields属性，values()中的目标字段必须是跟序列化中的fields字段完全相同，不能多，但也不能少。若values()的字段选择有多种，同理的serializers也要定义多种情况 12345serializers序列化中的fields表示要展示的字段，有两种写法：写法一： fields = &quot;__all__&quot;：表示全部展示Category模型里的所有字段写法二： fields = [&apos;id&apos;,&apos;name&apos;,...]：将想要展示的Category模型里的特定字段添加到数组中 返回单行数据的过滤器 方法 说明 .get() 返回一个满足条件的对象 .count() 返回当前查询集的对象个数 .first() 返回查询集的第一个对象 .last() 返回查询集的最后一个对象 .exists() 判断查询集中是否有数据，若有数据返回True 字段查询 概述：实现类sql中where语句，作为方法filter(),exclude(),get()的参数语法：属性名称__比较运算符 = 值外键：属性名_id 详细请查阅：https://www.cnblogs.com/vera-y/p/11918071.html 举例阐述：models.py模型自定义一个名为Publisher的类 1234# 传递单个参数到 filter() 来确定选取范围Publisher.objects.filter(name=&apos;Apress&apos;)# 传递多个参数到 filter() 来缩小选取范围Publisher.objects.filter(country=&quot;U.S.A.&quot;, state_province=&quot;CA&quot;) filter() 根据关键字参数来转换成 WHERE SQL语句。 前面这个例子 相当于这样： 123SELECT id, name, address, city, state_province, country, websiteFROM books_publisherWHERE name = 'Apress' 这样我们就可以明朗起来的，通过传递多个参数到filter()，来缩小选取范围 order_by 排序 字段前面加 - 号前缀，表示为desc倒序 12345Articlelist = Article.objects.filter(**kwargs).order_by(&apos;nid&apos;)Articlelist = Article.objects.filter(**kwargs).order_by(&apos;-nid&apos;) #倒序Articlelist = Article.objects.order_by(&apos;-nid&apos;) # 当查询方法为all时的简写可以使用两个字段进行排序:用在第一个字段相等，用第二个来排序的情形Articlelist = Article.objects.order_by(&apos;-nid&apos;,&apos;ctime&apos;) 注意：字符型字段是按照ascii码来排序的，而数值型是按照数值来排序的 .row(sql)执行原生sql查询 使用row来执行原生的sql查询，会有很多额外选项，代码更加灵活强大，但也要避免 SQL 注入 1234567Person.objects.raw(&apos;SELECT id, first_name, last_name, birth_date FROM myapp_person&apos;)Person.objects.raw(&apos;&apos;&apos;SELECT first AS first_name,... last AS last_name,... bd AS birth_date,... pk AS id,... FROM some_other_table&apos;&apos;&apos;) 注意：无论何时编写原生 SQL 都要万分小心。使用时，你要用 params 将任何用户传入的参数进行安全转义，避免 SQL 注入攻击。阅读 SQL 注入保护 了解更多。 3.APPEND_SLASH路由设置问题出现原因：发送请求时，提交表单报错:RuntimeError: You called this URL via POST, but the URL doesn’t end in a slash and you have APPEND_SLASH set. 出现这个问题主要是因为：在主urls.py中，注意下列这两个路由结尾是否存在斜杆 123456from django.urls import path, re_pathfrom . import views # 导入views文件中的视图函数(标准写法)urlpatterns = [ path('order', views.OrderView.as_view()), path('user/', views.UserView.as_view()),] 当路由结尾不存在斜杠时： 修改settings:APPEND_SLASH=False，此时访问路由时，有没有斜杠都没有关系 当路由结尾存在斜杠时： 修改settings:APPEND_SLASH=True，此时访问路由时，有没有斜杠都没有关系 路由设置举例： 12345# 哔哩哔哩个人主页path(&quot;bilibili/&quot;, views.BIli.as_view()),settings.py:APPEND_SLASH = True 4.DRF的三大认证 4.1 认证我们的某些接口需要对用户进行辨别，那么我们该如何区分A用户和B用户呢？如果A用户想访问B用户的余额，这种操作是不被允许的。在django中，已经完成过基于cookie和session的身份认证，对登录的用户返回一个cookie，并在服务端也进行保存，用户必须携带cookie才能通过用户认证。 drf的认证规则： 如果没有认证信息，则认为是游客 如果认证失败，抛出异常 认证成功返回（user，token） 正义 活着 rest_framework文件下的authentication.py中为我们写好了用户认证的基类，及一些基础的认证类。我们可以通过重写authenticate和相关的方法来定义自己的用户认证类。 DRF登录认证组件 写一个登录认证类（类名随意，类中的方法名固定） 12345678910111213141516from . import modelsfrom rest_framework import exceptionsfrom rest_framework.authentication import BaseAuthenticationclass Auth(BaseAuthentication): def authenticate(self,request): token = request.query_params.get('token') res = models.Token.objects.filter(token=token).first() if res: #放回的res.user就是将user添加到request中user中,res会添加到request的auth中 return res.user,res # return None, None else: raise exceptions.APIException('您还没有登录!') 参考文章 drf之三大认证 drf之三大认证详解","categories":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/tags/Django/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"vue-cli之router路由的花样年华","slug":"Vue(四)","date":"2020-07-29T16:00:00.000Z","updated":"2021-09-18T02:14:26.000Z","comments":true,"path":"2020/07/30/Vue(四)/","link":"","permalink":"https://ahrilove.top/2020/07/30/Vue(%E5%9B%9B)/","excerpt":"本章主要探究vue-cli脚手架的动态路由匹配， 所谓动态路由匹配：就是将不确定的参数进行路由映射到同一个组件上去。 本文要点： 1.参数匹配模式params，query2.路由mode：history，hash3.路由的配置4.路由的跳转☆☆5.keep-alive页面缓存☆☆","text":"本章主要探究vue-cli脚手架的动态路由匹配， 所谓动态路由匹配：就是将不确定的参数进行路由映射到同一个组件上去。 本文要点： 1.参数匹配模式params，query2.路由mode：history，hash3.路由的配置4.路由的跳转☆☆5.keep-alive页面缓存☆☆ 1.参数匹配模式params，queryparams是类似于post请求(形如 https://ip/user/5/name/lmm )，而query是类似于get请求（形如 https://ip/user?id=5） 关于params模式 如果要使用动态路由，先需要在路由index.js 文件里配置相关路由规则，然后再获取； 注册动态路由,一定要注意路由写法12345&#123; path: &apos;/list/:id/post/:name&apos;, 或&apos;/list/:id&apos; name: &apos;List&apos;, component: () =&gt; import(&apos;../views/List.vue&apos;)&#125; PS: 这里的id，name先随意取值单级path: ‘/list/:id’ :会被渲染成 /list/10多级path: ‘/list/:id/post/:name’ :会被渲染成 /list/10/post/chd 传参动态路由：脚手架会把router-link便签解析成a标签 1234&lt;template&gt; &lt;router-link :to=&quot;&#123;name : &apos;List&apos;, params : &#123;id : 10&#125;&#125;&quot;&gt;params单级路由&lt;/router-link&gt; &lt;router-link :to=&quot;&#123;name : &apos;List&apos;, params : &#123;id : 10,name:&apos;lmm&apos;&#125;&#125;&quot;&gt;params多级路由&lt;/router-link&gt;&lt;/template&gt; $route.params.XXXX 获取params路由参数值 有可能加一个this，即this.$route.params.id 1234&lt;template&gt; &lt;p&gt;User Id : &#123;&#123;$route.params.id&#125;&#125;&lt;/p&gt; &lt;p&gt;User Id : &#123;&#123;$route.params.name&#125;&#125;&lt;/p&gt;&lt;/template&gt; 关于query模式 如果要使用动态路由，先需要在 路由index.js 文件里配置相关路由规则，然后再获取； 注册动态路由,一定要注意路由写法,此刻没有后缀 12345&#123; path: &apos;/list, name: &apos;List&apos;, component: () =&gt; import(&apos;../views/List.vue&apos;)&#125; 传参动态路由：脚手架会把router-link便签解析成a标签 123&lt;template&gt; &lt;router-link :to=&quot;&#123;path : &apos;/list&apos;, query : &#123;id : 8, name:&apos;chd&apos;&#125;&#125;&quot;&gt;query动态路由&lt;/router-link&gt;&lt;/template&gt; 这里的query : {id : 8, name:’chd’}，query对象的键值对组成查询字符串 $route.query.XXXX 获取query路由参数值 有可能加一个this，即this.$route.params.id 1234&lt;template&gt; &lt;p&gt;User Id : &#123;&#123;$route.query.id&#125;&#125;&lt;/p&gt; &lt;p&gt;User Id : &#123;&#123;$route.query.name&#125;&#125;&lt;/p&gt;&lt;/template&gt; 2.两种路由mode：history，hashrouter下的路由index.js文件 12345const router = new VueRouter(&#123; routes, //mode: 'history', // history表示去掉锚点 mode : 'hash' // 默认为hash，即带有锚点&#125;) PS：当路由选择为history时，当参数匹配模式为“params”，此时修改动态参数，无论如何修改参数都不会执行成功，都会报错无论路由那种模式，当参数匹配模式为“query”，path按照标准的’/list’,动态路由都能获取到值。 举例说明: 3.路由的配置index.js文件中的route设置 123456789101112131415161718192021222324252627282930313233343536373839import Vue from 'vue'import VueRouter from 'vue-router'import axios from '../plugins/axios'Vue.use(VueRouter,axios); const routes = [ &#123; path: '/', name: 'APP', redirect: '/home', component: () =&gt; import('../App.vue'), meta: &#123; keepAlive: true, //此组件需要被缓存 &#125; &#125;,&#123; path: '/comic', name: 'Comic', component: () =&gt; import('../views/Comic.vue'), meta: &#123; keepAlive: true, &#125;, children:[&#123; path: 'category', name: 'Category', component: () =&gt; import('../views/Tools/catalog.vue'), meta: &#123; keepAlive: true &#125; &#125;] &#125;];const router = new VueRouter(&#123; routes, mode: 'history', // history表示去掉锚点，默认mode : 'hash'&#125;);export default router; 重点或者易错点： 引入vue和vue-router，切记要加上Vue.use(VueRouter) export default router这句话要记得加上，不然会报警告 在children 中，子路由的路径不要加 / this.$route 返回当前路由的信息；this.$router 返回路由全部配置 route-link与route-view router-link类似于a标签，区别在于router-link跳转不需要刷新页面 router-view标签给vue组件的跳转提供一个容器 12345678910&lt;template&gt; &lt;div id=\"app\"&gt; &lt;header&gt; &lt;router-link to=\"/about\"&gt;about&lt;/router-link&gt; &lt;router-link to=\"/user\"&gt;user&lt;/router-link&gt; &lt;router-link to=\"/home\"&gt;导航&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/header&gt; &lt;/div&gt;&lt;/template&gt; 当link会被渲染成a标签，而view则用来展示当前执行的link标签的内容：案例中存在三个路由about、user和home，当随便选中那个时，route-view标签都会加载其选中的那个路由的内容 同级路由的跳转，跳转至新页面:当任意选择about、user和home中一个路由，不写上view标签时，就会跳转至相应页面，而不是在本页面渲染 子路由跳转:子路由是无法实现跳转至新的页面的，只会在父页面上展示，因此需要在父页面写上router-view，不写的话，会导致跳转无响应的。子路由是嵌套必须在上级留下router-view坑位，不然无法显示 router-link渲染成目标标签：之前，我们已经了解到router-link标签默认会渲染成a标签（a标签会导致样式变化），但是Vue也支持渲染成其它标签，解决方案： 增加tag属性，表示将其渲染成目标标签 &lt;router-link tag=”element”&gt;&lt;/router-link&gt; element表示渲染的目标标签，比如span，button element-ui的导航栏组件开启router属性，将index可以设置为路由 案例：当我们有很多图片时，点击每一张图片会跳转至相应的页面，若此时我们使用子路由的话，会将众多的图片和图片对应的页面内容都加载至一个页面，此时就会看起来很杂乱，因此推荐使用同级路由，进入一个新的页面。父子路由推荐作为菜单栏使用 4.路由的跳转路由跳转分为两类：标签跳转(router-link)和程序跳转(this.$router.push) ;标签跳转没有校验，点击后就会直接跳转。而程序跳转，可以添加自定义的校验函数 基本的跳转 1&lt;router-link to=\"/demo1\"&gt;demo1:Hello,world&lt;/router-link&gt; 带参数的基本跳转 1234&lt;router-link v-bind:to=\"&#123;name:'demo1',params:&#123;userId:123&#125;&#125;\"&gt;跳转到demo1穿参123&lt;/router-link&gt;&lt;router-link :to=\"&#123;name:'demo1', query:&#123;plan:'private',sex:'male'&#125;&#125;\"&gt;name-query模式&lt;/router-link&gt;&lt;router-link :to=\"&#123;path:'/demo1', query:&#123;plan:'private',sex:'male'&#125;&#125;\"&gt;path-query模式&lt;/router-link&gt;&lt;!-- http://localhost:8080/#/demo1?plan=private&amp;sex=male --&gt; 通过js跳转 待跳转的路由与当前页面路由相同时，则会报错。所以我们需要判断路由是否是当前路由 12345678910111213141516171819202122232425export default &#123; data()&#123; return&#123; &#125; &#125;, methods:&#123; toURL:function()&#123; // 获取当前页面地址 if (this.$route.path === '/about') &#123; return false; &#125; // 页面跳转函数 this.$router.push( &#123; path:'/about', query:&#123; plan:\"public\", sex:\"female\" &#125; &#125; ); &#125; &#125;&#125; 5.keep-alive页面缓存 为什么需要页面缓存？keep-alive是vue2.0以上内置的组件，为了让组件数据缓存，避免每次资源重复加载（例如每次切换导航时数据会重新加载一次，体验真的差），因此使用了keep-alive，解决了以上产生的问题 keep-alive原理？参考文章： vue中keepAlive组件的作用及使用方式 keep-alive如何实现页面缓存？使用 keep-alive 实现缓存目前主流的有两种方法： 在路由元信息中添加缓存标识（最基本，但不推荐） 在router的index.js文件下 12345678const routes = &#123; path: 'json', name: 'json', meta: &#123; keepAlive: true &#125;, component: () =&gt; import('../views/components/json')&#125; 在需要使用的缓存页面，v-if 判断是否缓存 1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;/&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;/&gt; 这种方法是比较早版本时使用的方法，当时&lt;keep-alive&gt;还没有include属性。这个方法虽然方便，但是会带来很多bug，比如无法使用&lt;transition&gt;、缓存了不必要的，用来实现嵌套路由操作的&lt;router-view&gt;布局组件等 亲身体会：会导致页面很冗余，复杂，因为浏览器之前的已渲染好页面不会注销，会越堆积越多 keep-alive的include与exclude（★★★） 强烈文章：Vue 使用 ＜keep-alive include＞ 实现多级 ＜router-view＞ 缓存，无限层次缓存 参考文章 vue-router中children使用方法 vue实现路由跳转和嵌套（快速入门） vue如何获取并操作DOM元素 vue中获取并操作dom元素 路由匹配模式query,params vue-cli中的vue-router详解：四种跳转方式 爬坑点： 关于Vue-router子路由不显示的一个坑 vue-router 路由嵌套显示不出来_（八）vue-router子路由、参数","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/categories/Vue/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://ahrilove.top/tags/vue-cli/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（十九）：font字体反爬","slug":"Python全栈系列章节更新（十九）","date":"2020-07-27T16:00:00.000Z","updated":"2020-09-14T09:45:22.000Z","comments":true,"path":"2020/07/28/Python全栈系列章节更新（十九）/","link":"","permalink":"https://ahrilove.top/2020/07/28/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近开始了解抖音视频下载时，发现现在的抖音也像大众点评一样开始使用字体反扒了。本章内容： 目标网站：某douyin视频下载反爬机制：js逆向爬虫，字体反扒技术难度：★★★★★☆爬取目标：构建模拟请求signature，下载视频源代码：https://github.com/FioraLove/Net-Spider/tree/develop/抖音/抖音最新版","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近开始了解抖音视频下载时，发现现在的抖音也像大众点评一样开始使用字体反扒了。本章内容： 目标网站：某douyin视频下载反爬机制：js逆向爬虫，字体反扒技术难度：★★★★★☆爬取目标：构建模拟请求signature，下载视频源代码：https://github.com/FioraLove/Net-Spider/tree/develop/抖音/抖音最新版 1.如何确定是否已使用font反扒&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开chrome调试工具 先F12点中那个小箭头，然后点击目标数据，这时关于它的css就会显示出来在右边，像下面这样 从上图中看到 ‘📵📵’就是将真实的数据进行加密反爬了，Ctrl+U 参看网页源代码，可以看到这些图标的‘📵📵’的网页真实为 &amp;#xe611; ,&amp;#xe60c; 这类的 12345&lt;i class=\"icon iconfont follow-num\"&gt; &amp;#xe611; &lt;/i&gt;&lt;i class=\"icon iconfont follow-num\"&gt; &amp;#xe610; &lt;/i&gt;&lt;i class=\"icon iconfont follow-num\"&gt; &amp;#xe611; &lt;/i&gt;.&lt;i class=\"icon iconfont follow-num\"&gt; &amp;#xe60c; &lt;/i&gt;w &lt;/span&gt;&lt;span class=\"text\"&gt;粉丝&lt;/span&gt; 2.多版字体确认加密字体在开发者工具中选择Network筛选font后刷新网页就能找到这个加密字体了 如何浏览ttf格式文件的字体内容呢？ 百度网页字体编辑器，链接：http://fontstore.baidu.com/static/editor/index.html 将下载好的字体文件.ttf，.woff统一转换为 .ttf 格式。 woff convert ttf 工具：https://cloudconvert.com/woff-to-ttf 然后选择打开，打开下载好的字体文件： 看到没，在开发者工具哪里看得到，一个数字，其实是有三个编码对应的 3.确认加密字体内容 pip install fontTools ：使用fontTool打开ttf文件转化成xml文件 1234# -*- coding:utf-8 -*-from fontTools.ttLib import TTFontfont_1 = TTFont('./douyin.ttf')font_1.saveXML('font_1.xml') 截取xml文件中的字体加密保存内容： 123456789101112131415161718192021222324252627282930313233343536&lt;cmap&gt;&lt;tableVersion version=\"0\"/&gt; &lt;cmap_format_4 platformID=\"0\" platEncID=\"3\" language=\"0\"&gt; &lt;map code=\"0x78\" name=\"x\"/&gt;&lt;!-- LATIN SMALL LETTER X --&gt; &lt;map code=\"0xe602\" name=\"num_\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe603\" name=\"num_1\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe604\" name=\"num_2\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe605\" name=\"num_3\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe606\" name=\"num_4\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe607\" name=\"num_5\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe608\" name=\"num_6\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe609\" name=\"num_7\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe60a\" name=\"num_8\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe60b\" name=\"num_9\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe60c\" name=\"num_4\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe60d\" name=\"num_1\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe60e\" name=\"num_\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe60f\" name=\"num_5\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe610\" name=\"num_3\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe611\" name=\"num_2\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe612\" name=\"num_6\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe613\" name=\"num_8\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe614\" name=\"num_9\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe615\" name=\"num_7\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe616\" name=\"num_1\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe617\" name=\"num_3\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe618\" name=\"num_\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe619\" name=\"num_4\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe61a\" name=\"num_2\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe61b\" name=\"num_5\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe61c\" name=\"num_8\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe61d\" name=\"num_9\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe61e\" name=\"num_7\"/&gt;&lt;!-- ???? --&gt; &lt;map code=\"0xe61f\" name=\"num_6\"/&gt;&lt;!-- ???? --&gt; &lt;/cmap_format_4&gt;&lt;/cmap&gt; 从xml这里就可以看到对应之前的每一个字符有三个编码,&amp;#xe611; ,&amp;#xe60c; 这类的 整理数据： 1234567891011# 源码：https://s3.pstatp.com/ies/resource/falcon/douyin_falcon/static/font/iconfont_9eb9a50.wofffont_dict = &#123; \" &amp;#xe603; \": \"0\", \" &amp;#xe60d; \": \"0\", \" &amp;#xe616; \": \"0\", \" &amp;#xe602; \": \"1\", \" &amp;#xe60e; \": \"1\", \" &amp;#xe618; \": \"1\", \" &amp;#xe605; \": \"2\", \" &amp;#xe610; \": \"2\", \" &amp;#xe617; \": \"2\", \" &amp;#xe604; \": \"3\", \" &amp;#xe611; \": \"3\", \" &amp;#xe61a; \": \"3\", \" &amp;#xe606; \": \"4\", \" &amp;#xe60c; \": \"4\", \" &amp;#xe619; \": \"4\", \" &amp;#xe607; \": \"5\", \" &amp;#xe60f; \": \"5\", \" &amp;#xe61b; \": \"5\", \" &amp;#xe608; \": \"6\", \" &amp;#xe612; \": \"6\", \" &amp;#xe61f; \": \"6\", \" &amp;#xe60a; \": \"7\", \" &amp;#xe613; \": \"7\", \" &amp;#xe61c; \": \"7\", \" &amp;#xe60b; \": \"8\", \" &amp;#xe614; \": \"8\", \" &amp;#xe61d; \": \"8\", \" &amp;#xe609; \": \"9\", \" &amp;#xe615; \": \"9\", \" &amp;#xe61e; \": \"9\"&#125; 最后将网页源代码中的加密字体替换成相应的font_dict字典的值 参考文章 抖音用户信息爬取案例 抖音分享页用户信息爬取","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/lovezhuge.jpg"}},{"title":"关于如何养成Django女皇的那件事（Ⅱ）","slug":"Django系列章节更新（二）","date":"2020-07-22T16:00:00.000Z","updated":"2020-08-04T05:37:44.000Z","comments":true,"path":"2020/07/23/Django系列章节更新（二）/","link":"","permalink":"https://ahrilove.top/2020/07/23/Django%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.serializers序列化2.分页查询3.request4.实际案例:嘴臭生成器","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.serializers序列化2.分页查询3.request4.实际案例:嘴臭生成器 1.serializers序列化序列化帮助我们提供了 数据校验 序列化（即字符串化，网络传输都是以字符串形式传输） 创建一个serializers.py文件 在APP目录下创建一个名为serializers.py文件，用于描述序列化逻辑PS：序列化时一定要继承serializers.ModelSerializer 序列化类，不然会出很多问题，e.g., post请求时，缺少的create方法；put请求时，缺少update方法。 最简单的一个序列化案例 123456789101112131415from rest_framework import serializersfrom . import modelsclass NewCategorySerializer(serializers.ModelSerializer): class Meta: model = models.Category # 声明模型名 \"\"\" fields表示要展示的字段，有两种写法： 写法一： fields = \"__all__\"：表示全部展示Category模型里的所有字段 写法二： fields = ['id','name',...]：将想要展示的Category模型里的特定字段添加到数组中 \"\"\" fields = ['id','name'] depth = 1 # 此字段表示查看嵌套几层的数据【推荐0-3】，不建议太大，性能损耗 序列化深入:source用法 1234567891011121314151617181920from rest_framework import serializersfrom . import modelsclass ArticleSerializer(serializers.ModelSerializer): category_txt = serializers.CharField(source='category.name',required=False) x1 = serializers.SerializerMethodField() status_txt = serializers.CharField(source='get_status_display',required=False) x2 = serializers.SerializerMethodField() class Meta: model = models.Article # fields = \"__all__\" fields = ['id','title','summary','content','category','category_txt','x1','status','status_txt','x2'] # depth = 1 def get_x1(self,obj): return obj.category.name def get_x2(self,obj): return obj.get_status_display() 对序列化深入的详细说明 12345678910# fields添加展示字段方式一：直接使用定义的models的字段fields = ['title','summary','content','category']# fields添加展示字段方式二：使用source，引用category模型的name字段category_txt = serializers.CharField(source='category.name',required=False)# fields添加展示字段方式三：自定义函数x1 = serializers.SerializerMethodField() # 先定义x1，并声明为序列化方法字段def get_x1(self,obj): # 函数命名方式：get_自定义的字段名 return obj.category.name 创建一个views.py实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from .serializers import ArticleSerializerfrom rest_framework.response import Responsefrom rest_framework.views import APIViewfrom .models import Category, Articleclass ArticleView(APIView): def get(self, request, *args, **kwargs): pk = kwargs.get('pk') if not pk: queryset = Article.objects.all() ser = ArticleSerializer(instance=queryset, many=True) return Response(ser.data) article_object = Article.objects.filter(id=pk).first() ser = ArticleSerializer(instance=article_object, many=False) return Response(ser.data) def post(self, request, *args, **kwargs): ser = ArticleSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) return Response(ser.errors) def put(self, request, *args, **kwargs): pk = kwargs.get('pk') article_object = Article.objects.filter(id=pk).first() ser = ArticleSerializer(instance=article_object, data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) return Response(ser.errors) def patch(self, request, *args, **kwargs): \"\"\"局部\"\"\" pk = kwargs.get('pk') article_object = Article.objects.filter(id=pk).first() ser = ArticleSerializer(instance=article_object, data=request.data, partial=True) if ser.is_valid(): ser.save() return Response(ser.data) return Response(ser.errors) def delete(self, request, *args, **kwargs): pk = kwargs.get('pk') Article.objects.filter(id=pk).delete() return Response('删除成功') urls.py进行映射 12345678910# -*- coding:utf-8 -*-from django.conf.urls import urlfrom django.urls import path, re_pathfrom . import views # 导入views文件中的视图函数(标准写法)urlpatterns = [ # get获取列表；post增加数据 re_path(r'^drf/article/$', views.ArticleView.as_view()), re_path(r'^drf/article/(?P&lt;pk&gt;\\d+)/$', views.ArticleView.as_view()),] 2.分页查询drf中的分页查询有两种： PageNumberPagination类：访问url形如page/view/article/?page=2 LimitOffsetPagination类：访问url形如page/article/?offset=0&amp;limit=3 PageNumberPagination类 views.py文件：必须重写父类PageNumberPagination，重设每页展示数据量，不设置，则默认不分页 12345678910111213141516171819202122232425262728293031323334353637from .serializers import PageArticleSerializerfrom rest_framework.pagination import PageNumberPagination# 类似于Java中的接口interface，必须重写父类方法class NewPageNumberPagination(PageNumberPagination): page_size = 3 # 重写，每页展示数据数class PageViewArticleView(APIView): def get(self, request, *args, **kwargs): queryset = Article.objects.all() \"\"\" # 方式一：仅数据 # 分页对象 page_object = NewPageNumberPagination() # 调用 分页对象.paginate_queryset方法进行分页，得到的结果是分页之后的数据 # result就是分完页的一部分数据 result = page_object.paginate_queryset(queryset, request, self) # 序列化分页之后的数据 ser = PageArticleSerializer(instance=result, many=True) return Response(ser.data) \"\"\" # 方式二：数据 + 分页信息 \"\"\" page_object = NewPageNumberPagination() result = page_object.paginate_queryset(queryset, request, self) ser = PageArticleSerializer(instance=result, many=True) return page_object.get_paginated_response(ser.data) \"\"\" # 方式三：数据 + 部分分页信息 page_object = NewPageNumberPagination() result = page_object.paginate_queryset(queryset, request, self) ser = PageArticleSerializer(instance=result, many=True) return Response(&#123;'count': page_object.page.paginator.count, 'result': ser.data&#125;) LimitOffsetPagination分页 views.py文件：必须重写父类LimitOffsetPagination，限制每页最大偏移量。不设置，有可能会被黑客攻击比如：有一个黑衣人调用api后，修改请求url：offset=0&amp;limit=200000000…，如此庞大的数据量一下子加载到内存中，服务器直接宕机 123456789101112131415161718# 分页方式二：from rest_framework.pagination import LimitOffsetPaginationfrom .serializers import PageArticleSerializerclass HulaLimitOffsetPagination(LimitOffsetPagination): # 覆盖重写父类max_limit属性,设置最大数据量 max_limit = 2class PageArticleView(APIView): def get(self, request, *args, **kwargs): queryset = Article.objects.all() # 声明分页类 page_object = HulaLimitOffsetPagination() result = page_object.paginate_queryset(queryset, request, self) ser = PageArticleSerializer(instance=result, many=True) return Response(ser.data) 3. requestDRF引入了一个扩展Django常规 HttpRequest 对象的 Request 对象，并提供了更灵活的请求 解析能力。Request 对象的核心功能是 request.data 属性 request.headers 获取请求头，将其转化为字典dict request.method 获取请求方法 request.data 获取post请求携带参数，为字典类型 request.query_params 获取get请求的查询字符串，为&lt;QueryDict: {‘offset’: [‘0’], ‘limit’: [‘3’]}&gt;类型 request.user 判断当前用户认证情况（匿名或者已登录） 4.实际案例:嘴臭生成器 urls.py:路由设置 1234567891011# -*- coding:utf-8 -*-from django.conf.urls import urlfrom django.urls import path, re_pathfrom . import views # 导入views文件中的视图函数(标准写法)urlpatterns = [ path('demo/', views.demo, name='demo'), # 嘴臭生成器:offset,limit分页查询字符串形式为： ndsl/动态id/?offset=0&amp;limit=3 re_path(r'^ndsl/(?P&lt;pk&gt;\\d+)/', views.Nmsl8.as_view()),] model.py：orm模型 123456789101112131415from django.db import models# 嘴臭表class Nmsl(models.Model): category_choices = ( (1, '莲花模式'), (2, '仙人模式'), (3, '气急败坏'), (4, 'NMSL') ) level = models.IntegerField(verbose_name=\"嘴臭限度\", choices=category_choices, default=1) content = models.TextField(verbose_name=\"嘴臭内容\", blank=False) create_time = models.DateTimeField(verbose_name=\"嘴臭时间\", auto_now_add=True) objects = models.Manager() serializers.py:序列化函数 获取models模型中choices的值,参考文章: https://blog.csdn.net/qq_41854273/article/details/84987899 1234567891011121314151617# -*- coding:utf-8 -*-from rest_framework import serializersfrom . import models# 嘴臭生成器序列化class NmslAndNdslSerializer(serializers.ModelSerializer): # level = serializers.SerializerMethodField() class Meta: model = models.Nmsl fields = \"__all__\" depth = 1 # 获取models模型中choices的值,参考文章https://blog.csdn.net/qq_41854273/article/details/84987899 # def get_level(self, obj): # return obj.get_level_display() views.py:视图渲染 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import jsonfrom django.forms import model_to_dictfrom rest_framework import mixinsfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework.request import Requestfrom django.shortcuts import renderfrom django.http import JsonResponsefrom django.views import Viewfrom .models import Category, Article, Nmslfrom .form import SaveForm# 嘴臭生成器模块from rest_framework.pagination import LimitOffsetPaginationfrom .serializers import NmslAndNdslSerializerclass NmslLimitOffsetPagination(LimitOffsetPagination): # 覆盖重写父类max_limit属性 max_limit = 2class Nmsl8(APIView): def get(self, request, *args, **kwargs): queryset = Nmsl.objects.all() print(request.headers) print(request.method) print(request.path) # 声明分页类 page_object = NmslLimitOffsetPagination() result = page_object.paginate_queryset(queryset, request, self) ser = NmslAndNdslSerializer(instance=result, many=True) return Response(ser.data) def post(self, request, *args, **kwargs): ser = NmslAndNdslSerializer(data=request.data) print(request.data) if ser.is_valid(): ser.save() return Response(&#123;\"status\": \"success\", \"content\": request.data.get('content')&#125;) else: return Response(&#123;\"status\": \"failed\"&#125;) def put(self, request, *args, **kwargs): \"\"\" put全部更新 :param request: :param args: :param kwargs: :return: \"\"\" pk = kwargs.get('pk') article_object = Nmsl.objects.filter(id=pk).first() ser = NmslAndNdslSerializer(instance=article_object, data=request.data) if ser.is_valid(): ser.save() return Response(ser.data) return Response(ser.errors) def patch(self, request, *args, **kwargs): \"\"\"局部更新\"\"\" pk = kwargs.get('pk') article_object = Nmsl.objects.filter(id=pk).first() ser = NmslAndNdslSerializer(instance=article_object, data=request.data, partial=True) if ser.is_valid(): ser.save() return Response(ser.data) return Response(ser.errors) def delete(self, request, *args, **kwargs): pk = kwargs.get('pk') Nmsl.objects.filter(id=pk).delete() return Response('删除成功') 请求url 123456789101112131415161718192021222324252627282930313233get请求：url: http://127.0.0.1:8001/nmsl/ndsl/10/?offset=3&amp;limit=5PS:动态id为10不会影响get请求，只是在put，patch，delete时用来操作具体那个id。get请求是分页查询，结果是由offset与limit决定的post请求：创建一组新数据url：http://127.0.0.1:8001/nmsl/ndsl/10/请求参数：data=&#123; &quot;level&quot;:4, &quot;content&quot;:&quot;NMSL，狗贼&quot;&#125;pathch请求：局部更新url：http://127.0.0.1:8001/nmsl/ndsl/10/请求参数：将id为10的数据的content更新值data=&#123; &quot;content&quot;:&quot;NMLGB&quot;&#125;put请求：全部更新url：http://127.0.0.1:8001/nmsl/ndsl/10/请求参数：将id为10的数据的content以及level全部更新data=&#123; &quot;level&quot;:2, &quot;content&quot;:&quot;你今晚biss&quot;&#125;delete请求：删除（直接删除id为10的数据行）url：http://127.0.0.1:8001/nmsl/ndsl/10/","categories":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/tags/Django/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"关于如何养成Django女皇的那件事（Ⅰ）","slug":"Django系列章节更新（一）","date":"2020-07-20T16:00:00.000Z","updated":"2020-10-20T01:33:58.000Z","comments":true,"path":"2020/07/21/Django系列章节更新（一）/","link":"","permalink":"https://ahrilove.top/2020/07/21/Django%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.Django基础知识2.初识drf3.创建程序并初始化模型4.model.py模块5.urls.py模块","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Django是一个优秀的Python web框架，被众多python开发者所喜爱。新开这个Django专栏，并不是从零开始详细使用Django框架来开发web网页，而是用来开发api。前后分离是当前的技术栈潮流。 1.Django基础知识2.初识drf3.创建程序并初始化模型4.model.py模块5.urls.py模块 1.Django基础知识Django搭建web页面的知识，我在GitHub上已经写过了，若想了解搭建网站，请移步👉👉👉Django搭建网站知识基础 首先，我们需要了解三种开发模式： MVT(model,view,templates)模式：Django MVC(model,view,controller)模式：php MVVM(model,view,view—model)模式：vue django是典行的mvt模式，前后分离，后端给前段返回json数据，所以我们编写API时仅需要考虑model层，view层，抛弃template层。 2. 初识drf 安装restful框架 script1pip3 install djangorestframework 使用 注册app（rest_framework本质上也是一个APP，也需要注册） 123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework'] 写路由 1234567from django.conf.urls import urlfrom django.contrib import adminfrom . import viewsurlpatterns = [ url(r'^drf/info/', views.DrfInfoView.as_view()),] 写视图 12345678910111213from rest_framework.views import APIViewfrom rest_framework.response import Responseclass DrfInfoView(APIView): def get(self,request,*args,**kwargs): data = [ &#123;'id': 1, 'title': '震惊了...王阳居然...', 'content': '...'&#125;, &#123;'id': 2, 'title': '震惊了...王阳居然...', 'content': '...'&#125;, &#123;'id': 3, 'title': '震惊了...王阳居然...', 'content': '...'&#125;, &#123;'id': 4, 'title': '震惊了...王阳居然...', 'content': '...'&#125;, ] return Response(data) DRF的应用场景 以后在公司参与前后端分离项目、参与为app写接口时，用drf会比较方便。 restful规范 12345678910111213141516171819202122232425- URL中一般用名词： http://www.luffycity.com/article/ (面向资源编程，网络上东西都视为资源)- 根据请求不同做不同操作：GET/POST/PUT/DELETE/PATCH- 筛选条件，在URL参数中进行传递：http://www.luffycity.com/article/?page=1&amp;category=1一般传输的数据格式都是JSON1. 建议用https代替http2. 在URL中体现api，添加api标识 https://www.cnblogs.com/xwgblog/p/11812244.html # 错误 https://www.cnblogs.com/api/xwgblog/p/11812244.html # 正确 https://api.cnblogs.com/xwgblog/p/11812244.html # 正确 建议：https://www.cnblogs.com/api/...3. 在URL中要体现版本 https://www.cnblogs.com/api/v1/userinfo/ https://www.cnblogs.com/api/v2/userinfo/4. 一般情况下对于api接口，用名词不用动词。 https://www.cnblogs.com/api/v1/userinfo/5. 如果有条件的话，在URL后面进行传递。 https://www.cnblogs.com/api/v1/userinfo/?page=1&amp;category=26. 根据method不同做不同操作 get/post/put/patch/delete drf框架 不基于drf也可以实现restful规范来开发接口程序。使用了drf之后，可以快速帮我们开发restful规范来开发接口。 3. 创建程序并初始化模型DRF引入了一个扩展Django常规 HttpRequest 对象的 Request 对象，并提供了更灵活的请求 解析能力。 Request 对象的核心功能是 request.data 属性，它与 request.POST 类似，但 对于使用Web API更为有用。 12request.POST # 只处理表单数据 只适用于&apos;POST&apos;方法request.data # 处理任意数据 适用于&apos;POST&apos;，&apos;PUT&apos;和&apos;PATCH&apos;等方法,是字典型 rest_framework框架默认传输数据格式为x-www-urlencoded，并不是通常的json在DRF中，请始终使用 request.data ，不要使用 request.POST 4. model.py模块12345678910111213141516171819202122from django.db import models# Create your models here.class Category(models.Model): \"\"\" 文章分类表 verbose_name 代表别名 \"\"\" name = models.CharField(verbose_name=\"分类\", max_length=32) objects = models.Manager()class Article(models.Model): \"\"\" 文章明细表 \"\"\" title = models.CharField(verbose_name=\"标题\", max_length=32) summary = models.CharField(verbose_name=\"简介\", max_length=255) content = models.TextField(verbose_name=\"内容\") category = models.ForeignKey(verbose_name=\"分类\", to=\"Category\", on_delete=models.CASCADE) objects = models.Manager() 关于objects的说明： objects : 管理器对象，Manager类型的对象，定义在from django.db import models中，用于模型对象和数据库交互，是默认自动生成的属性，但是可以自定义管理器对象 自定义管理器对象：例如 books= models.Manager()，一旦自定义管理器对象，默认的objects 就不再自动生成 表字段类型及说明 表字段 描述 models.AutoField 默认会生成一个名为id的字段并未int类型 models.CharField 字符串类型 models.BooleanField 布尔类型 models.ComaSeparatedIntegerField 用逗号分隔的整数类型 models.DateField 日期（Date）类型,生成 年月日 e.g., 2020-06-10 models.DateTimeField 日期（datetime）类型,生成年月日是分秒 e.g., 2020-06-10 16:31:00 models.DecimalField 十进制小数类型 models.EmailField 字符串类型（正则表达式邮箱） models.FloatField 浮点类型 models.IntegerField 整数类型 models.BigIntegerField 长整数类型 models.IPAddressField 字符串类型（IPV4正则表达式） models.GenericIPAddressField 字符串类型，参数protocol可以是: both，IPv4 和ipv6，验证IP地址 models.NullBooleanField 允许为空的布尔类型 models.PositivelntegerField 正整数的整数类型 models.PositiveSmallIntegerField 小正整数类型 models.SlugField 包含字母、数字、下曲线和连字符的字符串， 常用于URL models.SmaIlIntegerField 小整数类型， 取值范围C -32,768—+32,767 ) models.TextField 长文本类型 models.TimeField 时间类型， 显东时分秒HH:MM[:ss[ .uuuuuu]] models.URLField 字符串， 地址为正则表达式 models.BinaryField 二进制数据类型 - - 表字段参数及说明 参数说明 Null 如为True，字段是否可以为空 Blank 如为True，设置添加数据时可以允许空值 Default 设置默认值 primary_key 如为True，将字段设置成主键 db_column 设置数据库中的字段名称 Unique 如为True，将字段设置成唯一属性，默认为False db_index 如为True，为字段添加数据库索引，索引知识点 verbose_name 设置字段的显示名称,别名 related_name 关联对象反向引用描述符，用于多表查询，可解决一个数据表有两个外键同时指向另一个数据表而出现重名的问题 拓： 关于model的表字段说明 auto_now，默认值为false，设置为true时，每次执行 save 操作时，将其值设置为当前时间，并且每次修改model，都会自动更新。注意：设置该参数为true时，并不意味着字段的默认值设为当前时间，而是指字段会被“强制”更新到当前时间，你无法程序中手动为字段赋值；如果使用django自带的admin管理器，那么该字段在admin中是只读的。 使用场景：该属性通常被用在存储“创建时间”的场景下。 auto_now_add，默认值为false，设置为true时，会在model对象第一次被创建时，将字段的值设置为创建时的时间，以后修改对象时，字段的值不会再更新。一旦被设置为True，就无法在程序中手动为字段赋值，在admin中字段也会成为只读的。 null与blank的区别 null：如果为True，表示允许为空，默认值是False blank：如果为True，则该字段允许为空白，默认值是False 对比：null是数据库范畴的概念，blank是表单验证证范畴的 表结构设计 不会经常变化的值放在内存：choices形式，避免跨表性能低 123456789choices形式category_choices = ( (1,&apos;咨询&apos;), (2,&apos;公司动态&apos;), (3,&apos;分享&apos;), (4,&apos;答疑&apos;), (5,&apos;其他&apos;))category = models.IntegerField(verbose_name=&apos;分类&apos;,choices=category_choices) choices用于页面上的选择框标签，需要先提供一个二维的二元元组，第一个元素表示存在数据库内真实的值，第二个表示页面上显示的具体内容。在浏览器页面上将显示第二个元素的值。 解决方案：https://blog.csdn.net/qq_41854273/article/details/84987899 123456789# 序列化文件class BrandSerializer(serializers.ModelSerializer): etype = serializers.SerializerMethodField() class Meta: model = Brand fields = \"__all__\" def get_etype(self,obj): return obj.get_etype_display() 分表：如果表中列太多/大量内容可以选择水平分表 表自关联 关系模型 关系型数据库的关系包括三种类型： ForeignKey：一对多，将字段定义在多的一端中。 ManyToManyField：多对多，将字段定义在任意一端中。 OneToOneField：一对一，将字段定义在任意一端中 外键(ForeignKey)和一对一(OneToOneField)的参数中可以看出,都有on_delete参数,而 django 升级到2.X之后,表与表之间关联的时候,必须要写on_delete参数,否则会报异常 举例：一对多关系 123456789101112131415161718from django.db import modelsclass ServerInfo(models.Model): server_hostname = models.CharField(max_length=20, default=None) server_intranet_ip = models.CharField(max_length=20, default=None) server_internet_ip = models.CharField(max_length=20, default=None) server_shelves_date = models.DateField(auto_now_add=True) # 数据加入时间 update_time = models.DateTimeField(auto_now=True) # 数据更新时间 is_delete = models.BooleanField(default=False) # 逻辑删除 objects = models.Manager()class MiddlewareInfo(models.Model): name = models.CharField(max_length=20) port = models.IntegerField() server = models.ForeignKey('ServerInfo',on_delete=models.CASCADE, default=None) shelves_date = models.DateTimeField(auto_now_add=True) # 数据加入时间 update_time = models.DateTimeField(auto_now=True) # 数据更新时间 is_delete = models.BooleanField(default=False) # 逻辑删除 objects = models.Manager() 关于objects的说明： object是模型属性—用于模型对象和数据库交互。objects = Manager() 是管理器类型的对象 ,是Model和数据库进行查询的接口. 假如不设置管理器对象，在进行数据库查询，更新时就会报错 123queryset = Article.objects.all()article_object = Article.objects.filter(id=pk).first()Article.objects.filter(id=pk).delete() 5. urls.py模块关于路由url，path，re_path的说明 在新版本Django2.x中，url的路由表示用path和re_path代替，模块的导入由django1.x版本的 from django.conf.urls import url,include变成现在的Django2.x中的 from django.urls import path, re_path, include。 path中不能有正则表达式，不然会找不到页面，此时可以使用re_path path(‘delete/(\\d+)’, views.delete), # 删除点击的图书,path中有正则，找不到页面使用re_path可以解决这个情况re_path(‘delete/(\\d+)’, views.delete), # 删除点击的图书 举例说明urls.py模块 123456789101112131415from django.conf.urls import urlfrom django.contrib import adminfrom . import viewsurlpatterns = [ # 管理员后台 url(r'^admin/', admin.site.urls), # as_view()是将类作为view url(r'^info/', views.InfoView.as_view()), url(r'^drf/info/', views.DrfInfoView.as_view()), url(r'^drf/category/', views.DrfCategoryView.as_view()), # 获取一条数据 url(r'^drf/category/$', views.DrfCategoryView.as_view()), url(r'^drf/category/(?P&lt;pk&gt;\\d+)/$', views.DrfCategoryView.as_view()),] 接口：实现访问接口时，创建一个文章类型 12345678910from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom . import Category, Articleclass DrfCategoryView(APIView): def post(self,request,*args,**kwargs): \"\"\"增加一条分类信息\"\"\" Category.objects.create(**request.data) return Response('成功') 接口：获取所有文章类型 1234567891011class DrfCategoryView(APIView): def get(self,request,*args,**kwargs): \"\"\"获取所有文章分类\"\"\" queryset = Category.objects.all().values('id','name') data_list = list(queryset) return Response(data_list) def post(self,request,*args,**kwargs): \"\"\"增加一条分类信息\"\"\" Category.objects.create(**request.data) return Response('成功') 接口：获取一条文章类型的详细信息 12345678910111213141516171819from api import modelsfrom django.forms.models import model_to_dictclass DrfCategoryView(APIView): def get(self,request,*args,**kwargs): \"\"\"获取所有文章分类/单个文章分类\"\"\" pk = kwargs.get('pk') if not pk: queryset = models.Category.objects.all().values('id','name') data_list = list(queryset) return Response(data_list) else: category_object = models.Category.objects.filter(id=pk).first() data = model_to_dict(category_object) return Response(data) def post(self,request,*args,**kwargs): \"\"\"增加一条分类信息\"\"\" models.Category.objects.create(**request.data) return Response('成功') 接口：文章分类的更新和删除 1234567from django.conf.urls import urlfrom django.contrib import adminfrom api import viewsurlpatterns = [ url(r'^drf/category/$', views.DrfCategoryView.as_view()), url(r'^drf/category/(?P&lt;pk&gt;\\d+)/$', views.DrfCategoryView.as_view()),] views.py模块 12345678910111213141516171819202122232425262728293031from api import modelsfrom django.forms.models import model_to_dictclass DrfCategoryView(APIView): def get(self,request,*args,**kwargs): \"\"\"获取所有文章分类/单个文章分类\"\"\" pk = kwargs.get('pk') if not pk: queryset = models.Category.objects.all().values('id','name') data_list = list(queryset) return Response(data_list) else: category_object = models.Category.objects.filter(id=pk).first() data = model_to_dict(category_object) return Response(data) def post(self,request,*args,**kwargs): \"\"\"增加一条分类信息\"\"\" models.Category.objects.create(**request.data) return Response('成功') def delete(self,request,*args,**kwargs): \"\"\"删除\"\"\" pk = kwargs.get('pk') models.Category.objects.filter(id=pk).delete() return Response('删除成功') def put(self,request,*args,**kwargs): \"\"\"更新\"\"\" pk = kwargs.get('pk') models.Category.objects.filter(id=pk).update(**request.data) return Response('更新成功')","categories":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://ahrilove.top/tags/Django/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"CSS属性补充(Ⅲ)","slug":"html与css(Ⅴ)","date":"2020-06-27T16:00:00.000Z","updated":"2021-12-04T00:40:20.232Z","comments":true,"path":"2020/06/28/html与css(Ⅴ)/","link":"","permalink":"https://ahrilove.top/2020/06/28/html%E4%B8%8Ecss(%E2%85%A4)/","excerpt":"本章内容： 1.移动端div左右滑动展示&amp;&amp;隐藏滚动条2.跨域问题3.css头像制作4.点击关闭悬浮框功能5.z-index元素堆叠","text":"本章内容： 1.移动端div左右滑动展示&amp;&amp;隐藏滚动条2.跨域问题3.css头像制作4.点击关闭悬浮框功能5.z-index元素堆叠 1.移动端div左右滑动展示&amp;隐藏滚动条 html页面布局 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于手机屏幕的宽度有限，内容太多移动设备一行装不下的，所以很多移动端网站的导航栏都有左右滑动效果，下面我就用CSS+HTML实现移动端div左右滑动展示。 12345678910111213&lt;div class=\"app\"&gt; &lt;div class=\"tabBar\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 三层嵌套模型： box层： 各个div模块 tabBar： 滚动条隐藏层 app层： .box::-webkit-scrollbar的兼用性较差，有些浏览器无效(如：IE等)，容器外面再嵌套一层 overflow:hidden 内部内容再限制尺寸和外部嵌套层一样，就变相隐藏了 在内容容器A外面再嵌套一层容器B并设置 overflow:hidden ，容器A和容器B需要限制尺寸，就变相隐藏了，兼容所有浏览器。 想要x轴或y轴隐藏滚动条时，子容器比父容器的宽度或高度多 17 px, 经测试正好是滚动条的默认宽度 1234567891011121314151617.app&#123; overflow: hidden; height: 118px;&#125;.tabBar&#123; background-color: #eee; padding: 10px 0; white-space: nowrap;/*文本不会换行，文本会在在同一行上继续*/ overflow-y: auto;/*可滑动*/&#125;.box&#123; width: 8em; margin-left: 3%; height: 100px; background:#fff; display: inline-block; /*行内块级元素*/&#125; 参考文章：https://blog.csdn.net/a785589446/article/details/102247936 举例说明： 12345678910111213&lt;div class=&quot;outer-bar&quot; &gt; &lt;div class=&quot;tabBar&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516.outer-bar&#123; overflow: hidden; width: 100%;&#125;.tabBar&#123; background-color: #eee; width:117%; height:30em; overflow-y: scroll;&#125;.box&#123; width: 10px; height: 60px; background-color:orchid; margin:3px;&#125; 2.跨域问题 ajax只能下载同源的数据，跨源的数据是禁止下载的。同源策略：同协议，同域名（ip），同端口号 html的src属性是可以跨域的，没有同源策略约束，比如可以任意访问其它数据源的图片url，script标签的src属性 对于计算机来说，文件的后缀是没有任何用处的，后缀名的作用是快速识别应该用什么软件打开 jsonp跨域的使用流程 跨域参考文章： 浏览器拦截跨域请求处理方法 不要再问我跨域的问题了 举例说明：目录结构 nmsl |___nmsl.txt |___nmsl.json |___跨域问题.html 先导入Ajax的cdn文件 &lt;script src=”https://unpkg.com/axios/dist/axios.min.js&quot;&gt;\\&lt;/script&gt; 接下来axios的简单举例： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div class=\"app\"&gt; &lt;p id=\"xon\"&gt;&lt;/p&gt; &lt;button&gt;Click me&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function getInfo() &#123; return axios(&#123; url:\"./nmsl.json\", method:\"get\", headers:&#123; 'x-requested-with':\"XMLHttpRequest\", \"x-csrf-token\": \"SJoNf6r3hhcqe0TYsMArfcH6lth6L2htr14ZiruL\", \"Access-Control-Allow-Origin\":\"*\" &#125;, timeout:5000 &#125;) &#125; axios.all([getInfo()]) .then(axios.spread(function (response) &#123; console.log(response); document.getElementById(\"xon\").innerHTML = (response.data)[\"page40\"][6]; &#125;)) &lt;/script&gt;&lt;/body&gt; 3.css头像制作3.1 div里面设置背景图片avatar层来包裹头像 12345678910&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"./demo.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"app\"&gt; &lt;div class=\"avatar\"&gt; &lt;img src=\"./2.jpg\" alt=\"touxiang\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; css样式： 1234567891011121314151617.app&#123; width: 200px; height: 200px; margin: 0 auto; position: fixed; right: 1em; bottom: 1em;&#125;.avatar&#123; width: 200px; height: 200px; background-image: url(./2.jpg); background-size: cover; /*设置边角*/ border-radius: 20%;&#125; 3.2 object-fit属性object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。 object-fit 一般用于 img 和 video 标签，一般可以对这些原素进行保留原始比例的剪切、缩放或者直接进行拉伸等object-position 属性一般与 object-fit一起使用，用来设置元素的位置。 12345678910111213141516.app&#123; width: 200px; height: 200px; margin: 0 auto; position: fixed; right: 1em; bottom: 1em;&#125;.inner img&#123; width: 200px; height: 200px; object-fit: cover; object-position: left;/*可能有时候图片不是从头部开始截图的 所以需要定位一下*/ border-radius: 20%;&#125; 最终成果： 4.点击关闭悬浮框功能设计思路：准备两张图片，一张是带×提示关闭按钮，另一张是广告内容。 123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html&#123; height: 3800px; background-image: linear-gradient(to top, #d9afd9 0%, #97d9e1 100%); &#125; .app&#123; position: fixed; right: 1em; bottom: 1em; &#125; .app i&#123; margin-left: 80%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"app\"&gt; &lt;i id=\"outer\"&gt;&lt;a href=\"javascript:;\"&gt;&lt;img src=\"./bullet.png\" alt=\"点击取消\"&gt;&lt;/a&gt;&lt;/i&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"./bee.png\" alt=\"广告弹窗\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; window.onload = function()&#123; let btn = document.getElementById(\"outer\"); btn.onclick = function() &#123; let img = document.getElementsByClassName(\"app\"); img[0].style.display = \"none\"; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 5.z-index元素堆叠z-index 属性设置元素的堆叠顺序,z-index的值也可以为负数。通俗来说就是类似于PPT的功能置于图层上，置于图层下z元素只对定位属性生效，position不能是默认值，即必须是绝对/相对/固定定位 z-index只针对于同级的定位元素生效, 不针对父子元素 若父元素与子元素z-index值都为正数，就算父元素z-index值大也是在下边 但是把子元素z-index值设成负值确实能达到父元素在子元素之上的效果 实例：z-index教程 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt;img&#123; position:fixed; left:2px; top:5px; z-index:-1;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;img src=\"w3css.gif\" width=\"100\" height=\"140\" alt=\"tupioan\"/&gt;&lt;p&gt;因为图像元素设置了 z-index 属性值为 -1, 所以它会显示在文字之后。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/lovezhuge.jpg"}},{"title":"青春猪头少年不会遇到Ajax异步请求","slug":"青春猪头少年不会遇到Ajax异步请求","date":"2020-06-24T09:20:34.000Z","updated":"2020-06-24T09:20:34.000Z","comments":true,"path":"2020/06/24/青春猪头少年不会遇到Ajax异步请求/","link":"","permalink":"https://ahrilove.top/2020/06/24/%E9%9D%92%E6%98%A5%E7%8C%AA%E5%A4%B4%E5%B0%91%E5%B9%B4%E4%B8%8D%E4%BC%9A%E9%81%87%E5%88%B0Ajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/","excerpt":"","text":"AhriLove function setLoadingBarProgress(num) { document.getElementById('loading-bar').style.width=num+\"%\"; } (function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })(); &nbsp;主页 &nbsp;朋友 &nbsp;关于 AhriLove &nbsp;博文 &nbsp;分类 &nbsp;标签 &nbsp;友链 &nbsp;每日计划 &nbsp;资料文档 &nbsp;肺炎疫情图 &nbsp;近期文章 &nbsp;文章归档 &nbsp;开源项目 &nbsp;我的友链 &nbsp;主题文档 &nbsp;肺炎疫情图 &nbsp;关于小站 setLoadingBarProgress(40); 青春猪头少年不会遇到Ajax异步请求 陈浩东 2020-06-11 javascript Ajax全名为Asynchronous JavaScript And XML，Ajax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面.归纳一下发送HTTP请求的技术方法大全本章内容： 1.Ajax工作原理2.jQuery的$.post(),$.get()3.vue的axios 1.原生Ajax 整个执行过程：网页中发生一个事件（页面加载、按钮点击）👇👇👇由 JavaScript 创建 XMLHttpRequest 对象👇👇👇XMLHttpRequest 对象向 web 服务器发送请求👇👇👇服务器处理该请求👇👇👇服务器将响应发送回网页👇👇👇由 JavaScript 读取响应👇👇👇由 JavaScript 执行正确的动作（比如更新页面） 1.XMLHttpRequest对象Ajax的核心就是XMLHttpRequest对象，几乎所有的现代浏览器都支持，用于同幕后服务器交换数据，意味着可以更新网页部分内容，而不需要重新加载整个页面。 12345678let http;if (window.XMLHttpRequest)&#123; // 用于现代浏览器的代码 http = new XMLHttpRequest();&#125;else&#123; // 应对老版本的IE浏览器 http = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; XMLHttpRequest对象方法与属性： 方法与属性 描述 XMLHttpRequest 对象方法 abort() 取消当前请求 getAllResponseHeaders() 返回头部信息 getResponseHeader() 返回头部信息 getAllResponseHeaders() 返回特定的头部信息 open(method, url, async) 规定请求: method：请求类型 GET 或 POST url：文件位置 async：true（异步）或 false（同步） send() 将请求发送到服务器，用于 GET 请求 send(string) 将请求发送到服务器，用于 POST 请求 setRequestHeader() 向要发送的报头添加标签/值对 XMLHttpRequest 对象属性 onreadystatechange 定义当 readyState 属性发生变化时被调用的函数 readyState 保存 XMLHttpRequest 的状态: 0：请求未初始化 1：服务器连接已建立 2：请求已收到3：正在处理请求4：请求已完成且响应已就绪 responseText 以字符串返回响应数据 responseXML 以 XML 数据返回响应数据 status 返回请求的状态号: 200: “OK”403: “Forbidden”404: “Not Found” … 2.onreadystatechange 属性1234567xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(\"demo\").innerHTML = this.responseText; &#125;&#125;;xhttp.open(\"GET\", \"ajax_info.txt\", true);xhttp.send(); 3.setRequestHeader请求头设置如需像 HTML 表单那样 POST 数据，请通过 setRequestHeader() 添加一个 HTTP 头部。请在 send() 方法中规定您需要发送的数据：计算机传送的始终都是字符 urlencoded数据格式 123xhttp.open(\"POST\", \"ajax_test.asp\", true);xhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");xhttp.send(\"fname=Bill&amp;lname=Gates\"); 传输json数据格式 123456789const body = JSON.stringify(&#123; a: '111', b: '222'&#125;);const xhr = new XMLHttpRequest();xhr.setRequestHeader('Content-Type', 'application/json');xhr.open('POST', 'url',true);xhr.send(body); // http请求一般来说就是发送字符串，所以必须先将json转换为json字符串 4.完整案例可以完善一下，封装成一个类似于jQuery的$.post方法 1234567891011function loadDoc() &#123; let xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(\"demo\").innerHTML = this.responseText; &#125; &#125;; xhttp.open(\"POST\", \"/demo/demo_post2.asp\", true); xhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhttp.send(\"fname=Bill&amp;lname=Gates\");&#125; 2. jQuery的$.post(),$.get()jQuery使用很简单，也封装的很好，这里就不再重复造轮子了，参考网址：https://www.cnblogs.com/sexintercourse/p/7017195.html 3.vue的axios因为vue.js中没有内置任何ajax请求方法。所以需要借助第三方资源库在发送ajax请求。比如vue-resource资源库和axios。详情请参考axios官方文档 安装使用npm：npm install axios使用bower: bower install axios使用cdn: &lt;script src=”https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 执行get请求案例12345678910111213// 为给定 ID 的 user 创建请求axios.get('/user', &#123; params: &#123; ID: \"123456\", PWD:\"9527\" &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行post请求的案例12345678910111213// 携带参数的post请求axios.post('/user',data=&#123; firstName: 'Fred', lastName: 'FlintStone' &#125;) // 获取响应结果 .then(function (response) &#123; console.log(response); &#125;) // 异常捕获 .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求123456789101112131415function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) // response1，2 分别代表并发请求的各响应函数 .then(axios.spread(function (response1, response2) &#123; // 两个请求现在都执行完成(业务代码模块) console.log(response1); console.log(response2); &#125;)); PS：上述发送Ajax请求的时，格式不统一，这里以后都统一一下，统一采用axios(config)传递配置参数来创建请求，如下所示 123456789101112131415axios(&#123; method:\"post\", url:\"https://AhriLove.top\", data:&#123; model: 23, condition: condition, field: \"overdue_type as overdue_type,\" + \"round(sum(overdue_money)/10000,2) as overdue_money\", group: \"overdue_type\", having: \"not ( round(sum(overdue_money)/10000,2)=0)\", showTotal: 0, sortname: \"overdue_money\", sortorder: \"desc\" &#125;&#125;) axios(config)配置参数大全123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134axios(&#123; // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: 'Fred' &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default // `responseEncoding` indicates encoding to use for decoding responses // Note: Ignored for `responseType` of 'stream' or client-side requests responseEncoding: 'utf8', // default // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. '/var/run/docker.sock' to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125;) 更新于 2020年6月17日 js &nbsp;上一页 为何不在blog v1.1活的悠闲点呢 blog改版 下一页&nbsp; Java（十三）：Java数据库 Java &nbsp;评论 &nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。 window.subData = { title: '青春猪头少年不会遇到Ajax异步请求', tools: true } AHRILOVE' BLOG 只有被明日的我们铭记 今天才有意义 &nbsp;&nbsp;本文目录 1.原生Ajax1.XMLHttpRequest对象2.onreadystatechange 属性3.setRequestHeader请求头设置4.完整案例2. jQuery的$.post(),$.get()3.vue的axios安装执行get请求案例执行post请求的案例执行多个并发请求axios(config)配置参数大全 &nbsp;&nbsp;关于博主 轻松一刻 相册 个人简历 &nbsp;&nbsp;站内导航 近期文章 文章归档 开源项目 我的友链 主题文档 每日计划 &nbsp;&nbsp;文章分类 Data analysis(4) Database(10) Java(13) Python(22) ThinkPHP(2) TypeScript(1) docker(3) javascript(11) json(2) 前端(11) 博客Hexo(2) 服务器架构(4) 随笔(5) &nbsp;&nbsp;热门标签 $.post() API Ajax CSS DBUtils DDL DML GNE Github Page Hexo Hyper-V InnoDB Java Jquery Linux Maven Memcached MyISAM MySQL Oracle PHP POST请求 Requests VMware Vue apache blog改版 clone component container css database datetime docker echarts fetchall() fetchone() float front-matter git git pull/push html images jQuery js json json.parse() json.stringify() js精确度丢失 js逆向 lambda margin matplotlib mysql nginx nginx.conf numpy pandas push python python+Django+MySQL re read() - readline() - readlines() redis requirement.txt salt thinkPHP time token union 交互式与守护式创建 元组 列表 前后分离 多线程 多进程 字典 字符串 定位照片拍摄位置 定时任务 对象 属性与方法 数值 数据库分批次处理 数据库通用连接函数 极验滑动 装饰器 解析库 负载均衡 逆向爬虫 选择器 setLoadingBarProgress(60); var GOOGLE_CUSTOM_SEARCH_API_KEY = \"\"; var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = \"\"; var ALGOLIA_API_KEY = \"\"; var ALGOLIA_APP_ID = \"\"; var ALGOLIA_INDEX_NAME = \"\"; var AZURE_SERVICE_NAME = \"\"; var AZURE_INDEX_NAME = \"\"; var AZURE_QUERY_KEY = \"\"; var BAIDU_API_ID = \"\"; var SEARCH_SERVICE = \"hexo\" || \"hexo\"; var ROOT = \"/\"||\"/\"; if(!ROOT.endsWith('/'))ROOT += '/'; $(function() { const $reveal = $('.reveal'); if ($reveal.length === 0) return; const sr = ScrollReveal({ distance: 0 }); sr.reveal('.reveal'); }); $(function() { Waves.attach('.flat-btn', ['waves-button']); Waves.attach('.float-btn', ['waves-button', 'waves-float']); Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']); Waves.attach('.flat-box', ['waves-block']); Waves.attach('.float-box', ['waves-block', 'waves-float']); Waves.attach('.waves-image'); Waves.init(); }); $(function(){ if ('.cover') { $('.cover').backstretch( [\"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.2.1/images/background/021.webp\", \"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(1).jpg.webp\", \"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(8).jpg.webp\", \"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(6).jpg.webp\", \"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imageskda.jpg.webp\", \"https://cdn.jsdelivr.net/gh/FioraLove/Images/531-bigskin-1.jpg\"], { duration: \"5000\", fade: \"3000\" }); } else { $.backstretch( [\"https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.2.1/images/background/021.webp\", \"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(1).jpg.webp\", \"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(8).jpg.webp\", \"https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cover/(6).jpg.webp\", \"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imageskda.jpg.webp\", \"https://cdn.jsdelivr.net/gh/FioraLove/Images/531-bigskin-1.jpg\"], { duration: \"5000\", fade: \"3000\" }); } }); (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') { return; } j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); })(document, 'script'); let COPY_SUCCESS = \"复制成功\"; let COPY_FAILURE = \"复制失败\"; /*页面载入完成后，创建复制按钮*/ !function (e, t, a) { /* code */ var initCopyCode = function(){ var copyHtml = ''; copyHtml += ''; copyHtml += ' 复制'; copyHtml += ''; $(\".highlight .code pre\").before(copyHtml); var clipboard = new ClipboardJS('.btn-copy', { target: function(trigger) { return trigger.nextElementSibling; } }); clipboard.on('success', function(e) { //您可以加入成功提示 console.info('Action:', e.action); console.info('Text:', e.text); console.info('Trigger:', e.trigger); success_prompt(COPY_SUCCESS); e.clearSelection(); }); clipboard.on('error', function(e) { //您可以加入失败提示 console.error('Action:', e.action); console.error('Trigger:', e.trigger); fail_prompt(COPY_FAILURE); }); } initCopyCode(); }(window, document); /** * 弹出式提示框，默认1.5秒自动消失 * @param message 提示信息 * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info * @param time 消失时间 */ var prompt = function (message, style, time) { style = (style === undefined) ? 'alert-success' : style; time = (time === undefined) ? 1500 : time*1000; $('') .appendTo('body') .addClass('alert ' + style) .html(message) .show() .delay(time) .fadeOut(); }; // 成功提示 var success_prompt = function(message, time) { prompt(message, 'alert-success', time); }; // 失败提示 var fail_prompt = function(message, time) { prompt(message, 'alert-danger', time); }; // 提醒 var warning_prompt = function(message, time) { prompt(message, 'alert-warning', time); }; // 信息提示 var info_prompt = function(message, time) { prompt(message, 'alert-info', time); }; let LAZY_LOAD_IMAGE = \"\"; $(\".article-entry\").find(\"fancybox\").find(\"img\").each(function () { var element = document.createElement(\"a\"); $(element).attr(\"data-fancybox\", \"gallery\"); $(element).attr(\"href\", $(this).attr(\"src\")); /* 图片采用懒加载处理时, * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original, * 那么此处将原本的属性名src替换为对应属性名data-original, * 修改如下 */ if (LAZY_LOAD_IMAGE) { $(element).attr(\"href\", $(this).attr(\"data-original\")); } $(this).wrap(element); }); setLoadingBarProgress(100); 联系我 | Contact with me Copyright © 2019-2020 谁知你知我，我知你知深。此恨经年深，比情度日久 博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议 &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;","categories":[],"tags":[]},{"title":"为何不在blog v1.1活的悠闲点呢","slug":"blog改版说明v1","date":"2020-06-16T16:00:00.000Z","updated":"2020-06-17T07:16:26.000Z","comments":true,"path":"2020/06/17/blog改版说明v1/","link":"","permalink":"https://ahrilove.top/2020/06/17/blog%E6%94%B9%E7%89%88%E8%AF%B4%E6%98%8Ev1/","excerpt":"记录博客 v1.1 改版变化，从博客开始运行的第一天起，UI就一直没有变动过，是时候开始一点点改变了🔱🔱🔱","text":"记录博客 v1.1 改版变化，从博客开始运行的第一天起，UI就一直没有变动过，是时候开始一点点改变了🔱🔱🔱 1.页脚改版这次主要是修改了博客的页脚界面，之前的感觉间距把握的不是很好，错落无致，决定先从这里入手。 改版前： 改版后（感觉确实好看了起来😝😝😝，线条，色差分明了起来）： 2.调整每页展示文章数之前是每页展示12章blog，但是随着抖音，快手等短视频流行起来，剧烈冲击的传统视煤，这种商业模式是相当牛皮的，以最短的时间，展示最多的数据，故调整到10章。 3.文章标题二刺螈有一天阅读CSDN时，发现了一篇取名很搞笑的文章，我的 Input框 不可能这么可爱，突然发现很有意思，一看就是老二刺螈，pxj勒，于是在轻小说SF互动传媒网的轻小说 ，抓取相关数据 部分结果展示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119死神的至高法则通关死亡游戏前被召唤了诺亚同学的秘密观察记录身体被夺舍之后我变成了狐娘穿越后有最强血脉的我还有预知挂为美好的光头献上润滑油异世界工匠大师重生为徒弟们打工血姬与骑士我真的只想养徒弟本狐仙才不要祸乱天下万界之我是假面骑士险些将宇宙撑爆的我只好低调做人和魔道帝尊成亲是什么体验守护之天启无限时之录3一隐藏最深的奥秘无聊药剂师被超高危能力打破日常反派复仇后我成了个好人穿上学姐的袜子后我就变成了学姐他们说妾身的相公是小白脸为何不在异世界活的悠闲点呢我真不是小白脸小小的背后灵反派boss重生记美女师尊放过我勇者的我怎么变成魔王了被称作灾恶的他们用异能闯荡世界虫族救世主的崛起日常我的无敌要由军团开始咸鱼公主想成为偶像这样的穿越非得累死怪谈少女的日常物语作为贵族不会魔法的我只能打铁了沐和的画寒头帮闹皇城亿界无双之诸天掠夺驭灵者文若九州记变身之后，我与她的狂想曲困难游戏开局之后该如何生存以最强之刀夺回世界被仙姬女帝两世倾心是什么体验魔教圣女想要平静生活有错吗猫娘少年今天也想征服世界骑士小姐做我男朋友吧我家娘子是妖不是仙变身仙子的我绝不做恶毒女配我和美少女们的恋爱故事变身美少女的我无敌可爱且无奈非正常侦探异闻录在约战变成精灵的我拒绝约会绝世丹妖的我才不要被吃掉蛇小姐的爱情故事神明的游戏世界普通人的我与魔导师的她误入魔道的我成了百花宗宗主虚实之路得到崩坏系统的我开始玩穿越盲信者的虔行命运眷顾的少年在女尊世界装废却被美少女包围拯救世界的一千零一种方法当用小号来到少女前线我万事屋老板决不会接她们的委托被美少女拒绝之后才能不断成长与职业死神同居画本子的日常在这个时代我发现了不得了的事情转生恶役的我怎样才能洗白明日方舟魔狼现世字母家族当代篇阿赖耶的英灵养成方法我是扫地就变强的骑士总是招惹病态少女的我该何去何从不要妨碍我学种植啦异世界归来的我才不要做女孩子呢关于如何养成女皇夫人的那件事我的真祖陛下我要成为大妖怪掌门我一刀一个师门叛徒啊白夜的荣耀枪神之路性别反转的校园恋情物语给主角们助攻的NPC生存之道身为反派女龙套我只能活七天在末世里努力生存的人们转生NPC的我想过上平静的生活成为魔神后开始穿越世界吧惊我变成了光明女神当血族女公爵看上我吾辈之人的理想乡泰拉世界的雇佣兵姐姐们饶了我好吗关于我在贵族女校的障碍回复让人哭笑不得的青春恋爱喜剧时崎狂三的星际旅行花520元变成女生是什么体验诊所里住进个美少女吸血鬼为啥只有无表情少女和妖怪喜欢我被少女疯狂逼婚的我天生面瘫我家魔王不靠谱邻居是位美少女盖尼亚史诗之复仇者白发美少女的养成记录在异界化身女仆与弟弟的幸福生活黑卡能力者丧尸的末日生存碎质危机这条红线真难牵美少女们想要攻略我这个冷淡作家今天的爱丽丝大小姐也是一脸嫌弃屠龙者的我娶了银龙女皇你们就放过我这正经摄影师吧我只是个路过的超级英雄身为血族的我只想初拥美少女当最强魔法师成为村夫之后别以为有系统就可以对付老师我既是末世女帝也是绝美贤妻","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"blog改版","slug":"blog改版","permalink":"https://ahrilove.top/tags/blog%E6%94%B9%E7%89%88/"}],"author":{"name":"陈浩东","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（十三）：Java数据库","slug":"Java数据库（十三）","date":"2020-06-09T16:00:00.000Z","updated":"2020-06-09T10:11:04.000Z","comments":true,"path":"2020/06/10/Java数据库（十三）/","link":"","permalink":"https://ahrilove.top/2020/06/10/Java%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射：框架的灵魂本章内容： 1.Junit测试2.注解3.反射","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射：框架的灵魂本章内容： 1.Junit测试2.注解3.反射 1.Junit测试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Junit白盒测试步骤： 定义一个测试类类名：被测试的类名Test ：CalculatorTest包名：xxx.xxx.test cn.Tencent.test 定义测试方法：可以独立运行方法名：test测试的方法名 testAdd()返回值：void参数列表：空参 给方法加@Test （注解，与之前的覆写@Override一样） 导入junit的依赖（使用时一定要导入junit的依赖，可以在maven中的pom.xml文件导入junit） 12345&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 判定：我们一般会使用断言操作来处理结果Assert.assertEquals(期望的结果，程序运行的结果) Junit的@Before与@After@Before:初始化方法，用于资源的申请，所有的测试方法在执行前都会先自动执行该方法@After:释放资源方法，用于资源的释放，所有的测试方法在执行后都会自动执行该方法 举例说明： 123456789101112131415161718192021222324252627import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class CalculatorTest &#123; @Before public void init()&#123; System.out.println(\"初始化资源。。。\"); &#125; @After public void close()&#123; System.out.println(\"释放资源。。。\"); &#125; @Test public void testAdd()&#123; int a = 8; int b = 7; int c = a+b; // 断言操作 Assert.assertEquals(15,c); System.out.println(a+\"+\"+b+\"=\"+c); &#125;&#125; 运行结果：初始化资源。。。8+7=15释放资源。。。 2.反射 框架：半成品软件，可以在框架的基础上进行软件开发，简化编码 反射：将类的各个组成部分封装为其它对象，这就是反射机制（可以在程序运行过程在，操作这些对象；可以解耦，提高程序的可扩展性） 获取Class对象（字节码文件对象）的方式： Class.forName(“包名.类名”)：将字节码文件加载进内存，返回Class对象（多数用于配置文件，将类名定义在配置文件在，读取文件） 类名.class：通过类名的属性class获取（多用于参数的传递） 对象.getClass():getClass()方法在Object类中定义着（多用于对象的获取字节码的方式） 结论：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 举例说明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package org.AhriLove;public class ReflectDemo &#123; /* * 反射类： * 1.包名.类名 * */ public static void main(String[] args) throws ClassNotFoundException &#123; // 1. 全类名 Class cls1 = Class.forName(\"org.AhriLove.Person\"); System.out.println(cls1); // 2. 类名.class Class cls2 = Person.class; System.out.println(cls2); // 3.对象.getClass() Person p = new Person(\"chd\",18); Class&lt;? extends Person&gt; cls3= p.getClass(); System.out.println(cls3); // 判断是否是相等时 System.out.println(cls1 == cls2); System.out.println(cls1 == cls3); System.out.println(p.getAge()); /* * 运行结果： class org.AhriLove.Person class org.AhriLove.Person class org.AhriLove.Person true true 18 * */ &#125;&#125;class Person &#123; private String name; private int age; public String lover; public Person() &#123;&#125; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void eat() &#123; System.out.println(\"eat.....\");&#125; public void eat(String food) &#123; System.out.println(\"eat.....\" + food); &#125; public static void show()&#123; System.out.println(\"hello world!!!\"); &#125;&#125; Class对象的功能：Declared表示暴力反射，忽略访问修饰符，在反射面前是没有什么隐私的 ① 获取成员变量们 Field[] getFields()：获取所有的public修饰的成员变量 Field getField(String name)：获取指定名称的public修饰的成员变量 Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符 ② 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructors(类&lt;?&gt;…parameterTypes) Constructor getDeclaredConstructors(类&lt;?&gt;…parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() ③ 获取成员方法们 Method[] getMethods() Method getMethods(String name,类&lt;?&gt;…parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethods(String name,类&lt;?&gt;…parameterTypes) ④ 获取类名 String name Field：成员变量 1234操作：1. 设置值 void set(Object obj,Object value)2. 获取值 get(Object obj)3. 忽略访问权限修饰符的安全检查 setAccessible(true)：暴力反射，在反射机制中不存在什么public，private等之类的权限概念 Constructor：构造方法 12创建对象： T newInstance(Object... initargs)如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 Method：方法对象 12执行方法：Object invoke(Object obj,Object... args)获取方法名称： 举例说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package org.AhriLove;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflerctDemo2&#123; public static void main(String[] args) throws Exception &#123; // 0.获取字节码对象 Class personClass = Person.class; // 1.Field[] getFields()获取所有的public修饰的成员变量 Field[] fields = personClass.getFields(); for (Field field:fields) &#123; System.out.println(field); &#125; System.out.println(\"-----------------\"); // 2.获取构造方法 Constructor constructor = personClass.getConstructor(String.class,int.class); System.out.println(constructor); // 全参创建对象 Object people = constructor.newInstance(\"成都\",150); System.out.println(people); // 空参创建对象 Constructor constructor2 = personClass.getConstructor(); Object people2 = constructor2.newInstance(); System.out.println(people2); System.out.println(\"-----------------\"); // 3. 获取指定名称的方法 Method eat_method = personClass.getMethod(\"eat\"); Person person = new Person(); // 执行方法 eat_method.invoke(person); Method eat_method2 = personClass.getMethod(\"eat\",String.class); // 执行方法 eat_method2.invoke(person,\"冰欺凌\"); System.out.println(\"------------------\"); // 获取所有的public修饰的方法 Method[] methods = personClass.getMethods(); for (Method method:methods) &#123; System.out.println(method); // 获取方法名称 System.out.println(method.getName()); &#125; System.out.println(\"--------------\"); // 4.获取类名 String className = personClass.getName(); System.out.println(className); &#125;&#125; 反射实际应用: 写一个“框架”，可以帮我们创建任意类的对象，并且执行其中的任意方法，实现原理 将需要创建的对象的全类名和执行的方法定义在配置文件中 在程序加载读取配置文件 使用反射技术来加载文件进内存 创建对象 执行方法 在src目录下创建一个配置pro.properties文件12className=org.AhriLove.PersonmethodName=eat 2.开始完成框架类 3.注解注解的本质其实就是一个接口interface 使用注解注解：放在Java源码的类、方法、字段、参数前的一种特殊的“注释” 1234567891011121314151617181920212223// 自定义一个注解（新建一个Report.java的接口）package com.gearsnet;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)// 注解名为Reportpublic @interface Report &#123; // int类型的type()方法 int type() default 0; String level() default \"info\"; String value() default \"\"; String[] str1() default \"\"; ...&#125; 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 注解的作用 从JVM的角度开看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定 Java的注解可以分为三类： 第一类是由编译器使用的注解，例如： @Override：让编译器检查该方法是否正确地实现了覆写；@SuppressWarnings：告诉编译器忽略此处代码产生的警告。这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类是由工具处理.class文件使用的注解 比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类是在程序运行期能够读取的注解 它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。 定义一个注解时，还可以定义配置参数，配置参数可以包括： 1234所有的基本类型String枚举类型基本类型，String以及枚举的数组 基本格式：数据类型 属性名() default 默认值;注意：虽然叫做属性，但是实际上是一个方法，因为注解本质上也是一个接口，接口是比抽象方法更抽象的抽象方法，它不存在属性名（字段） 因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。 注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。 此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。如果只写注解，相当于全部使用默认值。 举例说明:@Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。 12345678910111213public class Hello &#123; @Check(min=0, max=100, value=55) public int n; @Check(value=99) public int p; @Check(99) // @Check(value=99) public int x; @Check public int y;&#125; 定义注解Java语言使用@interface语法来定义注解（Annotation），它的格式如下： 12345public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。 元注解:实际上就是注解的注解 有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 @Target 最常用的元注解是@Target，使用@Target可以描述Annotation能够作用的位置： 作用于类或接口： ElementType.TYPE 作用于成员变量： ElementType.FIELD 作用于方法：ElementType.METHOD 作用于构造方法：ElementType.CONSTRUCTOR 作用于方法参数：ElementType.PARAMETER 例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)： 123456@Target(ElementType.METHOD)public @interface Report &#123; int type() default 0; String level() default \"info\"; String value() default \"\";&#125; 定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }： 1234567@Target(&#123; ElementType.METHOD, ElementType.FIELD&#125;)public @interface Report &#123; ...&#125; 实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。 @Retention 元注解@Retention定义了Annotation的生命周期： 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期，当前描述的注解会保留到class字节码文件中，并被jvm读取到：RetentionPolicy.RUNTIME。 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解： 1234567// 作用于运行期阶段@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; int type() default 0; String level() default \"info\"; String value() default \"\";&#125; @Repeatable 使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛 @Inherited 使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效： 1234567@Inherited@Target(ElementType.TYPE)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 在使用的时候，如果一个类用到了@Report： 123@Report(type=1)public class Person &#123;&#125; 则它的子类默认也定义了该注解： 12public class Student extends Person &#123;&#125; 注解总结如何定义Annotation，我们总结一下定义Annotation的步骤： 第一步，用@interface定义注解：注解名为Report，新建一个名为Report的接口 123Report.javapublic @interface Report &#123;&#125; 第二步，添加参数、默认值： 格式为：数据类型 属性名() default 默认值; 123456public @interface Report &#123; // 数据类型 属性名() default 默认值 int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。 第三步，用元注解配置注解： 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 处理注解我们接下来思考如何解析获取注解中的内容~通过优化反射上面的案例：创建任意类的对象，并且执行其中的任意方法 创建一个自定义的注解： Report.java 1234567891011121314package com.gearsnet;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; // String类型的className属性(实际上为抽象方法) String className() default \"\"; String methodName() default \"\";&#125; 创建一个Person对象：Person.java 123456789101112131415161718192021222324public class Person &#123; private String name; private int age; public String lover; public Person() &#123;&#125; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public static void show()&#123; System.out.println(\"hello world!!!\"); &#125;&#125; 创建一个AnnotationDemo.java 1234567891011121314151617181920212223242526272829303132333435package com.gearsnet;import java.lang.reflect.Method;/** 注解赋值：与注解定义类的属性相同* 数组的赋值：使用一个大括号来包裹数组集* */@Report(type = 1,level = \"best\",str1 = &#123;\"abc\",\"chd\"&#125;,className = \"com.gearsnet.Person\",methodName = \"show\")public class AnnotationDemo &#123; public static void main(String[] args) throws Exception &#123; // 1. 获取该类的字节码文件对象 Class&lt;AnnotationDemo&gt; annotation = AnnotationDemo.class; // 2. 获取注解内容 Report report = annotation.getAnnotation(Report.class); // 3. 调用注解对象中的抽象方法 System.out.println(report.className()); System.out.println(report.methodName()); // 4.加载进内存 Class cls = Class.forName(report.className()); // 5. 创建对象 Object obj = cls.newInstance(); // 6.获取方法的对象 Method method = cls.getMethod(report.methodName()); // 7.执行方法(执行Person对象中的show方法) method.invoke(obj); /* * 打印内容： com.gearsnet.Person show hello world!!! * */ &#125;&#125; 最终完成了写一个“框架”，可以帮我们创建任意类的对象，并且执行其中的任意方法 小结： 大多数时候，我们会使用注解，而不是定义注解 注解给谁用？ 编译器使用 给解析程序使用 注解不是程序的一部分，相当于一个标签","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"我的Oracle存储过程实在是太过稳健了","slug":"sql系列更新(八)","date":"2020-06-09T16:00:00.000Z","updated":"2020-06-18T07:09:56.000Z","comments":true,"path":"2020/06/10/sql系列更新(八)/","link":"","permalink":"https://ahrilove.top/2020/06/10/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E5%85%AB)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储过程是由一个或多个T-SQL语句组成的语句组，它可以接受输入参数和输出参数且能向调用程序返回多个值；可以调用其他过程；可以向调用程序返回结果状态值以标记执行成功或失败；","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储过程是由一个或多个T-SQL语句组成的语句组，它可以接受输入参数和输出参数且能向调用程序返回多个值；可以调用其他过程；可以向调用程序返回结果状态值以标记执行成功或失败； Oracle存储过程一个简单的存储过程案例： 12345create or replace procedure myDemo01asbegin dbms_output.put_line('hello word, my name is stored procedure');end; create or replace procedure：关键字用来创建或覆盖一个原有的存储过程。 myDemo01：自定义的存储过程的名字。 as：关键字。注： 在存储过程(PROCEDURE)和函数(FUNCTION)中没有区别； 在视图(VIEW)中只能用AS不能用IS； 在游标(CURSOR)中只能用IS不能用AS。 begin：关键字。 dbms_output.put_line(‘hello word’); 换行输出内容。 end 关键字。 ps：不区分大小写；以begin与end为核心体（类似于编程语言的{}）;每条语句以”;”结尾 1.sql的三大部分声明部分、可执行部分与异常处理部分 123456declare -- 声明部分 i integer ;begin dbms_output.put_line(\"hello world\");end; || 表示拼接符号(sql server的拼接符号为+) 声明变量的方式为：变量名 变量类型(长度) eg: name varchar2(length); 变量赋值方式： 3.1 直接赋值语句 :=(这是赋值符号，区别于其他语言) eg：name := ‘chd’; 3.2 语句赋值 使用 select 值 into 变量 from dual； 2.变量类型变量主要分为两大块：普通变量类型和 引用型变量 普通变量类型：前提你要了解数据库字段的类型和大小 声明变量的方式为：变量名 变量类型(长度) eg: name varchar2(length); 变量赋值方式： 直接赋值语句 :=(这是赋值符号，区别于其他语言) eg：name := ‘chd’; 语句赋值 使用 select 值 into 变量 from dual；普通变量类型的SQL查询 引用型变量：变量的类型和长度决定表中字段的类型和长度 声明变量的方式： 变量名 表名.列名%TYPE (即定义的变量的数据类型借用某个表下的某一列的数据类型) 12345678910eg:name 表名.列名%TYPE (推荐使用，不必了解数据库架构) declare v_name TW_DATAS.mny%TYPE; age tw_datas.rate%TYPE;begin select mny, rate into v_name, age from TW_DATAS where ly_rate = 12; dbms_output.put_line( &apos; hello java&apos; || &apos;MNY： &apos; ||&apos; &apos;|| v_name || &apos;RATE： &apos; || age); --打印hello worldend; 变量赋值方式： 直接赋值语句 :=(这是赋值符号，区别于其他语言) eg：name := ‘chd’; 语句赋值 使用 select 值 into 变量 from dual；普通变量类型的SQL查询 3. 流程控制 判断if…then…elsif…then…else…end if 12345678910111213141516171819202122BEGIN IF 条件 THEN 执行一; ELSIF 条件二 THEN 执行二; ELSE 执行否则; END IF ;END-- 举例说明declare v_emp TW_DATAS%ROWTYPE; v_count number;begin select count(distinct item_name) into v_count from Tw_Datas; dbms_output.put_line(v_count); if v_count &gt;= 300 then dbms_output.put_line(v_count + 1); elsif 200 &lt; v_count then dbms_output.put_line(v_count - 100); else dbms_output.put_line(v_count); end if;end; 循环Loop for循环 12345678910111213141516create or replace procedure mydemo09asbegin for stu in (select * from students) loop if (stu.id&lt;5) then dbms_output.put_line(stu.id); end if; end loop;commit;end;-- 调用存储过程begin mydemo09();end; while循环 123456789101112create or replace procedure test_while_loop as n_count number := 0;begin while n_count &lt; 10 loop dbms_output.put_line(n_count); n_count := n_count + 1; end loop;end; begin test_while_loop();end; 4.游标cursor基本概念游标（Cursor）是处理数据的一种方法，为了查看或者处理结果集中的数据，游标提供了在结果集中一次一行或者多行前进或向后浏览数据的能力。 游标的分类游标有两种类型：显式游标和隐式游标。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般我们用到的SELECT…INTO…查询语句，一次只能从数据库中提取一行数据，对于这种形式的查询和DML操作，系统都会使用一个隐式游标。但是如果要提取多行数据，就需要由程序员定义一个显式游标，并通过与游标有关的语句进行处理。显式游标对应一个返回结果为多行多列的SELECT语句。 游标一旦打开，数据就从数据库中传送到游标变量中，然后应用程序再从游标变量中分解出需要的数据，并进行处理。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的DML操纵语句和单行查询语句会使用隐式游标，这些语句分别是插入insert语句，更新update语句，删除delete语句，单行select查询语句。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统使用一个隐式游标时，可以通过隐式游标的属性来了解操作的状态和结果，进而控制程序的流程。隐式游标可以使用名字SQL来访问，但要注意，通过SQL游标名总是只能访问前一个DML操作或单行SELECT操作的游标属性。所以通常在刚刚执行完操作之后，立即使用SQL游标名来访问属性。 游标的属性有以下四种： SQL%ROWCOUNT 返回值为一个整型数字 代表DML语句成功执行的数据行数 2. SQL%FOUND 布尔型 值为TRUE代表插入、删除、更新或单行查询操作成功 3. SQL%NOTFOUND 布尔型 值为true表示插入、删除、更新或单行查询操作失败。 4. SQL%ISOPEN 布尔型 DML执行过程中为真，结束后为假 游标的使用12345678910111213141516171819202122232425-- 使用游标查询emp表中所有员工的姓名和工资declare -- 声明游标,c_emp为游标名 cursor c_emp is -- 业务代码块 select name,salary from emp; -- 声明变量用来接收游标中的元素 psnname emp.name%TYPE; salary emp.salary%TYPE;begin --打开游标 open c_emp; -- 遍历游标中的值 loop --通过fetch语句获取游标中的值并赋值给变量 fetch c_emp into psnname,salary; -- 通过%NOTFOUND判断是否有值，有值打印，没有则退出循环 exit when c_emp%NOTFOUND; dbms_output.put_line( '姓名:' || psnname || ',薪水：' || salary); end loop; -- 关闭游标 close c_emp;end; 5.Oracle存储过程（一）存储过程中没有declare，declare用于在语句块中，存储过程可以理解为java的方法，可以多次调用的 123456789101112语法：create or replace procedure 过程名称[(参数列表)] is(as,两者互用，功能一样)begin ...end 过程名称;创建的过程： 1.点击PL/SQL的文件--&gt;新建--&gt; 程序窗口--&gt; Procedure--&gt; ...--&gt; 编写完进行编译 2.调用Procedure文件：新的函数窗口下 begin 直接调用已编译好的Procedure文件 end 变量声明，赋值的存储过程 12345678910create or replace procedure mydemoasname varchar(10); -- 声明变量，注意varchar需要指定长度age int;begin name := &apos;Bob&apos;; age:= 18; --通过||符号达到连接字符串的功能 dbms_output.put_line(&apos;name=&apos;||name||&apos;, age=&apos;||age);end; 带有参数的存储过程 12345678910create or replace procedure myDemo03(name in varchar,age in int)asbegin dbms_output.put_line(&apos;name=&apos;||name||&apos;, age=&apos;||age);end;-- 调用存储过程 begin myDemo03(&apos;xiaoming&apos;,18);end; 注意参数 in在调用存储过程时，如果存储过程没有参数，调用时括号()可以不带。存储过程带参数需要注意参数的传递参数时的一致性，按顺序依次传递。 实参形参问题 1234567891011121314create or replace procedure myDemo04(name in varchar,age in int)asbegin dbms_output.put_line(&apos;name=&apos;||name||&apos;, age=&apos;||age);end; declare name varchar(10); age int;begin name:=&apos;xiaoming&apos;; age:=18; myDemo04(name=&gt;name,age=&gt;18);--此时不能myDemo04(name=&gt;name,18)，不能完成调用。end; 注;在调用存储过程时，=&gt;前面的变量为存储过程的形参且必须于存储过程中定义的一致，而=&gt;后的参数为实际参数。当然也不可以不定义变量保存实参 in,out问题 1234567891011121314create or replace procedure myDemo05(name out varchar,age in int)asbegin dbms_output.put_line(&apos;age=&apos;||age); select &apos;xiaoming&apos; into name from dual;end; declare name varchar(10); age int;begin myDemo05(name=&gt;name,age=&gt;10); dbms_output.put_line(&apos;name=&apos;||name);end; PS：in代表输入，out用于输出，参数默认类型是in类型 带输出参数的存储结果 带输出参数的存储过程一般是通过第三方程序来调用，这里举例Java调用存储过程：https://www.jianshu.com/p/8ad29c4c8114 异常问题，执行结果如下 12345678910111213create or replace procedure mydemo0006asage int;begin age:=10/0; dbms_output.put_line(age); exception when others then dbms_output.put_line(&apos;error&apos;);end; begin mydemo0006();end; 6.Oracle存储过程（二）两种循环+基本增删改查操作 1234567891011121314151617181920212223242526272829create or replace procedure mydemo07(ids in int, username in varchar,userpass in varchar, userage in int)asbegin -- insert into students(id,username,userpass,userage)--增 -- values(ids,username,userpass,userage); -- delete from students where id=ids;--删 --update students set userage=100 where id=ids;--改commit;end;beginmydemo07(10,&apos;a&apos;,&apos;b&apos;,&apos;17&apos;);end;---------------------------create or replace procedure mydemo08(ids in int, age out int)asbegin select userage into age from students where id=ids; --查 commit;end;declare ids int; age int;begin ids:=1; myDemo08(ids=&gt;ids,age=&gt;age); dbms_output.put_line(&apos;age=&apos;||age);end; for循环： 12345678910111213141516create or replace procedure mydemo09asbeginfor stu in (select * from students) loop if (stu.id&lt;5) then dbms_output.put_line(stu.id); end if; end loop;commit;end;begin mydemo09();end; 7.存储过程补充点 存储过程中的Execute immediate 12345678910111213141516171819202122232425262728293031323334353637在存储过程的开头，begin之前，经常会看到这么一段语句procedure nameisPRAGMA AUTONOMOUS_TRANSACTION;——————自治事物Begin -- 清空原表数据 Execute immediate ’truncate table xxx’;End为什么要用Execute immediate ’truncate table xxx’;而不是直接在begin里写truncate 呢？原因：因为存储过程中是没有truncate这条语句的，直接在存储过程中写truncate是会报错的。存储过程中只能写delete之类的语句。Execute immediate后台执行该语句，令存储过程强行转了SQL。SQL命令下是允许执行truncate的。所以，如果没有存储过程的权限，而有SQL的权限，可以使用execute immediate来执行。详细使用案例：CREATE OR REPLACE PROCEDURE PRO_TEST() IS V_SQL VARCHAR2(2000) := &apos;&apos;; V_NUM NUMBER;BEGIN --EXECUTE IMMEDIATE用法1:立刻执行 V_SQL := &apos;create or replace view mytest as select employee_id, first_name from employees&apos;; EXECUTE IMMEDIATE V_SQL; --EXECUTE IMMEDIATE用法2:立刻执行,并赋值给某变量 V_SQL := &apos;select count(1) from employees&apos;; EXECUTE IMMEDIATE V_SQL; INTO V_NUM; --EXECUTE IMMEDIATE用法3:带参数的sql V_SQL := &apos;select * from employees e where e.employee_id = :1 and first_name = :2&apos;; EXECUTE IMMEDIATE V_SQL; USING 200, &apos;Jennifer&apos;;END PRO_TEST; Oracle的转义字符 CHR(10)和 CHR(13)——在oracle都为换行 chr(32)——表示空格 &#39; &#39; 一对单引号表示的是字符串，两对单引号表示转义字符串的内容，比如 1234567-- 在sql里&apos;name&apos; =&gt; 字符串&apos;&apos;name&apos;&apos; =&gt; &apos;name&apos;举例说明：&apos; syear_name || substr(replace(speriod_name,&apos;&apos;月&apos;&apos;,&apos;&apos;&apos;&apos;) + 100,2,2) as smonth,&apos; ⬇syear_name || substr(replace(speriod_name,&apos;月&apos;,&apos;&apos;) + 100,2,2) as smonth, 8.实际案例 查询某个员工的（比如9527）的姓名与薪水，传入参数为id 1234567891011create or replace procedure P_QUERYNAMEANDSAL(psncode in emp.empno%TYPE) is -- 声明变量并接收查询结果 username emp.ename%TYPE ; sal emp.salary%TYPE ;begin -- 根据用户传递的员工1号查询姓名与薪水 select ename,sal into username,sal from emp where empno = psncode; -- 打印结果 dbms_output.put_line(username || ':' || sal);end; 存储过程类似于Java中的方法，那我们该如何调用：在测试窗口调用存储过程 1234567891011declare --声明变量id id emp.id%TYPEbegin -- 变量赋值 id := 7839; -- 存储过程调用方式一 p_querynameandsal(id); -- 存储结果调用方式二：直接赋值调用 p_querynameandsal（7839）;end; 参考文章 sqlserver存储过程学习(通俗易懂)","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://ahrilove.top/tags/Oracle/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"数据库存储过程(一)：sql server","slug":"sql系列更新(七)","date":"2020-06-08T16:00:00.000Z","updated":"2020-06-11T02:58:22.000Z","comments":true,"path":"2020/06/09/sql系列更新(七)/","link":"","permalink":"https://ahrilove.top/2020/06/09/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E4%B8%83)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储过程是由一个或多个T-SQL语句组成的语句组，它可以接受输入参数和输出参数且能向调用程序返回多个值；可以调用其他过程；可以向调用程序返回结果状态值以标记执行成功或失败；","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存储过程是由一个或多个T-SQL语句组成的语句组，它可以接受输入参数和输出参数且能向调用程序返回多个值；可以调用其他过程；可以向调用程序返回结果状态值以标记执行成功或失败； 1.SQL server存储过程 变量的声明 声明变量时必须在变量前加@符号： declare @i int（声明变量数据类型为int类型的i）declare @s varchar(10),@a int;(声明多个变量)print @s 打印变量值每条语句以”;”结尾 变量的赋值 变量赋值时变量前必须加set：set @i = 5; 使用select语句赋值： 循环语句 begin…end 类似于编程语言的{} if语句： 123456789101112if ..begin ...endelse if ..begin ...endelsebegin ...end eg: 12345678DECLARE @d INTset @d = 1IF @d = 1 BEGIN PRINT '正确'ENDELSE BEGIN PRINT '错误'END 多条件查询语句： 123456789101112131415-- 多条件选择语句declare @today intdeclare @week nvarchar(3)set @today=3set @week= case when @today=1 then '星期一' when @today=2 then '星期二' when @today=3 then '星期三' when @today=4 then '星期四' when @today=5 then '星期五' when @today=6 then '星期六' when @today=7 then '星期日' else '值错误'endprint @week while循环语句： 12345declare @i int set @i = 1while @i&lt;1000 begin set @i = @i+1end 定义游标 1234567891011121314151617181920212223--创建一个游标--my_cursor为游标的名称，随便起declare my_cursor cursor for --这是游标my_cursor的值，这里随便发挥看业务场景 select id,name from my_user --打开游标open my_cursor --声明变量declare @id int --声明变量 ‘declare’为声明变量 ‘@name’为变量名称 后面为变量类型declare @name varchar(50) --这里是两个变量用来接收游标的值--循环游标fetch next from my_cursor into @id,@name --获取my_cursor的下一条数据，其中为两个字段分别赋值给@id,@namewhile @@FETCH_STATUS=0 --假如检索到了数据继续执行 begin print(@name) --print()打印变量 随便发挥 select * from my_user where id=@id --这里是具体业务了，随便发挥。而我这是又执行了一次查询 fetch next from my_cursor into @id,@name --获取下一条数据并赋值给变量 end--关闭并释放游标close my_cursordeallocate my_cursor 临时表（参考sql系列更新六） SQL server的存储过程创建语法： GO在存储过程或语句中起结束，终止上面语句的作用 创建语法 1234567create proc | procedure pro_name [&#123;@参数数据类型&#125; [=默认值] [output], &#123;@参数数据类型&#125; [=默认值] [output], .... ]as SQL_statements 创建不带参数的存储过程 12345678910--创建存储过程if (exists (select * from sys.objects where name = &apos;proc_get_student&apos;)) drop proc proc_get_studentgocreate proc proc_get_studentas select * from student;--调用、执行存储过程exec proc_get_student; 带参数的存储过程 12345678910--带参存储过程if (object_id('proc_find_stu', 'P') is not null) drop proc proc_find_stugocreate procedure proc_find_stu(@startId int, @endId int)as select * from student where id between @startId and @endIdgoexec proc_find_stu 2, 4; 带通配符参数的存储过程 1234567891011--带通配符参数存储过程if (object_id('proc_findStudentByName', 'P') is not null) drop proc proc_findStudentByNamegocreate proc proc_findStudentByName(@name varchar(20) = '%j%', @nextName varchar(20) = '%')as select * from student where name like @name and name like @nextName;goexec proc_findStudentByName;exec proc_findStudentByName '%o%', 't%'; 带输出参数的存储过程★★ 12345678910111213141516171819202122if (object_id('proc_getStudentRecord', 'P') is not null) drop proc proc_getStudentRecordgocreate proc proc_getStudentRecord( @id int, --默认输入参数 @name varchar(20) out, --输出参数 @age varchar(20) output--输入输出参数)as select @name = name, @age = age from student where id = @id and sex = @age;go-- declare @id int, @name varchar(20), @temp varchar(20);set @id = 7; set @temp = 1;-- exec代表执行的含义exec proc_getStudentRecord @id, @name out, @temp output;select @name, @temp;print @name + '#' + @temp; 带游标参数存储过程★★ 12345678910111213141516171819202122232425if (object_id('proc_cursor', 'P') is not null) drop proc proc_cursorgocreate proc proc_cursor @cur cursor varying outputas set @cur = cursor forward_only static for -- 这里是具体业务了，随便发挥 select id, name, age from student; open @cur;go--调用declare @exec_cur cursor;declare @id int, @name varchar(20), @age int;exec proc_cursor @cur = @exec_cur output;--调用存储过程fetch next from @exec_cur into @id, @name, @age;while (@@fetch_status = 0) begin fetch next from @exec_cur into @id, @name, @age; print 'id: ' + convert(varchar, @id) + ', name: ' + @name + ', age: ' + convert(char, @age); endclose @exec_cur;deallocate @exec_cur;--删除游标 参考文章 sqlserver存储过程学习(通俗易懂)","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"sql临时表","slug":"sql系列更新(六)","date":"2020-06-07T16:00:00.000Z","updated":"2020-06-11T03:01:26.000Z","comments":true,"path":"2020/06/08/sql系列更新(六)/","link":"","permalink":"https://ahrilove.top/2020/06/08/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E5%85%AD)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;临时表顾名思义，是一个临时的表，数据库不会将其序列化到磁盘上(有些也会序列化到磁盘上)而是存在于数据库服务器的内存中(因此会增加数据库服务器内存的消耗)，在使用完之后就会销毁。临时表分为两种：会话临时表和全局临时表，区别在于可用的作用域和销毁的时机不同。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;临时表顾名思义，是一个临时的表，数据库不会将其序列化到磁盘上(有些也会序列化到磁盘上)而是存在于数据库服务器的内存中(因此会增加数据库服务器内存的消耗)，在使用完之后就会销毁。临时表分为两种：会话临时表和全局临时表，区别在于可用的作用域和销毁的时机不同。 1.SQL server临时表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;临时表分为两种：会话临时表和全局临时表，区别在于可用的作用域和销毁的时机不同。 会话临时表只在当前会话(连接)内可用，且在当前会话结束(断开数据库连接)后就会销毁； 全局临时表创建后在销毁之前所有用户都可以访问，销毁的时机是在创建该临时表的连接断开且没有其他会话访问时才销毁，实际上在创建全局临时表的会话断开后，其他用户就已经不能在访问该临时表了，但此时该临时表并不会立即销毁，而是等所有正在使用该全局临时表的会话(或者说连接)断开之后才会销毁。当然有时考虑到内存占用的问题，我们也可以手动销毁(DROP)临时表。 sql server临时表的创建 会话临时表：以 “#”作为前缀，后面加上表名 全局临时表：以 “##”作为前缀，后面加上表名 创建方式一： 12345678910111213#会话临时表CREATE TABLE #临时表名( 字段1 约束条件1, 字段2 约束条件2, ...);#全局临时表CREATE TABLE ##临时表名( 字段1 约束条件, 字段2 约束条件, ...); 创建方式二： 1234567#会话临时表SELECT 字段列表 INTO #临时表名 FROM 业务表;#全局临时表SELECT 字段列表 INTO ##临时表名 FROM 业务表; 临时表的使用： 123#查询临时表SELECT * FROM #临时表名;SELECT * FROM ##临时表名; 临时表的删除： 123#删除临时表DROP TABLE #临时表名;DROP TABLE ##临时表名; 2.mysql临时表MySQL临时表的创建： MySQL中没有全局临时表，创建时候没有“#” 1234567891011CREATE TEMPORARY TABLE [IF NOT EXISTS] 临时表名( 字段1 约束条件, 字段2 约束条件, ...);#根据现有表创建临时表CREATE TEMPORARY TABLE [IF NOT EXISTS] 临时表名[AS] SELECT 查询字段FROM 业务表[WHERE 条件]; MySQL临时表的使用： 创建的临时表可以和业务表同名，若临时表和业务表同名则在该会话中会使用临时表 1select * from 临时表名 MySQL临时表的删除：为避免临时表名和业务表名相同时导致误删除，可以加上TEMPORARY关键字 1DROP [TEMPORARY] TABLE 临时表名; 3.Oracle临时表Oracle的临时表也只有会话级的，但同时又细化出了一个事务级别的临时表，事务级别的临时表只在当前事务中有效。 Oracle临时表的创建： 12345678910111213#会话级别：当COMMIT的时候保留数据，当会话结束删除数据CREATE GLOBAL TEMPORARY TABLE 临时表名( 字段1 约束条件, 字段2 约束条件, ...) ON COMMIT PRESERVE ROWS;#事务级别：当COMMIT的时候删除数据（默认情况）CREATE GLOBAL TEMPORARY TABLE 临时表名( 字段1 约束条件, 字段2 约束条件, ...) ON COMMIT DELETE ROWS; oracle临时表的删除： 1DROP TABLE 临时表名; 注意：一个SQL中不能同时出现两次临时表","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（十二）：Junit测试与反射","slug":"Java注解与反射（十二）","date":"2020-05-12T16:00:00.000Z","updated":"2020-06-09T10:10:18.000Z","comments":true,"path":"2020/05/13/Java注解与反射（十二）/","link":"","permalink":"https://ahrilove.top/2020/05/13/Java%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射：框架的灵魂本章内容： 1.Junit测试2.注解3.反射","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射：框架的灵魂本章内容： 1.Junit测试2.注解3.反射 1.Junit测试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Junit白盒测试步骤： 定义一个测试类类名：被测试的类名Test ：CalculatorTest包名：xxx.xxx.test cn.Tencent.test 定义测试方法：可以独立运行方法名：test测试的方法名 testAdd()返回值：void参数列表：空参 给方法加@Test （注解，与之前的覆写@Override一样） 导入junit的依赖（使用时一定要导入junit的依赖，可以在maven中的pom.xml文件导入junit） 12345&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 判定：我们一般会使用断言操作来处理结果Assert.assertEquals(期望的结果，程序运行的结果) Junit的@Before与@After@Before:初始化方法，用于资源的申请，所有的测试方法在执行前都会先自动执行该方法@After:释放资源方法，用于资源的释放，所有的测试方法在执行后都会自动执行该方法 举例说明： 123456789101112131415161718192021222324252627import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;public class CalculatorTest &#123; @Before public void init()&#123; System.out.println(\"初始化资源。。。\"); &#125; @After public void close()&#123; System.out.println(\"释放资源。。。\"); &#125; @Test public void testAdd()&#123; int a = 8; int b = 7; int c = a+b; // 断言操作 Assert.assertEquals(15,c); System.out.println(a+\"+\"+b+\"=\"+c); &#125;&#125; 运行结果：初始化资源。。。8+7=15释放资源。。。 2.反射 框架：半成品软件，可以在框架的基础上进行软件开发，简化编码 反射：将类的各个组成部分封装为其它对象，这就是反射机制（可以在程序运行过程在，操作这些对象；可以解耦，提高程序的可扩展性） 获取Class对象（字节码文件对象）的方式： Class.forName(“包名.类名”)：将字节码文件加载进内存，返回Class对象（多数用于配置文件，将类名定义在配置文件在，读取文件） 类名.class：通过类名的属性class获取（多用于参数的传递） 对象.getClass():getClass()方法在Object类中定义着（多用于对象的获取字节码的方式） 结论：同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 举例说明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package org.AhriLove;public class ReflectDemo &#123; /* * 反射类： * 1.包名.类名 * */ public static void main(String[] args) throws ClassNotFoundException &#123; // 1. 全类名 Class cls1 = Class.forName(\"org.AhriLove.Person\"); System.out.println(cls1); // 2. 类名.class Class cls2 = Person.class; System.out.println(cls2); // 3.对象.getClass() Person p = new Person(\"chd\",18); Class&lt;? extends Person&gt; cls3= p.getClass(); System.out.println(cls3); // 判断是否是相等时 System.out.println(cls1 == cls2); System.out.println(cls1 == cls3); System.out.println(p.getAge()); /* * 运行结果： class org.AhriLove.Person class org.AhriLove.Person class org.AhriLove.Person true true 18 * */ &#125;&#125;class Person &#123; private String name; private int age; public String lover; public Person() &#123;&#125; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void eat() &#123; System.out.println(\"eat.....\");&#125; public void eat(String food) &#123; System.out.println(\"eat.....\" + food); &#125; public static void show()&#123; System.out.println(\"hello world!!!\"); &#125;&#125; Class对象的功能：Declared表示暴力反射，忽略访问修饰符，在反射面前是没有什么隐私的 ① 获取成员变量们 Field[] getFields()：获取所有的public修饰的成员变量 Field getField(String name)：获取指定名称的public修饰的成员变量 Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符 ② 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructors(类&lt;?&gt;…parameterTypes) Constructor getDeclaredConstructors(类&lt;?&gt;…parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() ③ 获取成员方法们 Method[] getMethods() Method getMethods(String name,类&lt;?&gt;…parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethods(String name,类&lt;?&gt;…parameterTypes) ④ 获取类名 String name Field：成员变量 1234操作：1. 设置值 void set(Object obj,Object value)2. 获取值 get(Object obj)3. 忽略访问权限修饰符的安全检查 setAccessible(true)：暴力反射，在反射机制中不存在什么public，private等之类的权限概念 Constructor：构造方法 12创建对象： T newInstance(Object... initargs)如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 Method：方法对象 12执行方法：Object invoke(Object obj,Object... args)获取方法名称： 举例说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package org.AhriLove;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflerctDemo2&#123; public static void main(String[] args) throws Exception &#123; // 0.获取字节码对象 Class personClass = Person.class; // 1.Field[] getFields()获取所有的public修饰的成员变量 Field[] fields = personClass.getFields(); for (Field field:fields) &#123; System.out.println(field); &#125; System.out.println(\"-----------------\"); // 2.获取构造方法 Constructor constructor = personClass.getConstructor(String.class,int.class); System.out.println(constructor); // 全参创建对象 Object people = constructor.newInstance(\"成都\",150); System.out.println(people); // 空参创建对象 Constructor constructor2 = personClass.getConstructor(); Object people2 = constructor2.newInstance(); System.out.println(people2); System.out.println(\"-----------------\"); // 3. 获取指定名称的方法 Method eat_method = personClass.getMethod(\"eat\"); Person person = new Person(); // 执行方法 eat_method.invoke(person); Method eat_method2 = personClass.getMethod(\"eat\",String.class); // 执行方法 eat_method2.invoke(person,\"冰欺凌\"); System.out.println(\"------------------\"); // 获取所有的public修饰的方法 Method[] methods = personClass.getMethods(); for (Method method:methods) &#123; System.out.println(method); // 获取方法名称 System.out.println(method.getName()); &#125; System.out.println(\"--------------\"); // 4.获取类名 String className = personClass.getName(); System.out.println(className); &#125;&#125; 反射实际应用: 写一个“框架”，可以帮我们创建任意类的对象，并且执行其中的任意方法，实现原理 将需要创建的对象的全类名和执行的方法定义在配置文件中 在程序加载读取配置文件 使用反射技术来加载文件进内存 创建对象 执行方法 在src目录下创建一个配置pro.properties文件12className=org.AhriLove.PersonmethodName=eat 2.开始完成框架类 3.注解注解的本质其实就是一个接口interface 使用注解注解：放在Java源码的类、方法、字段、参数前的一种特殊的“注释” 1234567891011121314151617181920212223// 自定义一个注解（新建一个Report.java的接口）package com.gearsnet;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)// 注解名为Reportpublic @interface Report &#123; // int类型的type()方法 int type() default 0; String level() default \"info\"; String value() default \"\"; String[] str1() default \"\"; ...&#125; 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 注解的作用 从JVM的角度开看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定 Java的注解可以分为三类： 第一类是由编译器使用的注解，例如： @Override：让编译器检查该方法是否正确地实现了覆写；@SuppressWarnings：告诉编译器忽略此处代码产生的警告。这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类是由工具处理.class文件使用的注解 比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类是在程序运行期能够读取的注解 它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。 定义一个注解时，还可以定义配置参数，配置参数可以包括： 1234所有的基本类型String枚举类型基本类型，String以及枚举的数组 基本格式：数据类型 属性名() default 默认值;注意：虽然叫做属性，但是实际上是一个方法，因为注解本质上也是一个接口，接口是比抽象方法更抽象的抽象方法，它不存在属性名（字段） 因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。 注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。 此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。如果只写注解，相当于全部使用默认值。 举例说明:@Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。 12345678910111213public class Hello &#123; @Check(min=0, max=100, value=55) public int n; @Check(value=99) public int p; @Check(99) // @Check(value=99) public int x; @Check public int y;&#125; 定义注解Java语言使用@interface语法来定义注解（Annotation），它的格式如下： 12345public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。 元注解:实际上就是注解的注解 有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 @Target 最常用的元注解是@Target，使用@Target可以描述Annotation能够作用的位置： 作用于类或接口： ElementType.TYPE 作用于成员变量： ElementType.FIELD 作用于方法：ElementType.METHOD 作用于构造方法：ElementType.CONSTRUCTOR 作用于方法参数：ElementType.PARAMETER 例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)： 123456@Target(ElementType.METHOD)public @interface Report &#123; int type() default 0; String level() default \"info\"; String value() default \"\";&#125; 定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }： 1234567@Target(&#123; ElementType.METHOD, ElementType.FIELD&#125;)public @interface Report &#123; ...&#125; 实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。 @Retention 元注解@Retention定义了Annotation的生命周期： 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期，当前描述的注解会保留到class字节码文件中，并被jvm读取到：RetentionPolicy.RUNTIME。 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解： 1234567// 作用于运行期阶段@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; int type() default 0; String level() default \"info\"; String value() default \"\";&#125; @Repeatable 使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛 @Inherited 使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效： 1234567@Inherited@Target(ElementType.TYPE)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 在使用的时候，如果一个类用到了@Report： 123@Report(type=1)public class Person &#123;&#125; 则它的子类默认也定义了该注解： 12public class Student extends Person &#123;&#125; 注解总结如何定义Annotation，我们总结一下定义Annotation的步骤： 第一步，用@interface定义注解：注解名为Report，新建一个名为Report的接口 123Report.javapublic @interface Report &#123;&#125; 第二步，添加参数、默认值： 格式为：数据类型 属性名() default 默认值; 123456public @interface Report &#123; // 数据类型 属性名() default 默认值 int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。 第三步，用元注解配置注解： 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;&#125; 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 处理注解我们接下来思考如何解析获取注解中的内容~通过优化反射上面的案例：创建任意类的对象，并且执行其中的任意方法 创建一个自定义的注解： Report.java 1234567891011121314package com.gearsnet;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Report &#123; // String类型的className属性(实际上为抽象方法) String className() default \"\"; String methodName() default \"\";&#125; 创建一个Person对象：Person.java 123456789101112131415161718192021222324public class Person &#123; private String name; private int age; public String lover; public Person() &#123;&#125; public String getName() &#123;return name;&#125; public void setName(String name) &#123;this.name = name;&#125; public int getAge() &#123;return age;&#125; public void setAge(int age) &#123;this.age = age;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public static void show()&#123; System.out.println(\"hello world!!!\"); &#125;&#125; 创建一个AnnotationDemo.java 1234567891011121314151617181920212223242526272829303132333435package com.gearsnet;import java.lang.reflect.Method;/** 注解赋值：与注解定义类的属性相同* 数组的赋值：使用一个大括号来包裹数组集* */@Report(type = 1,level = \"best\",str1 = &#123;\"abc\",\"chd\"&#125;,className = \"com.gearsnet.Person\",methodName = \"show\")public class AnnotationDemo &#123; public static void main(String[] args) throws Exception &#123; // 1. 获取该类的字节码文件对象 Class&lt;AnnotationDemo&gt; annotation = AnnotationDemo.class; // 2. 获取注解内容 Report report = annotation.getAnnotation(Report.class); // 3. 调用注解对象中的抽象方法 System.out.println(report.className()); System.out.println(report.methodName()); // 4.加载进内存 Class cls = Class.forName(report.className()); // 5. 创建对象 Object obj = cls.newInstance(); // 6.获取方法的对象 Method method = cls.getMethod(report.methodName()); // 7.执行方法(执行Person对象中的show方法) method.invoke(obj); /* * 打印内容： com.gearsnet.Person show hello world!!! * */ &#125;&#125; 最终完成了写一个“框架”，可以帮我们创建任意类的对象，并且执行其中的任意方法 小结： 大多数时候，我们会使用注解，而不是定义注解 注解给谁用？ 编译器使用 给解析程序使用 注解不是程序的一部分，相当于一个标签","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章九：ES6特性了解","slug":"Javascript篇章九","date":"2020-05-08T16:00:00.000Z","updated":"2021-11-27T03:09:22.771Z","comments":true,"path":"2020/05/09/Javascript篇章九/","link":"","permalink":"https://ahrilove.top/2020/05/09/Javascript%E7%AF%87%E7%AB%A0%E4%B9%9D/","excerpt":"1.异步Promise2.Async/Await3.Module语法","text":"1.异步Promise2.Async/Await3.Module语法 1.异步PromisePromise概述JavaScript的执行环境是单线程。所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。 Promise的介绍和优点：ES6中的Promise 是异步编程的一种方案。从语法上讲，Promise是一个对象，它可以获取异步操作的消息。Promise对象, 可以将异步操作以同步的流程表达出来。使用 Promise 主要有以下好处： 可以很好地解决回调地狱的问题（避免了层层嵌套的回调函数） 语法非常简洁，Promise 对象提供了简洁的API，使得控制异步操作更加容易 回调地狱的举例：假设买菜、做饭、洗碗都是异步的。但真实的场景中，实际的操作流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。这里面就涉及到了多层嵌套调用，也就是回调地狱 Promise基本用法（1）使用new实例化一个Promise对象，Promise的构造函数中传递一个参数。这个参数是一个函数，该函数用于处理异步任务 （2）并且传入两个参数：resolve和reject，分别表示异步执行成功后的回调函数和异步执行失败后的回调函数 （3）通过promise.then()处理返回结果 123456789101112131415161718192021222324252627282930// 带参数的异步请求简单案例function queryData(params) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; let data = &#123; retCode: 0, msg: 'success', data: params &#125;; // 模拟接口返回的数据 if (data.retCode === 0) &#123; // 接口请求成功时调用 resolve(data); &#125; else &#123; // 接口请求失败时调用 reject(&#123; retCode: -1, msg: 'network error', data: params &#125;); &#125; &#125;, 100); &#125;);&#125;queryData(params=\"赖萌蒙\").then((data) =&gt; &#123; // 从 resolve 获取正常结果 console.log('接口请求成功时，走这里'); console.log(data);&#125;).catch(function(data)&#123; // 从 reject 获取异常结果 console.log('接口请求失败时，走这里'); console.log(data);&#125;).finally(() =&gt; &#123; console.log('无论接口请求成功与否，都会走这里');&#125;); Promise对象状态等待状态：pending成功状态：fullfilled失败状态：rejected （1）当new Promise()执行之后，promise对象的状态会被初始化为pending，这个状态是初始化状态。new Promise()这行代码，括号里的内容是同步执行的。括号里定义一个function，function有两个参数：resolve和reject。如下：如果请求成功了，则执行resolve()，此时，promise的状态会被自动修改为fullfilled。如果请求失败了，则执行reject()，此时，promise的状态会被自动修改为rejected （2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2：如果promise的状态为fullfilled（意思是：如果请求成功），则执行function1里的内容如果promise的状态为rejected（意思是，如果请求失败），则执行function2里的内容另外，resolve()和reject()这两个方法，是可以给promise.then()传递参数的 Promise的异步并发Promise 自带的API提供了如下对象方法： Promise.all()：并发处理多个异步任务，所有任务都执行成功，才能得到结果（返回结果的顺序是 Promise.all(promiseArr) 里面promiseArr提供的顺序） Promise.race(): 并发处理多个异步任务，只要有一个任务执行成功，就能得到结果 12345678910111213141516171819202122232425function queryData(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let data = &#123; retCode: 0, msg: 'success', data: url &#125;; // 模拟接口返回的数据 if (data.retCode === 0) &#123; // 接口请求成功时调用 resolve(data); &#125; else &#123; // 接口请求失败时调用 reject(&#123; retCode: -1, msg: 'error', data: url &#125;); &#125; &#125;);&#125;Promise.all([queryData(\"google1.com\"), queryData(\"google2.com\"), queryData(\"google3.com\")]).then((result) =&gt; &#123; console.log(result);&#125;);/*返回的result结果：[ &#123; retCode: 0, msg: 'success', data: 'https://www.baidu.com/' &#125;, &#123; retCode: 0, msg: 'success', data: 'https://www.baidu.com/' &#125;, &#123; retCode: 0, msg: 'success', data: 'https://www.baidu.com/' &#125;]*/ 2.Async/Await任意一个名称都是有意义的，先从字面意思来理解。async是“异步”的简写，而await可以认为是async wait（异步等待）的简写。所以应该很好理解async用于申明一个function是异步的，而await用于等待一个异步方法执行完成。 另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？ async起什么作用 这个问题的关键在于，async 函数是怎么处理它的返回值的！ 我们当然希望它能直接通过return语句返回我们想要的值，但是如果真是这样，似乎就没await什么事了。写段代码来试试，看它到底会返回什么 123456async function testAsync() &#123; return \"hello async\";&#125;const result = testAsync();console.log(result); 可以看到结果返回一个Promise对象。async函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象。如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 async/await的优势在于处理then链 单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。 假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 setTimeout 来模拟异步操作（推荐使用简单for循环和for-in循环） 123456789101112131415161718async function someFunction(items) &#123; for (const i of items)&#123; // 循环执行异步函数，但以串行但方式，即一个任务执行完后再执行另一个任务 const res= await someAPICall(i); console.log('---&gt;', res); &#125;&#125;function someAPICall(param) &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; // 返回结果值 resolve(\"Resolved\" + param); &#125;,param); &#125;);&#125;someFunction(['3000','8000','1000','4000']); 3.Module语法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 CommonJS规范ps：这里说明一下，下列所有的代码演示均为CommonJS规范（即Node.js规范），直接在浏览器上运行会报错 1.模块暴露 我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块 123456789'use strict';let s = 'Hello';function greet(name) &#123; console.log(s + ', ' + name + '!');&#125;module.exports = greet; module.exports把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了 2.模块引入 12345678'use strict';// 引入hello模块:let greet = require('./hello');let s = 'Michael';greet(s); // Hello, Michael! 3.多模块暴露 我们不妨深入♂一下：将某个模块暴露出来，并访问该模块内的多个函数 12345678910111213141516171819// hello.static'use strict';let s = \"hello python\";function conn(name)&#123; console.log(s+','+name+'!'); return(s+\",\"+name+\"!\") &#125;function printer(n)&#123; let ab = []; if(n&gt;=1)&#123; for(let i = 0;i&lt;n;i++)&#123; ab.push(i)&#125; console.log(ab) &#125;else&#123; console.log(\"输入错误\") &#125;&#125;// 将模块暴露出来，以便于其它模块调用，采用对象的形式module.exports =&#123;conn:conn,printer:printer&#125;; 然后我们来访问hello模块，来玩♂一♀玩(注意模块里的函数调用方式) 123456// 主模块mian.static'use strict';let greet = require('./hello');let s = \"chd\";greet.conn(s);greet.printer(10) ES6规范PS：在报错中了解到，是说无法在模块外部使用import语句，因为Module 的加载实现的是es6语法，所以在浏览器加载html文件时，需要在script 标签中加入type=”module”属性。 更全的 ➡ Js模块化导入导出 参考文献 es6之扩展运算符 三个点（…） js的深浅拷贝 Promise入门详解和基本用法 聊聊CommonJS与ES6 Module的使用与区别 五种在循环中使用async/await 的方法 理解 JavaScript的async/await","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ahrilove.top/tags/js/"}],"author":{"name":"陈浩东","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"CSS属性补充(Ⅱ)","slug":"html与css(Ⅳ)","date":"2020-04-25T16:00:00.000Z","updated":"2021-06-01T08:13:20.000Z","comments":true,"path":"2020/04/26/html与css(Ⅳ)/","link":"","permalink":"https://ahrilove.top/2020/04/26/html%E4%B8%8Ecss(%E2%85%A3)/","excerpt":"本章内容： 1.font字体属性设置2.img标签3.position定位属性4.网页添加ico图标5.表单form标签6.transform属性","text":"本章内容： 1.font字体属性设置2.img标签3.position定位属性4.网页添加ico图标5.表单form标签6.transform属性 1.font字体属性 文本对齐方式 12345text-align： left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 inherit 规定应该从父元素继承 text-align 属性的值。 color:设置字体颜色 letter-spacing：字母间距（正为间距增大，负为间距缩小） 设置字体大小： 方式一：1em的默认大小是16px方式二：px（像素）方式三：百分比————————————————px : 我们最基础的单位（像素）em : 相对于当前父节点字体的大小 —- 1em = 父节点字体大小rem: 相对于当前根节点字体的大小 —- 1rem = 根（html）节点字体大小vw: 当前视窗宽度 —- 1vw = 1%视窗宽度vh: 可以理解成当前一个屏幕高度（一页高度） —- 1vh = 1%视窗宽度vmin: vw和vh中较小的那个vmax: vw和vh中较大的那个 拓：HTML中设置字体样式在新的 @font-face 规则中，您必须首先定义字体的名称（比如 myFirstFont），然后指向该字体文件。 1234567891011121314&lt;style&gt; @font-face&#123; /*设置字体名称*/ font-family: myFirstFont; /*导入字体url*/ src: url(\"./sansation_light.woff\");&#125;div&#123; font-family:myFirstFont;&#125;&lt;/style&gt; 2.&lt;img&gt;标签-和h系列标签/p标签还有hr标签不一样，img标签不会独占一行，如果我们手动指定了img标签显示的图片的宽度和高度，有可能会导致图片变形，那么如果又想指定宽度和高度，&lt;img src=”当前电脑图片的路径” width=”200px” height=”200px” /&gt; 又不想让图片发生变形，我们可以只指定宽度或者高度其中的一个值即可 -只要指定了宽度，系统会自动根据宽度计算出高度，只要指定了高度，系统会自动根据高度计算出宽度，并且都是等比拉伸的，也就是说不会变形：&lt;img src=”当前电脑图片的路径” width=”200px” /&gt;&lt;img src=”当前电脑图片的路径” height=”200px” /&gt; 利用border属性来创建缩略图： 1234567img &#123; border: 1px solid #ddd; border-radius: 4px; padding: 5px; width: 40%;&#125;/*&lt;img src=\"paris.jpg\" alt=\"Paris\"&gt;*/ 3.position定位属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postion:relative是相对定位:是相对于前面的容器定位的。这个时候不能用top left在定位,应该用margin。它可以随窗口大小变化。但大小仍然不会变。要是你设置成width:100%;height:100%;这样就会随着窗口变大变小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;postion:absolute是绝对定位:是相对于浏览器的定位，释放自己的位置，以网页坐标原点做一个新的坐标，它不会随着窗口大小变化，只是固定在一个特定的坐标轴上。比如：position：absolute；left:20px;top:80px; 这个容器始终位于距离浏览器左20px,距离浏览器上80px的这个位置。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。 position属性对应的值有： position: static; position: inherit; position: relative; position: absolute; position: fixed; position: sticky;（新的属性值） position：static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 position: relative 相对定位，相对于自己的初始位置，不脱离文档流。也就是说元素框偏移某个距离，元素仍保持其未定位前的形状，它原本所占的空间仍保留 举个例子说明： 1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;style&gt; .container&#123; background-color: #868686; width: 100%; height: 300px; &#125; .content_0&#123; background-color: yellow; width: 100px; height: 100px; &#125; .content_1&#123; background-color: red; width: 100px; height: 100px; position: relative;/* 这里使用了relative */ &#125; .content_2&#123; background-color: black; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content_0\"&gt; &lt;/div&gt; &lt;div class=\"content_1\"&gt; &lt;/div&gt; &lt;div class=\"content_2\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 这时没有设置left、top等属性时，正常出现在normal flow中的位置。接着添加left，top属性： 12345678.content_1&#123; background-color: red; width: 100px; height: 100px; position: relative;/* 这里使用了relative */ left: 40px; top: 40px; &#125; 可以看到，元素（content_1）的位置相对于原位置进行了移动，但原本所占的空间仍占有，position:relative相对定位可适用于微调，微微调动一点 position: absolute &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块(生成绝对定位的元素，其相对于 static 定位以外的第一个父元素进行定位,会脱离normal flow。注意：是除了static外)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MDN描述位：绝对定位不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。 绝对定位会脱离文档流 举例说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;head&gt; &lt;style&gt; .box&#123; width: 100px; height: 100px; background-color: darkgreen; &#125; .container&#123; background-color: #868686; width: 100%; height: 300px; &#125; .content_0&#123; background-color: yellow; width: 100px; height: 100px; &#125; .content_1&#123; background-color: red; width: 100px; height: 100px; position: absolute; /* 这里使用了绝对定位absolute：绝对定位的元素的位置相对于最近的已定位祖先元素，绝对定位可以使用margin属性，也会脱离文档流 这里不仅相对于box1设置left=40px的基础上，再设置了margin-left：100px，即相对于父类box1向左偏了140px 这里不仅相对于box1设置top=40px的基础上，即相对于父类box1向上偏了40px */ top: 40px; margin-left: 100px; left: 40px; &#125; .content_2&#123; background-color: black; width: 100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"content_0\"&gt; &lt;/div&gt; &lt;div class=\"content_1\"&gt; &lt;/div&gt; &lt;div class=\"content_2\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; position:fixedfixed属性会固定元素定位，也会使得元素脱离文档流1234567.box1&#123; position: fixed; right: 2em; bottom: 2em; width: 15em; height: 15em;&#125; 随着页面的滑动，元素仍然固定，始终保持在距离right，bottom为2em位置处，展示效果如下： position定位属性小结： 偏移量（top，bottom，left，right）当元素开启定位（即position属性设置不为static时）以后，通过使用偏移量来设置元素位置，如果开启定位时使用margin或者padding属性的话，则会出错，会带动其它div联动。偏移量top，bottom，left，right，仅在开启定位后才会生效 relative相对定位不会脱离文档流，是相对于元素自身在文档中的原来位置进行偏移 absolute绝对定位会脱离文档流，绝对定位的原点是父元素中最近的一个开启了相对定位的左上角，若父元素都没有开启相对定位，则以根元素（即html标签元素）为参照点 fixed固定定位是一种特殊的绝对定位，也会脱离文档流。唯一不同的是，固定定位永远参照于浏览器的视口进行定位，固定定位不会随着网页的滚动条而滚动 一旦开始position定位元素后，必须使用偏移量（top，bottom，left，right）元素来调整div的位置，绝对不能使用margin，padding 4.网页添加icon图标在head标签中添加：href表示icon文件的相对路径&lt;link rel=”Bookmark” type=”image/x-icon” href=”b/img/icon/favicon.ico” /&gt;&lt;link rel=”icon” type=”image/x-icon” href=”b/img/icon/favicon.ico” /&gt;&lt;link rel=”shortcut icon” type=”image/x-icon” href=”b/img/icon/favicon.ico” /&gt;(推荐) shortcut icon，特指浏览器中地址栏左侧显示的图标，一般大小为16x16，后缀名为.icon；icon，指的是图标，格式可为PNG\\GIF\\JPEG，尺寸一般为16x16、24x24、36x36等。把这个图标放到网站的根目录下就可以了，页面加载时浏览器会自动检索这个图标然后把它加到标题上（当然也可以放在一个页面可以请求到的目录下）。Bookmark，当网站收藏到收藏夹中时，显示在前面的图标。 readme文件的伪徽章样式,参考代码 5.表单form标签&lt;input&gt;标签 定义通用的表单元素,其type类型为： type=”text” 定义单行文本输入框 type=”password” 定义密码输入框 type=”radio” 定义单选框 type=”checkbox” 定义复选框 type=”file” 定义上传文件 form表单需要加上属性enctype=”multipart/form-data” type=”submit” 定义提交按钮 type=”reset” 定义重置按钮 type=”button” 定义一个普通按钮 相关属性介绍： value属性： 定义表单元素的值,此值是数据提交时键的值 name属性： 定义表单元素的名称，此名称是提交数据时的键名 checked: radio 和 checkbox 默认被选中 readonly: 只读. text 和 password disabled: 对所用input都好使. 高级用法：placeholder：1.input类型的文本框提供一种提示（hint）2.可以描述文本框期待用户输入何种内容3.提示语默认显示，当文本框中输入内容时提示语消失4.适合于input标签：text、search、url、email和password等类型 required： 1.规定文本框填写内容不能为空，否则不允许用户提交表单2.适合于input标签：text、search、url、email、password、number、checkbox、radio、file等类型 举一个案例：比较标准的表单格式 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt;&lt;!--action 定义表单数据提交地址--&gt;&lt;form action=\"http://127.0.0.1:8000/post_info\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;!--单行文本框--&gt; &lt;!--设置了required就要求此表单为必填项--&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入账号\" required&gt;&lt;br&gt;&lt;br&gt; &lt;!--密码框--&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;br&gt;&lt;br&gt; &lt;!-- 邮箱Email--&gt; &lt;input type=\"email\" name=\"email\" id=\"Email\" placeholder=\"请输入邮箱\"&gt;&lt;br&gt;&lt;br&gt; &lt;!--单选框--&gt; 性别：&lt;label&gt;&lt;input type=\"radio\" name=\"sex\" value=\"1\"&gt;男&lt;/label&gt; &lt;label&gt;&lt;input type=\"radio\" name=\"sex\" value=\"2\"&gt;女&lt;/label&gt; &lt;!--多选框--&gt; &lt;br&gt;&lt;br&gt; 最喜欢的游戏： &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"LOL\" checked&gt;英雄联盟&lt;/label&gt; &lt;!---默认选中 --&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"shoot\" disabled&gt;喷射战士&lt;/label&gt; &lt;!---无法选择 --&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"zelda\"&gt;塞尔达传说&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"mario\"&gt;马里奥&lt;/label&gt; &lt;!--上传图片--&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"file\" name=\"pic\"&gt; &lt;!--多行文本框--&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=\"text\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;!--下拉列表--&gt; &lt;br&gt;&lt;br&gt; &lt;select name=\"city\"&gt; &lt;option value=\"gz\" selected&gt;广州&lt;/option&gt; &lt;!-- 表示默认选中 --&gt; &lt;option value=\"sz\" disabled&gt;深圳&lt;/option&gt; &lt;!-- 表示无法选择 --&gt; &lt;option value=\"zh\"&gt;中山&lt;/option&gt; &lt;option value=\"hz\"&gt;杭州&lt;/option&gt; &lt;option value=\"cd\"&gt;成都&lt;/option&gt; &lt;/select&gt; &lt;!--提交表单--&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;!--重置表单--&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;!--- 点击提交到目标网址后：http://localhost:63343/FioraLove_Blog/demo.html?username=AhriLove&amp;password=chen654321&amp;sex=1&amp;fav=shoot&amp;pic=&amp;text=hello+world&amp;city=gz--&gt; tips：1.HTML下的表单标签中的&lt;input&gt;便签的value属性：定义表单元素的值,此值是数据提交时键的值2.单选框radio与多选框checkbox的name，type属性必须要全部一样，value值可以不一样，因为value值定义表单元素的值,此值是数据提交时键的值 6.transform属性Transform属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。语法：transform：none|transform-function (紧跟在 -webkit-, -ms- 或 -moz- 前的数字为支持该前缀属性的第一个浏览器版本号) 123456div&#123; transform:rotate(7deg); -ms-transform:rotate(7deg); /* 在IE 9 浏览器上生效 */ -webkit-transform:rotate(7deg); /* 在Safari and Chrome上生效 */&#125; -webkit、-ms-transform常见属性： none：定义不进行转换 rotate(30deg):旋转角度 translate(50px,200px);定义2D转换，进行平移 scale（）：进行缩放","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/lovezhuge.jpg"}},{"title":"CSS补充(Ⅰ)","slug":"html与css(Ⅲ)","date":"2020-04-24T16:00:00.000Z","updated":"2021-06-01T07:58:54.000Z","comments":true,"path":"2020/04/25/html与css(Ⅲ)/","link":"","permalink":"https://ahrilove.top/2020/04/25/html%E4%B8%8Ecss(%E2%85%A2)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:本章内容： 1.选择器2.transition过渡属性3.outline轮廓属性4.overflow滚动条5.background背景样式","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:本章内容： 1.选择器2.transition过渡属性3.outline轮廓属性4.overflow滚动条5.background背景样式 1.选择器 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开 常见的选择器： 标签选择器：HTML元素以标签名来表示，以 标签名 来定义 id选择器：HTML元素以id属性用来设置id选择器，以 “#id名” 来定义 class选择器：在HTML中以class属性表示, 在 CSS 中，类选择器以一个点 “.class名” 号显示 交集选择器：顾名思义，取交集，选择器之间不能有空格，要紧挨在一起 并集选择器：顾名思义，取并集，选择器用逗号分隔开来 属性选择器：[属性名=属性值]选取含有指定属性的元素 一些特殊的选择器 CSS伪类选择器（用来添加一些选择器的特殊效果） 伪类选择器： a:link - 正常，未访问过的链接a:visited - 用户已访问过的链接a:hover - 当用户鼠标放在链接上时a:active - 链接被点击的那一刻 1234a:link &#123;color:#000000;&#125; /* 未访问链接*/a:visited &#123;color:#00FF00;&#125; /* 已访问链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 鼠标点击时 */ 属性选择器 1234567891011作用：根据元素中的属性或属性值来选取指定元素语法：[属性名]选取含有指定属性的元素​ [属性名=“属性值”]选取含指定属性值的元素​ [属性名^=&quot;属性值&quot;] 选取属性值以指定内容开头的元素​ [属性名$=&quot;属性值&quot;] 选取属性值以指定内容结尾的元素​ [属性名*=&quot;属性值&quot;] 选取属性值包含指定内容的元素 表单选择器 input[type=text] - 选取文本输入框input[type=password] - 选择密码的输入框input[type=number] - 选择数字的输入框 举例说明：搜索输入框带动画 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; input[type=text]&#123; width: 130px; box-sizing: border-box; border: 2px solid #ccc; border-radius: 4px; font-size: 16px; box-shadow: 5px 5px 3px #888888; background-color: white; background-image: url('https://static.runoob.com/images/mix/searchicon.png'); background-position: 10px 10px; background-repeat: no-repeat; padding: 12px 20px 12px 40px; -webkit-transition: width 0.4s ease-in-out; transition: width 0.4s ease-in-out; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;搜索输入框带动画:&lt;/p&gt; &lt;form&gt; &lt;input type=\"text\" name=\"search\" placeholder=\"搜索..\" id=\"search\"&gt; &lt;/form&gt; &lt;script&gt; window.onload = function()&#123; let a =document.getElementById(\"search\"); a.onfocus = function () &#123; a.style.width = \"100%\" &#125;; a.onblur = function () &#123; a.style.width = \"40%\" &#125;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.transition过渡属性语法： transition: property duration timing-function delay; property 给指定CSS属性的name添加动画过渡效果（eg：width，height） duration transition效果需要指定多少秒或毫秒才能完成 delay 定义transition效果开始的时候 timing-function 指定transition效果的转速曲线 ease:由快到慢到更慢 linear:恒速 ease-in:越来越快 ease-out:越来越慢 ease-in-out:先加速后减速 过渡属性举例说明：将鼠标悬停在一个 div 元素上，逐步改变表格的宽度从 100px 到 300px div{ width:100px; height:100px; background:red; transition:width 2s ease-in-out; -webkit-transition:width 2s ease-in-out; /* Safari */} div:hover{ width:300px; } 3.outline轮廓属性outline（轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 outline-color 规定边框的颜色 outline-style 规定边框的样式 outline-width 规定边框的宽度 outline轮廓属性解决input设置圆角边框的相关问题 123456789101112131415161718192021222324252627 &lt;style&gt; .box&#123; text-align: center; &#125; input &#123; border-radius: 14px; /* 圆角边框 */ width: 20em; height:3em; outline: none; margin: 0; padding: 10px 0; border: 1px solid rgb(180, 180, 180); font-size: 16px; text-align: center; box-shadow: 10px 10px 3px rgba(158,125,35,0.3); &#125; input:hover &#123; border: 1px solid rgb(255, 0, 0); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;input type=\"text\" name=\"search\" id=\"search\" placeholder=\"搜索\"&gt; &lt;/div&gt;&lt;/body&gt; 4.overflow滚动条css样式的overflow-x：对边框中的溢出的内容进行隐藏 123div&#123; overflow-x:hidden;&#125; visible 默认值。超出部分呈现在元素框外面 hidden 裁剪超出部分 scroll 一直显示滚动条，超出部分滚动可见 auto 当超出元素框后，显示滚动条，超出部分滚动可见 inherit 从父元素继承overflow属性做一个简单的小demo： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-image: url(\"../public/images/5927f2c7269aa.jpg\"); background-attachment: fixed; background-size: 100%; &#125; div.ex1 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: scroll; &#125; div.ex2 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: hidden; &#125; div.ex3 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: auto; &#125; div.ex4 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: visible; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;overflow 属性&lt;/h1&gt;&lt;p&gt;如果元素中的内容超出了给定的宽度和高度属性，overflow 属性可以确定是否显示滚动条等行为。&lt;/p&gt;&lt;h2&gt;overflow: scroll:&lt;/h2&gt;&lt;div class=\"ex1\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;h2&gt;overflow: hidden:&lt;/h2&gt;&lt;div class=\"ex2\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;h2&gt;overflow: auto:&lt;/h2&gt;&lt;div class=\"ex3\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;h2&gt;overflow: visible (默认):&lt;/h2&gt;&lt;div class=\"ex4\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Demo展示：这里实现了背景图片的应用，以及css的overflow属性 -webkit-text-size-adjust:none :禁用Webkit内核浏览器的文字大小调整功能 12345故-webkit-text-size-adjust的用法如下：1、当样式表里font-size&lt;12px时，中文版chrome浏览器里字体显示仍为12px，这时可以用 html&#123;-webkit-text-size-adjust:none;&#125;2、-webkit-text-size-adjust放在body上会导致页面缩放失效3、body会继承定义在html的样式4、用-webkit-text-size-adjust不要定义成可继承的或全局的 浏览器内核前缀：Chrome(谷歌浏览器) ：WebKit内核 -webkit-Safari(苹果浏览器) ：WebKit内核 -webkit-Firefox(火狐浏览器) ：Gecko内核 -moz-IE(IE浏览器) ： Trident内核 -ms-Opera(欧朋浏览器) ：Presto内核 -o- CSS中, padding: 0px 0px 0px 0px; 四个0px分别代表什么? padding: 0px 0px 0px 0px; 按顺序分别表示上填充、右填充、下填充、左填充为0px。对应着：padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px; 5.background背景样式12345678910111213141516background-color：背景颜色background-image：背景图片 -- body&#123; background-image:url(&apos;相对路径URL&apos;); &#125;background-repeat：背景样式是否重复 --background-repeat:repeat-x;水平方向重复 --background-repeat:repeat-y;垂直方向重复background-attachment：设置背景图像是否固定或者随着页面的其余部分滚动 --：scroll 默认值，背景随着滚动而滚动 --：fixed 固定图像，不随页面滚动而滚动background-position：right top left bottom (可多个组合)background-size: 规定背景图像的尺寸(100%表示全局展示图片) 拓：背景图片自适应窗口大小案例 123456789101112&lt;!--背景图片自适应窗口大小--&gt;&lt;head&gt;&lt;style&gt; body&#123; background-image: url(./public/images/5bbd6378a1fdc.jpg); background-repeat: no-repeat; background-attachment: fixed; background-size: 100%; position: relative; // 可以选择不写 &#125;&lt;/style&gt;&lt;/head&gt; 参考文献 CSS3中的transition属性详解 CSS选择器汇总（清爽版） 菜鸟教程-CSS选择器","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/lovezhuge.jpg"}},{"title":"Python全栈系列章节更新（十八）：知识点补充（Ⅰ）","slug":"Python全栈系列章节更新（十八）","date":"2020-04-20T16:00:00.000Z","updated":"2022-01-04T03:01:52.566Z","comments":true,"path":"2020/04/21/Python全栈系列章节更新（十八）/","link":"","permalink":"https://ahrilove.top/2020/04/21/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/","excerpt":"本章内容： 1.python的占位符%s,%d,%r,%f2.进制转换3.bytes与str之间的转换4.python的运算符☆☆5.python通过http请求发送soap报文进行webservice接口调用6.python的编码与解码7.python的各种加密：base64加密，md5，RSA…8.python压缩打包文件为zip9.python类的继承和多态","text":"本章内容： 1.python的占位符%s,%d,%r,%f2.进制转换3.bytes与str之间的转换4.python的运算符☆☆5.python通过http请求发送soap报文进行webservice接口调用6.python的编码与解码7.python的各种加密：base64加密，md5，RSA…8.python压缩打包文件为zip9.python类的继承和多态 1.python的占位符 %s代表字符串占位符 %d代表数字占位符，但只能是十进制整数 %f默认保留6为小数位，而第7位根据四舍五入取值 2.进制转换 bin(number) 将十进制转换为二进制 oct(number) 将十进制转换为八进制 hex(number) 将十进制转换为十六进制 bytes(string) 将字符串字节化 ord(string) 将字符转换为ASCII码 chr(number) 将ASCII码转换为字符 二，八，十六进制转换为十进制： 123456&gt;&gt;&gt; int(&apos;0b1101&apos;,2) 13&gt;&gt;&gt; int(&apos;0o226&apos;,8) #00226 0：阿拉伯数字零 o：小写英文字母 o 226：八进制数150&gt;&gt;&gt; int(&apos;0x96&apos;,16)150 2020-10-29 新增：传入数值，转换为目标进制（2、8、10、16、32…） 12345678910# -*- coding:utf-8 -*- def BaseCovert(num, b): return ((num == 0) and \"0\") or (BaseCovert(num // b, b).lstrip(\"0\") + \"0123456789abcdefghijklmnopqrstuvwxyz\"[num % b])if __name__ == '__main__': print(BaseCovert(1603940678816, 32)) # 1elp50v50 3.bytes与str之间的转换bytes 和 str 的区别:bytes 存储字节( 通常值在 range(0, 256))str 存储unicode字符( 通常值在0~65535) 123456789101112131415# bytes objectb = b&quot;example&quot;# str objects = &quot;example&quot;解码(decode)bytes ----------&gt; str: 存在两种方式1. str(b, encoding = &quot;utf-8&quot;)2. bytes.decode(b)编码(encode)str ----------&gt; bytes：存在两种方式1. bytes(s, encoding = &quot;utf8&quot;)2. str.encode(s) bytes 与 str 的转换编码(encode)str ———-&gt; bytesb = s.encode(encoding=’utf-8’) 解码(decode)bytes ———-&gt; strs = b.decode(encoding=’utf-8’) 4.python的运算符位运算符： 运算符 描述 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 竖线 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0，即在末尾补N位0 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数，即删除右侧N位 举例说明： 12345678910111213141516171819202122232425a = 60 # 60 = 11 1100 b = 13 # 13 = 00 1101 （不足前面补零） c = 0 c = a &amp; b; # 12 = 00 1100print &quot;1 - c 的值为：&quot;, c c = a | b; # 61 = 11 1101 print &quot;2 - c 的值为：&quot;, c c = a ^ b; # 49 = 11 0001print &quot;3 - c 的值为：&quot;, c c = ~a; # -61 = 1100 0011print &quot;4 - c 的值为：&quot;, c A = 10 = 0b1010A &lt;&lt; 2 = 0b1010 &lt;&lt; 2 左移直接末尾补零 = 0b101000 = 40(decimal)A = 10 = 0b1010A &gt;&gt; 2 = 0b1010 &gt;&gt; 2 右移直接删除右侧N位数 = 0b10 = 2(decimal) 逻辑运算符 运算符 描述 + 两个对象相加 - 两个对象相减 * 两个对象相乘 / 两个对象相除 % 返回触发的余数 ** x的y次幂 // 返回商的整数部分，向下取整 逻辑运算符 运算符 描述 and 逻辑与，“一假则假” or 逻辑或，“一真为真，都假则假” not 逻辑非，取反义 成员运算符 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False not in 如果在指定的序列中没有找到值返回 True，否则返回 False 比较运算符 运算符 描述 实例 == 等于 比较对象是否相等 != 不等于 比较两个对象是否不相等 (a != b) 返回 True &gt; 大于 返回x是否大于y (a &gt; b) 返回 False &lt; 小于 返回x是否小于y。这分别与特殊的变量True和False等价。(a &lt; b)返回True &gt;= 大于等于 返回x是否大于等于y。 (a &gt;= b) 返回 False &lt;= 小于等于 返回x是否小于等于y。 (a &lt;= b) 返回 True 拓：身份运算符is：is 与 == 区别 is用于判断两个变量引用对象是否为同一个，== 用于判断引用变量的值是否相等 5.python通过http请求发送soap报文进行webservice接口调用 什么是xml？ 摘自百度百科：扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。XML是非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;country&gt; &lt;name&gt;中国&lt;/name&gt; &lt;province&gt; &lt;name&gt;广东&lt;/name&gt; &lt;citys&gt; &lt;city&gt;广州&lt;/city&gt; &lt;city&gt;深圳&lt;/city&gt; &lt;city&gt;珠海&lt;/city&gt; &lt;/citys&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;台湾&lt;/name&gt; &lt;citys&gt; &lt;city&gt;台北&lt;/city&gt; &lt;city&gt;高雄&lt;/city&gt; &lt;/citys&gt; &lt;/province&gt;&lt;/country&gt; 什么是SoapUI？ soapui提供一个工具通过soap/http协议来检查，调用，实现web service和web service的功能/负载/符合性测试。该工具既可作为一个桌面应用软件使用，也可利用插件集成到Eclipse，maven2.X，netbeans 和intellij中使用。即SoapUI是一款测试工具，你可以等同于Postman 什么是soap，http协议? http是标准超文本传输协议。使用对参数进行编码并将参数作为键值对传递，还使用关联的请求语义。SOAP（Simple Object AccessProtocol）简单对象访问协议。它是轻型协议，用于分散的、分布式计算环境中交换信息。SOAP有助于以独立于平台的方式访问对象、服务和服务器。它借助于XML，提供了HTTP所需的扩展。 SOAP与HTTP的区别: 都是底层的通信协议，请求包的格式不同，soap包是XML格式,http纯文本格式 soap可以传递结构化的数据，http只能传输纯文本数据； soap：简单对象访问协议；http是标准超文本传输协议 soap相对http（post/get）由于要进行xml解析，速度可能会有所降低。 总结：HTTPService基于http协议，而WebService基于soap协议。soap 就是xml 的格式传输，Http是传输协议，soap不是传输协议，只是按照约定的方式封装消息 ———————————————— 通过http请求发送soap报文调用webservice webservice的接口长什么样？ 很多api接口的后缀需要加 ?wsdlapi: http://www.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?wsdl 我们要明确知道，发送的soap报文也是xml，webservice也是xml数据格式 ★★★★ 要调用webservice接口的前提必须是请求头有如下三个值： Content-type：指定数据类型 Content-length：传入数据长度 SOAPAction：soap协议的动作或叫做方法（把webservice的api接口在浏览器输入并访问，文本内容中就有SoapAction） 123456789101112131415161718192021222324252627282930import requests# 发送给webservice的请求体数据send_webservice_data = '''&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ser=\"http://service.inf.oa.ztesoft.com\"&gt; &lt;soapenv:Header/&gt; &lt;soapenv:Body&gt; &lt;ser:Login&gt; &lt;ser:UserName&gt;username&lt;/ser:UserName&gt; &lt;ser:Password&gt;password&lt;/ser:Password&gt; &lt;/ser:Login&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;'''url = \"http://127.0.0.1:8088/mockOaOrderServicePortSoapBinding\"# 构造响应头headers = &#123; \"User-Agent\": \"Python Post\", \"Content-type\": \"text/xml; charset=UTF-8\", \"Content-length\": \"%d\" % len(send_webservice_data), \"SOAPAction\": \"UFIDA.U9.Cust.DoubleRing.ProjectSV/ICreateProject/Do\"&#125;\"\"\"发送webservice请求，获取响应信息\"\"\"response = requests.post(url, headers=headers, data=send_webservice_data, verify=False)xml_data = response.textprint(xml_data) 6.python的编码与解码python3默认编码为unicode（utf-8是其的一种扩展，两者本质相同，只是收集字数不同），由str类型进行表示。二进制数据使用byte类型表示，所以不会将str和byte混在一起。在实际应用中我们经常需要将两者进行互转. encode和decode分别指编码和解码。在python中，Unicode类型是作为编码的基础类型，即： 1234567891011 decode encodebytes ---------&gt; str(Unicode) ---------&gt; bytesu = &apos;中文&apos; #指定字符串类型对象ustr = u.encode(&apos;gb2312&apos;) #以gb2312编码对u进行编码，获得bytes类型对象stru1 = str.decode(&apos;gb2312&apos;) #以gb2312编码对字符串str进行解码，获得字符串类型对象u1u2 = str.decode(&apos;utf-8&apos;) #如果以utf-8的编码对str进行解码得到的结果，将无法还原原来的字符串内容with open(&apos;text.text&apos;,&apos;r+&apos;,encoding=&apos;utf-8&apos;) as f: #必须事先知道文件的编码格式，这里文件编码是使用的utf-8 content = f.read()#如果open时使用的encoding和文件本身的encoding不一致的话，那么这里将将会产生错误 f.write(&apos;你想要写入的信息&apos;) 关于一些奇奇怪怪的字符编码处理😓😓😓 strings.encode(‘raw_unicode_escape’).decode() 用来处理形如这种反人类字符：éç»äººè¡¨ç®çé¿å å­åè¶(æå­ strings.encode(“utf-8”).decode(“unicode_escape”) 用来处理形如这种的Unicode字符：\\u002F 123slashUStr = \"https:\\u002F\\u002Fm.dhgate.com\\u002Fproduct\\u002F427954156.html\"decodedUniChars = slashUStr.encode('utf-8').decode(\"unicode_escape\")print(\"decodedUniChars=\", decodedUniChars) urllib包中parse模块的quote和unquote 用来处理url编码/解码，功能类似于js的encodeURIComponent/decodeURIComponent 12345678from urllib import parse# 这个是js的结果# encodeURIComponent('中国')# \"%E4%B8%AD%E5%9B%BD\"jsRet='%E4%B8%AD%E5%9B%BD'print(parse.unquote(jsRet)) #输出：中国print(jsRet==parse.quote('中国')) #输出：True 通用字符串解码 当网页使用各种编码格式时，有可能会混编多种编码，以一种编码为主体 语法： text.encode(&#39;网页编码&#39;).decode(&quot;utf-8&quot;, &quot;ignore&quot;) 将网页目标编码转至utf-8编码，添加ignore关键词是自动忽略错误编码，即整体看着是正确的，忽略了部分非主体编码错误 7.python的各种加密7.1 背景关于对称加密与非对称加密，参考文章：https://blog.csdn.net/yangxiaodong88/article/details/80801278 7.2 base64加密 python3 输入的都是 二进制 / byte类型，注意：用于base64编码的，要么是ASCII包含的字符，要么是二进制数据 base64 是对称加密,即这种加密方式是可以被破解的 base64 是 一种用64 个字符来表示任意的二进制数据的方法。base64 可以成为密码学的基石。可以将任意二进制数据进行Base64 编码。 所有的数据都能被编码为并只有64个字符就能表示的文本文件。（ 64字符：A~Z a~z 0~9 + / ）编码后的数据~=编码前数据的4/3，会大1/3左右。 12345678910111213import base64s = 'hello, world'# 加密bs = base64.b64encode(s.encode(\"utf-8\")) # base64加密参数要求是字节型的print(bs.decode(\"utf-8\"))# 解密decode = base64.b64decode(\"target_string\") # 解密后为byte类型print(decode)# 解码：由byte转化为stringprint(decode.decode(\"utf-8\")) 说明：像出现这样的字段“aHR0cXXXXX…” 这类的字符串就是url进行base64编码后的样式 1234567aHR0cHM6Ly94aWFwaS54aWFwaWJ1eS5jb20vc2VhcmNoP2tleXdvcmQ9JUU3JTk0JUI3JUU3JUFCJUE1JUU0JUI4JThBJUU4JUExJUEz ⬇ base64解密https://xiapi.xiapibuy.com/search?keyword=男童上衣https://AhriLove.top ⬇ base64加密aHR0cHM6Ly9BaHJpTG92ZS50b3A= 7.3 md5加密在python3中使用hashlib模块进行md5操作(md5不可逆向破解) 123456789101112import hashlibstrs = \"我真帅\"# 创建一个md5 对象，初始化字符串h1 = hashlib.md5()# 此处必须声明encode# 若写法为hl.update(str) 报错为： Unicode-objects must be encoded before hashingh1.update(strs.encode(\"utf-8\")) # 用提供的字节串更新此哈希对象(hash object)的状态print(\"加密前\", strs)print(\"加密后\", h1.hexdigest()) # 返回摘要值,以十六进制数字字符串的形式print(\"加密后\", h1.digest()) # 返回摘要值,以二进制字节串的形式 拓展： 信息摘要算法 message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。 md5，其实就是一种算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit的串。这个串，基本上是唯一的。 md5特点： 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的 md5的长度：md5的长度，默认为128bit，也就是128个0和1的二进制串。这样表达是很不友好的。所以将二进制转成了16进制，每4个bit表示一个16进制，所以128/4 = 32 换成16进制表示后，为32位了。 为什么网上还有md5是16位的呢？其实16位的长度，是从32位md5值来的。是将32位md5去掉前八位，去掉后八位得到的 关于hexdigest与digest说明 之前我们已经提到过了，hexdigest返回是16进制的字符串，而digest返回二进制byte类型（注意！有一种加密方式是：digest加密的md5结果，然后在经过base64编码） 1234567891011121314151617import base64import hashlibb = \"hello,world\"md5 = hashlib.md5()md5.update(b.encode('utf-8'))b = md5.digest()print(u\"digest的md5加密结果：%s\" % b)print(u\"hexdigest的md5加密结果：%s\" % md5.hexdigest())print(u\"digest的md5加密结果再进行base64编码：%s\" % base64.b64encode(b).decode('utf-8'))\"\"\"digest的md5加密结果：b'&lt;\\xb9\\\\\\xfb\\xe1\\x03[\\xce\\x8cD\\x8f\\xca\\xf8\\x0f\\xe7\\xd9'hexdigest的md5加密结果：3cb95cfbe1035bce8c448fcaf80fe7d9digest的md5加密结果再进行base64编码：PLlc++EDW86MRI/K+A/n2Q==\"\"\" 7.4 sha系列加密常见的sha系列加密有：sha1,sha224,sha256,sha512 12345678import hashlibdef str_encrypt(str): \"\"\" 使用sha1加密算法，返回str加密后的字符串 \"\"\" sha = hashlib.sha1(str.encode(\"utf-8\")) encrypts = sha.hexdigest() return encrypts 7.5 RSA加密☆☆典型的非对称加密，如RSA等，常见方法，使用openssl ,keytools等工具生成一对公私钥对，使用被公钥加密的数据可以使用私钥来解密，反之亦然（被私钥加密的数据也可以被公钥解密) 。 在实际使用中私钥一般保存在发布者手中，是私有的不对外公开的，只将公钥对外公布，就能实现只有私钥的持有者才能将数据解密的方法。 这种加密方式安全系数很高，因为它不用将解密的密钥进行传递，从而没有密钥在传递过程中被截获的风险，而破解密文几乎又是不可能的。 但是算法的效率低，所以常用于很重要数据的加密，常和对称配合使用，使用非对称加密的密钥去加密对称加密的密钥。 前端RSA加密，后端RSA解密： 使用 PKCS1_v1_5，不要用 PKCS1_OAEP,使用 PKCS1_OAEP 的话，前端 jsencrypt.js 加密的数据解密不了 RSA生成公钥私钥 1234567891011121314from Crypto.PublicKey import RSA# rsa算法对象生成rsa_obj = RSA.generate(1024)# pem格式输出私钥private_pem = rsa_obj.exportKey()print(private_pem.decode(\"utf-8\"))print(\"=========================\")# 生成公钥public_key = rsa_obj.publickey()# 将公钥输出成pem格式public_pem = public_key.exportKey()print(public_pem.decode(\"utf-8\")) RSA实现加密解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import base64from Crypto import Randomfrom Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5from Crypto.PublicKey import RSAmessage = b\"this is test\" # 必须为byte型rsa_private_key = b'-----BEGIN RSA PRIVATE KEY-----\\n私钥内容\\n-----END RSA PRIVATE KEY-----\\n'rsa_public_key = b'-----BEGIN PUBLIC KEY-----\\n公钥内容\\n-----END PUBLIC KEY-----\\n'# 加密rsakey = RSA.importKey(rsa_public_key)cipher = Cipher_pkcs1_v1_5.new(rsakey)cipher_text = base64.b64encode(cipher.encrypt(message))print(cipher_text)# 解密rsakey = RSA.importKey(rsa_private_key)cipher = Cipher_pkcs1_v1_5.new(rsakey)random_generator = Random.new().readtext = cipher.decrypt(base64.b64decode(cipher_text), None)print(text.decode('utf-8'))def encrypt(message, public_key): \"\"\" 公钥加密字符串 :param message: string 待加密字符串 :param public_key: string 公钥 :return: \"\"\" public_key = \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCyIyRRm9YVHTQVMhKx4n6z025DCG9M7sR2jI32Obr52FF04QN8C6l...\" key = '-----BEGIN PUBLIC KEY-----\\n' + public_key + '\\n-----END PUBLIC KEY-----' rsa_key = RSA.importKey(key) cipher = Cipher_pkcs1_v1_5.new(rsa_key) encrypt_text = cipher.encrypt(message.encode()) cipher_text = base64.b64encode(encrypt_text) print(cipher_text.decode(\"utf-8\"))if __name__ == '__main__': pub = '\\n'.join([ '-----BEGIN PUBLIC KEY-----', 'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0M', 'ccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdg', 'OQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknr', 'ScAKC0XhadTHT3Al0QIDAQAB', '-----END PUBLIC KEY-----' ]) encrypt(\"this is a test\", public_key=pub) 简介RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。 该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用 几个知识点： 密匙格式：其实就是报文格式不同的区别 PKCS#8 格式公钥 PKCS#1 格式私钥 PEM格式包含几种报文头: 12345&quot;-----BEGIN PUBLIC KEY-----&quot;: PKCS#8 格式公钥&quot;-----BEGIN PRIVATE KEY-----&quot;: PKCS#8 格式私钥&quot;-----BEGIN RSA PUBLIC KEY-----&quot;: PKCS#1 格式公钥&quot;-----BEGIN RSA PRIVATE KEY-----&quot;: PKCS#1 格式私钥 公钥加密、私钥解密、私钥签名、公钥验签 :https://www.cnblogs.com/pcheng/p/9629621.html 私钥密码 密匙长度 1234- 512bit- 1024bit- 2048bit- 4096bit RSA1，RSA2 开放平台签名算法名称 标准签名算法名称 备注 RSA2 SHA256WithRSA 强制要求 RSA 密钥的长度至少为 2048 RSA SHA1WithRSA 对 RSA 密钥的长度不限制，推荐使用 2048 位以上 8.python压缩打包文件为zip1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-# 使用zipfile做目录压缩，解压缩功能import osimport os.pathimport zipfileclass Zip(object): def __init__(self, dirname, zipfilename): self.dirname = dirname self.zipfilename = zipfilename # 压缩功能 def zip_dir(self): filelist = [] if os.path.isfile(self.dirname): filelist.append(self.dirname) else: for root, dirs, files in os.walk(self.dirname): for name in files: filelist.append(os.path.join(root, name)) zf = zipfile.ZipFile(self.zipfilename, \"w\", zipfile.zlib.DEFLATED) for tar in filelist: arc_name = tar[len(self.dirname):] zf.write(tar, arc_name) zf.close()if __name__ == '__main__': zip = Zip(dirname=r'D:\\data\\demo\\weavercapture\\static\\images\\workflow', zipfilename=\"./workflow-吴爱平.zip\") zip.zip_dir() 9.python类的继承和多态1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding:utf-8 -*-class Person(object): def __init__(self, name, age): self.name = name self.age = age def eat(self): print(self.name + \"正在吃：&#123;&#125;岁的海子\".format(self.age)) def run(self): print(self.name + \"已经跑了：&#123;&#125;公里\".format(self.age))class Man(Person): def __init__(self, name, age, gender): # 在创建子类的过程中，你需要手动调用父类的构造函数__init__来完成子类的构造函数 super().__init__(name, age) self.gender = gender def ak(self): print(self.gender) def ab(self): # 当你使用Python super()关键字调用父类方法时时，注意去掉括号里self这个参数 super().run() print(\"正在调用父类的\" + self.name) def eat(self, types=\"千米\"): # 重写父类的方法，即多态 print(\"多态子类\"+self.name + \"：已经跑了&#123;&#125;-&#123;&#125;\".format(self.age, types))if __name__ == '__main__': a = Man(\"chd\", \"18\", \"man\") a.eat() a.run() print(a.gender) a.ak() print(\"=====================\") a.ab() print(\"=====================\") a.eat() 参考文章 Session 和 Cookies 数据格式XML、JSON详解 http协议与soap协议之间的区别 python模拟webservice客户端 python利用pycrypto进行加密解密操作 python3 使用Pycrypto进行RSA加解密 Python笔记-解决安装Crypto后No module named ‘Crypto‘问题 python pycryptodome 加密解密","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/lovezhuge.jpg"}},{"title":"数据分析章节（四）：jieba分词与wordcloud词云","slug":"数据分析章节（四）","date":"2020-04-14T16:00:00.000Z","updated":"2020-07-14T11:56:32.000Z","comments":true,"path":"2020/04/15/数据分析章节（四）/","link":"","permalink":"https://ahrilove.top/2020/04/15/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wordcloud是优秀的词云展示第三方库，以词语为基本单位，通过图形可视化的方式，更加直观和艺术的展示文本。而jieba库是十分优秀的分词三方库，将文本内容进行分词本文内容： 1.jieba库2.wordcloud库3.Windows中文字体文件名称","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wordcloud是优秀的词云展示第三方库，以词语为基本单位，通过图形可视化的方式，更加直观和艺术的展示文本。而jieba库是十分优秀的分词三方库，将文本内容进行分词本文内容： 1.jieba库2.wordcloud库3.Windows中文字体文件名称 1.jieba库pip安装wordcloud，jieba的过程中可能会提示pip工具版本低,需先更新pip包管理工具python -m pip install --upgrade pip jieba库常用函数： jieba.cut(strings,[cut_all])：strings需要分词的字符串；cut_all 参数用来控制是否采用全模式（cut_all=True表示全模式，为False表示精准模式） jieba.cut_for_search(strings) jieba.lcut()或者jieba.lcut_for_search()直接返回 list ps:jieba.cut 以及 jieba.cut_for_search 返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)jieba.lcut 以及 jieba.lcut_for_search 直接返回 list jieba库进行分词后，我们都需要将返回的数组或其它生成器generator，以空格重新拼接成一个新的字符串，将拼接后的新字符串传入wordcloud库制作词云 举例说明： 123456def cut_word(): comment_txt = \"壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。\" split_txt = jieba.cut(comment_txt, cut_all=False) print(split_txt) # &lt;generator object Tokenizer.cut at 0x0000028D12A477C8&gt; wl = \" \".join(split_txt) # 拼接成一个字符串 return wl 2.wordcloud库词云库的基本设置： 设置参数 描述 width 指定词云对象生成图片的宽度，默认400像素； WordCloud(width=600) height 指定词云对象生成图片的高度，默认200像素； WordCloud(height=600) min_font_size 指定词云中的最小字号，默认4号； WordCloud(min_font_size=10) max_font_size 指定词云中的最大字号，根据高度自动调节； WordCloud(max_font_size=20) font_step 指定词云中的字体字号的步进间隔，默认为1； WordCloud(font_step=2) font_path 指定文件的路径，默认None； WordCloud(font_path=“msyh.ttc”) max_words 指定词云现实的最大单词数量，默认200； WordCloud(max_words=20) stop_words 指定词云的排除词列表，即不显示的单词列表； WordCloud(stop_words={“Python”}) mask 遮罩，指定词云形状，默认为长方形；WordCloud(mask=mk) background_color 指定词云图片的背景颜色，默认为黑色； WordCloud(background_color=“white”) 词云库的基本方法： w.generate(string) 向WordCloud对象w中加载字符串，词云能够处理的数据格式为字符串形式；w.generate(“Python and WordCloud”) w.to_file(filename()) 将词云输出为图像文件，.png或.jpg格式；w.tp_file(“outfile,png”) 举例说明： 1234567891011121314151617181920212223242526272829from wordcloud import WordCloudimport numpy as npfrom matplotlib import pyplot as pltfrom PIL import Imagedef create_word_cloud(): \"\"\" 生成词云 :return: \"\"\" # 设置词云形状 shape = np.array(Image.open(r\"C:\\Users\\CHD\\Desktop\\2018.png\")) # 设置词云的基本配置 wc = WordCloud(background_color=\"white\", max_words=1000, width=600, height=600, mask= shape, scale=4, max_font_size=40, random_state=42, font_path=r\"C:\\Windows\\Fonts\\simfang.ttf\") # 生成词云 wc.generate(cut_word()) # 生成图像窗口 plt.figure() # 显示图像的格式 plt.imshow(wc, interpolation='bilinear') plt.axis(\"off\") # 展示图像 plt.show() # 保存词云图片 wc.to_file(\"old_word_cloud.png\") 小结： 文本中含有中文时，必须要字体文件路径font_path，不然无法显示，会出现方框，不出现汉字 设置词云形状时，有些图片会不成功，需要使用色差对比清晰的图片 mask为遮罩，限定词云的形状，选择图片作为遮罩，图片中白色的部分不显示词，非白色部分显示词 图片字迹不清楚的，可以在WordCloud里设置参数scale=4，数字越大图片越清楚，要求电脑配置也就越高 中文需要先分词并组成空格分隔字符串（eg: wl = “ “.join(split_txt) # 拼接成一个字符串） 导入指定词云图片时读取图片的二进制（np.array(Image.open(r”C:\\Users\\CHD\\Desktop\\2018.png”))） 3.Windows中文字体文件名称【Windows 中文字体类型对应的文件名称】 参考文章 python第三方库wordcloud绘制任意形状词云教程 【Python】Windows下用Jieba分词和WordCloud库生成中文词云 wordcloud库与可视化词云以及一些遇到的坑 Python之wordcloud库使用 使用jieba+wordcloud生成微信好友个性签名词云图","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://ahrilove.top/tags/matplotlib/"}]},{"title":"Java(十)：Java字符流，字节流，IO","slug":"Java系列章节更新(十)","date":"2020-04-13T16:00:00.000Z","updated":"2021-10-16T00:32:12.263Z","comments":true,"path":"2020/04/14/Java系列章节更新(十)/","link":"","permalink":"https://ahrilove.top/2020/04/14/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E5%8D%81)/","excerpt":"本章内容： 1.IO概述2.字节流3.字符流4.文件异常的处理","text":"本章内容： 1.IO概述2.字节流3.字符流4.文件异常的处理 1.IO概述 什么是IO 生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了ctrl+s ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。 我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 IO的分类 根据数据的流向分为：输入流和输出流。 输入流*：把数据从其他设备上读取到内存中的流。 输出流*：把数据从内存 中写出到其他设备上的流。 根据数据的类型分为：字节流和字符流。 字节流：以字节为单位，读写数据的流 字符流：以字符为单位，读写数据的流 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 2.字节流一切皆为字节（一切皆字节，让我联想到了在python和js中，一切皆对象；在资本博弈中，一切皆营销）一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 字节流包含InputStream和OutputStream，这两类又是所有字节流的父类。 InputStream类字节输入流InputStream又包含类诸多子类字节流：FileInputStream(写入文件的输入流)、PipedInputStream(输入管道)、FilterInputStream(过滤输出流)。。。 FileInputStreamjava.io.FileInputStream 类是文件输入流，从文件中读取字节到内存中。 方法创建 FileInputStream(File file)：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的 File对象 file命名 FileInputStream(String name)：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的路径名 name命名 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件，会抛出 FileNotFoundException 。 123456// 使用File对象创建流对象File file = new File(&quot;a.txt&quot;);FileInputStream fos = new FileInputStream(file);// 使用文件名称创建流对象FileInputStream fos = new FileInputStream(&quot;b.txt&quot;); 常用方法 方法 描述 void close() 关闭输入流 void mark() 标记输入流的当前位置 void reset() 将读取位置返回到标记处 int read() 从输入流中当前位置读入一个字节的二进制数据，以此数据为低位字节，补足16位的整型量（0~255）后返回，若输入流中当前位置没有数据，则返回-1 int read(byte b[]) 从输入流中的当前位置连续读入多个字节保存在数组中，并返回所读取的字节数 int read(byte b[], int off, int len) 从输入流中当前位置连续读len长的字节，从数组第off+1个元素位置处开始存放，并返回所读取的字节数 int available() 返回输入流中可以读取的字节数 1234567891011121314151617181920212223242526272829303132333435public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\"read.txt\"); // read()类 int b; // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // read(byte[] b)类 int len; // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // read(byte b[], int off, int len)类 int len; // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b, 0, len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125; PS:使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 OutputStream类java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地，它定义了字节输出流的基本共性功能方法。FileOutputStream、PipedOutputStream、FilterOutputStream void close()：关闭此输出流并释放与此流相关联的任何系统资源 void flush()：刷新此输出流并强制任何缓冲的输出字节被写出 void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流 void write(byte[] b, int offset, int len)：从指定的字节数组写入 len字节，从偏移量 offset开始输出到此输出流 abstract void write(int b)：将指定的字节输出流 注：close方法，当完成流的操作时，必须调用此方法，释放系统资源 FileOutputStreamOutputStream超类有很多的子类，FileOutputStream类也是超类中的的一个简单子类，表示文件输出流，用于将数据写出到文件 创建FileOutputStream FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件（推荐使用相对路径）。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会自动创建该文件；如果文件存在，则会清空这个文件的数据。 常用方法 close()：关闭输出流 flush()：强制清空缓冲区并执行向外设输出数据 write(int b)：b表示为一个ASCII码值的字节，每次写入一个字节数据(a-97 A-65) write(byte[] b)：b表示为一个字节型数组，每次写入数组中的数据 write(byte[] b, int offset, int len)：写入指定长度的字节数组，起始索引为offset（默认为0），长度为len字节 调用string.getBytes()方法将字符串转换为字节数组 byte[] b = “hello world”.getBytes(); 123456789101112131415161718192021import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; FileOutputStream fileOutputStream = new FileOutputStream(\"c.txt\"); // 文件写入方式一： fileOutputStream.write(65); // 文件写入方式二： byte[] bytes = &#123;65,69,68,97&#125;; fileOutputStream.write(bytes); // 文件写入方式三： byte[] by = &#123;98,99,105,107&#125;; fileOutputStream.write(by,2,2); // 文件写入方式四：字符串 fileOutputStream.write(\" hello world;hello china!!!\".getBytes()); fileOutputStream.close(); &#125;&#125;// 输出结果：AAEDaik hello world;hello china!!! 数据追加续写： 经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ 12public FileOutputStream(File file, boolean append)：创建文件输出流以写入由指定的 File对象表示的文件public FileOutputStream(String name, boolean append)：创建文件输出流以指定的名称写入文件 这两个构造方法，参数中都需要传入一个boolean类型的append值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了 写出换行： 回车符\\r和换行符\\n ： 回车符：回到一行的开头（return） 换行符：下一行（newline） 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r\\n Unix系统里，每行结尾只有 换行 ，即\\n Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一 12fos.write(97);fos.write(&quot;\\r\\n&quot;.getBytes()); 3.字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符流包含Reader和Writer，这两类又是所有字符流的父类。 Readerjava.io.Reader字符输入流，是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 FileReaderjava.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 创建方式 FileReader(File file)：创建一个新的FileReader，给定要读取的File对象 FileReader(String fileName)：创建一个新的FileReader，给定要读取的文件的名称 当你创建一个流对象时，必须传入一个文件路径，类似于FileInputStream，如果文件不存在则会报错。 123456// 使用File对象创建流对象File file = new File(&quot;a.txt&quot;);FileReader fr = new FileReader(file);// 使用文件名称创建流对象FileReader fr = new FileReader(&quot;b.txt&quot;); 常用方法 void close()：关闭此流并释放与此流相关联的任何系统资源 int read()：从输入流读取一个字符 int read(char[] ch)：从输入流中读取字符数组 读取字符数据： read()方法读取字符：每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314import java.io.FileReader;import java.io.IOException;public class FileReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(\"c.txt\"); int b; while((b = fileReader.read())!= -1)&#123; System.out.print((char)b + \" \"); &#125; fileReader.close(); &#125;&#125;// 结果为：欢 迎 来 到 英 雄 联 盟 ， 敌 军 还 有 三 十 秒 到 达 战 场 ! read(char[] ch)使用字符数组读取文件，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示 1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(\"read.txt\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125;输出结果：黑马程序员 Writerjava.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 FileWrite类Java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 创建方式 12FileWriter(File file)：创建一个新的 FileWriter，给定要读取的File对象FileWriter(String fileName)：创建一个新的 FileWriter，给定要读取的文件的名称 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。构造举例，代码如下： 123456// 使用File对象创建流对象File file = new File(\"a.txt\");FileWriter fw = new FileWriter(file);// 使用文件名称创建流对象FileWriter fw = new FileWriter(\"b.txt\"); 常用方法 void write(int c)：写入单个字符 void write(char[] ch)：写入字符数组 void write(char[] ch, int off, int len)：写入字符数组的某一部分，off数组的开始索引，len写的字符个数 void write(String str)：写入字符串 void write(String str, int off, int len)：写入字符串的某一部分，off字符串的开始索引，len写的字符个数 void flush()：刷新该流的缓冲 void close()：关闭此流，但要先刷新它 数据写入： write(int b):每次可以写出一个字符数据 123456789101112131415161718192021public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象(追加模式) FileWriter fw = new FileWriter(\"fw.txt\", true); // 法一：单字符写入数据 fw.write(97); fw.write('b'); // 法二：字符数组写入数据 char[] chars = \"黑马程序员\".toCharArray(); fw.write(chars); // 法三：字符串写入数据 fw.write(\"china！\"); /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ fw.close(); &#125;&#125; 小结： 字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时使用字符流，其他情况使用字节流 java的字节字符流调用close方法会清空缓存区的内容，也就是flush一下，不过为了保险起见，应该先调用flush()再close() flush():刷新缓冲区，流对象可以继续使用,还可以继续读写 close():先刷新缓存区，告知系统关闭资源，流对象不再使用 4.文件异常的处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示：java的io异常一定要用try…catch…finally，因为直接throws抛出异常是交给jvm，jvm直接中断程序运行，这会导致流对象无法关闭，会占用资源，这是要避免的 12345678910111213141516171819202122public class HandleException1 &#123; public static void main(String[] args) &#123; // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter(\"fw.txt\"); // 写出数据 fw.write(\"黑马程序员\"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（十一）：流(Stream)与文件(File)","slug":"Java系列章节更新(十一)","date":"2020-04-13T16:00:00.000Z","updated":"2021-10-16T03:02:24.681Z","comments":true,"path":"2020/04/14/Java系列章节更新(十一)/","link":"","permalink":"https://ahrilove.top/2020/04/14/Java%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E5%8D%81%E4%B8%80)/","excerpt":"本章内容： 1.输入输出流2.文件与目录管理File类3.缓冲流4.字节缓冲流5.字符缓冲流","text":"本章内容： 1.输入输出流2.文件与目录管理File类3.缓冲流4.字节缓冲流5.字符缓冲流 1.输入输出流在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用System.out.print()格式化输出：如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式： 1234567public class Main&#123; public static void main(String[] args)&#123; double d = 3.1415927; System.out.printf(\"%.2f\",d); System.out.printf(\"%.4f\",d); &#125;&#125; 占位符 说明 %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 输入： 直接看案例输入类型：方法&nbsp;&nbsp;&nbsp;&nbsp; 描述nextBoolean()&nbsp;&nbsp;&nbsp;&nbsp; 从用户输入中读取1个 boolean 值nextByte() &nbsp;&nbsp;&nbsp;&nbsp; 从用户输入中读取1个 byte 值nextDouble()&nbsp;&nbsp;&nbsp;&nbsp; 从用户输入中读取1个 double 值nextFloat()&nbsp;&nbsp;&nbsp;&nbsp; 从用户输入中读取1个 float 值nextInt()&nbsp;&nbsp;&nbsp;&nbsp; 从用户输入中读取1个 int 值nextLine()&nbsp;&nbsp;&nbsp;&nbsp; 从用户输入中读取1个 String 值nextLong() &nbsp;&nbsp;&nbsp;&nbsp;从用户输入中读取1个 long 值nextShort() &nbsp;&nbsp;&nbsp;&nbsp;从用户输入中读取1个 short 值 123456789101112import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(\"Input your name: \"); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(\"Input your age: \"); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // 格式化输出 &#125;&#125; 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头 然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。 有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()；要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 2.文件与目录管理File类Java的标准库java.io提供了File对象来操作文件和目录。我们从之前的知识可以推出java把电脑中的文件和文件夹(目录)封装为了一个File类,我们可以使用File类对文件和文件夹进行操作，并且类中存在构造函数，构造函数里传入的值为文件的路径。要构造一个file对象，需要传入文件路径：构造File对象时，可以是绝对路径（以根目录开头的完整路径），也可以是相对路径 创建File类对象 123File file = new File(path)：path表示文件路径File file = new File(parent-path，child-path)：将父子路径拼接成完成的文件路径File file = new File(File parent，child-path)：将File类型的父级路径和String类型的字节路径拼接成一个新路径，封装成File对象 注意Windows平台使用\\作为路径分隔符，在Java字符串中需要用\\\\表示一个\\。Linux平台使用/作为路径分隔符： 12linux: File f = new File(&quot;/usr/bin/javac&quot;);windows: File f = new File(&quot;C:\\\\Windows\\\\notepad.exe&quot;); File类的动态路径 separator：获取当前系统的文件路径分隔符，windows系统为\\ ，linux系统为”/“ pathSeparator：获取当前系统的环境变量的路径分割符，在UNIX系统上字符为:, 而Windows系统上它是; 1234// 操作路径:路径不能写死了(动态路径)String path = \"C:\"+File.separator+\"develop\"+File.separator+\"a\"+File.separator+\"a.txt\";windows：path为C:\\develop\\a\\a.txtlinux：path为C:/develop/a/a.txt File类的文件和目录操作方法 File对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。 boolean isFile()：判断File对象是否是文件 boolean isDirectory()：判断该File对象是否是已存在的目录 boolean canRead()：是否可读 boolean canWrite()：是否可写 boolean canExecute()：是否可执行 long length()：文件字节大小 boolean exists(): 判断文件或目录是否存在 createNewFile()：当且仅当原文件不存在时才会创建一个新文件（需要处理IOException） mkdir()：创建一个文件夹或者说目录 mkdirs()：既可以创建单级目录也可以创建多级目录，父目录不存在则会自动创建 getAbsolutePath()：返回此File的绝对路径名字符串 getPath()：获取文件完整路径 getName()：返回由此File表示的文件或目录的名称 delete()：删除该文件或目录（直接在硬盘上删除，不走回收站，无法找回，需要谨慎） 绝对路径与相对路径 绝对路径:是一个完整的路径 相对路径:相对路径指的是相对于当前项目的根目录 Java的相对路径读取文件方式： 在Java开发工具的project中使用相对路径 在project中，相对路径的根目录是project的根文件夹创建文件的写法是： 12File f = new File(&quot;src/com/lavasoft/res/a.txt&quot;);File f = new File(&quot;doc/b.txt&quot;); 注意：路径不以“/”开头；脱离了IDE环境，这个写法就是错误的，也并非每个IDE都如此，但我见到的都是这样的。 通过CLASSPATH读取包内文件（推荐）读取包内文件，使用的路径一定是相对的classpath路径，比如a，位于包内，此时可以创建读取a的字节流： InputStream in = ReadFile.class.getResourceAsStream(“/com/lavasoft/res/a.txt”); 注意：这里必须以“/”开头； 通过IDEA开发工具运行代码时，文件路径结果没问题，但如果换成控制台执行，那么使用了项目相对路径的读取方式会失败，原因是，此时已经脱离了项目的开发环境(经测试，确实会在命令行无法使用)—–这个问题常常困扰着一些初学者，代码在开发工具好好的，发布后执行就失败了！ 注意:1.路径是不区分大小写2.路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠 注：java不同于Python，HTML引入文件时可以使用. ：当前文件或 .. ：当前文件的上一级目录，Java的相对路径是以当前的项目的根目录为准。 遍历文件和目录File类遍历(文件夹)目录功能 String[] list()：返回一个String数组，表示该File目录中的所有子文件或目录（获取相对路径） File[] listFiles()：返回一个File数组，表示该File目录中的所有的子文件或目录（获取绝对路径） 1234567891011121314151617181920212223242526272829303132public class Main &#123; public static void main(String[] args) throws IOException &#123; // 初始化File类对象 File f1 = new File(\"src/bytedance/com\"); // 获取相对路径的String数组 String[] f2 = f1.list(); if (f2 != null) &#123; for (String subF: f2) &#123; System.out.println(subF); &#125; &#125; // 获取绝对路径但File类数组 File[] f3 = f1.listFiles(); if (f3 != null) &#123; for (File subF: f3) &#123; System.out.println(subF); &#125; &#125; &#125;&#125;/*程序结果：list类：CollectionDemo.javademo.txtBasicDataType.javaFile类：src/bytedance/com/CollectionDemo.javasrc/bytedance/com/demo.txtsrc/bytedance/com/BasicDataType.java*/ PathJava标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单。如果需要对目录进行复杂的拼接、遍历等操作，使用Path对象更方便： 123456789101112131415public class Main &#123; public static void main(String[] args) throws IOException &#123; Path p1 = Paths.get(\".\", \"project\", \"study\"); // 构造一个Path对象 System.out.println(p1); // .\\project\\study Path p2 = p1.toAbsolutePath(); // 转换为绝对路径 System.out.println(p2); // D:\\data\\demo2\\.\\project\\study Path p3 = p2.normalize(); // 转换为规范路径 System.out.println(p3); // D:\\data\\demo2\\project\\study File f = p3.toFile(); // 转换为File对象 System.out.println(f); // D:\\data\\demo2\\project\\study for (Path p : Paths.get(\"..\").toAbsolutePath()) &#123; // 可以直接遍历Path System.out.println(\" \" + p); &#125; &#125;&#125; 3.缓冲流缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 4.字节缓冲流创建方式： BufferedInputStream(InputStream in)：创建一个新的缓冲输入流 BufferedOutputStream(OutputStream out)：创建一个新的缓冲输出流 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\")); BufferedOutputStreamBufferedOutputStream表示字节缓冲输出流 继承自父类的共性成员方法: public void close()：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush()：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len)：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b)：将指定的字节输出流。 构造方法 123456BufferedOutputStream(OutputStream out)创建一个新的缓冲输出流，以将数据写入指定的底层输出流BufferedOutputStream(OutputStream out, int size)创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流参数:OutputStream out:字节输出流，我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的写入效率int size:指定缓冲流内部缓冲区的大小,不指定默认 使用步骤(重点) 创建FileOutputStream对象,构造方法中绑定要输出的目的地 创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率 使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中 使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中 释放资源(会先调用flush方法刷新数据,第4部可以省略) BufferedInputStream字节缓冲输入流 继承自父类的成员方法: int read()从输入流中读取数据的下一个字节 int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中 void close() 关闭此输入流并释放与该流关联的所有系统资源 构造方法: 12345BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。参数: InputStream in:字节输入流,我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率 int size:指定缓冲流内部缓冲区的大小,不指定默认 使用步骤(重点): 创建FileInputStream对象,构造方法中绑定要读取的数据源 创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率 使用BufferedInputStream对象中的方法read,读取文件 释放资源 普通流与缓存流效率测试： 查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（400MB），测试它的效率 基本的io流，考虑到文件最好选择二进制的字节流来读写 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(\"jdk9.exe\"); FileOutputStream fos = new FileOutputStream(\"copy.exe\") )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"普通流复制时间:\"+(end - start)+\" 毫秒\"); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\")); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\"); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？使用数组的方式 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\")); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\"); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 5.字符缓冲流BufferedWriter字符缓冲输出流 继承自父类的共性成员方法: void write(int c) 写入单个字符 void write(char[] ch)写入字符数组 abstract void write(char[] ch, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数 void write(String str)写入字符串 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数 void flush()刷新该流的缓冲 void close() 关闭此流，但要先刷新它 构造方法: 12345BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。BufferedWriter(Writer out, int size) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。参数: Writer out:字符输出流，我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率 int size:指定缓冲区的大小，不写默认大小 使用步骤: 创建字符缓冲输出流对象,构造方法中传递字符输出流 调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中 调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中 释放资源 1234567891011121314151617public class Demo03BufferedWriter &#123; public static void main(String[] args) throws IOException &#123; //System.out.println(); // 1.创建字符缓冲输出流对象,构造方法中传递字符输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"10_IO\\\\c.txt\")); // 2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中 for (int i = 0; i &lt;10 ; i++) &#123; bw.write(\"传智播客\"); //bw.write(\"\\r\\n\"); bw.newLine(); &#125; // 3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中 bw.flush(); // 4.释放资源 bw.close(); &#125;&#125; BufferedReader字符缓冲输入流 继承自父类的共性成员方法: int read() 读取单个字符并返回 int read(char[] ch)一次读取多个字符,将字符读入数组 void close() 关闭该流并释放与之关联的所有资源 构造方法: 1234BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。BufferedReader(Reader in, int size) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。参数: Reader in:字符输入流，我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率 特有的成员方法: String readLine() 读取一个文本行。读取一行数据，通过下列字符之一即可认为某行已终止：换行 (‘\\n’)、回车 (‘\\r’) 或回车后直接跟着换行(\\r\\n)。返回包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回null 使用步骤: 创建字符缓冲输入流对象,构造方法中传递字符输入流 使用字符缓冲输入流对象中的方法read/readLine读取文本 释放资源 1234567891011121314151617181920212223242526public class Demo04BufferedReader &#123; public static void main(String[] args) throws IOException &#123; // 1.创建字符缓冲输入流对象,构造方法中传递字符输入流 BufferedReader br = new BufferedReader(new FileReader(\"10_IO\\\\c.txt\")); // 2.使用字符缓冲输入流对象中的方法read/readLine读取文本 /*String line = br.readLine(); System.out.println(line); line = br.readLine(); System.out.println(line);*/ /* 发现以上读取是一个重复的过程,所以可以使用循环优化 不知道文件中有多少行数据,所以使用while循环 while的结束条件,读取到null结束 */ String line; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; //3.释放资源 br.close(); &#125;&#125; 参考文章 Java相对路径读取文件","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"sql数据库引发的生产事故案例","slug":"sql系列更新(五)","date":"2020-04-08T16:00:00.000Z","updated":"2020-04-09T05:30:06.000Z","comments":true,"path":"2020/04/09/sql系列更新(五)/","link":"","permalink":"https://ahrilove.top/2020/04/09/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E4%BA%94)/","excerpt":"数据库是每一个IT工程师必备的技能树，通常一些很小错误操作，尤其对生产环境带来很大的经济损失。收集网上大佬分享的数据库重大事故，警示自己，与君共勉。 本文要点：1.Insert into select语句引发的生产事故","text":"数据库是每一个IT工程师必备的技能树，通常一些很小错误操作，尤其对生产环境带来很大的经济损失。收集网上大佬分享的数据库重大事故，警示自己，与君共勉。 本文要点：1.Insert into select语句引发的生产事故 1.Insert into select语句引发的生产事故复制表结构和表数据先参考文献：select into from 和 insert into select 的用法和区别 前言：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Insert into select请慎用。这天xxx接到一个需求，需要将表A的数据迁移到表B中去做一个备份。本想通过程序先查询查出来然后批量插入。但xxx觉得这样有点慢，需要耗费大量的网络I/O，决定采取别的方法进行实现。通过在Baidu的海洋里遨游，他发现了可以使用insert into select实现，这样就可以避免使用网络I/O，直接使用SQL依靠数据库I/O完成，这样简直不要太棒了。然后他就被开除了。 事件经过：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于数据数据库中order_today数据量过大，当时好像有700W了并且每天在以30W的速度增加。所以上司命令xxx将order_today内的部分数据迁移到order_record中，并将order_today中的数据删除。这样来降低order_today表中的数据量。 由于考虑到会占用数据库I/O，为了不影响业务，计划是9:00以后开始迁移，但是xxx在8:00的时候，尝试迁移了少部分数据(1000条)，觉得没啥问题，就开始考虑大批量迁移。 在迁移的过程中，应急群是先反应有小部分用户出现支付失败，随后反应大批用户出现支付失败的情况，以及初始化订单失败的情况，同时腾讯也开始报警。 然后xxx就慌了，立即停止了迁移。本以为停止迁移就就可以恢复了，但是并没有。后面发生的你们可以脑补一下。 解决方案：网友 大鸡腿童鞋：走普通做法就可以了，查询完再插入。越是花里花哨越多问题。通过外部工具或代码来做归档最好。 作者：不一样的科技宅链接：https://juejin.im/post/5e670f0151882549274a65ef来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（九）：Java数据结构基础","slug":"Java数据结构基础（九）","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-09T07:02:50.000Z","comments":true,"path":"2020/04/03/Java数据结构基础（九）/","link":"","permalink":"https://ahrilove.top/2020/04/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89/","excerpt":"本章内容： 1.数据结构简述2.常见的数据结构","text":"本章内容： 1.数据结构简述2.常见的数据结构 1.数据结构有什么作用当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。 现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。 我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。 2.常见的数据结构数据存储的常用结构有：栈，队列，数组，链表和红黑树 栈 Stackstack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 栈的入口、出口的都是栈的顶端位置。 这里两个名词需要注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列 queuequeue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 数组 ArrayArray,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢（每一次增删都会创建一个新数组） 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表链表:linked list,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 我们要说的是二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 红黑树的约束: 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 红黑树的特点: ​ 速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍 参考文章 Java具体实现数据结构代码","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/zhugedali3.jpg"}},{"title":"html页面布局","slug":"html与css(Ⅱ)","date":"2020-03-31T16:00:00.000Z","updated":"2020-07-01T01:13:56.000Z","comments":true,"path":"2020/04/01/html与css(Ⅱ)/","link":"","permalink":"https://ahrilove.top/2020/04/01/html%E4%B8%8Ecss(%E2%85%A1)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们做网页布局时，一般都是用div标签来做页面划分，这时就要考虑到块级元素，内联元素（span）。块级元素在浏览器显示时，通常会以新行来开始（和结束）本章内容： 1.div的margin和padding2.float属性3.默认自带margin或padding的标签4.a标签的链接样式5.table标签的补充6.HTML文本格式化标签7.transform旋转属性","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们做网页布局时，一般都是用div标签来做页面划分，这时就要考虑到块级元素，内联元素（span）。块级元素在浏览器显示时，通常会以新行来开始（和结束）本章内容： 1.div的margin和padding2.float属性3.默认自带margin或padding的标签4.a标签的链接样式5.table标签的补充6.HTML文本格式化标签7.transform旋转属性 1.div的margin和padding&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;margin属性是对div兄弟节点使用的。若div中还有子div节点，使用margin属性后，两个都会同时变化，起不到调整div间距的作用。针对父子div节点，应该使用padding来调整父子div节点的间距（亲测会改变父div尺寸，不建议使用） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在页面重构中，利用margin进行定位非常常见，然而margin-top这个属性经常会给我们带来一定的困扰，有时候不起作用，还把父层“拉”了下来，如图所示 123456789101112131415161718&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;test2&lt;/title&gt;&lt;style&gt;.header &#123; width:300px; height:100px; background: green; &#125;.outer &#123; width:300px; height:300px; background: yellow; &#125;.inner &#123; margin-top:100px; width:100px; height:100px; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 解决方案： 都用float来定位（有条件要求，适用范围较广） 为父元素添加overflow不为visible 的属性 （适用范围极广，推荐使用） 为元素添加border（一般不用） 使用绝对定位（适用范围较窄） 父元素增加padding属性（亲测会改变父div尺寸，不建议使用） float解决方案：要浮动都要浮动；然后就都可以各自使用margin，padding属性；父节点相对于整个文档微调，子节点相对于父节点微调 12345678910111213141516171819202122 &lt;style&gt; .box1&#123; width: 120px; height: 120px; background-color: #48b685; float: left; margin-top: 10px; /*父节点的外边距10px*/ &#125; .box2&#123; margin-top: 20px; /*子节点相对于父节点的外边距20px*/ width: 60px; height: 60px; background-color: #00b0e8; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\"&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; overflow解决方案:为父元素添加overflow不为visible 的属性 1234567891011121314151617181920 &lt;style&gt; .box1&#123; width: 120px; height: 120px; background-color: #48b685; overflow: hidden; /*父元素添加overflow*/ &#125; .box2&#123; margin-top: 20px; width: 60px; height: 60px; background-color: #00b0e8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box1\"&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 小结： 使用 margin:0 auto;的盒子，必须要有width，有明确的width； 只有标准流中的盒子，才能使用 margin:0 auto; 居中，即当一个盒子浮动了，绝对定位了，固定定位了，都不能使用 margin:0 auto; margin:0 auto;是在居中盒子，不是居中文本，文本的居中，用 text-align:center; margin的属性本质上描述的是兄弟标签之间的距离，最好不要用这个属性描述父子之间的距离，描述父子之间距离时要善于使用父亲的padding； IE6兼容性问题解决方案：使浮动方向与margin方向相反； 2.float属性关于浮动的使用一定要注意三个事情：①. 要浮动，所有的兄弟都要浮动两个盒子并排，则两个盒子必须都要设置浮动。不能老大浮动，老二不浮动；老二不浮动，老大也不浮动 ②. 一定要把浮动的元素放在一个div中你看，因为box1与box2要并排，所以它们必须要放到一个div中 12345&lt;div class=\"up\"&gt; &lt;div class=\"box1\"&gt;&lt;/div&gt; &lt;div class=\"box2\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"down\"&gt;&lt;/div&gt; ③. 父盒子要有足够的空间，否则会掉下来 3.默认自带margin或padding的标签12345/* 内外边距通常让各个浏览器样式的表现位置不同（推荐这种写法） */body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td,hr,button,article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section &#123; margin:0; padding:0;&#125; css如果写作*{margin:0;padding:0}作用也是一样的，但是这种写法会使查询速度变慢，现在一般的大公司都使用第一种方法 4.a标签的链接样式链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。特别的链接，可以有不同的样式，这取决于他们是什么状态 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 拓：ul标签，ol标签去掉前面的编码：list-style-type: none; a标签的最重要功能是实现超链接和锚点。而且，大多数人认为a标签最重要的作用是实现超链接，今天我刚好碰到a标签的一种写法&lt;a href=”javascript:;”&gt;，所以就来整理下a标签中href的几种用法: &lt;a href=”javascript:void(0);” οnclick=”js_method()”&gt; 这种方法是很多网站最常用的方法，也是最周全的方法，onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转。而且这种方法不会像第一种方法一样直接将js方法暴露在浏览器的状态栏。 &lt;a href=”javascript:;” οnclick=”js_method()”&gt; 这种方法跟方法一类似，区别只是执行了一条空的js代码。 &lt;a href=”#” οnclick=”js_method()”&gt; 这种方法也是网上很常见的代码，#是标签内置的一个方法，代表top的作用。所以用这种方法点击后网页后返回到页面的最顶端。 a标签的target属性：_black，_self，_top，_parent 5.table标签补充HTML表格由table标签以及一个或多个tr、th或td标签组成： table标签用来定义表格，整个表格包含在&lt;table&gt;和&lt;/table&gt;标签中； tr标签用来定义表格中一个行，它是单元格的容器，每行可以包含有多个单元格，由&lt;tr&gt;和&lt;/tr&gt;标签表示； td标签和th标签用来定义单元格，所有单元格都在tr标签内，每个单元格由一对&lt;td&gt;和&lt;/td&gt;标签或一对&lt;th&gt;和&lt;/th&gt;标签表示，具体的表格内容放置在这一对td标签或th标签之中，其中th标签中的内容默认以粗体、居中的方式显示，以为它代表表格标题。 rowspan属性来实现单元格的跨行操作，所有的浏览器均可支持 colspan属性规定单元格可横跨的列数，所有的浏览器均可支持 123456789101112131415161718&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th colspan=\"3\"&gt;物资详情说明&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" align=\"center\"&gt;数量(支)&lt;/td&gt; &lt;td rowspan=\"2\"&gt;重量(吨)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;实发数&lt;/td&gt; &lt;td&gt;实收数&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;100.00&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 经过渲染后的colspan，rowspan属性展示如下: 物资详情说明 数量(支) 重量(吨) 实发数 实收数 12 10 100.00 6.HTML文本格式化标签 &lt;b&gt;：加粗 &lt;br&gt;：换行 &lt;ins&gt;：插入字 &lt;i&gt;：斜体 &lt;del&gt;：删除字 &lt;em&gt;：着重字 &lt;small&gt;：小写字 &lt;code&gt;：计算机代码 &lt;kbd&gt;：键盘码 &lt;kbd&gt;：预格式文本，显示内容与预设的文本格式一致 7.transform旋转属性默认为顺时针旋转 1234567div&#123; transform:rotate(90deg); -ms-transform:rotate(90deg); /* IE 9 */ -moz-transform:rotate(90deg); /* Firefox */ -webkit-transform:rotate(90deg); /* Safari 和 Chrome */ -o-transform:rotate(90deg); /* Opera */&#125; 参考文献 HTML的表格table属性 HTML表格跨行、跨列操作(rowspan、colspan) margin属性总结","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"margin","slug":"margin","permalink":"https://ahrilove.top/tags/margin/"},{"name":"float","slug":"float","permalink":"https://ahrilove.top/tags/float/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/lovezhuge.jpg"}},{"title":"Python全栈系列章节更新（十五）：Requests库","slug":"Python全栈系列章节更新（十五）","date":"2020-03-20T16:00:00.000Z","updated":"2021-09-06T08:30:50.000Z","comments":true,"path":"2020/03/21/Python全栈系列章节更新（十五）/","link":"","permalink":"https://ahrilove.top/2020/03/21/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/","excerpt":"1.requests的请求方式2.请求参数传递3.响应response4.Cookie和Session5.Cookie基础详细","text":"1.requests的请求方式2.请求参数传递3.响应response4.Cookie和Session5.Cookie基础详细 1.requests请求方式requests库下主要有两个请求方式：POST，GET请求 GET请求 举例说明： 12345import requestsresponse = requests.get(\"http://www.baidu.com\")print(type(response)) # &lt;class ‘requests.models.Response’&gt;print(response.status_code) # 200 将参数写成字典的形式，利用get()方法的参数进行请求，可以动态更改请求参数 123456789101112131415import requests# 普通请求r = requests.get('https://anoyi.com/')# 带 Query 参数，等价于 https://anoyi.com/?key1=value1&amp;key2=value2payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.get('https://anoyi.com/', params=payload)# 带 Headersheaders = &#123;'user-agent': 'anoyi-app/0.0.1'&#125;r = requests.get('https://anoyi.com/', headers=headers)# 带 Basic Authenticationr = requests.get('https://anoyi.com/', auth=('user', 'pass')) POST请求 POST请求可以携带多种形式的参数： request payload(负载) 先将request payload格式的数据写成标准的json数据格式，最后再转换成字符串(json.dumps将数据字符串化，json.loads是将字符串还原成原本的数据格式) 123456789101112import jsonimport requests# request payload数据格式payloadData = &#123; 'afnPriceStr': 10, 'currency':'USD', 'productInfoMapping': &#123; 'asin': 'B072JW3Z6L', 'dimensionUnit': 'inches', &#125;&#125;r = requests.post(url=\"url\", data=json.dumps(payloadData)) application/json application/json格式的请求头是指用来告诉服务端post过去的消息主体是序列化后的 JSON 字符串，但是如果服务器后端支持可以直接传入一个字典的话，就不需要再将数据JSON序列化了 12345678910111213141516171819import jsonimport requests url = 'http://official-account/app/messages/group'body = &#123;\"type\": \"text\", \"content\": \"测试文本\", \"tag_id\": \"20717\"&#125;headers = &#123;'content-type': \"application/json\"&#125; #print type(body)#print type(json.dumps(body))# 这里有个细节，如果body需要json形式的话，需要做处理# 可以是data = json.dumps(body)response = requests.post(url, data = json.dumps(body), headers = headers)# 也可以直接将data字段换成json字段，2.4.3版本之后支持response2 = requests.post(url, json = body, headers = headers)# 返回信息print(response.text)# 返回响应头print(response.status_code) x-www-form-urlencoded(默认格式) 最常见post提交数据的方式，以form表单形式提交数据 reqeusts支持以application/x-www-form-urlencoded数据格式发送post请求，只需要将请求的参数构造成一个字典，然后传给requests.post()的data参数即可。 同时也是支持以键值对的形式来提交数据 1234567891011import requests# 键值对参数headers = &#123;'content-type': 'application/x-www-form-urlencoded; charset=UTF-8'&#125;res = requests.post('https://anoyi.com/', headers=headers, data='key=value')# 字典型参数data = &#123; \"key1\": \"value1\", \"key2\": \"value2\"&#125;rsp = requests.post('https://anoyi.com/', headers=headers, data=data) form-data 除了传统的application/x-www-form-urlencoded表单，我们另一个经常用到的是上传文件用的表单，这种表单的类型为multipart/form-data。 一般用于实现文件上传外，也可同样作为简单form表单发送请求 12345678910111213import requests# 基本 post 请求data = &#123; 'name':'M.Lu', 'age':'22'&#125;response = requests.post(\"http://httpbin.org/post\", data=data)print(response.text)# 文件上传files = &#123;\"file\": open(\"C:/Users/Administrator/Desktop/test.txt\", \"rb\")&#125;res = requests.post(\"http://httpbin.org/post\", files=files) print(res.text) text/xml text/xml可实现对webService发送数据请求 1234import requestsxml = \"\"\"my xml\"\"\"headers = &#123;'Content-Type': 'application/xml'&#125;requests.post('http://www.example.com', data=xml, headers=headers) 其它请求 123456789101112import requests# PUTr = requests.put('https://anoyi.com/', data=&#123;'key':'value'&#125;)# DELETEr = requests.delete('https://anoyi.com/')# HEADr = requests.head('https://anoyi.com/')# OPTIONSr = requests.options('https://anoyi.com/') 2.传递参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是post还是get请求，对url进行请求时，都可以传递参数 headers反爬虫措施的基本操作，将爬虫伪装成正常的浏览器，躲过服务器的验证 123456headers = &#123; &quot;User-Agent&quot;: &quot;&quot;, 浏览器对象 &quot;Cookie&quot;:&quot;&quot;, cookie能够存储浏览器上次访问的信息 &quot;host&quot;:&quot;&quot;, 计算机ip &quot;referer&quot;:&quot;&quot; 引用&#125; timeout超时&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;超时是请求能够容忍的最大时间，如果在这个时间内，还没有响应返回过来，那么这次请求就算失败了，不再继续等待请求的结果。浏览器发送请求后，服务器接受数据处理后，再返回目标数据，这过程中可能因为各种原因导致响应很慢，设置timeout，超时后停止访问response = requests.post(“http://httpbin.org/post&quot;, data=data，timeout = 10) verify证书&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;证书验证也是我们经常会遇到的问题，通常情况下，访问一些网站的时候，都会验证访问者的证书是否合法，如果不合法，就不允许访问。大部分情况，我们之间设置证书验证为 False 即可 1234567891011121314# 有验证response = requests.get(&quot;https://cms.hit.edu.cn/&quot;) # 程序会中断print(response.status_code)# 没有验证response = requests.get(&quot;https://cms.hit.edu.cn/&quot;, verify=False)print(response.status_code)去除 warning 方法from requests.packages import urllib3urllib3.disable_warnings()response = requests.get(&quot;https://cms.hit.edu.cn/&quot;, verify=False)print(response.status_code)cert 手动指定证书response = requests.get(&quot;https://cms.hit.edu.cn/&quot;,cert=&#123;&apos;path/server.crt&apos;, &apos;/path/key&apos;&#125;)print(response.status_code) 当我们设置SSL验证为False时，会弹出很多警告，这时我们就需要新增两行代码： 1234import requestsfrom urllib3.exceptions import InsecureRequestWarning# 禁用安全请求警告requests.packages.urllib3.disable_warnings(InsecureRequestWarning) proxies代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代理也是一个很常用的方法。通常，在我们需要多个主机进行访问或需要绕过防火墙时，可以利用代理进行访问 1234567891011121314151617# 无密码proxies = &#123; &quot;http&quot;:&quot;http://178.128.63.64:8388&quot;&#125;# 有密码proxies = &#123; &quot;http&quot;:&quot;http://user:password@178.128.63.64:8388&quot;&#125;response = requests.get(&quot;https://www.taobao.com&quot;, proxies=proxies)print(response.status_code)# 利用 socks 进行代理设置proxies = &#123; &quot;http&quot;:&quot;socks5://178.128.63.64:8388&quot;, &quot;https&quot;:&quot;socks5://178.128.63.64:8388&quot;&#125;response = requests.get(&quot;https://www.taobao.com&quot;, proxies=proxies)print(response.status_code) 补充：2020-4-13 代理池的设计 今天花了一段时间设计了一个代理池，参考我的GitHub【python代理池设计】 cookiescookies除了放置在headers请求头里之外，也可以使用requests关键字里的cookies={…} cookie放在请求头里发请求和使用requests关键字cookies={…}没有任何区别 1response = requests.post(url=url, headers=headers, data=data, cookies=cookies) 区别cookie放置位置： cookie放在headers中:格式类似于（&quot;key1:value1; key2:value2; key3:value3&quot;） 123headers = &#123; \"Cookie\": \"_octo=GH1.1.162052.1572277627; _ga=GA1.2.579499272.1572277630; tz=Asia%2FShanghai\"&#125; cookie放在requests关键词中的cookies：可以为CookieJar类或者字典格式的cookie stream流文件Bit、 Byte、KB、MB、GB之间的换算: 1 Byte = 8 Bits（即 1B=8b，字节是内存的基本单位）1 KB = 1024 Bytes1 MB = 1024 KB1 GB = 1024 MB Bit意为“位”或“比特”，是计算机运算的基础，属于二进制的范畴；Byte意为“字节”，是计算机文件大小的基本计算单位； 这两者应用的场合不同。通常用bit来作数据传输的单位，因为物理层，数据链路层的传输对于用户是透明的，而这种通信传输是基于二进制的传输。在应用层通常是用byte来作单位，表示文件的大小，在用户看来就是可见的数据大小。比如一个字符就是1byte,如果是汉字，则是2byte 比如常见的音视频，放置某些文件过大，内存溢出 12345response = requests.post(url=url, headers=headers, data=data, cookies=cookies, stream=True) 拓：进度条下载二进制文件 12345678910111213141516171819import sysimport requestsurl = \"https://w.wallha.com/ws/12/uOaBe9fY.MP4\"rsp = requests.head(url)# 获取返回文件的大小size = rsp.headers['Content-Length']# 将字节Byte转换为MBprint(\"文件大小: %.2f MB\" % (int(size) / 1024 / 1024))p = 0rp = requests.get(url, stream=True)with open('./video.mp4', 'wb') as f: # 开始下载每次请求1024字节 for i in rp.iter_content(chunk_size=1024): p += len(i) f.write(i) done = 50 * p / int(size) sys.stdout.write(\"\\r[%s%s] %.2f%%\" % ('█' * int(done), '' * int(50 - done), done + done)) sys.stdout.flush() allow_redirects重定向 Redirect重定向就是通过各种方法将各种网络请求重新定个方向转到其它位置,从地址A跳转到地址 B 了： 重定向状态码: 301 redirect: 301 代表永久性转移(Permanently Moved) 302 redirect: 302 代表暂时性转移(Temporarily Moved) (PS:有时是307 Temporarily) 实际场景： 举个简单的场景案例，先登录博客园打开我的博客首页，进我的随笔编辑界面，记住这地址：https://i.cnblogs.com/EditPosts.aspx?opt=1 ，退出博客园登录，把刚才我的随笔这个地址输入浏览器回车，抓包会看到这个请求状态码是 302，浏览器地址栏瞬间刷新跳到登录首页去了 自动处理重定向地址后，我们就获取不到重定向后的 url 了，就无法走下一步，这里我们可以设置一个参数禁止重定向：allow_redirects=False（allow_redirects=True 是启动重定向），然后就可以看到 status_code 是 302 了,重定向的跳转地址是在返回的请求头中 -301 永久性重定向处理方法 1234import requestsresponse = requests.session.get(url=deal_url, headers=headers, timeout=10)# 获取重定向后的简化urlprint(response.url) 302/307 临时重定向处理方法1234567891011121314151617import requests#禁用安全请求警告from requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)url = \"https://i.cnblogs.com/EditPosts.aspx?opt=1\"headers = &#123;\"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36\"&#125;s = requests.Session()#打开我的随笔r = s.get(url,headers=headers,verify=False,allow_redirects=False)# print(r.content.decode(\"utf-8\"))#打印状态码，自动处理重定向请求print(r.status_code)#获取重定向后的地址print(r.headers[\"Location\"]) 3.响应response&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;响应是浏览器返回过来的信息，它有不同的属性 response.status_code: 状态码，不同的状态码代表了不同的请求状态 response.headers: 获取请求头 response.cookies: 获取cookies response.url: 获取统一资源定位符url（也可以获取重定向后的跳转url） response.text: 获取请求成功后的响应内容，数据类型为字符串型 response.content: 获取请求成功后的响应内容，数据类型为byte型。如果想取图片，文件，则可以通过response.content. response.json(): 返回的是json格式的数据，也就是字典。现在的前后端的数据交互绝大部分都是通过json交互了 4.Cookie和SessionSession对象可以像requests一样调用get和post发起指定的请求，只不过如果使用session发请求的过程中如果产生了cookie，则cookie会被自动存储到该session对象中，那么意味着下一次使用session对象发送请求时，则该次请求就会自动携带cookie进行请求发送。 在爬虫中使用session的时候，session对象至少会被使用几次？ 至少两次：第一次使用session是为了将cookie捕获并存储到session对象中，下次的时候就会自动携带cookie进行发送 12345678910import requests# 两次 get 请求， 没有任何关联，不可以requests.get(\"http://httpbin.org/cookies/set/number/123456789\") # 第一次请求response = requests.get(\"http://httpbin.org/cookies\") # 第二次请求print(response.text)\"\"\"&#123;“cookies”: &#123;&#125;&#125;\"\"\" 我们可以看到利用cookie模拟登陆时，两次访问，没有存储登录的状态。但我们利用 Session 对象，可以模拟登录：第一利用session登录，存储浏览器信息，再发送请求，访问目标网站 1234567891011import requests# Session 对象， 相当于在一个浏览器中先后访问（例如：登录验证）session = requests.Session()result = session.get(\"http://httpbin.org/cookies/set/number/123456789\")response = session.get(\"http://httpbin.org/cookies\")print(response.text)\"\"\"&#123; “cookies”: &#123;“number”: “123456789”&#125;&#125;\"\"\" 5.Cookie基础详细&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由前面我们已经知道了使用requests库的响应中可以获取cookie值，但却存在多种cookie写法 response.cookie获取的是如下这种形式的cookieJar类（此种形式的cookie必须放置在response = requests.post(url=url, headers=headers, data=data, cookies=cookies)里面，而不是像以前一样放置在headers里面） 123456&lt;RequestsCookieJar[ &lt;Cookie X_HTTP_TOKEN=42daf4b72327b2813774136851bf5e71415983ed09 for .lagou.com/&gt;, &lt;Cookie user_trace_token=20200408105933-6470e1a5-1be3-4b1a-85c4-2cf2ced07646 for .lagou.com/&gt;, &lt;Cookie JSESSIONID=ABAAAECABBJAAGIEB8B11EEB347561D234F0B9E026FE063 for www.lagou.com/&gt;, &lt;Cookie SEARCH_ID=aff2447a4a0543a8bed59c906e97ba8a for www.lagou.com/&gt;]&gt; response.cookie.get_dict():就是将cookieJar形式的cookie变为字典格式(字典格式，读取保存为json文件，以此来读写json，然后放置到headers请求头里) { 'X_HTTP_TOKEN': '42daf4b72327b2813774136851bf5e71415983ed09', 'user_trace_token': '20200408105933-6470e1a5-1be3-4b1a2ced07646', 'JSESSIONID': 'ABAAAECABBJAAGIEB8B11EEB347561D234F0B9E026FE063', 'SEARCH_ID': 'aff2447a4a0543a8bed59c906e97ba8a' } requests.utils.dict_from_cookiejar(response.cookies)：同理也是将cookieJar形式的cookie变为字典格式(字典格式，读取保存为json文件，以此来读写json，然后放置到headers请求头里) 案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding:utf-8 -*-import requestsimport osimport json\"\"\"三种Cookie请求方式:第一种：cookie放在headers中第二种：cookie字典传给cookies参数第三种：先发送post请求，获取cookie，带上cookie请求登陆之后的页面\"\"\"# cookie的读取(先判断cookie文件是否存在，若存在直接读取填入headers中，若不存在，则需要模拟登录后保存cookie)COOKIE_PATH = 'xxx.json'# to check whether it existif os.path.exists(COOKIE_PATH): # to load the file of cookie with open(COOKIE_PATH, 'r') as f: cookie_ct = json.loads(f.read()) headers = &#123; 'User-Agent': 'xxxxxx', 'Host': 'www.baidu.com', 'Cookie': cookie_ct, &#125; try: # try to load some website session = requests.session() response = session.get(url='www.baidu.com', headers=headers, timeout=0.1) if response.status_code == 200: print(response.content) except Exception as e: print(e)\"\"\"assume the cookie is not existing:so,we need to send request_POST ,and get the cookies,finally,we should load the website with the cookies \"\"\"headers = &#123; \"User-Agent\": 'dddddddd',&#125;session = requests.session()# the post_url can be found in the form or capture the urlpost_url = 'http://www.renren.com/PLogin.do'data = &#123; 'name': 'chd', 'age': 18, 'password': 'chen111',&#125;res = session.post(url=post_url, headers=headers, data=data, timeout=0.1)# 请求失败抛出if (res.status_code != 200): raise Exception(\"登录失败！\")# 获取cookiecookies_ct = requests.utils.dict_from_cookiejar(session.cookies)# 将cookie保存至本地文件with open(COOKIE_PATH, \"w\",encoding=\"utf-8\") as f: f.write(json.dumps(cookies_ct)) 参考文章 Session 和 Cookies 小白学爬虫（三）– requests库之Cookie Python3使用requests模块显示二进制文件下载进度 Requests方法 – 重定向操作","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"Requests","slug":"Requests","permalink":"https://ahrilove.top/tags/Requests/"}],"author":{"name":"曲率矩阵","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/lovezhuge.jpg"}},{"title":"Javascript篇章八：文档对象模型DOM","slug":"Javascript篇章八","date":"2020-03-10T16:00:00.000Z","updated":"2021-09-18T02:34:02.000Z","comments":true,"path":"2020/03/11/Javascript篇章八/","link":"","permalink":"https://ahrilove.top/2020/03/11/Javascript%E7%AF%87%E7%AB%A0%E5%85%AB/","excerpt":"1.DOM概念2.查找HTML元素节点3.改变HTML4.DOM事件5.事件绑定6.Console对象","text":"1.DOM概念2.查找HTML元素节点3.改变HTML4.DOM事件5.事件绑定6.Console对象 1.DOM概念当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），什么是DOM？ DOM是一项W3C标准，它定义了访问文档的标准：W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问、更新文档的内容、结构和样式。 W3C DOM标准被分为 3 个不同的部分： Core DOM - 所有文档类型的标准模型 XML DOM - XML 文档的标准模型 HTML DOM - HTML 文档的标准模型（HTML DOM是关于如何获取、更改、添加或删除HTML元素的标准） 2.查找HTML元素节点通过 JavaScript，您需要操作HTML元素。为了做到这件事情，您必须首先找到该元素： 通过id查找HTML元素 document.getElementById(“元素节点的唯一id”) 通过标签名来查找元素集合 document.getElementsByTagName(“元素节点的标签名”) 通过class类名来查找元素集合 document.getElementsByClassName(“元素节点的class名”) css选择符模式 document.querySelector() :返回与该模式匹配的第一个元素，结果为一个元素；如果没找到匹配的元素，则返回null css选择符模式 document.querySelectorAll() : 返回与该模式匹配的所有元素，结果为一个类数组 拓：获取HTML的DOM元素节点集合：HTMLCollection对象的 length 属性定义了集合中元素的数量，但它不是一个数组。HTMLCollection看起来可能是一个数组，但其实不是。你可以像数组一样，使用索引来获取元素，但无法使用数组的方法：valueOf、pop、push和join等。 1234let myCollection = document.getElementsByTagName(\"p\");for (let i = 0; i &lt; myCollection.length; i++) &#123; myCollection[i].style.backgroundColor = \"red\";&#125; 3.改变HTML 改变HTML输出流：js能够创建动态的HTML内容，而document.write() 可用于直接向 HTML 输出流写内容 改变HTML内容：document.getElementById(id).innerHTML=新的HTML（推荐） 改变HTML元素属性：document.getElementById(id).attribute=新属性值 改变css：document.getElementById(id).style.property=新样式 123456789101112// 1.改变输出流document.write(\"新页面内容\");// 2.改变html内容document.getElementById(\"username\").innerHTML=\"badwoman\";// 3.改变元素属性document.getElementById(\"image\").src=\"landscape.jpg\";// 4.改变cssdocument.getElementById(\"p2\").style.color=\"blue\";document.getElementById(\"p2\").style.fontFamily=\"Arial\"; 补充：我们已经了解到了改变HTML元素的样式 document.getElementById(“id_name”).属性attribute=新的属性，但是这种方法无法获取我们自定义的style属性，且官方给出了三种方法： 设置节点属性：节点变量.setAttribute(“class”，“box”) 获取节点属性：节点变量.getAttribute(“class”) 移除节点属性：节点变量.removeAttribute(“class”) 4.DOM事件 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 onblur onblur事件会在对象失去焦点时发生，一般用于表单输入框 onfocus onfocus事件会在对象获得焦点时发生，一般用于表单输入框 oncontextmenu oncontextmenu事件鼠标右击时触发，弹出右键菜单 拓展说明： 对onkeydown键盘按键事件的说明 12345678910/** 全局监听键盘按下的键码键盘常用的键码属性为keyCode或者which（which适用于低版本IE），且均不区分键码大小写*/window.onload = function() &#123; window.onkeydown = function(el) &#123; let e = el || window.event; let code = e.keyCode || e.which; console.log(code); &#125;&#125; oncontextmenu返回值设置为false，即无法右击弹出菜单12345window.onload = function() &#123; document.oncontextmenu = function() &#123; return false; &#125;&#125; 小结：HTML DOM事件主要分为几个大类 鼠标事件 键盘事件 框架/对象（Frame/Object）事件 表单事件 剪贴板事件 打印事件 拖动事件 多媒体事件 动画事件 其它事件 5.事件绑定事件绑定有两种方法：内联模式和外联模式 语法： 元素节点.on + 事件类型 = 匿名函数 元素节点.on + 事件类型 = function(){js_code} 123456789101112131415161718&lt;!-- 内联模式 --&gt;&lt;button onclick=\"myFunction('Harry Potter','Wizard')\"&gt;内联模式&lt;/button&gt;&lt;script&gt; function myFunction(name,job)&#123; alert(\"Welcome \" + name + \", the \" + job); &#125;&lt;/script&gt;&lt;!--外联模式：可以将js，HTML分隔开来--&gt;&lt;button id=\"btn2\"&gt;外联模式&lt;/button&gt;&lt;script&gt; window.onload = function()&#123; let btn = document.getElementById(\"btn2\"); btn.onclick = function()&#123; alert(\"外联模式\"); &#125; &#125;&lt;/script&gt; 6.Console对象DOM的Console对象提供了访问浏览器调试模式的信息到控制台（IE6/7/8/9浏览器是没有定义console） count(label) 一般用于计数，记录count调用次数 12345678for(let i = 0; i &lt; 3; i++) &#123; console.count(\"label\");&#125;/** 打印结果label: 1label: 2label: 3*/ log()与info() 控制台输出一条信息；warn()输出警告信息 log除了打印标准的文本信息外，还支持输出图片和彩色文字 123console.log(\"%cPixiviz - v1.24.3\\nBuild time: 2021-08-08 21:32:42\", \"color:#da7a85\");console.log(\"%c \", \"background: url(http://p79mwfmry.bkt.clouddn.com/logo50.jpg) no-repeat center;padding-left:80px;padding-bottom: 80px;border-radius:50%;\")console.log(\"%c \", \"background: url(http://p3i10hjs7.bkt.clouddn.com/console.jpeg) no-repeat center;padding-left:640px;padding-bottom: 242px;\") time(label)与timeEnd(label)联合使用，可作为计时器，用于算出一个操作所花费的准确时间 123456// 循环10w次所需时间console.time(\"循环10w次\");for(let i = 0; i &lt; 1e5; i++) &#123; // js代码&#125;console.timeEnd(\"循环10w次\"); // 循环10w次: 2.9658203125 ms 参考文献 HTML DOM事件大全 window.event对象详细介绍 JS获取子节点、父节点和兄弟节点的方法实例总结 js获取DOM节点的几种方式","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ahrilove.top/tags/js/"}],"author":{"name":"陈浩东","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Json（二）：关于json的前后分离","slug":"json(二)","date":"2020-03-09T16:00:00.000Z","updated":"2020-03-21T05:50:44.000Z","comments":true,"path":"2020/03/10/json(二)/","link":"","permalink":"https://ahrilove.top/2020/03/10/json(%E4%BA%8C)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某天，张先生有一个需求怎么把Java项目打包成一个.exe文件，这样对于其它没有安装JRE的电脑来说也能直接使用。其实我当时想把代码重构为python，张先生在前端HTML页面输入相关数据，然后传入后端flask，处理好了才返回给前端，这就达到了前后分离。搭建一个CI/CD自动化部署，持续集成(CI)、持续部署(CD),可以简化工作流程,提高工作效率。本章内容： 1.json文件的读写2.json作为前后端数据交互3.flask与requests，前端form表单交互","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某天，张先生有一个需求怎么把Java项目打包成一个.exe文件，这样对于其它没有安装JRE的电脑来说也能直接使用。其实我当时想把代码重构为python，张先生在前端HTML页面输入相关数据，然后传入后端flask，处理好了才返回给前端，这就达到了前后分离。搭建一个CI/CD自动化部署，持续集成(CI)、持续部署(CD),可以简化工作流程,提高工作效率。本章内容： 1.json文件的读写2.json作为前后端数据交互3.flask与requests，前端form表单交互 1.json文件的读写&nbsp;&nbsp;&nbsp;&nbsp;由前文可知，当我们读写json文件时，一定要用loads、dumps，不然会报错json.dumps ：将 Python 对象编码成 JSON 字符串json.loads ：将已编码的 JSON 字符串解码为 Python 对象 文件的储存的数据格式只能是字符串，不能为json字符串(python里实际为dict字典)，文件无法存储字典对象 读取json文件： 12345import jsonwith open(\"./demo_json.json\",'r',encoding='utf-8') as f: a = json.loads(f.read())# 打印python对象print(a) 写入json文件：无论写入txt、json文件无非就是open()文件时，需要添加utf-8，dumps()时。带有中文数据时，需要添加ensure_ascii=False，防止ascii中文编码 123import jsonwith open(\"demo_json.json\", 'w', encoding=\"utf-8\") as f: f.write(json.dumps(response, ensure_ascii=False)) 2.json作为前后端数据交互&nbsp;&nbsp;&nbsp;&nbsp;需求：我们用flask作为服务器后端，做一个API，携带目标参数，flask接受POST或GET请求的参数，处理后返回到前端展示&nbsp;&nbsp;&nbsp;&nbsp;请求参数：json数据格式 12345678910request_body = &#123; &quot;username&quot;: &quot;1900201&quot;, &quot;data&quot;: &#123; &quot;age&quot;: 18, &quot;location&quot;: &quot;Hangzhou&quot;, &quot;birthday&quot;: &quot;1997-01-25&quot;, &quot;ip&quot;: [&quot;10.10.11.1&quot;, &quot;10.10.11.2&quot;, &quot;10.10.11.3&quot;], &quot;request-type&quot;: 2 &#125;&#125; 数据发送端：利用requests库，构建一个API，向由flask创建的服务器后端，发送POST数据请求 123456789101112131415161718192021222324252627282930313233343536import jsonimport requests# 定义一个函数 测试一个服务接口def get_info(): # 构造服务接口地址 url = 'http://localhost:9527/' # 构造请求体 请求体将被转换为 JSON 格式 request_body = &#123; \"username\": \"1900201\", \"data\": &#123; \"age\": 18, \"location\": \"Hangzhou\", \"birthday\": \"1997-01-25\", \"ip\": [\"10.10.11.1\", \"10.10.11.2\", \"10.10.11.3\"], \"request-type\": 2 &#125; &#125; try: # 向指定服务接口发送 POST 请求 response = requests.post(url=url, json=request_body) if response.status_code == 200: # 解析 JSON 格式的响应体 并打印 print('Response info:', response.json()) # 将返回的数据写入文件 with open(\"demo_json.json\", 'w', encoding=\"utf-8\") as f: f.write(json.dumps(response.json(), ensure_ascii=False)) return None except Exception as e: print(e)if __name__ == '__main__': get_info() 数据处理端： 拓展（牢记）：flask服务端获取数据方式： data = request.data ：获取的是字符串，得到的是原始提交的数据 data = request.get_data() ：获取的是字符串，得到的是原始提交的数据 data = request.get_json() ：获取 JSON 格式的请求体 username = request.form.get(&quot;username&quot;) 获取前端form表单名为name=”username”的表单数据 password = request.form.get(“password”) 获取前端form表单名为name=”password”的表单数据 12345678910111213141516171819202122232425262728293031323334353637383940414243from flask import Flask, request, jsonify# 创建一个服务app = Flask(__name__)# 声明一个端口APP_PORT = 9527# 创建一个接口 指定路由和请求方法 定义处理请求的函数@app.route(rule='/', methods=['POST', \"GET\"])def index(): if request.method == \"POST\": # 获取 JSON 格式的请求体 并解析 data = request.get_json() print('Request info: ', data) # 解析POST/GET请求传递过来的数据 item = data[\"data\"] # 生成响应信息 response_info = &#123; 'msg': '收到', \"数据\": item &#125; print('Response info:', response_info) # 将响应信息转换为 JSON 格式 response_body = jsonify(response_info) # 最终对请求进行相应 return response_body else: return \"&lt;h1&gt;请使用post请求&lt;/h1&gt;\"# 这种路由模式：&lt;name&gt;尖括号代表传入参数@app.route('/user/&lt;name&gt;')def user(name): return \"&lt;h2&gt; hello python+html, %s&lt;/h2&gt;\" % nameif __name__ == '__main__': # 启动服务 指定主机和端口 app.run(host='127.0.0.1', port=APP_PORT, debug=True) 路由模式Ⅱ：尖括号&lt;name&gt;尖括号代表传入参数 运行结果： 123456789Response info: &#123; &apos;msg&apos;:&apos;收到&apos;, &quot;data&quot;: &#123; &quot;age&quot;: 18, &quot;location&quot;: &quot;Hangzhou&quot;, &quot;birthday&quot;: &quot;1997-01-25&quot;, &quot;ip&quot;: [&quot;10.10.11.1&quot;, &quot;10.10.11.2&quot;, &quot;10.10.11.3&quot;], &quot;request-type&quot;: 2&#125;&#125; 参考文章 Python 使用 flask 库传递 JSON 数据 Flask框架前端后端交互之传递Json数据 【python学习笔记】flask实现简单的接收json返回json的接口 Flask框架基础教程 flask接受前台的form表单数据 flask接受前台Ajax的post请求传递过来的json数据 一个页面上多个form表单的用json数据格式提交到后台","categories":[{"name":"json","slug":"json","permalink":"https://ahrilove.top/categories/json/"}],"tags":[{"name":"json","slug":"json","permalink":"https://ahrilove.top/tags/json/"},{"name":"前后分离","slug":"前后分离","permalink":"https://ahrilove.top/tags/%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（七）：Java的static关键字","slug":"Java的static关键字(七)","date":"2020-03-04T16:00:00.000Z","updated":"2021-10-19T02:58:13.705Z","comments":true,"path":"2020/03/05/Java的static关键字(七)/","link":"","permalink":"https://ahrilove.top/2020/03/05/Java%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97(%E4%B8%83)/","excerpt":"本章内容： 1.static静态关键字概述2.静态变量3.静态方法4.总结","text":"本章内容： 1.static静态关键字概述2.静态变量3.静态方法4.总结","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（十四）：函数基础补充","slug":"Python全栈系列章节更新（十四）","date":"2020-03-02T16:00:00.000Z","updated":"2021-08-25T03:37:38.000Z","comments":true,"path":"2020/03/03/Python全栈系列章节更新（十四）/","link":"","permalink":"https://ahrilove.top/2020/03/03/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/","excerpt":"1.匿名函数2.enumerate内置函数3.列表生成式4.print中的end5.生成器generator6.可迭代对象和迭代器7.Python文件目录路径的选择","text":"1.匿名函数2.enumerate内置函数3.列表生成式4.print中的end5.生成器generator6.可迭代对象和迭代器7.Python文件目录路径的选择 1.匿名函数匿名函数：不需要显示的指定函数名，匿名函数支持的最复杂的运算就是三元运算lambda也是一个简短的匿名函数，格式：lambda 参数 : 表达式 举例说明： 1234x = lambda a, b, c : a + b + cprint(x(5, 6, 2)) # 13func = lambda x,y:x*y # 声明一个匿名函数并赋值给funcprint(func(3,8)) # 输出结果为24 2.enumerate内置函数对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 123456789list1 = [\"这\", \"是\", \"一个\", \"测试\"]for index, item in enumerate(list1): print(index, item)\"\"\"0 这1 是2 一个3 测试\"\"\" 3.列表生成式列表生成式格式：[执行语句 列表生成]: 123456789101112131415161718192021222324252627# 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]# for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]# 用三元运算生成列表&gt;&gt;&gt; a = range(1,11)&gt;&gt;&gt; a = [i if i &lt; 5 else i*i for i in a]&gt;&gt;&gt; a[1, 2, 3, 4, 25, 36, 49, 64, 81, 100]# 使用两层循环，可以生成全排列&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;][&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]# 列表生成式也可以使用两个变量来生成list&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()][&apos;x=A&apos;, &apos;y=B&apos;, &apos;z=C&apos;]# 字符串操作，都变为小写&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;, &apos;IBM&apos;, &apos;Apple&apos;]&gt;&gt;&gt; [s.lower() for s in L][&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过列表生成式可以直接创建一个列表。列表创建在内存中，因此列表容量受到内存限制。特别是对一个元素量很大的列表，仅需访问前几个元素时，尤其浪费空间 4.print中的end为末尾end传递一个空字符串，这样print函数不会在字符串末尾添加一个换行符，而是添加一个空字符串 print默认是打印一行，结尾加换行。end=’’意思是末尾不换行，加空格。 5.生成器generator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列表元素可以按照某种算法推算出来（有规律的数组），则可以在循环的过程中不断推算出后续的元素。这种方式就不必创建完整的list，可以节省大量的空间。python中，这种一边循环一边计算的机制，称为生成器：generator。 生成器创建方法一：将列表生成式的‘[]’改为‘()’ 123456789101112131415161718192021222324252627# 生成器保存的是公式，取一次创建一次，只能往前不能后退&gt;&gt;&gt; a2 = (i for i in range(1000))&gt;&gt;&gt; a2&lt;generator object &lt;genexpr&gt; at 0x103761a98&gt;&gt;&gt;&gt; next(a2)0&gt;&gt;&gt; next(a2)1#生成器走完时，会报错：StopIteration&gt;&gt;&gt; a3 = (i for i in range(5)) # 限制5个&gt;&gt;&gt; a3&lt;generator object &lt;genexpr&gt; at 0x103761e08&gt;&gt;&gt;&gt; next(a3)0&gt;&gt;&gt; next(a3)1&gt;&gt;&gt; next(a3)2&gt;&gt;&gt; next(a3)3&gt;&gt;&gt; next(a3)4&gt;&gt;&gt; next(a3)Traceback (most recent call last): File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;StopIteration 生成器保存的是算法，每次调用next(g)就计算出g的下一个元素的值，直到计算出最后一个元素，没有更多的元素时，抛出StopIteration的错误。 创建生成器后，很少会调用next()，一般是通过for循环来迭代。使用for循环(有且仅有for循环满足)来迭代生成器，不会出现StopIteration报错，直接结束 1234567# 创建一个生成器aa = (i for i in range(10))# a=&lt;generator object demo2.&lt;locals&gt;.&lt;genexpr&gt; at 0x0000026556A46B10&gt;print(a)for i in a: print(i, end=\" \") # end=\"strings\",end表示每行连接格式# 结果为：0 1 2 3 4 5 6 7 8 9 生成器创建方法二：一个函数定义中包含yield关键字，函数为生成器(generator)这种生成器和函数相似，但与函数的执行流程不同： 函数是顺序执行，遇到return语句或最后一行函数语句就返回。 函数转化为生成器后，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; def fib_g(max):... n, a, b = 0, 0, 1... while n &lt; max:... print(&apos;before yield&apos;)... yield b # yield 把函数的执行过程冻结在这一步，并且把b的值返回给外面的next()... print(b)... a, b = b, a+b... n = n + 1... return &apos;done&apos;...&gt;&gt;&gt; f = fib_g(15) # 将函数转换为生成器，有了yeild后，函数名(参数)根本不执行&gt;&gt;&gt; next(f)before yield1&gt;&gt;&gt; next(f)1before yield1&gt;&gt;&gt; next(f)1before yield2&gt;&gt;&gt; next(f)2before yield3&gt;&gt;&gt; next(f)3before yield5 总结： send(“Strings”)方法：①唤醒并继续执行,直到遇到下一个yield ②发送一个信息到生成器内部 next():唤醒冻结的函数执行过程，继续执行，直到遇到下一个yield 6.可迭代对象和迭代器可直接作用于for循环的数据类型有一下几种： 一、集合数据类型，如：list、tuple、dict、set、str等； 二、generator，包括生成器表达式(geneator expression)和生成器函数(generator function)两组构建方式。 上述这些可以直接作用于for循环的对象统称为可迭代对象(Iterable)。 7.Python文件目录路径的选择显示的文件目录用“/”，使用../ 表示的是表示上一级目录（也可以理解为 上一级文件夹，上行一个文件夹；就是文件夹HeadFirstPython/ chapter3往上一级，就到达目录文件夹/Users/barryp） ./ 表示的是当前目录，“../../”表示上上级的目录（上行两个文件夹） 绝对路径：即从最大的根目录开始表示，一直到该文件名。 相对路径：即该文件自己相对于目标（另一个文件）位置。不论将这些文件放到哪里，只要他们的相对关系没有变，就不会出错。 参考文献 python文件目录路径选择","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"https://ahrilove.top/tags/lambda/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（六）：Java正则表达式与多线程基础","slug":"Java多线程基础(六)","date":"2020-02-28T16:00:00.000Z","updated":"2020-03-24T14:34:34.000Z","comments":true,"path":"2020/02/29/Java多线程基础(六)/","link":"","permalink":"https://ahrilove.top/2020/02/29/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80(%E5%85%AD)/","excerpt":"本章内容： 1.正则表达式简介2.多线程3.maven编程","text":"本章内容： 1.正则表达式简介2.多线程3.maven编程 1.正则表达式简介匹配规则正则表达式是一套标准，它可以用于任何语言。Java标准库的java.util.regex包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单注意Java字符串用\\\\表示\\，比如正常的202\\d\\d ,在Java中的202\\\\d\\\\d正则表达式也有特殊字符，比如转义字符\\，对于正则表达式a\\&amp;c来说，对应的Java字符串是a\\\\&amp;c，因为\\也是Java字符串的转义字符，两个\\\\实际上表示的是一个\\：透过现象看本质，Java与python正则表达式关于正则表达式的使用方法是相同的，可以参考使用,注意Java字符串用\\\\表示\\ 正则表达式 规则 可以匹配 A 指定字符 A \\u548c 指定Unicode字符 和 . 任意字符 a，b，&amp;，0 \\d 数字0~9 0~9 \\w 大小写字母，数字和下划线 a~z，A~Z，0~9，_ \\s 空格、Tab键 空格，Tab \\D 非数字 a，A，&amp;，_，…… \\W 非\\w &amp;，@，中，…… \\S 非\\s a，A，&amp;，_，…… A* 任意个数字符 空，A，AA，AAA，…… A+ 至少1个字符 A，AA，AAA，…… A? 0个或1个字符 空，A A{3} 指定个数字符 AAA A{2,3} 指定范围个数字符 AA，AAA A{2,} 至少n个字符 AA，AAA，AAAA，…… A{0,3} 最多n个字符 空，A，AA，AAA ^ 开头 字符串开头 $ 结尾 字符串结束 [ABC] […]内任意字符 A，B，C [A-F0-9xy] 指定范围的字符 A，……，F，0，……，9，x，y [^A-F] 指定范围外的任意字符 非A~F String.matches(regex)方法：只能匹配目标字符串是否满足给定的正则表达式规则，返回值是Boolean类型 12345678910111213public class Main &#123; public static void main(String[] args) &#123; String re1 = \"java\\\\d\"; // 对应的正则是java\\d System.out.println(\"java9\".matches(re1)); System.out.println(\"java10\".matches(re1)); System.out.println(\"javac\".matches(re1)); String re2 = \"java\\\\D\"; System.out.println(\"javax\".matches(re2)); System.out.println(\"java#\".matches(re2)); System.out.println(\"java5\".matches(re2)); &#125;&#125; 分组匹配我们前面讲到的(…)可以用来把一个子规则括起来，这样写learn\\s(java|php|go)就可以更方便地匹配长字符串了。 实际上(…)还有一个重要作用，就是分组匹配。 前面已经了解到String.matches(regex)来判断是否满足目标正则表达式。但是如何提取匹配的子串？这就必须引入java.util.regex包，用Pattern对象匹配，匹配后获得一个Matcher对象，如果匹配成功，就可以直接从Matcher.group(index)返回子串： 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; // 编译解析规则 Pattern p = Pattern.compile(\"(\\\\d&#123;3,4&#125;)\\\\-(\\\\d&#123;7,8&#125;)\"); // 待匹配的字符 Matcher m = p.matcher(\"010-12345678\"); if (m.matches()) &#123; String g1 = m.group(1); String g2 = m.group(2); System.out.println(g1); System.out.println(g2); &#125; else &#123; System.out.println(\"匹配失败!\"); &#125; &#125;&#125; 运行上述代码，会得到两个匹配上的子串010和12345678。 要特别注意，Matcher.group(index)方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是010-12345678，即整个正则匹配到的字符串。 搜索和替换123456789101112131415161718192021222324252627282930313233343536public class Main &#123; public static List&lt;String&gt; regexFind()&#123; // 目标字符串 String s = \"the quick brown fox jumps over the lazy dog.\"; // 正则表达式编译模板 Pattern p = Pattern.compile(\"\\\\wo\\\\w\"); // 编译获取Matcher对象 Matcher m = p.matcher(s); // 创建ArrayList集合，用于存储 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 反复调用find()方法 while (m.find()) &#123; // 在整个串中搜索能匹配上\\\\wo\\\\w规则的子串 String sub = s.substring(m.start(), m.end()); // 将所有的字串添加到集合中 list.add(sub); &#125; return list; &#125; public static void main(String[] args) &#123; // 调用regexFind()方法 List&lt;String&gt; demo = regexFind(); System.out.println(demo); System.out.println(demo.get(0)); System.out.println(demo.get(1)); System.out.println(demo.size()); /* 运行结果： [row, fox, dog] row fox 3 */ &#125;&#125; 我们获取到Matcher对象后，不需要调用matches()方法（因为匹配整个串肯定返回false），而是反复调用find()方法 替换字符串使用正则表达式替换字符串可以直接调用String.replaceAll()，它的第一个参数是正则表达式，第二个参数是待替换的字符串。举例说明：语言格式：strings.replaceAll(“正则表达式规则”,a) 用a替换strings里面的正则表达式规则 1234567public class Main&#123; public static void main(String[] args)&#123; String s = \"the quick brown fox jumps over the lazy dog.\"; return s.replaceAll(\"\\\\s+\",\"--\"); // 运行结果： the--quick--brown--fox--jumps--over--the--lazy--dog. &#125;&#125; 2.多线程进程 vs 线程进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。 和多线程相比，多进程的缺点在于： 创建进程比创建线程开销大，尤其是在Windows系统上； 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。而多进程的优点在于： 多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。 多线程Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。 因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。 和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。 Java多线程编程的特点又在于： 多线程模型是Java程序最基本的并发模型； 后续读写网络、数据库、Web开发等都依赖Java多线程模型。 创建新线程Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行main()方法。在main()方法中，我们又可以启动其他线程。 要创建一个新线程非常容易，我们需要实例化一个Thread实例，然后调用它的start()方法方法一：从Thread派生一个自定义类，然后覆写 创建多线程程序的第一种方式:创建Thread类的子类java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类 实现步骤:1.创建一个Thread类的子类2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要执行什么任务?)3.创建Thread类的子类对象4.调用Thread类中的方法start方法,开启新的线程,执行run方法 拓展：关于start()的说明：void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); // 说明：为什么这里使用start()方法，其实start方法是Thread类的方法 // 但由于MyThread继承了Thread类，便可以使用了 t.start(); // 启动新线程 &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"start new thread!\"); System.out.println(\"我是一个线程中要执行的任务!\"); &#125;&#125; 方法二：创建Thread实例时，传入一个Runnable实例 创建多线程程序的第二种方式:实现Runnable接口java.lang.Runnable：Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。java.lang.Thread类的构造方法： Thread(Runnable target) 分配新的 Thread 对象。 Thread(Runnable target, String name) 分配新的 Thread 对象。 实现步骤: 1.创建一个Runnable接口的实现类 2.在实现类中重写Runnable接口的run方法,设置线程任务 3.创建一个Runnable接口的实现类对象 4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象 5.调用Thread类中的start方法,开启新的线程执行run方法 实现Runnable接口创建多线程程序的好处: 1.避免了单继承的局限性 一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类 实现了Runnable接口,还可以继承其他的类,实现其他的接口 2.增强了程序的扩展性,降低了程序的耦合性(解耦) 实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦) 实现类中,重写了run方法:用来设置线程任务 创建Thread类对象,调用start方法:用来开启新线程 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(new MyRunnable()); t.start(); // 启动新线程 &#125;&#125;// 接口的实现类写法class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"start new thread!\"); &#125;&#125; 方法三：用匿名内部类语法进一步简写： 匿名内部类方式实现线程的创建 匿名:没有名字内部类:写在其他类内部的类 格式: 123new 父类/接口()&#123; 重写父类/接口中的方法&#125;; 匿名内部类作用:简化代码 把子类继承父类,重写父类的方法,创建子类对象合一步完成 把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成匿名内部类的最终产物:子类/实现类对象,而这个类没有名字 123456789101112131415public class Demo01InnerClassThread &#123; public static void main(String[] args) &#123; //线程的父类是Thread // new MyThread().start(); new Thread()&#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+\"黑马\"); &#125; &#125; &#125;.start(); &#125;&#125; 线程的三种创建方式综合演练： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.Alibaba;// 实现三种线程的创建方式public class ThreadDemo &#123; public static void main(String[] args) throws InterruptedException &#123; try &#123; MyThread t1 = new MyThread(); t1.start(); t1.join(); // join方法会抛出编译期异常，必须要try catch或throws来处理异常 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(\"=====\"); // 线程二的创建 Thread t2 = new Thread(new MyRunnable()); t2.start(); t2.join(); // 线程方式三：匿名创建方式 System.out.println(\"=====\"); new Thread() &#123; //重写run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + \"--&gt;\" + \"黑马\" + i); &#125; &#125; &#125;.start(); &#125;&#125;// 创建方式一：创建Thread类的子类，并重写父类的run方法class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 60; i++) &#123; System.out.println(Thread.currentThread().getName() + \"--&gt; 当前数字为：\" + i); &#125; &#125;&#125;// 创建方式二：接口的实现类class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int index = 1; index &lt;= 20; index++) &#123; System.out.println(Thread.currentThread().getName() + \"当前数字为：\" + index); &#125; &#125;&#125; 小结： Java用Thread对象表示一个线程，通过调用start()启动一个新线程； 一个线程对象只能调用一次start()方法； 线程的执行代码写在run()方法中； 线程调度由操作系统决定，程序本身无法决定调度顺序； Thread.sleep()可以把当前线程暂停一段时间，单位是毫秒（Thread.sleep在编译时会出现中断异常InterruptedException，需要使用try catch捕获处理异常） 线程安全当有多个线程抢夺共享数据时就会出现争抢资源的情况（与python的多进程同理），这时就会出现线程安全问题（比如卖票问题就会出现卖出了不存在的票和重复的票的线程安全问题） 解决线程安全问题的一种方案:使用同步代码块 格式: synchronized(锁对象){ 可能会出现线程安全问题的代码(访问了共享数据的代码) } 注意: 1.通过代码块中的锁对象,可以使用任意的对象 2.但是必须保证多个线程使用的锁对象是同一个 3.锁对象作用:把同步代码块锁住,只让一个线程在同步代码 1234567891011121314151617181920212223242526272829303132333435public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建Runnable接口的实现类对象 MyRunnable run = new MyRunnable(); //创建Thread类对象,构造方法中传递Runnable接口的实现类对象 Thread t0 = new Thread(run); Thread t1 = new Thread(run); Thread t2 = new Thread(run); //调用start方法开启多线程 t0.start(); t1.start(); t2.start(); &#125;&#125;class MyRunnable implements Runnable &#123; private int ticket = 100; // 创建一个锁对象 final Object obj = new Object(); @Override public void run() &#123; while(ticket&gt;0)&#123; synchronized (obj)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"正在卖第：\"+ticket+\"票\"); ticket --; &#125; &#125; &#125;&#125; 解决线程安全问题的一种方案:使用Lock锁 包路径：java.util.concurrent.locks.Lock（Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。） Lock接口中的方法: void lock()获取锁。 void unlock() 释放锁。 使用步骤: 在成员位置创建一个ReentrantLock对象（可以采用多态方法：左父右子Lock lock = new ReentrantLock();这是因为java.util.concurrent.locks.ReentrantLock implements Lock接口，实现类继承父类） 在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 举例说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ThreadDemo &#123; public static void main(String[] args) &#123; //创建Runnable接口的实现类对象 MyRunnable run = new MyRunnable(); //创建Thread类对象,构造方法中传递Runnable接口的实现类对象 Thread t0 = new Thread(run); Thread t1 = new Thread(run); Thread t2 = new Thread(run); //调用start方法开启多线程 t0.start(); t1.start(); t2.start(); &#125;&#125;// 创建方式二：接口的实现类class MyRunnable implements Runnable &#123; private int ticket = 100; // 1.在成员位置创建一个ReentrantLock对象 Lock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 lock.lock(); if (ticket &gt; 0) &#123; try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \" 正在卖 第\" + ticket + \"票！\"); ticket--; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁.使用finally，无论程序是否异常,都会把锁释放 lock.unlock(); &#125; &#125; &#125; &#125;&#125; 线程状态 New：新创建的线程，尚未执行； Runnable：运行中的线程，正在执行run()方法的Java代码； Blocked：运行中的线程，因为某些操作被阻塞而挂起； Waiting：运行中的线程，因为某些操作在等待中； Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待； Terminated：线程已终止，因为run()方法执行完毕。 join()方法：优先运行子线程，主线程卡在原地，子线程结束后，运行主线程后面的代码，即join就是指等待该线程结束，然后才继续往下执行自身线程。(join方法会抛出编译期异常，必须要try catch或throws来处理异常)Thread.sleep()方法：线程暂停，时间为毫秒级 守护进程Java程序入口就是由JVM启动main线程，main线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。 如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束 1234// 创建方式：只是在调用start()方法前，调用setDaemon(true)把该线程标记为守护线程Thread t = new MyThread();t.setDaemon(true);t.start(); 线程池线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池的使用步骤： Java里面线程池的顶级接口是java.util.concurrent.Executor （JDK1.5之后提供的），但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 java.util.concurrent.Executors:线程池的工厂类,用来生成线程池，声明线程数量： 123456Executors类中的静态方法:public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池 参数: int nThreads:创建线程池中包含的线程数量 返回值: ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收(面向接口编程) java.util.concurrent.ExecutorService:线程池接口 用来从线程池中获取线程,调用start方法,执行线程任务submit(Runnable task) 提交一个 Runnable 任务用于执行 关闭/销毁线程池的方法:通常不推荐这么做，一旦销毁了进程池，后续就不能再次获取进程了void shutdown() 线程池的使用步骤: 使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类,实现Runnable接口,重写run方法,设置线程任务 调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法 调用ExecutorService中的方法shutdown销毁线程池(不建议执行) 举例说明： 12345678910111213141516171819202122232425262728import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPool &#123; public static void main(String[] args) &#123; //1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 ExecutorService es = Executors.newFixedThreadPool(2); //3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法 es.submit(new RunnableImpl());//pool-1-thread-1创建了一个新的线程执行 //线程池会一直开启,使用完了线程,会自动把线程归还给线程池,线程可以继续使用 es.submit(new RunnableImpl());//pool-1-thread-1创建了一个新的线程执行 es.submit(new RunnableImpl());//pool-1-thread-2创建了一个新的线程执行 es.submit(new RunnableImpl());//pool-1-thread-2创建了一个新的线程执行 es.submit(new RunnableImpl());//pool-1-thread-2创建了一个新的线程执行 System.out.println(\"这是主线程\"); // 优先运行主线程 //4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行) es.shutdown(); es.submit(new RunnableImpl());//抛异常,线程池都没有了,就不能获取线程了 &#125;&#125;// 2.创建一个类,实现Runnable接口,重写run方法,设置线程任务class RunnableImpl implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"：创建了一个新的线程执行\"); &#125;&#125; PS:java的线程，进程与python的线程，进程类似。 对于Python：进程对象的join方法使得主进程在等待子进程运行完毕之后，再运行下一行代码( 而不是主进程先运行代码，等待子进程运行结束 )；而python的线程之间没有先后之分，主线程需要等待子线程全部运行结束后,才能释放掉子线程所占用的资源。主线程代表了一个进程的生命周期,而一个进程一定要等到内部包含的所有线程都运行结束后,才能释放资源 python的 join 会卡住主线程，并让当前已经 start 的子线程继续运行，直到调用.join的这个线程运行完毕 对于Java：线程的join方法优先运行子线程，主线程卡在原地，子线程结束后，运行主线程后面的代码，即join就是指等待该线程结束，然后才继续往下执行自身线程 Java的线程池是不会自动关闭的，若没有shutdown()方法，则进程池文件会一直运行下去 3.Maven基础Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有： 提供了一套标准化的项目结构； 提供了一套标准化的构建流程（编译，测试，打包，发布……）； 提供了一套依赖管理机制。12345678910111213141516a-maven-project├── pom.xml├── src│ ├── main│ │ ├── java│ │ └── resources│ └── test│ ├── java│ └── resources└── targetPs:1.main目录用来存放Java源代码，而test目录用来存放Java测试代码2.resources用来存放配置文件，资源文件（图片，js，css等等）3.pom.xml项目描述文件：groupId类似于Java的包名，artifact类似于Java的类名，version代表版本号4.target 存放所有编译、打包生成的文件 4.lambda表达式Lambda表达式的标准格式: 12345678910由三部分组成: a.一些参数 b.一个箭头 c.一段代码格式: (参数列表) -&gt; &#123;一些重写方法的代码&#125;;解释说明格式: ():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔 -&gt;:传递的意思,把参数传递给方法体&#123;&#125; &#123;&#125;:重写接口的抽象方法的方法体 案例Ⅰ：lambda表达式，实现多线程 1234567891011121314151617181920public class ThreadPool &#123; public static void main(String[] args) &#123; //使用匿名内部类的方式,实现多线程 new Thread()&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\" 新线程创建了\"); &#125; &#125;.start(); //使用Lambda表达式,实现多线程 new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" 新线程创建了\"); &#125; ).start(); //优化省略Lambda new Thread(()-&gt;System.out.println(Thread.currentThread().getName()+\" 新线程创建了\")).start(); &#125;&#125; 案例Ⅱ： 123456789101112131415161718192021222324252627282930public class ThreadPool &#123; public static void main(String[] args) &#123; //调用invokeCook方法,参数是Cook接口,传递Cook接口的匿名内部类对象 invokeCook(new Cook() &#123; @Override public void makeFood() &#123; System.out.println(\"吃饭了\"); &#125; &#125;); //使用Lambda表达式,简化匿名内部类的书写 invokeCook(()-&gt;&#123; System.out.println(\"吃饭了\"); &#125;); //优化省略Lambda invokeCook(()-&gt; System.out.println(\"吃饭了\")); &#125; //定义一个方法,参数传递Cook接口,方法内部调用Cook接口中的方法makeFood public static void invokeCook(Cook cook)&#123; cook.makeFood(); &#125;&#125;// 定一个厨子Cook接口，内含唯一的抽象方法makeFoodinterface Cook &#123; //定义无参数无返回值的方法makeFood public abstract void makeFood();&#125; 参考文献 Maven 与 IntelliJ IDEA 的完美结合 java 使用idea将工程打成jar并创建成exe文件类型执行 Python 进程与子进程，线程与子线程","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（五）：Java面向对象的补充","slug":"Java面向对象补充（五）","date":"2020-02-18T16:00:00.000Z","updated":"2020-04-01T07:27:42.000Z","comments":true,"path":"2020/02/19/Java面向对象补充（五）/","link":"","permalink":"https://ahrilove.top/2020/02/19/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"本章内容： 1.如何创建一个标准的类2.API的概述与使用3.对象型数组4.面向对象的三大特性5.抽象类和抽象方法补充6.接口7.多态性的补充8.final关键字","text":"本章内容： 1.如何创建一个标准的类2.API的概述与使用3.对象型数组4.面向对象的三大特性5.抽象类和抽象方法补充6.接口7.多态性的补充8.final关键字 1.如何创建一个标准的类一个标准的类通常要拥有下面四个部分： 所有的成员变量都要使用private关键字修饰 为每一个成员变量编写一堆Getter/Setter方法 编写一个无参数的构造方法 编写一个全参数的构造方法 举一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.bytedance;public class Pokers &#123; public static void main(String[] args) &#123; // 实例对象创建方式一： Woman w1 = new Woman(); w1.setName(\"迪丽热巴\"); w1.setAge(18); System.out.println(\"姓名：\"+w1.getName()+\",年龄：\"+w1.getAge()); System.out.println(\"========\"); // 实例对象的创建方式二：（推荐，很推荐） Woman w2 = new Woman(\"古力娜扎\",19); System.out.println(\"姓名：\"+w2.getName()+\",年龄：\"+w2.getAge()); System.out.println(\"========\"); // 此时Setter方法也很有用，比如我们想改写一下年纪 w2.setAge(20); System.out.println(\"修改年龄后~\"+\"姓名：\"+w2.getName()+\",年龄：\"+w2.getAge()); &#125;&#125;class Woman&#123; private String name; private int age; // 无参数的构造方法 public Woman()&#123; &#125; // 全参数的构造方法 public Woman(String name,int age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 运行结果：姓名：迪丽热巴,年龄：18========姓名：古力娜扎,年龄：19========修改年龄后~姓名：古力娜扎,年龄：20 2. API的概述与使用导包：import 包路径.类名称只有Java.lang包内的内容不需要导入，其余的API都要手动导入 3.对象型数组对象型数组这一小节不仅能够温习如何创建一个最标准的类，也复习了有关于数组（数组长度不可改变）的一些操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.bytedance;public class objectArray &#123; public static void main(String[] args)&#123; // 创建一个对象数组，即包含对象的数组 People[] people = new People[3]; // 创建三个People对象实例 People p1 = new People(\"迪丽热巴\", 18); People p2 = new People(\"古力娜扎\", 28); People p3 = new People(\"马尔扎哈\", 688); // 将三个people对象赋予到数组中 people[0] = p1; people[1] = p2; people[2] = p3; System.out.println(people[0]); // 打印地址值：com.bytedance.People@2d98a335 System.out.println(people[1]); // 打印地址值：com.bytedance.People@16b98e56 // 调用对象的方法 people[0].sayHello(\"陈浩东\"); // 大家好，我叫迪丽热巴,今年18岁了，喜欢陈浩东 &#125;&#125;// 最标准的类的创建方式如下所示：class People &#123; private String name; private int age; // 无参构造函数 public People() &#123; &#125; // 全参构造函数 public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void sayHello(String lover) &#123; System.out.println(\"大家好，我叫\" + this.name + \",今年\" + this.age + \"岁了，喜欢\" + lover); &#125;&#125; 4.面向对象的三大特性面向对象的三大特性：继承，封装，多态封装性在Java当中的体现： 方法（理解成python中的函数）就是一种封装 关键字private也是一种封装 一旦使用了private进行修饰，只能在本类中随意访问，但是，超出了本类范围就不能直接访问（间接访问private成员变量，就是定义一对getter，setter方法） 对于Getter来说，不能有参数，返回值类型与成员变量对应 对于Setter来说，不能有返回值，参数类型和成员变量对应 对于基本类型当中的Boolean值，Getter方法一定要携程isXXXX的形式，而SetXXX规则不变 12345678910111213141516171819202122232425262728293031323334353637public class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(); ming.setName(\"Xiao Ming\"); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + \", \" + ming.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; // 对参数name进行校验 if (name == null || name.isBlank()) &#123; throw new IllegalArgumentException(\"invalid name\"); &#125; this.name = name.strip(); // 去掉首尾空格 &#125; public int getAge() &#123; return this.age; &#125; public void setAge(int age) &#123; // 对参数age进行校验 if (age &lt; 0 || age &gt; 100) &#123; throw new IllegalArgumentException(\"invalid age value\"); &#125; this.age = age; &#125;&#125; 5.抽象类和抽象方法补充&nbsp;&nbsp;&nbsp;&nbsp;如果父类当中的方法不确定能实现什么具体的方法，那么这应该就是一种抽象方法（通俗的理解，比如求图形的面积计算方法，动物吃东西的方法。这里我们具体确定是什么图形，是三角形？还是正方形？，是比较抽象的一类概念） 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可 如何使用抽象类和抽象方法： 不能直接创建new抽象对象 必须用一个子类来继承抽象父类 子类必须覆盖重写抽象父类当中的所有抽象方法（即子类去掉抽象方法的abstract关键字，然后补上方法体和大括号），否追编译无法通过 创建子类对象进行使用 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的 6.接口接口就是一种公共的规范标准。只要符合标准规范，就可以大家通用（比如插座，U盘）。接口是一种引用数据类型，最重要的内容就是其中的抽象方法。 如何定义一个接口的格式：123public interface 接口名&#123; // 接口内容&#125; 接口内容在任何版本中，接口都能定义抽象方法 2.1 常量 接口当中也可以定义“成员变量”，但必须使用public static final三个关键字进行修饰。从效果上看，这就是接口的常量格式：public static final 数据类型 常量名称 = 数据值 PS： 一旦使用final关键字，就说明不可变 接口当中的常量必须赋值 接口当中的常量的命名规范：使用完全大写的字母，用下划线进行分隔 调用接口名的常量方法：接口名.常量名 2.2 抽象方法 接口中最重要的时抽象方法格式： 1[public] [abstract] 返回值类型 方法名（参数）&#123;方法体&#125; 注意：实现类必须覆盖重写接口的所有的抽象方法，除非实现类是抽象的 2.3 默认方法（接口中的默认方法，可以解决接口升级的问题） 12345678格式：public default 返回值类型 方法名（参数列表）&#123; 方法体 // 默认方法里面可以有方法体&#125;使用：1.接口的默认方法，可以通过接口实现类对象，直接调用2.接口的默认方法，也可以被接口实现类进行覆盖重写 2.4 静态方法 创建格式： 12345格式：public static 返回值类型 方法名称(参数列表)&#123; 方法体&#125;tips：就是将abstract 或者default换成static即可，带上方法体。 注意：1.不能通过实现类的的对象来调用接口当中的静态方法2.正确调用方式：接口名.静态方法名（参数）。与之前学习的static静态方法的调用方式（类名称.静态方法）一样 2.5 私有方法 问题描述：我们需要一个共有方法，用来解决两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的 解决方案：从java9开始，接口当中允许定义私有方法Ⅰ. 普通私有方法，解决多个默认方法之间重复代码问题 123private 返回值类型 方法名（参数列表）&#123; 方法体&#125; Ⅱ. 静态私有方法，解决多个静态方法之间的重复代码问题 123private static 返回值类型 方法名（参数列表）&#123; 方法体&#125; 接口使用步骤 接口不能直接使用，必须有一个“实现类”来“实现”该接口 格式：public class 实现类名 implements 接口名称{…} 接口的实现类必须重写接口中所有的抽象方法（即去掉abstract关键字，加上方法体和大括号） 创建实现类的对象，进行使用（即直接 new 实现类的对象，才能使用）。 接口是没有静态代码块或者构造方法的 Java的类只能单继承，但接口可以implement多个接口接口的小结： 7.多态性的补充代码当中体现多态性，其实就是一句话：父类引用指向子类对象（extends，implement是体现多态性的前提） 格式：父类引用指向子类对象（即以左父右子）父类名称. 对象名 = new 子类名称();或者：接口名称. 对象名 = new 实现类名称() 在多态的代码，父类引用指向子类对象是，即 Fu obj = new Zi() 中： 成员方法的访问规则： 看new的是谁（即看右边），就优先用谁，没有就向上一级找 成员变量的访问规则：Ⅰ. 直接通过对象名称访问成员变量，看等号左边是谁，优先用谁Ⅱ. 间接通过成员方法访问成员变量：看该方法属于谁（假如子类覆盖重写了父类，则通过访问子类调用成员方法来访问成员变量），就优先用谁 12345678910111213141516171819202122232425262728package com.Alibaba;public class Mult &#123; public static void main(String[] args) &#123; Fu1 fu1 = new Zi1(); System.out.println(fu1.num); // 10:通过对象名称访问成员变量 fu1.showNum(); // 20 System.out.println(\"====\"); // 开始覆盖重写父类 fu1.showNum(); // 20 &#125;&#125;// 创建父类class Fu1&#123; int num = 10; public void showNum()&#123; System.out.println(num); &#125;&#125;// 创建子类class Zi1 extends Fu1&#123; int num = 20; @Override public void showNum()&#123; System.out.println(num); &#125;&#125; 对象的向上转型 对象的向上转型，其实就是多态的写法； 格式：父类名称 对象名 = new 子类名称() 12Animal animal = new Cat();创建了一只猫，当作中午来看，是没问题的。 含义：右侧创建一个子类对象，把它当作父类来看待注意事项；向上转型一定是安全的，从小范围转向了大范围。从小范围的猫，向上转换成为了范围更大的动物 对象的向下转型 对象的向下转型，其实是一个【还原】的动作 若想要实现向下转型的前提是有一个向上转型成功的对象名 格式：子类名称 对象名 = （子类名称） 父类对象名 12Animal animal = new Cat(); //向上转型成功，将本来是猫，向上转型成为动物Cat cat = (Cat) animal; // 本来是猫，已经被当做动物了，还原回来成为了原本的猫 注意事项；Ⅰ. 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫Ⅱ. 如果对象创建的时候本来不是猫。现在非要向下转型成为猫，就会报错(ClassCastException) 用instanceof关键字判断一个父类的引用对象，本来是什么子类？ 格式：对象名 instanceof 类名称 完整的源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class InstanceofDemo&#123; public static void main(String[] args)&#123; // 多态写法；新建一只猫 Animal animal = new Cat(); animal.eat(); // 如果希望调用子类的特有方法，需要向下转型 if(animal instanceof Dog)&#123; // 判断父类引用animal是不是Dog Dog dog = (Dog) animal; dog.watchHOuse(); &#125; if(animal instanceof Cat)&#123; Cat cat = (Cat) animal; cat.catchMOnth(); &#125; // 调用getMeAPet函数:传参为Dog()子类 getMeAPet(new Dog()); &#125; public static void getMeAPet(Animal animal)&#123; if(animal instanceof Dog)&#123; // 判断父类引用animal是不是Dog Dog dog = (Dog) animal; dog.watchHOuse(); &#125; if(animal instanceof Cat)&#123; Cat cat = (Cat) animal; cat.catchMouse(); &#125; &#125;&#125;// 创建抽象父类abstract class Animal&#123; public abstract void eat();&#125;// 创建Cat子类class Cat extends Animal&#123; @Override public void eat()&#123; Systeam.out.println(\"猫吃鱼\"); &#125; public void catchMouse()&#123; Systeam.out.println(\"猫抓老鼠吃\"); &#125;&#125;//创建Dog子类class Dog extends Animal&#123; @Override public void Dog()&#123; Systeam.out.println(\"狗吃骨头\"); &#125; public void watchHouse()&#123; Systeam.out.println(\"狗正在看家\"); &#125;&#125; 8.final关键字final关键字代表最终，不可改变，常见的四种方法： 可以用来修饰一个类 当final关键字用来修饰一个类时（表示当前这个类不能有任何子类，即无法继承），格式：public final class 类名称{属性和方法} 可以用来修饰一个方法 当final关键字修饰一个方法时，这个方法就是最终方法，也无法被覆盖重写，格式：修饰符 final 返回值类型 方法名（参数列表）{方法体} 还可以修饰一个局部变量 一般局部变量：int age = 18; int age = 20(对于普通变量来说可以任意重新赋值)final最终变量：一旦使用final用来修饰局部变量，那么这个变量就无法更改：final int age = 18 还可以修饰一个成员变量 对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样不可变由于成员变量具有默认值，所以采用final之后必须要手动赋值，不会再给默认值对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一必须保证类当中的所有重载的构造方法，都最终会对final的成员变量进行赋值 123456789101112131415161718/*当使用构造方法时，无参构造也要赋值，且因为final特性，构造函数就不存在Setter方法了*/class Person&#123;private final String name; /* = 鹿晗*/public Person()&#123;name = \"关晓彤\"&#125;public Person(String name)&#123;this.name = name;&#125;public String gerName()&#123;return name;&#125;&#125; PS：对于类和方法来说，abstract与final关键字不能同时使用，因为自相矛盾","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"2020 新年快乐  \\﻿ (•◡•) /","slug":"HappyNewYear","date":"2020-01-23T16:00:00.000Z","updated":"2020-02-01T06:50:50.000Z","comments":true,"path":"2020/01/24/HappyNewYear/","link":"","permalink":"https://ahrilove.top/2020/01/24/HappyNewYear/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"你很秀！但下一秒，我跟你一样秀","slug":"成神装逼进化之路","date":"2020-01-22T16:00:00.000Z","updated":"2020-04-08T07:19:24.000Z","comments":true,"path":"2020/01/23/成神装逼进化之路/","link":"","permalink":"https://ahrilove.top/2020/01/23/%E6%88%90%E7%A5%9E%E8%A3%85%E9%80%BC%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/","excerpt":"【天不造人上之人,亦不造人下之人】谢邀，人在美国，刚下飞机。利益相关，圈子太小，匿了(总结装逼的知识百科)。","text":"【天不造人上之人,亦不造人下之人】谢邀，人在美国，刚下飞机。利益相关，圈子太小，匿了(总结装逼的知识百科)。 要想修身,齐家,治国,平天下,无形之中装逼，除了超凡的智商压制，还离不开知识的积累铺垫。 1. 大相径庭：比喻相差很远，大不相同近义词： 迥然不同、泾渭分明、截然不同、天差地别反义词： 一模一样、如出一辙、大同小异、相差无几 2. 量子纠缠态官方解释：【在量子力学里，当几个粒子在彼此相互作用后，由于各个粒子所拥有的特性已综合成为整体性质，无法单独描述各个粒子的性质，只能描述整体系统的性质，则称这现象为量子缠结或量子纠缠（quantum entanglement）。量子纠缠是一种纯粹发生于量子系统的现象；在经典力学里，找不到类似的现象。】我一直不能理解量子纠缠理论的解释，为什么两个相距甚远的两个粒子发生量子纠缠现象，就会瞬间互相改变对方的状态？今天早晨，我有了新的理解！因为我觉得爱情可以用量子纠缠来解释，两个完全不相关的人，在某一点发生相遇，发生纠缠，产生了爱情，即使这两个人一个在火星，一个在地球，只要一个人心情发生变化，也会影响到另外一个人的心情，比如一个人像另一个人提出分手，即使距离很远，两个人的恋爱状态都在瞬间发生改变了！爱情的不确定性用量子物理学解释的很清楚，太诡异啦！ 3. 从量子纠缠态解释记忆记忆是个神奇的东西，虚虚实实，如薛定谔的猫，也就像处在不同态同时叠加的量子，确定了他的位置，就摸不到他的温度。 集体记忆更是个神奇的东西，大家一起构建，共同维护，却不一定就是真实的时间轨迹。物理学里面世界尺度小到原子级别以后，就会出现量子态，而相干的量子态之间，一定会纠缠。正如有关联的的两个人，记忆缠在一起，只能同时出现或消失，而无法分开。 最神奇的事情是，量子态被测量时，会坍缩。本来都有一定几率发生的叠加态，会坍缩到其中一个确定的态，而纠缠的量子之间，因为相干，而无法相互独立，故而测量会使得纠缠的所有量子态集体坍缩，如同集体记忆的共同丢失，变得诡异异常。 当一个群体的记忆发生变化时，一切都仿佛演化到了新的世界线，在那里，现状里看不清过去，过去的推演不到现在。如同被测量的量子态，并不在遵循因果律，因而也完全无法时间反演，要做的，只有重新建立原来的叠加态，然后二次测量。 假设我是一个眼睁睁地看着另一个量子态在测量中坍缩的（光或者原子）量子，我记得他坍缩前的样子，记得测量前发生的所有事情，我还和他是一个好朋友。目睹了这一切之后，脑子可能要炸了吧。 4. 诸葛大力对张伟的告白情书特斯拉穿过平面，编织成一个又一个韦伯 。 安倍冲过欧姆，寻找着法拉，充电到一个伏特，电键已断，我以库仑之名涌出，化为焦耳，为了你，烟消云散。我们知道，磁生电的其中一个方法为让闭合电路中的导体在磁场中做切割磁感线的运动。那么这个“平面”的理解即是其定义式：Φ=BS，即当平面与磁场方向不垂直时：Φ=BS⊥=BScosθ（θ为两个平面的二面角,即垂直于磁感线的平面），所以晚上老抢我被子的大力所说“平面”应该就指的是上文中物理意义上的抽象的平面。所以“特斯拉穿过平面，编织成一个又一个韦伯 ”整句的意思就是以电磁感应做一个开始，以电流作为主要人物贯穿整封情书。 5. 蚂蚁花呗，京东白条背后的真实利率惊人在网购支付时，经济不宽裕时我们常常选择分期付款，看似每个月支付的很少，其实背后的利率究竟有多吓人？？其计算方式究竟是怎样的？？我用两张图片来展示如何详细计算不同的平台对利息的叫法是不同的，比如阿里的手续费，京东的服务费等等，就是换了个壳子的叫法而已这是京东上面价值3899.00的iPhone8，可以看到其费率是1.00%（3899.001.00% = 38.99）即每期的利息相当于38.99元， 这里需要注意的是：不管你每月还了多少，每月利息不是按剩余未还本金计算，而是按照总共本金计算每月利息，总结起来都是这样的套路。假如我们选择`201.4124期`这一选项，我们来具体算算这些数字的得来吧 每月固定的利息为1.00%，其利息 = 本金 * 利率 （3899.00*1.00% = 38.99） 每月固定的偿还本金为：总金额/分期时限 （3899/24 = 162.46） 相加大约为38.99+162.46 = 201.45 （201.45 * 24 = 4834.8） 分期付款时，你的商品（手机）价格是一直贬值的，而你一直支付的该商品的原来价值，所以说资本家又会将这价值差拿来在钱生钱 比如上图这张图片，虽然没有明确标注出费率是多少，我们也可以计算出来，依旧选择24期分期，由图可知，其24期的手续费为14.36元： 商品价格 * 费率 = 每期固定利息 （14.36 / 2299 = 0.625%费率） 每月固定偿还的本金：总金额/分期时限 （2299/24 = 95.79） （95.79 + 14.36 = 110.15元） 可知在分期付款方面，白条的费率更高，更吓人呀！！ 至于真实的年化率怎么计算，直接在微信小程序IRR内部收益率计算器上输入计算得知 6. 佳句赏析 Diamonds and gold last for ever，and so will our love:宝石与金子能够永存，我们的爱也是！！ 生前何必久睡，死后自会长眠 ：用来文艺化来表达睡什么睡，起来嗨（睡NMB睡这类的）之意 7. 如何做一个优质的自媒体？做B站UP赚钱吗？对于B站，我是十分喜欢的，上面有很多的优质的视频资源，我认为它是“多元宇宙最好的APP”，旨在对标YouTube 【做B站up主赚钱吗? - 魔法纽扣的回答 - 知乎】我这里对于视频流量特别说明一哈：千万不要刷流量x3，也不要加互助群，因为平均有效观看时长被你弄得很低很低。系统算法会认为你的视频质量极低首先它很贵…比如说1万的播放量，B站近百元，爱奇艺16元，腾讯2元，优酷8元，乐视0.8元，秒拍、美拍1元。为什么贵这么多，因为B站一个IP一天算一个播放量，应该算是播放量最真实的一个视频网站了，所以我说B站潜力很大，像微博僵尸粉和机器人遍地走之后想变回来都不可能。这么贵的刷，会不会回本呢？ 永远不会，你刷一千播放量，是的，视频很快破千，然后你会发现它几乎就不动了。你在互助群和十几个小伙伴点来点去，然后视频就再也没什么赞了。为什么？因为平均有效观看时长被你弄得很低很低。系统算法会认为你的视频质量极低，一千个人都是点开来一秒钟就走，这个视频可能会被判定为标题党。no作no die 8.微商&amp;&amp;传销微商与传销本质都是割韭菜，找接盘侠。不同之处是微商有真实的商品，传销完完全全是虚空的，没有实际商品价值，纯粹收人头费，入会费！ 9.2019武汉新型冠状肺炎&amp;瑞德西韦2019年的武汉肺炎可谓闹的是沸沸扬扬，给全中国人民带来很大的不便和经济损失。美国的吉利德公司（HIV，流感，丙肝等）研发出了一款瑞德西韦药物，中国与吉利德公司于2月5号紧急签订协议，通常一款药物从研发到上市差不多要10年之久，流程十分复杂： 一期：安全性的试验 二期，三期：药物疗效对照试验。实验对象分为两组，实验组注射韦德西韦，对照组注射安慰剂。实验主要分为三个阶段：一盲（实验对象不知道自己注射的是那种试剂），双盲（实验对象，医生不知道试剂类别），三盲（实验对象，医生，实验结果统计专家都不知道） 上市阶段 拓展：对于某些疾病尚未有有效药物时，美国的“同情原则”==“中国的死马当活马医”，2月5号第一位病人注射了瑞德西韦，到4月底实验结束才能确定这种特效药究竟有没有作用 10.老千层饼了释义: 大司马直播LOL游戏时对自己预判操作的解释， 我预判他，他预判了我的预判，我预判他预判了我的预判……一层一层预判像千层饼，所以被网友称他为老千层饼 用法: 多用于形容或者调侃迂腐的人 来源: LOL主播大司马直播语录:你只看到了第二层 ，以为我在第一层 ，实际上我在第五层 ~ 11.幸存者偏差幸存者偏差意思是指，当取得资讯的渠道，仅来自于幸存者时（因为死人不会说话），此资讯可能会存在与实际情况不同的偏差。此规律也适用于金融和商业领域。存活下来的企业往往被视为 “传奇”，它们的做法被争相效仿。而其实有些也许只是因为偶然原因幸存下来了而已。生活中的例子：读书无用论 12.通货膨胀 20年来，China平均年化通货膨胀率5%，银行定期利率才2%，存银行只会越来越少。 若你的基金或股票年化收益率到达15%，那么你就是巴菲特，每十年资本翻一番 财经类经典读物《小狗钱钱》推荐 13.GPU与CPUCPU(中央处理器)与显卡（有集显和独显之分）是两个不同的配件，两者相辅相成。GPU与CPU也是不同的，GPU图像处理器是显卡的核心组成部分，一个偏向于逻辑计算处理，一个偏向于数据的运算处理 怎么查看自己的电脑上的CPU，GPU版本？ Windows：在“运行”对话框中输入dxdiag,点击“确定” 按钮，会打开“DirectX诊断工具”窗口。点击其中的“显示”标签页，便可查看电脑的显卡信息；点击其中的“系统”标签页，便可查看电脑的CPU信息 Linux： lspci | grep -i vga 怎么查看自己电脑上的显卡算力？ （python深度学习算力至少3.5） GPU的计算能力成为算力，可以在NVIDIA官网（ https://developer.nvidia.com/cuda-gpus ），比如：GPU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute CapabilityGeforce RTX 2080&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.5Geforce RTX 2070&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.5Geforce RTX 2060&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.5GeForce GTX 1080&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.1 CUDA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"无名","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章七：js函数与构造函数","slug":"Javascript篇章七","date":"2020-01-21T16:00:00.000Z","updated":"2021-08-28T02:52:42.000Z","comments":true,"path":"2020/01/22/Javascript篇章七/","link":"","permalink":"https://ahrilove.top/2020/01/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%83/","excerpt":"1.函数2.构造函数和new关键字3.python，js与java关于类和对象的理解","text":"1.函数2.构造函数和new关键字3.python，js与java关于类和对象的理解 1.函数的创建方式方式一：函数声明/函数语句（推荐） 123function 函数名(参数1, 参数2, ... , 参数3) &#123; // 需要执行的代码块&#125; 方式二：函数表达式 (function expression) 1var myFunction = function name([param1, param2, ... paramN)&#123;statements&#125; ps:在使用函数表达式时，注意以下几点 name:函数名，可以省略。当省略函数名的时候，该函数就成为了匿名函数。 param:传递给函数的参数的名称，一个函数最多可以有255个参数. statements:组成函数体的声明语句。 方式三：箭头函数 包含多条语句，这时候就不能省略{ … }和return，且仅适用于ES6语法 1234// 箭头函数最标准的写法，不要搞一些花里胡哨的let funcName = (a,b) =&gt;&#123; return a &gt; b ? a : b;&#125; 方式四：自执行函数 1234567891011121314//1.使用 ！开头，结构清晰，不容易混乱，推荐使用；!function()&#123; document.write('ni hao');&#125;();//2.能够将匿名函数与调用的()为一个整体，官方推荐使用；(function()&#123; document.write('hello');&#125;());//3.使用 voidvoid function()&#123; document.write('ni hao');&#125;(); 2.js的构造函数 函数名首字母大写(不强制,味蕾和普通函数的区别) 通过this来给对象添加属性和方法 new关键字使用自定义的构造函数去创建，那么new不能省略 ES5只有构造函数，ES6则可以使用class类 举例说明： 123456789101112131415161718function Student(name,age,grender) &#123; // 添加属性 this.name = name; this.age = age; this.grender = grender; // 添加方法 this.sayHi = function()&#123; return name+\":\"+age+\":\"+grender &#125;&#125;// 使用构造函数来创建对象(new关键字使用自定义的构造函数去创建对那么new不能省略)var student1 = new Student(\"chd\",18,\"man\");var student2 = Student(\"lmm\",19,\"woman\"); // undefined// 调用对象的属性和方法console.log(student1.name); // 调用属性：\"chd\"console.log(student1.sayHi()); // 调用方法：\"chd:18:man\" instanceof判断是否是实例对象，返回true或者false 2020-3-28： 关于构造函数的新增我们知道在一个已存在的对象构造器中是不能添加新的属性的。若想再添加新的属性，要么删除原来的对象，新建一个构造函数；要么通过prototype（原型对象）来再原来的基础上新增举例说明： 1234567891011function Person(first, last, age, eye) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eye;&#125;// 在已存在的对象构造器中新增一个nationality属性Person.prototype.nationality = \"English\";let myFather = new Person(\"John\", \"Doe\", 50, \"blue\");document.getElementById(\"spider案例\").innerHTML =\"我父亲对国籍是 \" + myFather.nationality; 3.python，js与java关于类和对象的理解 Python的类和对象 12345678910111213class 类名(object/父类): def __init__(self,参数1,参数2): self.对象的属性1 = 参数1 self.对象的属性2 = 参数2 def 方法名(self):pass def 方法名2(self):pass对象名 = 类名(实参1,实参2) #对象就是实例，代表一个具体的东西 #类名() : 类名+括号就是实例化一个类，相当于调用了__init__方法 #括号里传参数，参数不需要传self，其他与init中的形参一一对应 #结果返回一个对象对象名.对象的属性 #查看对象的属性，直接用 对象名.属性名 即可对象名.方法名() #调用类中的方法，直接用 对象名.方法名() 即可 js的class类与对象 (本质上看js是没有class这个概念的：)constructor 是一种用于创建和初始化class创建的对象的特殊方法(与js的构造函数用法相差无几)。 123456789101112131415class Polygon &#123; constructor(age) &#123; this.name = \"Polygon\"; this.age = age; this.demo = function()&#123; return this.name+\":\"+this.age &#125; &#125;&#125;const poly1 = new Polygon(18); console.log(poly1); // [object Object] console.log(poly1.demo()); // \"Polygon:18\" java的类与对象 123456789101112131415161718192021222324252627282930313233public class OOP &#123; public static void main(String[] args) &#123; // 在通过new操作符调用的时候，构造方法的参数数量、位置和类型一一对应 Person p = new Person(\"chd\",18,10086); System.out.println(p.getAge()); // 调用实例对象的属性 System.out.println(p.tel); System.out.println(p.getAge()); System.out.println(p.getName()); &#125;&#125;class Person &#123; // 这个不能省略，用以声明变量 private String name; private int age; public int tel; // 这就是Java的构造方法，类似于python的def __init__函数 public Person(String name, int age,int tel) &#123; this.name = name; this.age = age; this.tel = tel; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 参考文章 箭头函数","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ahrilove.top/tags/js/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"html关于图片自适应大小的说明","slug":"html关于图片自适应大小的说明","date":"2020-01-19T16:00:00.000Z","updated":"2020-09-18T07:59:32.000Z","comments":true,"path":"2020/01/20/html关于图片自适应大小的说明/","link":"","permalink":"https://ahrilove.top/2020/01/20/html%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AF%B4%E6%98%8E/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在div盒子中想要展示一张图片，我们可以使用style样式来设置width或者height中的某一项，即style=&quot;width:100px&quot;，这时另一项就会自适应变化,按比例变化。学习犹如逆水行舟，不进则退。 前端 img标签显示 base64格式的图片","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在div盒子中想要展示一张图片，我们可以使用style样式来设置width或者height中的某一项，即style=&quot;width:100px&quot;，这时另一项就会自适应变化,按比例变化。学习犹如逆水行舟，不进则退。 前端 img标签显示 base64格式的图片 1. 图片自适应大小变化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设置网页的整个背景图片时，我们可以在css中的使用background-size：100%来铺满整个页面，也可以设置为其它的百分比数值来局部铺HTML页面。 123456body&#123; background-image: url(\"../public/images/5927f2c7269aa.jpg\"); background-attachment: fixed; background-size: 100%;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在div盒子中想要展示一张图片，我们可以使用style样式来设置width或者height中的某一项，即style=&quot;width:100px&quot;，这时另一项就会自适应变化,按比例变化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我来举一个例子说明，也可以总结出一个公式，以后若固定了width或height中的某一项，另一项也就会求出来： 12&lt;a href=\"#\"&gt;&lt;img src=\"../public/images/5d5e5c7d1e1b8.jpg\" style=\"width: 100px\" /&gt;&lt;/a&gt;&lt;!--引入的图片的原分辨率为1920*1080--&gt; style=&quot;width: 100px&quot;：将引入的图片的宽度固定为100px；此时height就会自适应变化。由上图可知，图片已经自适应变化了，height:56.25px，这个数字是怎么得出来的？width:1920---&gt;100heidth:1080 ---&gt;56.25 &nbsp;&nbsp;&nbsp;因为：1080/(1920/100)=56.25px 2.前端 img标签显示 base64格式的图片前端img标签想要展示base64编码的图片，只需要在html中加上（这种方法不兼容IE6/7，使用时要注意！） 1&lt;img src=\"data:image/jpg;base64,图片数据\" alt=\"\"/&gt; 更多格式： data:,文本数据 data:text/plain,文本数据 data:text/html,HTML代码 data:text/html;base64,base64编码的HTML代码 data:text/css,CSS代码 data:text/css;base64,base64编码的CSS代码 data:text/javascript,Javascript代码 data:text/javascript;base64,base64编码的Javascript代码 data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://ahrilove.top/tags/html/"},{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"sql查询大全补充","slug":"sql系列更新(四)","date":"2020-01-16T16:00:00.000Z","updated":"2021-02-09T08:28:46.000Z","comments":true,"path":"2020/01/17/sql系列更新(四)/","link":"","permalink":"https://ahrilove.top/2020/01/17/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E5%9B%9B)/","excerpt":"数据库是每一个IT工程师必备的技能树，而select往往是使用频率最大的，总结并补充之前有关于select查询的补充 本文要点：1.sql的执行顺序2.select+case…when…then…end 语句3.select top语句4.where条件查询5.sql函数大全","text":"数据库是每一个IT工程师必备的技能树，而select往往是使用频率最大的，总结并补充之前有关于select查询的补充 本文要点：1.sql的执行顺序2.select+case…when…then…end 语句3.select top语句4.where条件查询5.sql函数大全 1.sql的执行顺序下面展示一张sql的执行图： 这里我们可以理解为：先执行from语句，获取表----&gt;然后在使用where过滤掉不相关的记录----&gt;再执行聚合函数或者group by分组----&gt;紧接着执行having进行二次过滤----&gt;最后执行sql的select语句 2.Select+case…when…then…end 语句case…when…then语句，相当于编程语言中if判断(important) 例1:根据IsUser字段查询学生是否在线12345select a.StudentID, (case a.IsUse when '0' then '未在线' when '1' then '在线' else '未上传' end) as 在线情况from StudentBindPaperTypeEntity as a 3.select top语句TOP 子句用于规定要返回的记录的数目。对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。注释：并非所有的数据库系统都支持 TOP 子句(top仅适用于sql server)。 12345-- 例1.取出表中第几行数据（如第一行）select top 1 * from TABLE_NAME --例2.取出表中百分之多少数据select top 50 percent * from TABLE_NAME oracle语法:rownum 123SELECT column_name(s)FROM table_nameWHERE ROWNUM &lt;= number mysql语法：limit 123SELECT column_name(s)FROM table_nameLIMIT number 4.where条件查询 特别注意：关于存在多个查询条件时的一个大坑,2020-3-23就是被这个大坑花了很多时间关于SQL的where子句中包含多个and和or是计算顺序问题，SQL在处理操作时会优先处理 and 操作，这就是很多人会得到很多错误的原因,要多使用小括号，以免产生歧义 1where corg_code = '199' and (period between '201801' and '201803' or period BETWEEN '201901' and '201903') 执行顺序： 12345678910111213select 一般在的后面的内容都是要查询的字段from 要查询到表wheregroup byhaving 分组后带有条件只能使用havingorder by limit 0,100 它必须放到最后面 5.sql函数大全【常用经典SQL语句大全完整版–详解+实例】【SQL函数大全及示例汇总】 补充：left(filed,numbers):字段从左边开始截取指定位数geohash通过算法将1个定位的经度和纬度2个数值，转换成1个hash字符串。如果2个地方距离越近，那么他们的hash值的前缀越相同。然后通过数据库中like操作符 “ like wtw366%” 快速查找到附近的车。比如上海腾讯大厦的经纬度是： （31.1688749, 121.3975184），那么转换成geohash就是 wtw366ngz5qt，我们想找附近的车子，可以用：left(filed,numbers):字段从左边开始截取指定位数 12select * from cart where geohash like 'wtw366%' ;select * from cart where LEFT(geohash, 6) = 'wtw366'; 6.多字段的group bygroup by表示为分组，一定要和聚合函数一起并用。但是在这里，我们不深思分组函数的基本用法，而是考虑sql对多个字段进行group by分组： GROUP BY X意思是将所有具有相同X字段值的记录放到一个分组里，GROUP BY X, Y意思是将所有具有相同X字段值进行分组后，再把Y字段值进行分组处理。 7. SQL中IS NOT NULL与 !=NULL的区别平时经常会遇到这两种写法：IS NOT NULL与!=NULL。也经常会遇到数据库有符合条件!=NULL的数据，但是返回为空集合。实际上，是由于对二者使用区别理解不透彻。 默认情况下，推荐使用 IS NOT NULL去做条件判断，因为SQL默认情况下对WHERE XX！= Null的判断会永远返回0行，却不会提示语法错误最后，我们再次声明：数据库默认情况下，做SQL条件查询比较时使用关键字“is null”和“is not null” 拓：对于字段非空判断，若为空则用某个值替换，不为空则不做变更 数据库 isnull()、nvl()、ifnull() 使用原理 SqlServer 插入字段值 为空 设置默认值：isnull(val_1,val_2) 当val_1为 null 的时候 返回 val_2的值 Oracle：nvl(val_1,val_2) 当val_1为 null 的时候 返回 val_2的值 MySql：ifnull(val_1,val_2) 当val_1为 null 的时候 返回 val_2的值 参考文章： SQL GROUP BY对多个字段进行分组 Using group by on multiple columns","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"数据分析章节（三）：pandas","slug":"数据分析章节（三）","date":"2020-01-15T16:00:00.000Z","updated":"2020-05-19T02:44:40.000Z","comments":true,"path":"2020/01/16/数据分析章节（三）/","link":"","permalink":"https://ahrilove.top/2020/01/16/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pandas是Python的一个大数据处理模块。Pandas使用一个二维的数据结构DataFrame来表示表格式的数据，相比较于Numpy，Pandas可以存储混合的数据结构，同时使用NaN来表示缺失的数据，而不用像Numpy一样要手工处理缺失的数据，并且Pandas使用轴标签来表示行和列。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pandas是Python的一个大数据处理模块。Pandas使用一个二维的数据结构DataFrame来表示表格式的数据，相比较于Numpy，Pandas可以存储混合的数据结构，同时使用NaN来表示缺失的数据，而不用像Numpy一样要手工处理缺失的数据，并且Pandas使用轴标签来表示行和列。 pandas与numpy在数据处理前期阶段起着重要作用，两者相辅相成，异曲同工 1.Series一维数据Series是一种类似于一维数组的对象，由一组数据和一组与之相关的数据标签（索引）组成Series的字符串表现形式为：索引在左边，值在右边。如果没有为数据指定索引，于是会自动创建一个0到N-1(N为数据的长度)的整数型索引。可以通过Series的values和index属性获取其数组表现形式和索引对象： 123456789import numpy as npimport pandas as pda = pd.Series([1,2,3])\"\"\" a:左边为索引，右边为值0 11 22 3\"\"\" 1.1 传递带有日期时间索引和标签dates = pd.date_range(&#39;20190110&#39;,periods=6):period表示时间期间 1234&gt;&gt;&gt; datesDatetimeIndex([&apos;2020-01-10&apos;, &apos;2020-01-11&apos;, &apos;2020-01-12&apos;, &apos;2020-01-13&apos;, &apos;2020-01-14&apos;, &apos;2020-01-15&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;) 1.2 pandas的index指定索引目录123456789a1 = pd.Series([2, 3, 4, 5], index=['a', 'b', 'c', 'd'])\"\"\"&gt;&gt;&gt; a1a 2b 3c 4d 5dtype: int64\"\"\" 2.Series支持numpy的array特性 从ndarray创建Series 12345678910111213import pandas as pdimport numpy as np# np.array创建一维数组a2 = pd.Series(np.array([1,2,3,4]))# np.arrange(start,end,jiange)创建一维数组a3 = pd.Series(np.arange(1,9,2))\"\"\"a2:0 11 22 33 4dtype: int32\"\"\" 与标量的运算两个series运算,即索引值相对应的值相加减:a2 + a3 Series的索引:下角标从零开始(类似于数组的索引切片)b[0] :单个字符的索引b[[1,2,3]] :数组组合的索引所对应的具体值 切片操作(满足左闭右开，起始索引为0的原则)b[1:4] 通用函数（最大值，绝对值等） 12345678import pandas as pdimport numpy as npdata = 10c1 = pd.Series(np.linspace(-1,1,data))print(c1)print(c1.min())print(c1.max()) 3.从字典创建series 3.1 从字典创建series12345678910sr = pd.Series(&#123;'name': 'chd', 'age': 18, 'gender': 'man', 'capacity': 10,'is_love_girl':True&#125;)\"\"\"&gt;&gt;&gt; srname chdage 18gender mancapacity 10is_love_girl Truedtype: object\"\"\" 3.2.in运算：&#39;a&#39; in sr:只能判断键名是否在’pandas.core.series.Series’类中，不能判断values值 123print('name' in sr) # trueprint('age' in sr) # trueprint('love is unlimited' in sr) # false 3.3.遍历运算:只遍历打印值，不会打印键名123&gt;&gt;&gt; x = [i for i in sr]&gt;&gt;&gt; x[&apos;chd&apos;, 18, &apos;man&apos;, 10, True] 3.4.获取索引以及对应值12print(sr.index) # 获取索引print(sr.values) # 获取对应的值 3.5 整数索引问题：12str = pd.Series(np.arange(4.))print(str) 3.6 浅拷贝，a，b都指向内存地址，若其中一个修改值，则另一个也必会修改值12str2 = str[1:].copy()print(str2) series数据对齐，pandas在进行两个Series对象运算时，会按索引自动对齐然后运算若两series对象的index长度不一样，则会当做数据缺失值NaN处理 4.Series对象运算123sr1 = pd.Series([12, 23, 34, 34], index=['c', 'a', 'b', 'd'])sr2 = pd.Series([11, 20, 10], index=['a', 'b', 'c'])print(sr1 + sr2) 4.1 Series灵活算术方法123print(sr1.add(sr2,fill_value = 0))print(sr1.sub(sr2,fill_value = 0))print(sr1.div(sr2,fill_value = 0)) 4.2 缺失值处理方式： 缺失值处理方式一：过滤缺失数据str.dropna()：直接删除缺值的键值 123d = pd.Series(np.array([1, 3, 4., None, 8, None, 99]))print(d.dropna())print(d.isnull()) # 判断每一键值对是否缺失数据 缺失值处理方式二：填充缺失数据：str.fillna(填充值) print(d.fillna(1)) 缺失值处理方式三：不处理 提出NaN后求得平均值 print(d.mean()) 5.DataFrame二维数组对象DataFrame是一个表格式的数据结构，含有一组有序的列（即：好几列）。DataFrame可以被看做是由Series组成的字典，并且共用一个索引。 5.1 创建方式1：通过一个字典来创建123456789a = pd.DataFrame(&#123;'name': ['chd', 'zyq', 'fqt'], 'age': [18, 12, 15]&#125;)print(a)\"\"\"&gt;&gt;&gt;a 结果为 name age0 chd 181 zyq 122 fqt 15\"\"\" 5.2 index指定行索引12345&gt;&gt;&gt;pd.DataFrame(&#123;&apos;name&apos;: [&apos;chd&apos;, &apos;zyq&apos;, &apos;fqt&apos;], &apos;age&apos;: [18, 12, 15]&#125;,index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) name agea chd 18b zyq 12c fqt 15 5.3 创建方式二：用Series来组成字典123456&gt;&gt;&gt;pd.DataFrame(&#123;&apos;one&apos;:pd.Series([1,2,3],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]),&apos;two&apos;:pd.Series([5,6,7,8],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#125;) one twoa 1.0 5b 2.0 6c 3.0 7d NaN 8 5.4 其它1234567891011121314151617181920212223242526272829303132333435363738# CSV文件的读写# CSV文件的写入print(a2.to_csv('spider案例.csv'))# CSV文件的读取print(pd.read_csv('spider案例.csv'))# json数据的读取和存储df = pd.read_json('demo2.json')# 读取时可能乱序，需要对索引进行重新排序df = df.sort_index()print(df)# 存储为json数据df.to_json('out.json')# Excel数据的读取df_excel = pd.read_excel('inputs.xlsx')# Excel的存储:需要用到openpyxl库# sheet_name：设置工作表名，indexA=None不存储行索引df_excel.to_excel('biao_name.xlsx',sheet_name='biao_name',index = None)# DataFrame常用属性# var.index获取行索引print(a2.index)# var.columns:获取列索引print(a2.columns)# values 获取取值数组（一般是二维数组）print(a2.values)# T:装置print(a2.T)# descriibe():获取统计数据print(a2.describe()) 6.pandas操作excel文件pandas库操作excel其实是依赖其他的一些库，所以我们需要安装多个库 pip install xlrdpip install openpyxlpip install numpypip install pandas 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#pandas读取Excel的第一种方法#方法一：默认读取第一个表单print(\"\\n方法一：\")xls_data=pd.read_excel('ceshi.xlsx',index_col='序列') #index_col 分行编号# #这个会直接默认读取到这个Excel的第一个表单print(xls_data.head()) #默认读取前5行的数据# print(\"输出:\\n&#123;0&#125;\".format(xls_data.head()))#格式化输出#方法二：通过指定表单名的方式来读取print(\"\\n方法二：\")df=pd.read_excel('ceshi.xlsx',sheet_name='Sheet2')data=df.head() #默认读取前5行的数据print(\"获取到所有的值:\\n&#123;0&#125;\".format(data))#格式化输出#方法三：通过表单索引来指定要访问的表单，0表示第一个表单#也可以采用表单名和索引的双重方式来定位表单#也可以同时定位多个表单，方式都罗列如下所示print(\"\\n方法三：\")# df=pd.read_excel('ceshi.xlsx',sheet_name=['Sheet1','Sheet2'])#可以通过表单名同时指定多个--不推荐使用，效果不好# df=pd.read_excel('ceshi.xlsx',sheet_name=['Sheet2',0])#可以混合的方式来指定--不推荐使用，效果不好# df=pd.read_excel('ceshi.xlsx',sheet_name=1)#可以通过表单索引来指定读取的表单--列表形式# df=pd.read_excel('ceshi.xlsx',sheet_name=[0,1])#可以通过索引 同时指定多个--不推荐使用，效果不好data=df.values #获取所有的数据，注意这里不能用head()方法哦~print(\"获取到所有的值:\\n&#123;0&#125;\".format(data))#格式化输出# 以上读取的数据是一个二维矩阵，不利于处理自动化测试，# pandas操作Excel的行列print(\"\\npandas操作Excel的行列\")# 1：读取指定的单行，数据会存在列表里面df=pd.read_excel('ceshi.xlsx')data1=df.loc[0].values #0表示第一行 这里读取数据并不包含表头，要注意哦！print(\"读取指定的单行数据：\\n&#123;0&#125;\".format(data1))print(\"\\n2：读取指定的多行，数据会存在嵌套的列表里面：\")# 2：读取指定的多行，数据会存在嵌套的列表里面：df=pd.read_excel('ceshi.xlsx')data2=df.loc[[1,2]].valuesprint(\"读取指定的多行数据：\\n&#123;0&#125;\".format(data2))print(\"\\n3：读取指定的行列\")# 3：读取指定的行列：df=pd.read_excel('ceshi.xlsx')data3=df.iloc[1,2]print(\"读取指定行列的数据：\\n&#123;0&#125;\".format(data3)) #dandelion-alipaymobile# 4：读取指定的多行多列值：print(\"\\n4：读取指定的多行多列值：\")df=pd.read_excel('ceshi.xlsx',sheet_name='Sheet2')data4=df.loc[[1,2],['姓名','年龄','性别']]print(\"读取多行多列的数据：\\n&#123;0&#125;\".format(data4))# 姓名 年龄 性别# 1 sun 18 女# 2 zhao 19 男# 5：获取所有行的指定列print(\"\\n5：获取所有行的指定列\")df=pd.read_excel('ceshi.xlsx',sheet_name='Sheet2')data5=df.loc[:,['姓名','年龄','性别']].values #得到的是嵌套列表data6=df.loc[:,['姓名','年龄','性别']] #得到二维矩阵print(\"获取所有行的指定列的数据：\\n&#123;0&#125;\".format(data5)) #得到的是嵌套列表print(\"获取所有行的指定列的数据：\\n&#123;0&#125;\".format(data6)) #得到二维矩阵# 6：获取行号并打印输出print(\"\\n6：获取行号并打印输出\")df=pd.read_excel('ceshi.xlsx',sheet_name='Sheet2')print(\"输出行号列表:\",df.index.values)# 输出行号列表: [0 1 2 3 4 5 6]# 7：获取列名并打印输出print(\"\\n7：获取列名并打印输出\")df=pd.read_excel('ceshi.xlsx',sheet_name='Sheet2')print(\"输出标题:\",df.columns.values)# 输出标题: ['姓名' '年龄' '性别' '出生日期']# 8：随机获取几行数的值：print(\"\\n8：获取指定行数的值：\")df=pd.read_excel('ceshi.xlsx',sheet_name='Sheet2')print(\"输出值:\\n\",df.sample(3).values) #随机抽取3行查看，这个方法类似于head()方法以及df.values方法# [['liu' 23 '女' '1995-05']# ['wang' 17 '男' '1992-11']# ['li' 20 '男' '1992-09']]# 9：获取指定列的值：print(\"\\n9：获取指定列的值：\")df=pd.read_excel('ceshi.xlsx',sheet_name='Sheet2')print(\"输出值:\\n\",df['姓名'].values)# pandas处理Excel数据成为字典print(\"\\npandas处理Excel数据成为字典\")df=pd.read_excel('ceshi.xlsx',sheet_name=\"Sheet2\")test_data=[]for i in df.index.values: #获取行号的索引，并对其进行遍历：# 根据i来获取每一行指定的数据 并利用to_dict转成字典row_data=df.loc[i,['姓名','年龄','性别','出生日期']].to_dict()test_data.append(row_data)print(test_data)\"\"\" [ &#123;'姓名': 'wang', '年龄': 17, '性别': '男', '出生日期': '1992-11'&#125;, &#123;'姓名': 'sun', '年龄': 18, '性别': '女', '出生日期': '1992-12'&#125;, &#123;'姓名': 'zhao', '年龄': 19, '性别': '男', '出生日期': '1993-01'&#125;, &#123;'姓名': 'zhang', '年龄': 22, '性别': '女', '出生日期': '1994-05'&#125;, &#123;'姓名': 'zhou', '年龄': 16, '性别': '女', '出生日期': '1992-07'&#125;, &#123;'姓名': 'liu', '年龄': 23, '性别': '女', '出生日期': '1995-05'&#125;, &#123;'姓名': 'li', '年龄': 20, '性别': '男', '出生日期': '1992-09'&#125;]\"\"\" 这里有点坑的是pandas操作excel没有追加模式，只能先读取数据后使用append追加再写入excel！ 参考文章 Python利用pandas处理Excel数据的应用 :文章里面有一点问题，详细看12楼评论","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://ahrilove.top/tags/pandas/"}]},{"title":"Javascript篇章六：js的数值保留指定有效位数","slug":"Javascript篇章六","date":"2020-01-14T16:00:00.000Z","updated":"2021-11-27T02:03:50.536Z","comments":true,"path":"2020/01/15/Javascript篇章六/","link":"","permalink":"https://ahrilove.top/2020/01/15/Javascript%E7%AF%87%E7%AB%A0%E5%85%AD/","excerpt":"本章内容： 1.四舍五入相关2.保留有效数字3.数字格式化","text":"本章内容： 1.四舍五入相关2.保留有效数字3.数字格式化 1.四舍五入相关 toFixed(number):保留指定小数位数，将数值类型转换为字符串类型 12345// 1.四舍五入var num =2.446242342; num = num.toFixed(2); console.log(num); //2.45console.log(typeof num); // string Math.floor()，不四舍五入，向下取整,不改变数据类型 1234// 2.不四舍五入 向下取整num = Math.floor(num * 100) / 100;console.log(num); //2.44console.log(typeof num); // number 字符串匹配注意，先将数据转换为字符串，最后再转为数值类型 1234// 3.不四舍五入 字符串匹配再转换num = Number(num.toString().match(/^\\d+(?:\\.\\d&#123;0,2&#125;)?/));console.log(num); //2.44console.log(typeof num); // number 四舍五入保留2位小数（若第二位小数为0，则保留一位小数） 12345678910111213//4.四舍五入保留2位小数（若第二位小数为0，则保留一位小数） function keepTwoDecimal(num) &#123; var result = parseFloat(num); if (isNaN(result)) &#123; alert('传递参数错误，请检查！'); return false; &#125; result = Math.round(num * 100) / 100; return result; &#125; keepTwoDecimal(num); console.log(num); //2.44 console.log(typeof num); //number 四舍五入保留2位小数（不够位数，则用0替补）注意，数据类型变为字符串类型 123456789101112131415161718192021222324252627282930//5.四舍五入保留2位小数（不够位数，则用0替补） function keepTwoDecimalFull(num) &#123; var result = parseFloat(num); if (isNaN(result)) &#123; alert('传递参数错误，请检查！'); return false; &#125; result = Math.round(num * 100) / 100; var s_x = result.toString(); //将数字转换为字符串 var pos_decimal = s_x.indexOf('.'); //小数点的索引值 // 当整数时，pos_decimal=-1 自动补0 if (pos_decimal &lt; 0) &#123; pos_decimal = s_x.length; s_x += '.'; &#125; // 当数字的长度&lt; 小数点索引+2时，补0 while (s_x.length &lt;= pos_decimal + 2) &#123; s_x += '0'; &#125; return s_x; &#125; console.log(keepTwoDecimalFull(120.5)); //120.50 console.log(typeof keepTwoDecimalFull(120.5)); //string console.log(keepTwoDecimalFull(2.446242342)); //2.45 console.log(typeof keepTwoDecimalFull(2.446242342)); //string 2.浮点数保留两位小数 将浮点数四舍五入，取小数点后2位(数据类型不变) 123456789101112//浮点数保留两位小数 //1.功能：将浮点数四舍五入，取小数点后2位 function toDecimal(x) &#123; var f = parseFloat(x); if (isNaN(f)) &#123; return; &#125; f = Math.round(x*100)/100; return f; &#125; console.log(toDecimal(3.1465926)); // 3.15 console.log(typeof toDecimal(3.1415926)); //number 强制保留2位小数，如：2，会在2后面补上00.即2.00注意，数据类型变为字符串类型 1234567891011121314151617181920//2.强制保留2位小数，如：2，会在2后面补上00.即2.00 function toDecimal2(x) &#123; var f = parseFloat(x); if (isNaN(f)) &#123; return false; &#125; var f = Math.round(x*100)/100; var s = f.toString(); var rs = s.indexOf('.'); if (rs &lt; 0) &#123; rs = s.length; s += '.'; &#125; while (s.length &lt;= rs + 2) &#123; s += '0'; &#125; return s; &#125; console.log(toDecimal2(3.1)); // 3.10console.log(typeof toDecimal2(3.1415926)); //string 保留两位小数 浮点数四舍五入 位数不够 不补0注意，数据类型不变 123456// 3.保留两位小数 浮点数四舍五入 位数不够 不补0function fomatFloat(src,pos)&#123; return Math.round(src*Math.pow(10, pos))/Math.pow(10, pos); &#125; console.log(fomatFloat(3.12645,2)); // 3.13console.log(typeof fomatFloat(3.1415926)); //number 3.JS数字，金额 ，用逗号隔开（数字格式化）JS将数字，金额，用逗号隔开（数字格式化），并按照需求保留规定小数位数 123456789101112function format_number(s, n) &#123; n = n &gt; 0 &amp;&amp; n &lt;= 20 ? n : 2; s = parseFloat((s + \"\").replace(/[^\\d\\.-]/g, \"\")).toFixed(n) + \"\"; let l = s.split(\".\")[0].split(\"\").reverse(), r = s.split(\".\")[1]; let t = \"\"; for (i = 0; i &lt; l.length; i++) &#123; t += l[i] + ((i + 1) % 3 == 0 &amp;&amp; (i + 1) != l.length ? \",\" : \"\"); &#125; return t.split(\"\").reverse().join(\"\") + \".\" + r;&#125;format_number(589455642.2598,3);// \"589,455,642.260\" format_number(s,n):s代表传入的数值，n代表保留的小数位数","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ahrilove.top/tags/js/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"union和union all（联合查询）","slug":"sql系列更新(三)","date":"2020-01-13T16:00:00.000Z","updated":"2020-01-15T09:12:08.000Z","comments":true,"path":"2020/01/14/sql系列更新(三)/","link":"","permalink":"https://ahrilove.top/2020/01/14/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E4%B8%89)/","excerpt":"如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。","text":"如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。 1.基础概念union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； Union All：对两个结果集进行并集操作，包括重复行，不进行排序； Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序； Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。 注意的是：UNION 、UNION ALL内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 2.使用方法基本语法： union：123select employee_id,job_id from employees union select employee_id,job_id from job_history union all：123select employee_id,job_id from employees union allselect employee_id,job_id from job_history 3.FAQ 1.union 和 union all都可以将多个结果集合并，而不仅仅是两个，你可以将多个结果集串起来。 2.使用union和union all必须保证各个select 集合的结果有相同个数的列，并且每个列的类型是一样的。但列名则不一定需要相同，oracle会将第一个结果的列名作为结果集的列名。例如下面是一个例子： 123select empno,ename from emp union select deptno,dname from dept 3.没有必要在每一个select结果集中使用order by子句来进行排序，我们可以在最后使用一条order by来对整个结果进行排序。例如： 1234select empno,ename from emp union select deptno,dname from dept order by ename;","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"},{"name":"union","slug":"union","permalink":"https://ahrilove.top/tags/union/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（十）：个性化脚本","slug":"Python全栈系列章节更新（十）","date":"2020-01-06T16:00:00.000Z","updated":"2021-11-29T10:42:37.641Z","comments":true,"path":"2020/01/07/Python全栈系列章节更新（十）/","link":"","permalink":"https://ahrilove.top/2020/01/07/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%EF%BC%89/","excerpt":"1.headers字符串处理2.控制台输出带颜色3.包管理requirement.txt4.文件读取read、readline、readlines5.文件打开方式★★6.py文件调用其它py文件的类和函数7.python和anaconda常用指令8.py和.exe文件命令行执行方式","text":"1.headers字符串处理2.控制台输出带颜色3.包管理requirement.txt4.文件读取read、readline、readlines5.文件打开方式★★6.py文件调用其它py文件的类和函数7.python和anaconda常用指令8.py和.exe文件命令行执行方式 知识点回顾：python字典与js的对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，我懵了，最近有点迷糊，刚刚说起字典（值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。），这就可以联想到js的对象写法 12# 字典dicts = &#123;'Alice': '2341', 9527: '9102', (2,3): '3258'&#125; js的对象提供多个内建对象，比如 Object、String、Date、Array,Number,Function 等等 1234567let obj = &#123; name : \"xiaoming\", age : 18, show : function (girlfriend) &#123; console.log(this.name + \"的女朋友是\" + girlfriend); &#125;&#125;; 1. headers字符串处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从chrome里面的截取到的headers往往是需要我们二次处理的，而我一般喜欢加双引号，构造成json格式，一劳永逸。源代码： 123456789101112import reheaders_str = \"\"\"sec-fetch-mode: navigatesec-fetch-site: same-originsec-fetch-user: ?1upgrade-insecure-requests: 1user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36\"\"\"pattern = re.compile(\"^(.*?): (.*)$\")for line in headers_str.splitlines(): print(re.sub(pattern, \"\\\"\\\\1\\\": \\\"\\\\2\\\",\", line)) 这里的headers_str存放我们的目标headers字符串，运行结果为： 12345&quot;sec-fetch-mode&quot;: &quot;navigate&quot;,&quot;sec-fetch-site&quot;: &quot;same-origin&quot;,&quot;sec-fetch-user&quot;: &quot;?1&quot;,&quot;upgrade-insecure-requests&quot;: &quot;1&quot;,&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36&quot; 2.控制台输出带颜色设置颜色开始 ：\\033[显示方式;前景色;背景色m 文本内容 \\033[0m（此处为结束语） 12345print('\\033[1;31m我以我血荐轩辕\\033[0m')print('\\033[4;35m我以我血荐轩辕\\033[0m')print('\\033[5;37;40m我以我血荐轩辕\\033[0m')print('\\033[0;32m我以我血荐轩辕\\033[0m')print('\\033[1;32m我以我血荐轩辕\\033[0m') 3.包管理requirement.txt正如 PHP 中使用 Composer 维护依赖一样，Python 也需要维护项目相关的依赖包。通常我们会在项目的根目录下放置一个 requirement.txt 文件，用于记录所有依赖包和它的确切版本号。 1.Python的依赖requirement.txt 的内容长这样： 12345678910111213alembic==1.0.10appnope==0.1.0astroid==2.2.5attrs==19.1.0backcall==0.1.0bcrypt==3.1.6bleach==3.1.0cffi==1.12.3Click==7.0decorator==4.4.0defusedxml==0.6.0entrypoints==0.3... 2.如何使用：那么 requirement.txt 究竟如何使用呢？当我们拿到一个项目时，首先要在项目运行环境安装 requirement.txt 所包含的依赖： script1pip install -r requirement.txt 当我们要把环境中的依赖写入 requirement.txt 中时，可以借助 freeze 命令： script1pip freeze &gt;requirements.txt 3.环境混用怎么办？在导出依赖到 requirement.txt 文件时会有一种尴尬的情况。你的本地环境不仅包含项目 A 所需要的依赖，也包含着项目 B 所需要的依赖。此时我们要如何做到只把项目 A 的依赖导出呢？ pipreqs 可以通过扫描项目目录，帮助我们仅生成当前项目的依赖清单。 通过以下命令安装： script1pip install pipreqs 运行： script1pipreqs ./ 4.文件读取read、readline、readlines read():读取整个文件，将文件内容放到一个字符串变量中 readline():每次读取一整行，包括换行符，并将其作为字符串返回 readlines():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素） readline()示例 假设需求是读取一个多行的all_term.txt文件，并列出每一个单词 1234new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothrnobyl social impact chernobyl disastdavid r marpl st martin piano 程序源代码： 123456789101112131415161718def main(): obj = [] with open('all_term.txt', 'r', encoding='utf-8',errors=\"ignore\") as f: while True: myStr = f.readline() # 表示一次读取一行 if not myStr: # 读到数据最后跳出，结束循环。数据的最后也就是读不到数据了，mystr为空的时候 break # 指定字符串来分割目标字符串，以列表形式返回 new_list = myStr.split() # 表示将拆分好的每一行重新拼接成一个完整的数组 obj += new_list print(obj)if __name__ == '__main__': main() readline()表示读取一整行，那如果一个文件有多行数据，使用readline()函数是不是一直重复读取第一行？其实不然，使用with open()打开文件后，第一个readline()读取第一行（也包括换行符），第二个读取第二行,…,第n个读取第n行数据，这是由系统机制判定的。下面我列举一个实例： 12345678910111213141516171819\"\"\"all_term.txt:new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothnew fallout chernobyl social impact chernobyl disastdavid r marpl st martin press cloth\"\"\"# -*- coding:utf-8 -*-with open('all_term.txt', 'r', encoding='utf-8', errors='ignore') as f: a = f.readline().replace(\"\\n\", \"\") b = f.readline().replace(\"\\n\", \"\")print(\"a:\", a)print(\"b:\", b)\"\"\"结果为：a: new fallout chernobyl social impact chernobyl disastb: david r marpl st martin press cloth\"\"\" 根据结果可以得出结论： 1.第一个readline()读取第一行（也包括换行符），第二个读取第二行，…… 2.上面是我们经常看到的按行遍历一个文件方法，你可能已经注意到我在代码中写的if not myStr:部分。当readline读取到为空的时候，意味着读到了文件的结束。这个时候，问题就在这里，很多人会想，是不是遇到一个空行，也会被认为是文件的结束呢？事实上，文件的空白行并不会返回一个空行。因为在每一行的末尾还有一个或者多个分隔符，因此“空白行”至少会有一个换行符或者系统使用的其他符号。所以，即使文件中真的包含一个“空白行”，读入的行也不是空的，这就意味着在真实遍历读取到文件结束之前，程序实际上是不会停止的 5.文件打开方式 打开方式 详解 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 6.py文件调用其它py文件的类和函数python文件如何调用另一个.py文件中的类和函数？首先我们要区分是在同一文件夹下还是在不同文件夹 同一文件夹 调用函数 A.py文件： 12def add(x,y): print('和为：%d'%(x+y)) B.py文件： 123456import AA.add(985, 211)# 法二from A import addadd(985, 211) 调用类 A.py文件 123456class A: def __init__(self,xx,yy): self.x=xx self.y=yy def add(self): print(\"x和y的和为：%d\"%(self.x+self.y)) B.py文件 123456789from A import A# 对象的实例化a=A(2,3)a.add()# 法二import Aa=A.A(2,3)a.add() 不同文件夹 A.py文件的文件路径：E:\\PythonProject\\winycgB.py文件： 1234567891011import syssys.path.append(r'E:\\PythonProject\\winycg')'''python import模块时， 是在sys.path里按顺序查找的。sys.path是一个列表，里面以字符串的形式存储了许多路径。使用A.py文件中的函数需要先将他的文件路径放到sys.path中'''import A a=A.A(2,3)a.add() 7.python和anaconda常用指令 Python script123456789101112131415161718192021# pip版本pip --version# 列出已安装的包pip list# 安装包（不指定版本，默认最新）pip install pymssqlpip install pymssql==2.2.1# 卸载包pip uninstall pymssql# 查看包详细消息pip show package-name# 更新指定包版本pip install [—U | --upgrade] package-name# 更新pippython -m pip install --upgrade pip anaconda script123456789101112131415# 查看anaconda版本conda -V# 列出conda管理的所有环境conda env list# 激活目标环境conda activate environment# 安装指定版本包conda install numpy==1.10conda remove---卸载包conda update package_name----更新包conda update --all ---更新所有包 8.py和.exe文件命令行执行方式对于.py文件以命令行的方式携参数执行：python name.py arg1 arg2 ...argN 前面一定要有python关键词 参数之间使用空格隔开 程序内使用sys.argv[0]获取脚本名、sys.argv[1]获取参数1、sys.argv[2]获取参数2、sys.argv[N]获取参数N 对于.exe文件以命令行的方式携参数执行（在windows系统中执行python打包对exe文件）： .\\name.exe arg1 arg2 ...argN 注意有点+反斜杠.\\ 前面不要加python关键词 程序内使用sys.argv[0]获取脚本名、sys.argv[1]获取参数1、sys.argv[2]获取参数2、sys.argv[N]获取参数N 参考文章 控制台输出带颜色文字的方法 python文件如何调用另一个.py文件中的类和函数 python命令行参数实现读取命令行参数的方法","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"数据分析章节（二）：matplotlib","slug":"数据分析章节（二）","date":"2020-01-01T16:00:00.000Z","updated":"2020-01-02T08:34:14.000Z","comments":true,"path":"2020/01/02/数据分析章节（二）/","link":"","permalink":"https://ahrilove.top/2020/01/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。！ 本文要点：struct模块科学运算基本三大库Matplotlib图形","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。！ 本文要点：struct模块科学运算基本三大库Matplotlib图形 1.import struct库1.1 struct模块: 在Python中，『一切皆对象』，基本数据类型也不列外C语言的数组int a[3] = {1, 2, 4};存储的是真正的值Python的列表list = [1, 2, 4]，存储的是元素的指针 1.2 pack(),unpack()函数: struct模块最重要的两个函数就是pack()、unpack()方法：打包函数：pack(fmt, v1, v2, v3, …)；解包函数：unpack(fmt, buffer)，其中，fmt是格式字符（format的谐音），struct模块支持的格式化字符如下表 2.matplotlib库&nbsp;&nbsp;&nbsp;&nbsp;在python的matplotlib库中分别可用bar、barh、plot函数来构建它们，再使用xticks与yticks（设置坐标轴刻度）、xlabel与ylabel（设置坐标轴标签）、title（标题）、legend（图例）、xlim与ylim（设置坐标轴数据范围）、grid（设置网格线）等命令来装饰图形 2.1导入库文件&nbsp;&nbsp;&nbsp;&nbsp;from matplotlib import pyplot as plt&nbsp;&nbsp;&nbsp;&nbsp;import numpy as np 2.2 简单figure图像生成案例：123456789101112131415161718192021# 使用import导入模块matplotlib.pyplot，并简写成plt 使用import导入模块numpy，并简写成npfrom matplotlib import pyplot as pltimport numpy as npimport matplotlib# 使用np.linspace定义x：范围是(-1,1);个数是50x = np.linspace(-1, 1, 50)# 函数y=x^3y = x ** 3y1 = x ** 2# 使用plt.figure定义一个图像窗口.num代表图像窗口编号，figsize表示窗口大小plt.figure(num=3, figsize=(8, 5), )# 使用plt.plot画(x ,y1)曲线，曲线的颜色属性(color)为红色;# 曲线的宽度(linewidth)为1.0；曲线的类型(linestyle)为虚线. 使用plt.show显示图像plt.plot(x, y1, color='red', linewidth='1.0', linestyle='--')# 使用plt.plot画(x ,y1)曲线.plt.plot(x, y)# 展示绘制图像plt.show() 2.3坐标轴以及line： 设置坐标轴不同的名字、刻度以及范围： 1234567891011121314151617# 使用plt.xlim设置x坐标轴范围：(-2, 2)plt.xlim((-2,2))# 使用plt.ylim设置x坐标轴范围：(-2, 2)plt.ylim((-2,2))# 定义x轴名称plt.xlabel('x轴')# 定义y轴名称plt.ylabel('y轴')new_ticks = np.linspace(-2, 2, 5)print(new_ticks)# 使用plt.xticks设置x轴刻度：范围是(-2,2);个数是8.plt.xticks(new_ticks)# 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]# 对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]plt.yticks([-2, -1.8, -1, 1.22, 2],[r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$']) 坐标轴移至中心： 12345678910111213\"\"\"plt.gca获取当前坐标轴信息. 使用.spines设置边框；使用.set_color设置边框颜色\"\"\"# 坐标轴中移：ax = plt.gca()# 隐藏上边和右边ax.spines['top'].set_color('none')ax.spines['right'].set_color('none')# 移动另外两个轴ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data', 0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0)) 图例legend 123456# set line sylesl1, = plt.plot(x, y1, label='linear line')l2, = plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='square line')# legend将要显示的信息来自于上面代码中的 label(表示图例的名称). 所以我们只需要简单写下一下代码, plt 就能自动的为我们添加图例.# 图例展示plt.legend(loc='upper right') # loc属性表示图例放置位置：upper，right，bottom，left annotate标注 123456789101112# 标注具体某点x0 = 0.5y0 = x0**2plt.plot([x0, x0,], [0, y0,], 'k--', linewidth=2.5)# set dot stylesplt.scatter([x0, ], [y0, ], s=50, color='b')# 注释annotate，对(x0,y0)这个点进行标注plt.annotate(r'$x**2=%s$' % x0, xy=(x0, y0), xycoords='data', xytext=(+10, -10), # xytext=(+10, -10) 和 textcoords='offset points' 对于标注位置的描述 和 xy 偏差值 textcoords='offset points', fontsize=10, arrowprops=dict(arrowstyle='-&gt;', connectionstyle=\"arc3,rad=.2\")) matplotlib的颜色及线条控制（linestyle，color） linestyle: 12345&apos;-&apos; solid line style&apos;--&apos; dashed line style&apos;-.&apos; dash-dot line style&apos;:&apos; dotted line styl color:【参考此篇文章】 多图分区展示 语法格式：subplot(a,b,c)表示a行，b列，第c个图像区域 12345678910111213141516171819202122232425262728from matplotlib import pyplot as pltimport numpy as np# 规则图形：# 创建一个图形窗口plt.figure()# subplot(m,n,x):代表创建m*n个小图，x代表第i个图plt.subplot(2, 2, 1)# 绘制折线图x = [1, 2, 3, 4, 5, 6]y = [3, 5, 7, 8, 1, 2]plt.plot(x, y)# plt.subplot(2,2,2)表示将整个图像窗口分为2行2列, 当前位置为2plt.subplot(2, 2, 2)data = np.arange(1, 4, .25)plt.scatter(data, data)# plt.subplot(2,2,3)表示将整个图像窗口分为2行2列,当前位置为3plt.subplot(223)plt.plot([0, 1], [0, 3])# plt.subplot(2,2,4)表示将整个图像窗口分为2行2列,当前位置为4plt.subplot(2, 2, 4)plt.plot([0, 1], [3, 3])plt.show() plt.text()给图形添加数据标签 123456789101112131415161718import matplotlib.pyplot as pltimport numpy as np#创建带数字标签的直方图numbers = list(range(1,11))#np.array()将列表转换为存储单一数据类型的多维数组x = np.array(numbers)y = np.array([a**2 for a in numbers])plt.bar(x,y,width=0.5,align='center',color='c')plt.title('Square Numbers',fontsize=24)plt.xlabel('Value',fontsize=14)plt.ylabel('Square of Value',fontsize=14)plt.tick_params(axis='both',labelsize=14)plt.axis([0,11,0,110])for a,b in zip(x,y): # 用%.2f保留两位小数，横向居中对齐ha='center'，纵向底部（顶部）对齐va='bottom' plt.text(a,b+0.1,'%.2f'%b,ha = 'center',va = 'bottom',fontsize=7)plt.savefig('images\\squares.png')plt.show() &nbsp;&nbsp;&nbsp;&nbsp;首先，前边设置的x、y值其实就代表了不同柱子在图形中的位置（坐标），通过for循环找到每一个x、y值的相应坐标——a、b，再使用plt.text在对应位置添文字说明来生成相应的数字标签，而for循环也保证了每一个柱子都有标签。其中，a+0.5, b+0.05(表示位置高度)表示在每一柱子对应x值、y值上方0.05处标注文字说明，&#39;%.2f’ % b,代表标注的文字，即每个柱子对应的y值，其中0表示不显示小数后面的数值，1就表示显示小数后面一位，以此类推； ha=’center’, va= ‘bottom’代表horizontalalignment（水平对齐）、verticalalignment（垂直对齐）的方式，fontsize则是文字大小。条形图、折线图也是如此设置，饼图则在pie命令中有数据标签的对应参数。对于累积柱状图、双轴柱状图则需要用两个for循环，同时通过a与b的不同加减来设置数据标签位置。 3.图形未完待续： -3.1 散点图 -3.2 柱形图","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://ahrilove.top/tags/numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://ahrilove.top/tags/matplotlib/"}]},{"title":"Python全栈系列章节更新（九）：极验滑动二维码","slug":"Python全栈系列章节更新（九）","date":"2019-12-29T16:00:00.000Z","updated":"2019-12-30T03:04:08.000Z","comments":true,"path":"2019/12/30/Python全栈系列章节更新（九）/","link":"","permalink":"https://ahrilove.top/2019/12/30/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B9%9D%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：极验官网 哔哩哔哩反爬机制：极验滑动3.0版本相关技术：selenium技术难度：★★☆☆☆☆爬取目标：模拟登录官网，破解滑动二维码源代码：本页面说明：找到相关节点DOM，其他网站则可复用此源代码","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：极验官网 哔哩哔哩反爬机制：极验滑动3.0版本相关技术：selenium技术难度：★★☆☆☆☆爬取目标：模拟登录官网，破解滑动二维码源代码：本页面说明：找到相关节点DOM，其他网站则可复用此源代码 1.识别思路目标网站：哔哩哔哩动画&nbsp;&nbsp;&nbsp;但是对于应用了极验验证码的网站，识别并不是没有办法的。如果我们直接模拟表单提交的话，加密参数的构造是个问题，参数构造有问题服务端就会校验失败，所以在这里我们采用直接模拟浏览器动作的方式来完成验证，在 Python 中我们就可以使用 Selenium 来通过完全模拟人的行为的方式来完成验证，此验证成本相对于直接去识别加密算法容易不少。 模拟登录，找到入口url 模拟点击验证按钮 识别滑动缺口的位置 模拟拖动滑块&nbsp;&nbsp;&nbsp;&nbsp;可以看到缺口的四周边缘有明显的断裂边缘，而且边缘和边缘周围有明显的区别，我们可以实现一个边缘检测算法来找出缺口的位置。对于极验来说，我们可以利用和原图对比检测的方式来识别缺口的位置，因为在没有滑动滑块之前，缺口其实是没有呈现的.&nbsp;&nbsp;&nbsp;&nbsp;所以我们可以同时获取两张图片，设定一个对比阈值，然后遍历两张图片找出相同位置像素 RGB 差距超过此阈值的像素点位置，那么此位置就是缺口的位置。&nbsp;&nbsp;&nbsp;&nbsp;第四步操作看似简单，但是其中的坑比较多，极验验证码增加了机器轨迹识别，匀速移动、随机速度移动等方法都是不行的，只有完全模拟人的移动轨迹才可以通过验证，而人的移动轨迹一般是先加速后减速的，这又涉及到物理学中加速度的相关问题，我们需要模拟这个过程才能成功。2.初始化&nbsp;&nbsp;&nbsp;&nbsp;首先这次我们选定的链接为：https://account.geetest.com/login，也就是极验的管理后台登录页面，在这里我们首先初始化一些配置，如 Selenium 对象的初始化及一些参数的配置：123456789101112# 极验账号EMAIL = 'test@test.com'# 极验密码PASSWORD = '123456' class CrackGeetest(): def __init__(self): self.url = 'https://account.geetest.com/login' self.browser = webdriver.Chrome() self.wait = WebDriverWait(self.browser, 20) self.email = EMAIL self.password = PASSWORD 3.模拟点击随后我们需要实现第一步的操作，也就是模拟点击初始的验证按钮，弹出滑动二维码，所以我们定义一个方法来获取这个按钮，利用显式等待的方法来实现： 12345678def get_geetest_button(self): \"\"\" 获取初始验证按钮（点击就会弹出验证码滑块，这一步按实际情况出发， 有些验证码滑块是直接存在，不用再点击一次来触发生成滑块） :return: 按钮对象 \"\"\" button = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_radar_tip'))) return button 这里返回一个网页节点对象，直接调用click()方法即可模拟点击 12button = self.get_geetest_button()button.click() 到这里就完成了第一步，点击一下就会弹出极验滑动二维码界面 4.识别缺口&nbsp;&nbsp;&nbsp;&nbsp;接下来我们需要识别缺口的位置，首先我们需要将前后的两张比对图片获取下来，然后比对二者的不一致的地方即为缺口。首先我们需要获取不带缺口的图片，利用 Selenium 选取图片元素，然后得到其所在位置和宽高，随后获取整个网页的截图，再从截图中裁切出来即可，代码实现如下： 1234567891011121314151617181920212223def get_position(self): \"\"\" 获取验证码位置 :return: 验证码位置元组 \"\"\" img = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'geetest_canvas_img'))) time.sleep(2) location = img.location size = img.size top, bottom, left, right = location['y'], location['y'] + size['height'], location['x'], location['x'] + size[ 'width'] return (top, bottom, left, right) def get_geetest_image(self, name='captcha.png'): \"\"\" 获取验证码图片 :return: 图片对象 \"\"\" top, bottom, left, right = self.get_position() print('验证码位置', top, bottom, left, right) screenshot = self.get_screenshot() captcha = screenshot.crop((left, top, right, bottom)) return captcha &nbsp;&nbsp;&nbsp;&nbsp;在这里 get_position() 函数首先获取了图片对象，然后获取了它的位置和宽高，随后返回了其左上角和右下角的坐标。而 get_geetest_image() 方法则是获取了网页截图，然后调用了 crop() 方法将图片再裁切出来，返回的是 Image 对象。&nbsp;&nbsp;&nbsp;&nbsp;随后我们需要获取第二张图片，也就是带缺口的图片，要使得图片出现缺口，我们只需要点击一下下方的滑块即可，触发这个动作之后，图片中的缺口就会显现，实现如下： 1234567def get_slider(self): \"\"\" 获取滑块 :return: 滑块对象 \"\"\" slider = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_slider_button'))) return slider 利用 get_slider() 方法获取滑块对象，接下来调用其 click() 方法即可触发点击，缺口图片即可呈现： 123# 点击呼出缺口slider = self.get_slider()slider.click() &nbsp;&nbsp;&nbsp;&nbsp;随后还是调用 get_geetest_image() 方法将第二张图片获取下来即可。 &nbsp;&nbsp;&nbsp;&nbsp;到现在我们就已经得到了两张图片对象了，分别赋值给变量 image1 和 image2，接下来对比图片获取缺口即可。要对比图片的不同之处，我们在这里遍历图片的每个坐标点，获取两张图片对应像素点的 RGB 数据，然后判断二者的 RGB 数据差异，如果差距超过在一定范围内，那就代表两个像素相同，继续比对下一个像素点，如果差距超过一定范围，则判断像素点不同，当前位置即为缺口位置，代码实现如下： 123456789101112131415161718192021222324252627282930313233def is_pixel_equal(self, image1, image2, x, y): \"\"\" 判断两个像素是否相同 :param image1: 图片1 :param image2: 图片2 :param x: 位置x :param y: 位置y :return: 像素是否相同 \"\"\" # 取两个图片的像素点 pixel1 = image1.load()[x, y] pixel2 = image2.load()[x, y] threshold = 60 if abs(pixel1[0] - pixel2[0]) &lt; threshold and abs(pixel1[1] - pixel2[1]) &lt; threshold and abs( pixel1[2] - pixel2[2]) &lt; threshold: return True else: return False def get_gap(self, image1, image2): \"\"\" 获取缺口偏移量 :param image1: 不带缺口图片 :param image2: 带缺口图片 :return: \"\"\" left = 60 for i in range(left, image1.size[0]): for j in range(image1.size[1]): if not self.is_pixel_equal(image1, image2, i, j): left = i return left return left &nbsp;&nbsp;&nbsp;&nbsp;get_gap() 方法即为获取缺口位置的方法，此方法的参数为两张图片，一张为带缺口图片，另一张为不带缺口图片，在这里遍历两张图片的每个像素，然后利用 is_pixel_equal() 方法判断两张图片同一位置的像素是否相同，比对的时候比较了两张图 RGB 的绝对值是否均小于定义的阈值 threshold，如果均在阈值之内，则像素点相同，继续遍历，否则遇到不相同的像素点就是缺口的位置。 5.模拟拖动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def get_track(self, distance): \"\"\" 根据偏移量获取移动轨迹 :param distance: 偏移量 :return: 移动轨迹 \"\"\" # 移动轨迹 track = [] # 当前位移 current = 0 # 减速阈值 mid = distance * 4 / 5 # 计算间隔 t = 0.2 # 初速度 v = 0 while current &lt; distance: if current &lt; mid: # 加速度为正2 a = 2 else: # 加速度为负3 a = -3 # 初速度v0 v0 = v # 当前速度v = v0 + at v = v0 + a * t # 移动距离x = v0t + 1/2 * a * t^2 move = v0 * t + 1 / 2 * a * t * t # 当前位移 current += move # 加入轨迹 track.append(round(move)) return track def move_to_gap(self, slider, tracks): \"\"\" 拖动滑块到缺口处 :param slider: 滑块 :param tracks: 轨迹 :return: \"\"\" ActionChains(self.browser).click_and_hold(slider).perform() for x in tracks: ActionChains(self.browser).move_by_offset(xoffset=x, yoffset=0).perform() time.sleep(0.5) ActionChains(self.browser).release().perform() 在这里传入的参数为滑块对象和运动轨迹，首先调用ActionChains 的 click_and_hold() 方法按住拖动底部滑块，随后遍历运动轨迹获取每小段位移距离，调用 move_by_offset() 方法移动此位移，最后移动完成之后调用 release() 方法松开鼠标即可。 6.完整源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218import timefrom io import BytesIOfrom PIL import Imagefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECEMAIL = 'example@example.com'PASSWORD = ''BORDER = 6INIT_LEFT = 60class CrackGeetest(): def __init__(self): self.url = 'https://account.geetest.com/login' self.browser = webdriver.Chrome() self.wait = WebDriverWait(self.browser, 20) self.email = EMAIL self.password = PASSWORD def __del__(self): self.browser.close() def get_geetest_button(self): \"\"\" 获取初始验证按钮 :return: \"\"\" button = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_radar_tip'))) return button def get_position(self): \"\"\" 获取验证码位置 :return: 验证码位置元组 \"\"\" img = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'geetest_canvas_img'))) time.sleep(2) location = img.location size = img.size top, bottom, left, right = location['y'], location['y'] + size['height'], location['x'], location['x'] + size[ 'width'] return (top, bottom, left, right) def get_screenshot(self): \"\"\" 获取网页截图 :return: 截图对象 \"\"\" screenshot = self.browser.get_screenshot_as_png() screenshot = Image.open(BytesIO(screenshot)) return screenshot def get_slider(self): \"\"\" 获取滑块 :return: 滑块对象 \"\"\" slider = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_slider_button'))) return slider def get_geetest_image(self, name='captcha.png'): \"\"\" 获取验证码图片 :return: 图片对象 \"\"\" top, bottom, left, right = self.get_position() print('验证码位置', top, bottom, left, right) screenshot = self.get_screenshot() captcha = screenshot.crop((left, top, right, bottom)) captcha.save(name) return captcha def open(self): \"\"\" 打开网页输入用户名密码 :return: None \"\"\" self.browser.get(self.url) email = self.wait.until(EC.presence_of_element_located((By.ID, 'email'))) password = self.wait.until(EC.presence_of_element_located((By.ID, 'password'))) email.send_keys(self.email) password.send_keys(self.password) def get_gap(self, image1, image2): \"\"\" 获取缺口偏移量 :param image1: 不带缺口图片 :param image2: 带缺口图片 :return: \"\"\" left = 60 for i in range(left, image1.size[0]): for j in range(image1.size[1]): if not self.is_pixel_equal(image1, image2, i, j): left = i return left return left def is_pixel_equal(self, image1, image2, x, y): \"\"\" 判断两个像素是否相同 :param image1: 图片1 :param image2: 图片2 :param x: 位置x :param y: 位置y :return: 像素是否相同 \"\"\" # 取两个图片的像素点 pixel1 = image1.load()[x, y] pixel2 = image2.load()[x, y] threshold = 60 if abs(pixel1[0] - pixel2[0]) &lt; threshold and abs(pixel1[1] - pixel2[1]) &lt; threshold and abs( pixel1[2] - pixel2[2]) &lt; threshold: return True else: return False def get_track(self, distance): \"\"\" 根据偏移量获取移动轨迹 :param distance: 偏移量 :return: 移动轨迹 \"\"\" # 移动轨迹 track = [] # 当前位移 current = 0 # 减速阈值 mid = distance * 4 / 5 # 计算间隔 t = 0.2 # 初速度 v = 0 while current &lt; distance: if current &lt; mid: # 加速度为正2 a = 2 else: # 加速度为负3 a = -3 # 初速度v0 v0 = v # 当前速度v = v0 + at v = v0 + a * t # 移动距离x = v0t + 1/2 * a * t^2 move = v0 * t + 1 / 2 * a * t * t # 当前位移 current += move # 加入轨迹 track.append(round(move)) return track def move_to_gap(self, slider, track): \"\"\" 拖动滑块到缺口处 :param slider: 滑块 :param track: 轨迹 :return: \"\"\" ActionChains(self.browser).click_and_hold(slider).perform() for x in track: ActionChains(self.browser).move_by_offset(xoffset=x, yoffset=0).perform() time.sleep(0.5) ActionChains(self.browser).release().perform() def login(self): \"\"\" 登录 :return: None \"\"\" submit = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'login-btn'))) submit.click() time.sleep(10) print('登录成功') def crack(self): # 输入用户名密码 self.open() # 点击验证按钮 button = self.get_geetest_button() button.click() # 获取验证码图片 image1 = self.get_geetest_image('captcha1.png') # 点按呼出缺口 slider = self.get_slider() slider.click() # 获取带缺口的验证码图片 image2 = self.get_geetest_image('captcha2.png') # 获取缺口位置 gap = self.get_gap(image1, image2) print('缺口位置', gap) # 减去缺口位移 gap -= BORDER # 获取移动轨迹 track = self.get_track(gap) print('滑动轨迹', track) # 拖动滑块 self.move_to_gap(slider, track) success = self.wait.until( EC.text_to_be_present_in_element((By.CLASS_NAME, 'geetest_success_radar_tip_content'), '验证成功')) print(success) # 失败后重试 if not success: self.crack() else: self.login()if __name__ == '__main__': crack = CrackGeetest() crack.crack()","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"极验滑动","slug":"极验滑动","permalink":"https://ahrilove.top/tags/%E6%9E%81%E9%AA%8C%E6%BB%91%E5%8A%A8/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Vue(三)：组件与webpack","slug":"Vue(三)","date":"2019-12-21T16:00:00.000Z","updated":"2021-08-28T06:09:02.000Z","comments":true,"path":"2019/12/22/Vue(三)/","link":"","permalink":"https://ahrilove.top/2019/12/22/Vue(%E4%B8%89)/","excerpt":"1.父子组件之间的访问方式2.前端模块化3.webpack","text":"1.父子组件之间的访问方式2.前端模块化3.webpack 1.父子组件之间的访问方式Vue基础知识&nbsp;&nbsp;&nbsp;&nbsp;之前我们已经了解到组件的创建方式（三种全局组件创建方式和两种局部组建方式），props属性使用以及接受动态数据和静态数据。那我们今天就要学习一下关于： 有时候我们需要父组件访问子组件，子组件直接访问父组件，或者是子组件访问跟组件 父组件访问子组件：使用$children或$refs(reference引用之意) $refs =&gt; 对象类型，默认为空的对象，必须要加ref=”xxxx” ：在组件中使用ref（即，即表示给组件添加唯一的id属性）相当于给标签添加一个id，使得开发者可以知道我们操作的是那个DOM，用来获取DOM元素和组建引用 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;div id=\"app\"&gt; &lt;cpn ref=\"aaa\"&gt;&lt;/cpn&gt; &lt;button @click=\"btnClick('hello woman')\" value=\"click\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/template&gt; &lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; message:'hello man' &#125;, methods:&#123; btnClick(hi)&#123; console.log(hi); /* *调用子组件的name返回值 * 经测试：this必须添加，否则会出现$refs未定义的报错 * $refs.aaa.name中的aaa相当于id属性，也必须需要，否则会弹出name未定义的错误undefined * */ console.log(this.$refs.aaa.name); console.log(this.$refs.aaa.num) &#125; &#125;, components:&#123; 'cpn':&#123; template:'#cpn' , data()&#123; return &#123; name:\"我是子组件的name\", num:18 &#125; &#125;, methods: &#123; showMessage()&#123; console.log(\"showMessage\") &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 子组件访问父组件：使用$parent（不常用） 2.前端模块化方式 2.1 CommonJS的模块化实现,需要nodeJS的支持 【参考之前的文章】 2.2 ES6的模块化实现(可以直接在浏览器上直接运行) 如何实现模块化，在html中需要使用type=’module’属性。 1234&lt;!--index.html--&gt;&lt;h3&gt;hello world&lt;/h3&gt;&lt;script src=\"./aaa.js\" type=\"module\"&gt;&lt;/script&gt;&lt;script src=\"./bbb.js\" type=\"module\"&gt;&lt;/script&gt; 此时表示aaa.js等是一个单独的模块，此模块是有作用域的。如果要使用aaa.js内的变量，需要在aaa.js中先导出变量，再在需要使用的地方导入变量。 2.1 导出方式:这里推荐使用统一导出 123456789101112// aaa.static// 这里推荐使用统一导出：var age = 22;function sum(num1, num2) &#123; return num1 + num2;&#125;var flag = true;if (flag) &#123; console.log(sum(10, 20))&#125;//2.最后统一导出,导出sum函数，flag，age等属性值export &#123;flag,sum,age&#125; 2.2 导入方式:使用import {name,flag,sum} from &#39;./aaa.js&#39;导入多个变量 12345678910// bbb.js导入aaa.js中的sum函数，flag，name等属性值import &#123;name,flag,sum&#125; from './aaa.static';console.log(name);if(flag)&#123; console.log(\"小明是天才\");&#125;console.log(sum(20,30)); 2.3 默认导入 export default:有且只有一个export default导出： 123export default &#123; flag,sum,age&#125; 导入：注意：使用默认导出会将所有需要导出的变量打包成一个对象，此时导出一个对象，此时我在bbb.js中导入变量时候命名为aaa，如果要调用变量需要使用aaa.变量。 12345678910//默认导入 export defaultimport aaa from './aaa.static';console.log(aaa.sum(10,110));//使用import * as aaa from './aaa.static'统一全部导入// 5.统一全部导入import * as aaa from './aaa.static';console.log(aaa.flag);console.log(aaa.name); 3.webpack3.1 webpack的安装 webpack依赖node环境。 node环境依赖众多包，所以需要npm，npm（node packages manager）node包管理工具 nvm是node管理工具可以自由切换node环境版本 3.2 webpack起步【参考GitHub关于webpack的详细说明，这里不做重复累述】 以及【哔哩哔哩视频】 未完待续。。。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/categories/Vue/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ahrilove.top/tags/webpack/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（八）：js逆向爬虫的奇技淫巧","slug":"Python全栈系列章节更新（八）","date":"2019-12-18T16:00:00.000Z","updated":"2020-07-08T09:09:56.000Z","comments":true,"path":"2019/12/19/Python全栈系列章节更新（八）/","link":"","permalink":"https://ahrilove.top/2019/12/19/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AB%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：微信公众平台反爬机制：用户名不变，密码加密相关技术：selenium，requests，execjs技术难度：★★☆☆☆☆爬取目标：模拟登陆公共号，获取页面的所有信息源代码：本页面（selenium代码还在测试更新当中）说明：第一次玩js逆向爬虫，如有不足，多多指教","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：微信公众平台反爬机制：用户名不变，密码加密相关技术：selenium，requests，execjs技术难度：★★☆☆☆☆爬取目标：模拟登陆公共号，获取页面的所有信息源代码：本页面（selenium代码还在测试更新当中）说明：第一次玩js逆向爬虫，如有不足，多多指教 1.分析js，找到目标接口函数F12打开 开发者工具, 按照一般逻辑步骤，先输入一个错误账号密码，找到真正的入口接口函数,案例如下：继续向下翻动，我们可以看到请求参数表单数据的pwd密码是明显经过加密的 2.破解在Search功能栏下搜索pwd 很快可以定位到以下代码 12345678910_loginPost: function(e, i) &#123; n.post(&#123; url: i.url, data: &#123; username: i.account, pwd: o(i.pwd.substr(0, 16)), // 关键代码 imgcode: i.verify, f: \"json\", userlang: i.currentLang, redire 我们在pwd: o(i.pwd.substr(0, 16))行处下断点。然后步入进去. 1234567t.exports = function(n, r, t) &#123; return r ? t ? c(r, n) : function(n, r) &#123; return e(c(n, r)) &#125;(r, n) : t ? o(n) : function(n) &#123; return e(o(n)) // ***** &#125;(n)&#125; 继续步入一次，代码最后会走到我标****的地方。这就是我们需要的关键函数,扣代码吧。 扣下代码。然后自己编写一个Js function 123function JsKiller(pwd)&#123; return e(o(pwd));&#125; js逆向加密源代码：pwd.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091function d(n, r) &#123; var t = (65535 &amp; n) + (65535 &amp; r); return (n &gt;&gt; 16) + (r &gt;&gt; 16) + (t &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; t&#125;function f(n, r, t, e, u, o) &#123; return d(function (n, r) &#123; return n &lt;&lt; r | n &gt;&gt;&gt; 32 - r &#125;(d(d(r, n), d(e, o)), u), t)&#125;function g(n, r, t, e, u, o, c) &#123; return f(r &amp; t | ~r &amp; e, n, r, u, o, c)&#125;function l(n, r, t, e, u, o, c) &#123; return f(r &amp; e | t &amp; ~e, n, r, u, o, c)&#125;function v(n, r, t, e, u, o, c) &#123; return f(r ^ t ^ e, n, r, u, o, c)&#125;function s(n, r, t, e, u, o, c) &#123; return f(t ^ (r | ~e), n, r, u, o, c)&#125;function i(n, r) &#123; n[r &gt;&gt; 5] |= 128 &lt;&lt; r % 32; n[14 + (r + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = r; var t, e, u, o, c, f = 1732584193, i = -271733879, a = -1732584194, h = 271733878; for (t = 0; t &lt; n.length; t += 16) i = s(i = s(i = s(i = s(i = v(i = v(i = v(i = v(i = l(i = l(i = l(i = l(i = g(i = g(i = g(i = g(u = i, a = g(o = a, h = g(c = h, f = g(e = f, i, a, h, n[t], 7, -680876936), i, a, n[t + 1], 12, -389564586), f, i, n[t + 2], 17, 606105819), h, f, n[t + 3], 22, -1044525330), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 4], 7, -176418897), i, a, n[t + 5], 12, 1200080426), f, i, n[t + 6], 17, -1473231341), h, f, n[t + 7], 22, -45705983), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 8], 7, 1770035416), i, a, n[t + 9], 12, -1958414417), f, i, n[t + 10], 17, -42063), h, f, n[t + 11], 22, -1990404162), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 12], 7, 1804603682), i, a, n[t + 13], 12, -40341101), f, i, n[t + 14], 17, -1502002290), h, f, n[t + 15], 22, 1236535329), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 1], 5, -165796510), i, a, n[t + 6], 9, -1069501632), f, i, n[t + 11], 14, 643717713), h, f, n[t], 20, -373897302), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 5], 5, -701558691), i, a, n[t + 10], 9, 38016083), f, i, n[t + 15], 14, -660478335), h, f, n[t + 4], 20, -405537848), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 9], 5, 568446438), i, a, n[t + 14], 9, -1019803690), f, i, n[t + 3], 14, -187363961), h, f, n[t + 8], 20, 1163531501), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 13], 5, -1444681467), i, a, n[t + 2], 9, -51403784), f, i, n[t + 7], 14, 1735328473), h, f, n[t + 12], 20, -1926607734), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 5], 4, -378558), i, a, n[t + 8], 11, -2022574463), f, i, n[t + 11], 16, 1839030562), h, f, n[t + 14], 23, -35309556), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 1], 4, -1530992060), i, a, n[t + 4], 11, 1272893353), f, i, n[t + 7], 16, -155497632), h, f, n[t + 10], 23, -1094730640), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 13], 4, 681279174), i, a, n[t], 11, -358537222), f, i, n[t + 3], 16, -722521979), h, f, n[t + 6], 23, 76029189), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 9], 4, -640364487), i, a, n[t + 12], 11, -421815835), f, i, n[t + 15], 16, 530742520), h, f, n[t + 2], 23, -995338651), a = s(a, h = s(h, f = s(f, i, a, h, n[t], 6, -198630844), i, a, n[t + 7], 10, 1126891415), f, i, n[t + 14], 15, -1416354905), h, f, n[t + 5], 21, -57434055), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 12], 6, 1700485571), i, a, n[t + 3], 10, -1894986606), f, i, n[t + 10], 15, -1051523), h, f, n[t + 1], 21, -2054922799), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 8], 6, 1873313359), i, a, n[t + 15], 10, -30611744), f, i, n[t + 6], 15, -1560198380), h, f, n[t + 13], 21, 1309151649), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 4], 6, -145523070), i, a, n[t + 11], 10, -1120210379), f, i, n[t + 2], 15, 718787259), h, f, n[t + 9], 21, -343485551), f = d(f, e); i = d(i, u); a = d(a, o); h = d(h, c); return [f, i, a, h]&#125;function a(n) &#123; var r, t = \"\"; for (r = 0; r &lt; 32 * n.length; r += 8) t += String.fromCharCode(n[r &gt;&gt; 5] &gt;&gt;&gt; r % 32 &amp; 255); return t&#125;function h(n) &#123; var r, t = []; for (t[(n.length &gt;&gt; 2) - 1] = void 0, r = 0; r &lt; t.length; r += 1) t[r] = 0; for (r = 0; r &lt; 8 * n.length; r += 8) t[r &gt;&gt; 5] |= (255 &amp; n.charCodeAt(r / 8)) &lt;&lt; r % 32; return t&#125;function e(n) &#123; var r, t, e = \"0123456789abcdef\", u = \"\"; for (t = 0; t &lt; n.length; t += 1) r = n.charCodeAt(t); u += e.charAt(r &gt;&gt;&gt; 4 &amp; 15) + e.charAt(15 &amp; r); return u&#125;function u(n) &#123; return unescape(encodeURIComponent(n))&#125;function o(n) &#123; return function (n) &#123; return a(i(h(n), 8 * n.length)) &#125;(u(n))&#125;function c(n, r) &#123; return function (n, r) &#123; var t, e, u = h(n), o = [], c = []; for (o[15] = c[15] = void 0, 16 &lt; u.length &amp;&amp; (u = i(u, 8 * n.length)), t = 0; t &lt; 16; t += 1) o[t] = 909522486 ^ u[t]; c[t] = 1549556828 ^ u[t]; return e = i(o.concat(h(r)), 512 + 8 * r.length); a(i(c.concat(e), 640)) &#125;(u(n), u(r))&#125;function JsKiller(pwd) &#123; return e(o(pwd))&#125; 3.执行破解出的js123456789101112import execjsdef parseJS(pwd): # 读取pwd.js文件内容 with open(\"pwd.static\", 'r') as f: js_code = f.read() # 编译js函数 ctx = execjs.compile(js_code) # 执行js中的JsKiller函数，参数为pwd result = ctx.call('JsKiller', pwd) return result 比如我们来执行一下这个python代码，测试一下结果：令pwd=”Github” ctx.call(‘JsKiller’, pwd) ==&gt; &quot;e1adbcbb92c622d0b3e619f9d0730abf”,即将GitHub加密成32位。 4.模拟登陆 这里直接列出来模拟登录的源代码，这里需要注意一定要加referer 12345678910111213141516171819202122232425262728293031323334353637383940414243import execjsimport requestsurl = \"https://mp.weixin.qq.com/cgi-bin/bizlogin?action=startlogin\" # 这就是真正的入口urldef get_content(username, pwd): headers = &#123; \"referer\": \"https://mp.weixin.qq.com/\", # 必须要写 \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36\" &#125; data = &#123; \"username\": username, \"pwd\": pwd, \"f\": \"json\", \"imgcode\": \"\", \"userlang\": \"zh_CN\", \"lang\": \"zh_CN\", \"ajax\": 1 &#125; try: response = requests.post(url=url, headers=headers, data=data, timeout=10) if (response.status_code == 200): return response.text return None except Exception as e: print(e)def parseJS(pwd): with open(\"pwd.static\", 'r') as f: js_code = f.read() ctx = execjs.compile(js_code) result = ctx.call('JsKiller', pwd) return resultif __name__ == '__main__': username = \"980710425@qq.com\" pwd = \"XXXXXXXX\" pwd = parseJS(pwd) print(get_content(username, pwd)) 5.结果分析得到返回结果：这里返回了一个json格式数据，并且我们可以得知，这里其实是重定向到了这个新的URL地址 12345&#123;\"base_resp\":&#123; \"err_msg\":\"ok\", \"ret\":0&#125;, \"redirect_url\":\"/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account=980710425%40qq.com\"&#125; https://mp.weixin.qq.com/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account=980710425%40qq.com这个链接其实是需要微信扫码登陆认证的链接，我也不知道怎么去绕过这个扫码认证，如果有大神巨佬知道，请带带我。我的笨办法是通过selenium自动化测试，还是不可避免要扫码，然后扫码登陆，获取目标数据 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"逆向爬虫","slug":"逆向爬虫","permalink":"https://ahrilove.top/tags/%E9%80%86%E5%90%91%E7%88%AC%E8%99%AB/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章五：常见函数和属性","slug":"Javascript篇章五","date":"2019-12-17T16:00:00.000Z","updated":"2021-09-07T02:31:38.000Z","comments":true,"path":"2019/12/18/Javascript篇章五/","link":"","permalink":"https://ahrilove.top/2019/12/18/Javascript%E7%AF%87%E7%AB%A0%E4%BA%94/","excerpt":"1.Math(算术对象)2.运算符★★★3.循环与跳出循环4.数组的map，reduce与filter5.原生JS实现树状结构列表★★★","text":"1.Math(算术对象)2.运算符★★★3.循环与跳出循环4.数组的map，reduce与filter5.原生JS实现树状结构列表★★★ 1.MathMath对象，提供科学数学计算，也同样具有属性与方法 Math对象属性 Math 对象方法 扩展：当求数组中最大/最小值时，我们也可以使用Math对象 ES5：Math.max.apply(null,targetArray) ES6：Math.max(…targetArray) 2.运算符 算术运算符 + - * / 加减乘除 % 取余 ++ 自增 -- 自减 赋值运算符 运算符 说明 = 简单赋值 += 作和赋值 -= 作差赋值 *= 作乘赋值 /= 作除赋值 %= 取余赋值 比较运算符 == ：判断是否值相等 === ：判断值和数据类型是否相等 ！= ：不等于 &gt; &lt; &gt;= &lt;= :基本判断 逻辑运算符 &amp;&amp; ：逻辑与 || ：逻辑或 ！ ：逻辑非 在js逻辑运算中，0、&quot;&quot;、null、false、undefined、NaN都会判为false，其他都为true 条件运算符 (condition) ? value1 : value2 逻辑为真时，值为value1；逻辑为假时，同理 位运算符 位运算符工作于32位的数字上,任何数字操作都将转换为32位。结果会转换为JavaScript数字 运算符 描述 实例 等同 结果 实际值 &amp; AND x = 5 &amp; 1 0101 &amp; 0001 0001 1 竖线 OR x = 5 竖线 1 0101 竖线 0001 0101 5 ~ 取反 x = ~ 5 ~0101 1010 -6 ^ 异或 x = 5 ^ 1 0101 ^ 0001 0100 4 &lt;&lt; 左移 x = 5 &lt;&lt; 1 0101 &lt;&lt; 1 1010 10 &gt;&gt; 右移 x = 5 &gt;&gt; 1 0101 &gt;&gt; 1 0010 2 常见几个短小却令人惊叹的 JavaScript 代码 123451. 随机数：Math.random()*1000|0 比 Math.floor() 写起来简单多了2. 判断奇偶性：222 % 2 == 0 还可以写成 (222 &amp; 1) == 03. 取最近的偶数：(1111 | 1) - 1 结果为 1110，比写 if 判断奇偶再-1是不是更直接4. 除2取整：最基础Math.floor(5/2)，最快的方法 X&gt;&gt;1，起码可以提高60%运行效率+26%编程效率5. 向下取整: x &gt;&gt; 0 或者 ~~x 或者 x|0 均可以实现浮点数取整(等于Math.floor) 3. 循环与跳出循环 条件判断 if…else if…else if…else 循环语句 普通for循环 for(let i=1;i&lt;=1000;i++){} for-in循环 for (key in items){ items[key] } for-in循环是为遍历对象而设计的，并不适用于遍历数组 12345678910// 创建一个js对象let b = &#123;name: \"chd\", age: 18, sex: \"man\"&#125;;for (let index in b)&#123; console.log(index+\":\"+b[index]);&#125;/* 运行结果name:chdage:18sex:man*/ forEach循环 JavaScript5开始启用,回调函数中的value,index,array分别为值，索引，数组本身 12345678910let myArray = [1,3,5,7,9,\"hello world\"];myArray.forEach(function (value, index, array) &#123; console.log(\"索引：\"+index+\" =&gt; \"+value); console.log(\"数组本身：\"+array);&#125;);// 回调函数改为箭头函数（仅适用于ES6语法及以上）myArray.forEach((value, index) =&gt; &#123; console.log(\"索引：\"+index+\" =&gt; \"+value);&#125;); forEach缺陷：不能中断循环(即不能使用break语句,continue语句或使用return语句) for-of循环 ES6新语法，适用于遍历可序列化数据结构，字符串、数组、Map、Set for–of循环并不能直接使用在普通的对象上，但如果我们按对象所拥有的属性进行循环，可使用内置的Object.keys()方法 1234let someObject = &#123;a:1, b:2, c:3&#125;;for (let key of Object.keys(someObject)) &#123; console.log(key + \": \" + someObject[key]);&#125; while循环 while(true){} 在循环体中，跳出循环常用三种：continue，break，return continue:无论在单层，多层循环中，都只会结束最里层循环中的本次循环 break:无论在单层，多层循环中，都只会跳出最里层循环 return:无论在单层，多层循环中，遇到return都会直接跳出函数，for循环后面的语句也不再执行 4.数组的map，reduce与filtermap()，reduce()与filter()方法的参数均为匿名函数（也可以为箭头函数），即不存在函数名的函数 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 1234567'use strict'; //严格模式let arr = [1, 2, 3, 4];let newArr = arr.map(function(item) &#123; // 使用map方法将每一个元素变为两倍 return item * 2;&#125;);console.log(newArr); // [2, 4, 6, 8] filter()函数用于筛选出符合要求的数据,并返回该数据集合. 1234567let arr = [1, 2, 3, 4];let newArr = arr.filter(function(item) &#123; // 使用filter方法：判断每一个元素，如果是奇数，则直接返回该值 if (item % 2 !== 0) &#123; return item;&#125;&#125;);console.log(newArr); // [1, 3] reduce()函数用于把数组或对象归结为一个值,并返回这个值,使用方法为arr.reduce(func,memo),其中func为处理函数,memo为初始值,初始值可缺省. 123456'use strict';let arr = [1,2,3,4];let newArr=arr.reduce(function(a,b)&#123; return a+b;&#125;,0); console.log(newArr) ; // 10 5.原生JS实现树状结构列表此方法的数据结构层次没有限制，均为动态层数，若节点的上级节点不存在，便会将其作为一级节点 确定原始数据结构 原始数据是需要按照下面这种结构来定义的，如果原始数据已经是被后端处理成树状结构，就可以省略这一步骤 1234567891011121314151617181920212223242526272829let data = [&#123; \"id\": \"1\", \"name\": \"1\", \"fatherId\": \"0\", &#125;,&#123; \"id\": \"2\", \"name\": \"1-1\", \"fatherId\": \"1\" &#125;,&#123; \"id\": \"3\", \"name\": \"1-2\", \"fatherId\": \"1\" &#125;,&#123; \"id\": \"4\", \"name\": \"1-1-1\", \"fatherId\": \"2\" &#125;,&#123; \"id\": \"5\", \"name\": \"1-1-2\", \"fatherId\": \"2\" &#125;,&#123; \"id\": \"6\", \"name\": \"2\", \"fatherId\": \"0\" &#125;,&#123; \"id\": \"7\", \"name\": \"1-2-1\", \"fatherId\": \"3\" &#125;]; 使用map处理数据 其中的id表示节点id，fatherId表示当前节点的父类id，children表示子集列表，这几个变量名都是可自定义的。 12345678910111213const map = &#123;&#125;; // 将数据存储为以id为 KEY的 map索引数据列const val = []; // 返回的最终树状结构jsondata.forEach((item) =&gt; &#123; map[item.id] = item;&#125;);data.forEach((item) =&gt; &#123; const parent = map[item.fatherId]; // 以当前遍历项的parentId去map对象中找到索引的id if (parent) &#123; // 如果找到索引，说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中 (parent.children || (parent.children = [])).push(item); &#125; else &#123; val.push(item); // 如果没有在map中找到对应的索引ID,那么直接把当前的item添加到val结果集中，作为顶级 &#125;&#125;); 参考网址： element-ui中table树形表格的实现 原生JS实现树状结构列表","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Vue(二):生命周期函数","slug":"Vue(二)","date":"2019-12-16T16:00:00.000Z","updated":"2021-09-11T08:22:20.000Z","comments":true,"path":"2019/12/17/Vue(二)/","link":"","permalink":"https://ahrilove.top/2019/12/17/Vue(%E4%BA%8C)/","excerpt":"1.生命周期函数2.生命周期函数(Ⅱ)3.watch监听属性4.computed计算属性","text":"1.生命周期函数2.生命周期函数(Ⅱ)3.watch监听属性4.computed计算属性 1.生命周期函数 创建阶段 1234567891.beforeCreate():表示实例完全被创建时，会执行它 /ps：在beforCreate生命周期函数执行时，data和methods中的数据均未被初始化2.created():在created中，data与methods都已经被实例化了，3.beforeMount(): 表示模板已经在内存中编译好了，只是未渲染到真正要展示的页面上4.mounted():是实例创建期间最后一个生命周期函数，当执行完mounted就表示，实例已经完全创建好了， 此时，如果没有其它操作的话，这个实例就静静地躺在内存中 组件运行阶段： 12341.beforeUpdate(): 表示我们的界面还没有更新，但数据肯定被更新了 结论：运行beforeUpdate，页面上显示的数据还没有被更新，但数据已经更新了，页面与数据更新不同步2.updated():页面都data数据已经保持同步了，都是最新的 销毁过程 1231.beforeDestroy：Vue示例已经从运行阶段，进入到销毁阶段，实例身上的所有data，methods以及过滤器，指令都处于可用状态，未执行真正的销毁动作2.destroyed：组件已经完全销毁了，一切data，方法，指令，过滤器均不可使用 2. 生命周期函数(二)在理清生命周期函数之前，先看两张图 初识： 详解： 小结一： created执行时会初始化Vue实例的数据对象data。但$el,dom树还没有加载，即改变 data() 中的数据是不会触发 change 事件的，无法进入 watch 代码部分 mounted执行时，vue实例挂载完成，data.filter成功渲染，即此时改变 data 中的数据是会触发 change 事件的，也就能被 watch 到 关于create函数和watch执行顺序问题，一般在watch里面写上immediate：true，会使得执行优先级高于created watch 与 computed 的区别，最关键的是watch需要监听值的变化而改变，但是computed从一开始就可以达到和某个值关联起来（computed会忽略其它生命周期函数，从一开始就会监听某个值） 案例一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div&gt; &lt;p&gt; &#123;&#123; firstNum &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; secondNum &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; thirdNum &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; firstNum: 0, thirdNum: 0 &#125; &#125;, created() &#123; // 该步骤在 data() 数据实例化之前。 // 此时改变 data() 中的数据是不会触发 change 事件的，无法进入 watch 代码部分。 this.firstNum = 1; console.log('created: ' + this.firstNum); &#125;, mounted() &#123; // 该步骤在 data 数据实例化之后。 // 此时改变 data 中的数据是会触发 change 事件的，也就能被 watch 到。 this.firstNum = 2; console.log('mounted: ' + this.firstNum) &#125;, computed: &#123; secondNum() &#123; // firstNum 从一开始就与之绑定关联 console.log('secondNum is computing: ' + this.firstNum * 100); return this.firstNum * 100; &#125; &#125;, watch: &#123; firstNum(val) &#123; // firstNum 只有在发生改变时，才会进入该逻辑 console.log('firstNum is watched: ' + val); this.thirdNum = val * 100 &#125; &#125;&#125;&lt;/script&gt; 执行结果如何呢： html显示结果： 123452200200 console.log显示结果： 12345created: 1secondNum is computing: 100mounted: 2firstNum is watched: 2secondNum is computing: 200 结果解释： created方法是在data()数据初始化之前执行，开始执行created方法，给firstNum赋值为1，并console当前的firstNum赋值后的值 ⬇由于created方法执行后，并没有挂载$el，改变 data() 中的数据是不会触发 change 事件的，无法进入 watch 代码部分 ⬇firstNum被赋值后，由于computed从一开始就可以达到和firstNum关联起来，firstNum值改变，执行计算方法 ⬇接下来开始执行mounted方法，挂载$el，完成DOM树的创建，数据完成渲染。firstNum再次被赋值，由于此时数据已完成渲染，此时改变 data 中的数据是会触发 change 事件的，也就能被 watch 到 ⬇执行完watch完后，computed再检测有没有数据的变更 案例二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"a in arr\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"fn\"&gt;点我一下&lt;/button&gt; &lt;/div&gt; &lt;script src=\"../node_modules/axios/dist/axios.js\"&gt;&lt;/script&gt; &lt;script src=\"../node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; // 生命周期： Vue是一个构造函数，当执行执行这个函数时，相当于初始化vue实例； // 在创建实例过程中，需要设置数据监听，编译模板，将实例挂载到DOM上，数据更新能够让DOM也更新， // 在这个初始化，又会不同阶段默认调用一些函数执行，这些函数就是生命周期的钩子函数； // 生命周期钩子函数，让够让咱们在初始化实例时，添加自己的代码； //生命周期的钩子函数中的this，会默认指向vue的实例 // beforeCreate created // beforeMount mounted // beforeUpdate updated // beforeDestroy destroyed let vm = new Vue(&#123; data: &#123; msg: \"hello\", arr: [1, 2, 3, 4] &#125;, // 1. 在这个钩子函数执行之前初始化事件以及生命周期 beforeCreate() &#123; // 1. 在这个钩子函数中，不能获取data中的数据 // console.log(this.msg); // 2. 这个函数不能操作DOM； // console.log(document.getElementsByTagName(\"li\")) &#125;, // 给Vue的实例注入数据，进行数据监听 created() &#123; // 在created发送请求 // 1. 可以获取到data中的数据 // 2. 不能操作DOM的 // console.log(this.msg); // console.log(document.getElementsByTagName(\"li\")) axios.get(\"./carts.json\").then(data =&gt; &#123; // 异步的； this.arr = data.data; console.log(2); &#125;) &#125;, methods: &#123; fn() &#123; this.msg = \"world\" &#125; &#125;, // 执行之前，判断是否有el,template;编译 beforeMount() &#123; // console.log(document.getElementsByTagName(\"li\")) &#125;, // 挂载完毕 mounted() &#123; // debugger // 挂载： 把VUE实例生成的虚拟的DOM转成真实的DOM，放在了页面中，这就是挂载； // 编译出的DOM把原有的DOM替换完毕； // 可以获取最终的DOM元素 // let d = &#123;type:\"div\",a:\"1\",chidlren:[&#123;type:\"span\",children:[]&#125;]&#125; console.log(document.getElementsByTagName(\"li\")); //console.log(\"mounted\",\"初始化\"); &#125;, // 当数据更新时，会调用beforeUpdate 和updated钩子函数；上面四个不再运行 beforeUpdate() &#123; console.log(\"beforeUpdate\", \"更新之前\"); console.log(this.msg) // 更新数据之前执行 &#125;, updated() &#123; console.log(\"beforeUpdate\", \"更新之后\"); // 数据更新，虚拟的DOM更新，然后更新真实的DOM；最后触发这个函数 &#125;, // 销毁之前 beforeDestroy() &#123; // 销毁之前 // 清除定时器 console.log(\"beforeDestroy\"); &#125;, // 销毁之后 destroyed() &#123; console.log(\"destroyed\"); // 销毁子组件，销毁观察者，事件监听者 // 元素的事件还在，但是更改数据不会再让视图进行更新了； &#125; &#125;).$mount(\"#app\"); // vm.$destroy(); // console.log(vm); // 在项目中，你遇到过什么问题，怎么解决的？ // 准备 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.watch监听属性Watch：可以监听data属性域中的数据变化，主要有handler方法，immediate属性，deep属性 handler方法就是你watch中需要具体执行的方法 immediate为true时则立即触发回调函数；如果为false，则和上面的例子一样，不会立即执行回调 deep顾名思义就是深入监听，也就是在对象中层层遍历，并在监听对象上的每一个属性上都添加监听，固然也会损耗性能 123456789watch: &#123; orgBarChartData: &#123; // 监听的目标属性 handler(newVal,oldVal)&#123; this.renderOrgBarChart(); //重设图表，这两个都是动作体 this.orgBarChart.resize(); //重新设置图表高宽 &#125;, deep: true // deep:true &#125;,&#125; 4.computed计算属性computed和methods虽然都可以实现对数据的计算，但两者有一定的区别: methods:使用methods方法可以接受外部传参,使用更加灵活 computed: 计算属性computed的亮点在于：它能够依赖缓存，当计算属性所依赖的数据发生改变时,才会重新触发计算属性方法执行。所以对于较复杂或消耗效率的计算，一定要采用计算属性。 计算属性computed里面也可以写函数，并且调用函数时使用的mustache语法不用加括号 computed里虽然存放的是函数，但在调用时，computed里的东西是一个属性，所以我们在调用时不能使用() ，因为()表示是在调用函数，而不是调用属性 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;!--这里的mustache语法调用计算属性时没有声明括号--&gt; &lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;script &gt; const vm = new Vue(&#123; el: '#app', data:&#123; firstName:\"985\", lastName:\"Miss\" &#125;, computed:&#123; fullname () &#123; return this.lastName+this.firstName; &#125; &#125;, methods:&#123;&#125; &#125;)&lt;/script&gt; 参考文章 Vue生命周期(11个钩子函数) vue中 computed与watch、created与mounted 彼此的关联与顺序","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/tags/Vue/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"ThinkPHP项目（三）：常见函数和属性","slug":"php(四)","date":"2019-12-15T16:00:00.000Z","updated":"2021-05-06T06:31:48.000Z","comments":true,"path":"2019/12/16/php(四)/","link":"","permalink":"https://ahrilove.top/2019/12/16/php(%E5%9B%9B)/","excerpt":"还是紧接前面的知识展开，本章节列举出遇到的一些项目相关函数与属性 1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单","text":"还是紧接前面的知识展开，本章节列举出遇到的一些项目相关函数与属性 1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单 1. is_array(search_value,array,type)in_array() 函数搜索数组中是否存在指定的值。type是可选的，如果设置该参数为true，则又要检查搜索的数据与数组的值的类型是否相同 12345678&lt;?php $people = array(\"Bill\", \"Steve\", \"Mark\", \"David\"); if (in_array(\"Mark\", $people))&#123; echo \"匹配已找到\";&#125; else&#123; echo \"匹配未找到\";&#125;?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://ahrilove.top/categories/PHP/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://ahrilove.top/tags/ThinkPHP/"}],"author":{"name":"憨批龟","avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png"}},{"title":"数据分析章节（一）：初始数学之美","slug":"数据分析章节（一）","date":"2019-12-14T16:00:00.000Z","updated":"2019-12-15T11:27:00.000Z","comments":true,"path":"2019/12/15/数据分析章节（一）/","link":"","permalink":"https://ahrilove.top/2019/12/15/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学是一门美丽的学科，是美丽的，也充满悲剧的！ 本文要点：直角坐标系与极坐标方程科学运算基本三大库Matplotlib，Numpy，Pandas一个浪漫又悲情的爱情故事——笛卡尔心形线执子之魂，与子共生——玫瑰线给我一个支点——阿基米德螺线","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学是一门美丽的学科，是美丽的，也充满悲剧的！ 本文要点：直角坐标系与极坐标方程科学运算基本三大库Matplotlib，Numpy，Pandas一个浪漫又悲情的爱情故事——笛卡尔心形线执子之魂，与子共生——玫瑰线给我一个支点——阿基米德螺线 1.直角坐标与极坐标方程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较直角坐标系方程y=x，它表示平面上的一条线，而极坐标方程ρ=θ表示螺线。用极坐标系描述的曲线方程称作极坐标方程，通常用来表示ρ为自变量θ的函数(ρ,θ)=0。 两坐标系之间的转换 极坐标系中的两个坐标r和θ可以由下面的公式转换为直角坐标系下的坐标值。x = rcos（θ），y = rsin（θ），由上述二公式，可得到从直角坐标系中x和y两坐标如何计算出极坐标下的坐标：角度θ = arctan(y/x)总结如下： 2.科学运算三大基本库基本知识点参考我的GitHub补充一点：PYTHON使用MATPLOTLIB绘图时出现的中文乱码问题,设置代码如下 1234from matplotlib import pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 3.一个浪漫又悲情的爱情故事——笛卡尔心形线【转载】1650年，斯德哥尔摩的街头，52岁的笛卡尔邂逅了18岁的瑞典公主克里斯汀。 那时，落魄、一文不名的笛卡尔过着乞讨的生活，全部的财产只有身上穿的破破烂烂的衣服和随身所带的几本数学书籍。生性清高的笛卡尔从来不开口请求路人施舍，他只是默默地低头在纸上写写画画，潜心于他的数学世界。 一个宁静的午后，笛卡尔照例坐在街头，沐浴在阳光中研究数学问题。他如此沉溺于数学世界，身边过往的人群，喧闹的车马队伍。都无法对他造成干扰。 突然，有人来到他旁边，拍了拍他的肩膀，“你在干什么呢？”扭过头，笛卡尔看到一张年轻秀丽的睑庞，一双清澈的眼睛如湛蓝的湖水，楚楚动人，长长的睫毛一眨一眨的，期待着他的回应。她就是瑞典的小公主，国王最宠爱的女儿克里斯汀。 她蹲下身，拿过笛卡尔的数学书和草稿纸，和他交谈起来。言谈中，他发现，这个小女孩思维敏捷，对数学有着浓厚的兴趣。 和女孩道别后，笛卡尔渐渐忘却了这件事，依旧每天坐在街头写写画画。 几天后，他意外地接到通知，国王聘请他做小公主的数学老师。满心疑惑的笛卡尔跟随前来通知的侍卫一起来到皇宫，在会客厅等候的时候，他听到了从远处传来的银铃般的笑声。转过身，他看到了前儿天在街头偶遇的女孩子。慌忙中，他赶紧低头行礼。 从此，他当上了公主的数学老师。 公主的数学在笛卡尔的悉心指导下突飞猛进，他们之间也开始变得亲密起来。笛卡尔向她介绍了他研究的新领域——直角坐标系。通过它，代数与几何可以结合起来，也就是日后笛卡尔创立的解析几何学的雏形。 在笛卡尔的带领下，克里斯汀走进了奇妙的坐标世界，她对曲线着了迷。每天的形影不离也使他们彼此产生了爱慕之心。 在瑞典这个浪漫的国度里，一段纯粹、美好的爱情悄然萌发。 然而，没过多久，他们的恋情传到了国王的耳朵里。国王大怒，下令马上将笛卡尔处死。在克里斯汀的苦苦哀求下，国王将他放逐回国，公主被软禁在宫中。 当时，欧洲大陆正在流行黑死病。身体孱弱的笛卡尔回到法国后不久，便染上重病。在生命进入倒计时的那段日子，他日夜思念的还是街头偶遇的那张温暖的笑脸。他每天坚持给她写信，盼望着她的回音。然而，这些信都被国王拦截下来，公主一直没有收到他的任何消息。 在笛卡尔给克里斯汀寄出第十三封信后，他永远地离开了这个世界。此时，被软禁在宫中的小公主依然徘徊在皇宫的走廊里，思念着远方的情人。 这最后一封信上没有写一句话，只有一个方程：r=a(1-sinθ)。 国王看不懂，以为这个方程里隐藏着两个人不可告人的秘密，便把全城的数学家召集到皇宫，但是没有人能解开这个函数式。他不忍看着心爱的女儿每天闷闷不乐，便把这封信给了她。 拿到信的克里斯汀欣喜若狂，她立即明白了恋人的意图，找来纸和笔，着手把方程图形画了出来，一颗心形图案出现在眼前，克里斯汀不禁流下感动的泪水，这条曲线就是著名的“心形线”。 国王去世后，克里斯汀继承王位，登基后，她便立刻派人去法国寻找心上人的下落，收到的却是笛卡尔去世的消息，留下了一个永远的遗憾…… 这封享誉世界的另类情书，至今，还保存在欧洲笛卡尔的纪念馆里。———————————————— 4.三大曲线图像展示 极坐标方程： 心形线：r=a(1-cosθ) (a&gt;0)玫瑰线：r=asin(3θ) (a&gt;0)阿基米德螺线：r=aθ(a&gt;0,θ&gt;=0) 成品展示 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import numpy as npfrom matplotlib import pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号def draw(): plt.title(\"数学其实很美\") pi = np.pi a = 1 # 生成0到2pi的数据集 datas = np.linspace(0, 2 * pi, 100) # 绘制极坐标r = a(1-cosθ)(a&gt;0)的心形图 x = a * (1 - np.cos(datas)) * (np.cos(datas)) y = a * (1 - np.cos(datas)) * (np.sin(datas)) plt.plot(x, y, label='心形线', color='red', linewidth='1.0') # 绘制极坐标r = a(1-cosθ)(a&gt;0)的心形图 x1 = a * (np.sin(3 * datas)) * (np.cos(datas)) y1 = a * (np.sin(3 * datas)) * (np.sin(datas)) plt.plot(x1, y1, label='玫瑰线', color='blue', linewidth='2.0', linestyle=\"--\") # 绘制极坐标r = a(1-cosθ)(a&gt;0)的阿基米德螺线图 x2 = a * datas * (np.cos(datas)) y2 = a * datas * (np.sin(datas)) plt.plot(x2, y2, label='阿基米德螺线', color='black', linewidth='1.0', linestyle=\"-.\") # # 使用plt.xlim设置x坐标轴范围： # plt.ylim((-10, 10)) # # 使用plt.ylim设置x坐标轴范围： # plt.ylim((-10, 10)) # 定义x轴名称 plt.xlabel('x轴') # 定义y轴名称 plt.ylabel('y轴') new_ticks = np.arange(-5, 10, 1) # 使用plt.xticks设置x轴刻度：范围是(-2,2);个数是8. plt.xticks(new_ticks) \"\"\" plt.gca获取当前坐标轴信息. 使用.spines设置边框；使用.set_color设置边框颜色 \"\"\" # 坐标轴中移 ax = plt.gca() # 隐藏上边和右边 ax.spines['top'].set_color('none') ax.spines['right'].set_color('none') # 移动另外两个轴 ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) plt.legend() plt.savefig(\"math.png\") plt.show()if __name__ == '__main__': draw()","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://ahrilove.top/tags/numpy/"}]},{"title":"docker安装使用redis","slug":"docker容器虚拟技术(Ⅲ)","date":"2019-12-11T16:00:00.000Z","updated":"2020-04-25T05:49:34.000Z","comments":true,"path":"2019/12/12/docker容器虚拟技术(Ⅲ)/","link":"","permalink":"https://ahrilove.top/2019/12/12/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF(%E2%85%A2)/","excerpt":"docker系列章节更新（三），这一章节主要学习docker安装redis以及非关系型数据库redis学习 docker安装redis redis学习笔记","text":"docker系列章节更新（三），这一章节主要学习docker安装redis以及非关系型数据库redis学习 docker安装redis redis学习笔记 1.docker安装redis 拉取镜像 docker search redisdocker pull redis:[version] 创建容器 docker run -di -p 6379:6379 -p指定端口,-d以守护式形式-v /zzyyuse/myredis/data:/data-v /zzyyuse/myredis/conf/redis.conf:/usr/local/etc/redis/redis.confredis-server /usr/local/etc/redis/redis.confredis:3.2 指定redis版本--appendonly yes 新建redis.conf文件 在宿主机/zzyyuse/myredis/conf/redis.conf目录下新建redis.conf文件（文件内容） 进入容器并以命令行交互 docker exec -it container_id redis-cli(区分其它容器的/bin/bash或者/bin/sh) 退出命令 SHUTDOWN 2.redis的基础知识【转载】羊松林博客的redis讲解就很详细了，不重复造轮子，先抄他一手再说 3.Windows下的redis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前我们已经了解到了通过docker命令安装运行redis内部，但是在Windows和Linux下，我们也可以通过安装exe或者tar.gz包来运行 Windows下的配置： 安装完毕后，进入redis安装目录找到配置文件，注意是redis.windows-service.conf,不是redis.windows.conf,后者是以非系统服务方式启动程序使用的配置文件 在配置文件中,找到requirepass foobared字样，在其后面追加一行，输入requirepass 123456。这是访问Redis时所需的密码，一般测试情况下可以不用设定密码。不过，即使是作为本地访问，也建议设定一个密码。此处以简单的123456来演示，然后保存退出 由于前面修改过配置文件，需要重启服务 Windows下的简单使用： 用命令进入redis安装路径，输入redis-cli并回车（redis-cli是客户端程序） 输入 auth 设置的密码：返回提示OK表示验证通过 参考文章 windows下Redis的安装和配置–图文教程","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://ahrilove.top/tags/redis/"}]},{"title":"ALL MY LIFE","slug":"2020","date":"2019-12-10T16:00:00.000Z","updated":"2020-06-17T06:40:10.000Z","comments":true,"path":"2019/12/11/2020/","link":"","permalink":"https://ahrilove.top/2019/12/11/2020/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做她的战士，跟她一起经历&nbsp;&nbsp;&nbsp;失败！！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做她的战士，跟她一起经历&nbsp;&nbsp;&nbsp;失败！！ 自我介绍&nbsp;&nbsp;&nbsp;兄弟萌，您们好，我叫陈浩东，浩东陈的陈，你也可以叫我陈某。97年的四川绵阳人，于2019年6月5日毕业于中国计量大学信息与计算科学专业。虽然口头上一直在说~不会再爱了( ﹁ ﹁ ) ~→，但是我还是忘不了那个badwoman,试问，如果不是真心喜欢，谁愿意当舔狗呢？☹ ☹ ☹ 她不是漂不漂亮的问题，她真的就是那种，很少见，很冷艳的漂亮…&nbsp;&nbsp;&nbsp;你们有可能会说：你那叫喜欢吗？你那是馋她的身子，你下贱 &nbsp;&nbsp;&nbsp;作为一个正能量，儒雅随和的知识分子，兴趣爱好当然必不可少。喜欢羽毛球、乒乓球、登山、游泳（仅能浮起来☹ ☹）、钓鱼以及英雄联盟，当然作为一个资深的土味鉴定师,文艺复兴模仿者,能够快速洞察每一个土味视频背后的正能量思想，有内味了。 2020年职业技术规划： XXXXXXXXX(终极目标，可以决定是否可以改变未来轨迹的) Python进阶，web框架以及爬虫框架~js逆向解密爬虫 Python爬取抓包app数据 Vue基础知识与微信小程序MVVM（两者大同小异） java ThinkPHP以及PHP学习 HTML+CSS+JavaScript Jquery进阶以及bootstrap Docker容器虚拟技术 Linux的Ubuntu要经常多用 数据库进阶以及存储过程 数据分析与深度学习 完成一个简单的健康指数的微信小程序 完成一个GitHub开源项目，暂时有一点想法 每日作息安排：1.早上7:25-7:50起床2.中午早点休息，下午一点上班3.五点下班：会寝室吃饭并休息到6:00-6:30,继续学习4.晚上10:40到11:00开始收拾收拾准备下班5.回到寝室，做10-15分钟的Keep，锻炼胸肌腹肌6.周六周日特殊安排：早上9-10点起床，其余正常安排 7.周而复始，学会坚持，每天多学一点，未来会好很多，兄弟萌，不甘碌碌无为，那就，冲，杀！！ 推荐学习方法： 渗透科学学习法 晚上睡觉前，把文献放在脑袋和枕头之间，知识会从浓度较高的的书本向浓度较低的脑袋渗透。书本越多，外界知识浓度越高，夜间复习的效果越好！ 奋斗目标 1.翻新/二手iPhone 16年买的iPhone6s 32G，现在内存不到5个G。可以买但没必要☹ ☹ ☹，还不卡，让手机再奋斗个两三年吧，先存钱买房吧 2.翻新/二手Macbook Pro 16年5月买的联想小新700，有点重，不方便携带，但换个内存条也超神。可以买，但没必要☹ ☹ ☹，让电脑再奋斗个三四年吧，存钱买房 3.Audi 直接想就完事了，买不起，也没必要☹ ☹ ☹ 4.买房 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红颜一春树,流年一掷梭，一瞬为白骨","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（七）：爬虫解析库","slug":"Python全栈系列章节更新（七）","date":"2019-12-09T16:00:00.000Z","updated":"2021-08-25T03:36:58.000Z","comments":true,"path":"2019/12/10/Python全栈系列章节更新（七）/","link":"","permalink":"https://ahrilove.top/2019/12/10/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"正则表达式XpathBeautifulSouppyqueryScrapy的selector的用法Selenium自动测试库学习","text":"正则表达式XpathBeautifulSouppyqueryScrapy的selector的用法Selenium自动测试库学习 1.正则表达式12345678910111213141516171819202122&apos;.&apos; 默认匹配除\\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行&apos;^&apos; 匹配字符串的开头，若指定flags MULTILINE,这种也可以匹配上(r&quot;^a&quot;,&quot;\\nabc\\neee&quot;,flags=re.MULTILINE)&apos;$&apos; 匹配字符结尾， 若指定flags MULTILINE ,re.search(&apos;foo.$&apos;,&apos;foo1\\nfoo2\\n&apos;,re.MULTILINE).group() 会匹配到foo1&apos;*&apos; 匹配*号前的字符0次或多次， re.search(&apos;a*&apos;,&apos;aaaabac&apos;) 结果&apos;aaaa&apos;&apos;+&apos; 匹配前一个字符1次或多次，re.findall(&quot;ab+&quot;,&quot;ab+cd+abb+bba&quot;) 结果[&apos;ab&apos;, &apos;abb&apos;]&apos;?&apos; 匹配前一个字符1次或0次 ,re.search(&apos;b?&apos;,&apos;alex&apos;).group() 匹配b 0次&apos;&#123;m&#125;&apos; 匹配前一个字符m次 ,re.search(&apos;b&#123;3&#125;&apos;,&apos;alexbbbs&apos;).group() 匹配到&apos;bbb&apos;&apos;&#123;n,m&#125;&apos; 匹配前一个字符n到m次，re.findall(&quot;ab&#123;1,3&#125;&quot;,&quot;abb abc abbcbbb&quot;) 结果&apos;abb&apos;, &apos;ab&apos;, &apos;abb&apos;]&apos;|&apos; 匹配|左或|右的字符，re.search(&quot;abc|ABC&quot;,&quot;ABCBabcCD&quot;).group() 结果&apos;ABC&apos;&apos;(...)&apos; 分组匹配， re.search(&quot;(abc)&#123;2&#125;a(123|45)&quot;, &quot;abcabca456c&quot;).group() 结果为&apos;abcabca45&apos;&apos;[...]&apos; 用来表示一组字符，单独列出，比如匹配[amk]匹配a,m或k&apos;[^...]&apos; 用来匹配不在[]里面的字符：如[^abc]匹配除了a，b，c之外的字符 &apos;\\A&apos; 只从字符开头匹配，re.search(&quot;\\Aabc&quot;,&quot;alexabc&quot;) 是匹配不到的，相当于re.match(&apos;abc&apos;,&quot;alexabc&quot;) 或^&apos;\\Z&apos; 匹配字符结尾，同$&apos;\\d&apos; 匹配数字0-9&apos;\\D&apos; 匹配非数字&apos;\\w&apos; 匹配[A-Za-z0-9],还包括下划线‘_’&apos;\\W&apos; 匹配非[A-Za-z0-9]&apos;\\s&apos; 匹配空白字符、\\t、\\n、\\r , re.search(&quot;\\s+&quot;,&quot;ab\\tc1\\n3&quot;).group() 结果 &apos;\\t&apos;&apos;(.*?)&apos; 贪婪匹配，用来获取目标字符&apos;.*?&apos; 非贪婪匹配，用来替换任意非目标字符 常用方法： re.match() re.match()方法会从字符串的起始位置开始匹配正则表达式，如果匹配，就返回匹配成功的结果，一旦开头不匹配，直接返回None，整个匹配失败 re.search() re.search()：扫描整个字符串，然后返回第一个成功匹配的结果 re.findall() re.findall()：把所有匹配到的字符放到以列表中的元素返回，返回的列表中的每一个元素都是元组类型 re.sub() re.sub(‘a’,’b’,content) ,即在content中，用b替换a的内容 re.compile() re.compile(正则表达式,修饰符re.S等)方法将正则表达式字符串编译成正则表达式对象，以便在后面的匹配中复用 修饰符 修饰符 描述 re.I 使匹配对大小写不敏感 re.M 多行匹配 re.S 使.匹配包括换行在内的所有字符 2.xpath1.导入相关库包from lxml import etree2.初始化html = etree.HTML(response.text) 3.文本内容的获取标签的属性值获取：/@属性名（如：@href，@class…），返回列表格式文本内容的获取：/text()，返回列表格式 1234567891011121314151617from lxml import etree text = ''' &lt;html&gt;&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link1.html\"&gt;first item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link2.html\"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-inactive\"&gt;&lt;a href=\"link3.html\"&gt;third item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-1\"&gt;&lt;a href=\"link4.html\"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=\"item-0\"&gt;&lt;a href=\"link5.html\"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;'''# 初始化html = etree.HTML(text)result = html.xpath('//li[2]/a/text()') # second itemresponse = html.xpath(\".//li[2]/a/@href\") # link2.html 4.常用规则 表达式 描述 nodename 选取此节点的所有子节点 / 从根节点选取 // 从匹配选择的当前节点选择文档的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 路径表达式 描述 bookstore 选取 bookstore 元素的所有子节点 /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。索引默认从1开始 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 举例说明如何使用xpath： 1234567891011121314151617181920212223242526272829303132import requestsfrom lxml import etree# 1.指定urlurl = 'https://ishuo.cn/joke'# 2.发起请求headers = &#123; 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36'&#125;response = requests.get(url=url, headers=headers)# 3.获取页面内容page_text = response.text# 4.数据解析tree = etree.HTML(page_text)# 获取所有的li标签（已经经过了xpath插件验证）li_list = tree.xpath('//div[@id=\"list\"]/ul/li')# 这段话的意思是：选择所有子孙节点是id=\"list\"的div标签，在选择子节点ul标签，再选择子节点li标签'''[&lt;Element li at 0x10e32c248&gt;, &lt;Element li at 0x10e30ae88&gt;,...,&lt;Element li at 0x10ef5bfc8&gt;]# 注意：Element类型的对象可以继续调用xpath函数，对该对象表示的局部内容进行指定内容的解析'''fp = open('./duanZi.txt', 'w', encoding='utf-8') # 一次打开多次写入for li in li_list: content = li.xpath('./div[@class=\"content\"]/text()')[0] # 调用text()函数取得段子内容 title = li.xpath('./div[@class=\"info\"]/a/text()')[0] # 获得a标签文本内容 # 5.持久化 fp.write(title + \":\" + content + \"\\n\\n\") # 段子换行分隔 print(\"一条数据写入成功\") 3.pyquery 导入相关库包 from pyquery import PyQuery as pq 初始化工作 doc = pq(html)字符串初始化doc = pq(url)URL初始化doc = pq(filename=””)文件初始化item = doc(&#39;li&#39;)) 获取li标签的变量为item css选择器 表达式 说明 id选择器 使用# class选择器 使用. 标签选择器 直接使用标签，什么都不加 * 选择所有元素 p 选择所有p标签 div,p 选择所有的div和p标签（并集） div p 选择div下的所有p标签（子集），空格代表嵌套关系 举例说明： 12345678910from pyquery import PyQuery as pq# 初始化doc = pq(html)#首先选class=“.list”，空格即使选择list里面的标签，再选class=“item-0”，并列active（实际就是一个整体）li = doc('.list .item-0.active')#获取所有的兄弟元素print(li.siblings())#在向其中筛选print(li.siblings('.active')) pyquery获取信息(跟jQuery用法一样) 1.获取指定属性值：变量名.attr(目标属性名) 或者 变量名.attr.属性名2.获取文本内容：变量名.text()3.获取html： 变量名.html()4.获取父节点： 变量名.parent()5.获取所有的祖先节点： 变量名.parents()6.获取所有的兄弟元素： 变量名.siblings()7.过滤选择器：li = doc(&quot;li:first-child&quot;)#第一个子节点8.过滤选择器：li = doc(&quot;li:gt(2)&quot;)#索引值大于2的9.找寻某一特定标签：变量名.find(标签名).eq(n) n从0开始，表示find某标签，并选择第n个目标值 遍历(重要) pyquery的遍历需要使用items()方法我们可以观察到，pyquery的选择结果可能是多个节点，也可能是单个节点，但类型都是PyQuery类型。 对于单节点来说，可以直接打印输出，也可以直接转换为字符串 对于多个节点来说，就必须使用遍历items()函数来获取了（PS：这里的items函数不同于字典的items函数，注意区分） 举例说明： 1234567891011121314151617181920212223from pyquery import PyQuery as pqhtml = \"\"\".stock_sub .stockTable a&lt;div class= \"stock_sub\"&gt; &lt;li class=\"stockTable\"&gt; &lt;a href=\"link1.html\"&gt; link1.html &lt;/a&gt; &lt;a href=\"link2.html\"&gt; link2.html &lt;/a&gt; &lt;a href=\"link3.html\"&gt; link3.html &lt;/a&gt; &lt;/li&gt;&lt;/div&gt;\"\"\"# 初始化doc = pq(html)# 查找目标节点result = doc(\".stock_sub .stockTable a\") # 单节点可以直接打印for i in range(len(result)): print(result.eq(i).attr(\"href\"), result.eq(i).text())# 多节点测试lis = doc(\".stock_sub .stockTable a\") # 这里有多个a标签节点for item in lis.items(): print(item.attr(\"href\"), item.text()) 4.Selenium库学习动态渲染页面不仅仅涉及到Ajax技术，绝大多数的网页是通过Javascript计算生成新页面的，比如说百度Echarts，淘宝，中国青年网。。。 4.1基本库导入 123456789101112from selenium import webdrivefrom selenium.webdrive.common.by import By# 若想要模拟键盘，就需要导入keys()类from selenium.webdrive.common.keys import Keys# 等待条件类from selenium.webdrive.support import expected_conditions as EC# 等待条件from selenium.webdrive.support.wait import WebDriverWait# 监听鼠标事件,声明动作链from selenium.webdrive import ActionChains# 导入下拉选择框Select类from selenium.webdriver.support.select import Select 4.2 声明浏览器对象 browser = webdriver.Chrome()/Firefox()/PhantomJS() 等等 4.3 访问目标页面 browser.page_source:打印网页源代码 123456# 访问目标网址browser.get(\"https://www.taobao.com\")# 打印页面源代码print(browser.page_source)# 关闭浏览器browser.close() 4.4 获取单个节点的方法 语法：find_element(By.xx,”XXX”)或者是find_elements(By.xx,”XXX”)一般常用的是(By.ID,id_name),(By.XPath,xpath_path),(By.CSS_SELECTOR,css_selector_path) 4.5 节点交互 Selenium可以驱动浏览器执行一些列操作，可以模仿一些列简单的人的动作：nodeName.send_keys(“content”)：输入目标节点框文字nodeName.clear()：清空目标节点框文字nodeName.click()：点击目标节点 控制浏览器的操作方法 说明 click() 点击目标节点 set_window_size() 设置浏览器的大小 back() 控制浏览器后退 forward() 控制浏览器前进 refresh() 刷新当前页面 clear() 清除文本 send_keys (value) 模拟按键输入 close() 关闭浏览器 quit() 关闭所有窗口 submit() 用于提交表单 is_displayed() 设置该元素是否用户可见 size 返回元素的尺寸 location 返回元素在浏览器中的位置，以字典的形式返回 get_attribute(name) 获取元素节点的属性值 text 获取元素的文本内容 2019-12-30：新增关于location和size方法的说明先看示例源代码： 12345# 显示等待图片节点加载出来img = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'geetest_canvas_img')))time.sleep(2)location = img.locationsize = img.size 这里用了显示等待获取到了我要识别的滑动验证码图片对象，接下来调用该对象的location属性和size属性。location属性可以返回该图片对象(既这张图片)在浏览器中的位置(坐标轴是以屏幕左上角为原点，x轴向右递增，y轴像下递增)，以字典的形式返回 12345678910&#123;&quot;x&quot;:30, &quot;y&quot;:30 &#125;# 这里我们假设图片的位置是（30,30)size属性同样返回一个字典，size属性是图片对象的高度，宽度。&#123;&quot;height&quot;:30,&quot;width&quot;:30&#125; 4.6 鼠标事件 在WebDriver中，将这些关于鼠标操作的方法封装在 ActionChains 类提供。详情ActionChains解析参考 鼠标监听方法 说明 ActionChains(driver) 构造ActionChains对象 move_to_element(above) 执行鼠标悬停操作 context_click() 右击 double_click() 双击 drag_and_drop() 拖动 move_to_element(above) 执行鼠标悬停操作 context_click() 用于模拟鼠标右键操作， 在调用时需要指定元素定位 click_and_hold(on_element=None) 点击鼠标左键，不松开 drag_and_drop_by_offset(source, xoffset, yoffset) 拖拽到某个坐标然后松开 move_to_element_with_offset(to_element, xoffset, yoffset) 移动到距某个元素（左上角坐标）多少距离的位置 perform() 执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作 ———————————————— 123456789101112131415161718192021222324252627282930313233import timefrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC# 淘宝滑块的拖动def login(self, username, password, chromedriverpath, **kwargs): # 基本设置 browser = webdriver.Chrome(executable_path=chromedriverpath, options=self.chrome_opts) browser.get(self.login_url) driver_wait = WebDriverWait(browser, 60) # 点击'亲, 请登录', 进入登录界面 button = driver_wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'h'))) button.click() # 输入用户名密码 username_sender = driver_wait.until(EC.presence_of_element_located((By.ID, 'fm-login-id'))) username_sender.send_keys(username) password_sender = driver_wait.until(EC.presence_of_element_located((By.ID, 'fm-login-password'))) password_sender.send_keys(password) time.sleep(2) # 检查是否出现了滑动验证码 try: slider = browser.find_element_by_xpath(\"//span[contains(@class, 'btn_slide')]\") if slider.is_displayed(): ActionChains(browser).click_and_hold(on_element=slider).perform() ActionChains(browser).move_by_offset(xoffset=258, yoffset=0).perform() ActionChains(browser).pause(0.5).release().perform() except: pass # 点击登录按钮 button = driver_wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'password-login'))) button.click() 4.7 多表单切换，点击详情 &nbsp;&nbsp;&nbsp;&nbsp;在Web应用中经常会遇到frame/iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。 鼠标监听方法 说明 switch_to.frame() 将当前定位的主体切换为frame/iframe表单的内嵌页面中 switch_to.default_content() 跳回最外层的页面 1234567891011121314from selenium import webdriverdriver = webdriver.Chrome()driver.get(&quot;http://www.126.com&quot;)# 切换到id为x-URS-iframe的iframe表单driver.switch_to.frame(&apos;x-URS-iframe&apos;)driver.find_element_by_name(&quot;email&quot;).clear()driver.find_element_by_name(&quot;email&quot;).send_keys(&quot;username&quot;)driver.find_element_by_name(&quot;password&quot;).clear()driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;password&quot;)driver.find_element_by_id(&quot;dologin&quot;).click()driver.switch_to.default_content()driver.quit() switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。 先通过xpth定位到iframexf = driver.find_element_by_xpath(‘//*[@id=”x-URS-iframe”]’) 再将定位对象传给switch_to.frame()方法driver.switch_to.frame(xf) driver.switch_to.parent_frame() 4.8 设置元素等待 元素等待分为显示等待（推荐：显式等待使WebdDriver等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException））与隐式等待selenium.webdriver.support.ui 和selenium.webdriver.support.wait都是用来做显式等待的，但两者没有任何一丢丢的区别，将ui换成了wait，这样更直接易懂。 1234567891011121314151617181920from selenium import webdriverimport timefrom selenium.webdriver.common.by import By# 导入时间等待库文件from selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Chrome()driver.get(\"http://www.baidu.com\")# 最长超时时间为10s，检测间隔为0.5swait = WebDriverWait(driver,10,0.5)element = wait.until( # 等待节点出现的含义 EC.presence_of_element_located((By.ID, \"kw\")) )# 输入文本 element.send_keys('selenium')time.sleep(10)# 浏览器退出driver.quit() 2020-1-11 新增： 4.9 下拉框选择操作 导入选择下拉框Select类，使用该类处理下拉框操作方法：select_by_value(“选择值”)：相当于我们使用鼠标选择下拉框的值 1234567891011121314151617181920from selenium import webdriverfrom selenium.webdriver.support.select import Selectfrom time import sleepdriver = webdriver.Chrome()driver.get('http://www.baidu.com')#1.鼠标悬停至“设置”链接driver.find_element_by_link_text('设置').click()sleep(1)#2.打开搜索设置driver.find_element_by_link_text(\"搜索设置\").click()sleep(2)#3.搜索结果显示条数sel = driver.find_element_by_xpath(\"//select[@id='nr']\")Select(sel).select_by_value('50') # 显示50条sleep(3)driver.quit() 4.10 警告框处理 在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用 switch_to.alert 方法定位到 alert/confirm/prompt，然后使用text/accept/dismiss/ send_keys等方法进行操作。 鼠标监听方法 说明 text 返回 alert/confirm/prompt 中的文字信息 accept() 接受现有警告框 dismiss() 解散现有警告框 send_keys(keysToSend) 发送文本至警告框。keysToSend：将文本发送至警告框 2020-3-30:新增 4.11 正确移除Selenium中window.navigator.webdriver的值 前言：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有不少朋友在开发爬虫的过程中喜欢使用Selenium + Chromedriver，以为这样就能做到不被网站的反爬虫机制发现。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先不说淘宝这种基于用户行为的反爬虫策略，仅仅是一个普通的小网站，使用一行Javascript代码，就能轻轻松松识别你是否使用了Selenium + Chromedriver模拟浏览器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我就不详细阐述了，Kingname青南大佬已经给出了解决方案（亲测成功）。 123456789101112from selenium import webdriver# 声明一个浏览器driver = webdriver.Chrome()driver.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", &#123; \"source\": \"\"\" Object.defineProperty(navigator, 'webdriver', &#123; get: () =&gt; undefined &#125;) \"\"\"&#125;)driver.get('http://exercise.kingname.info') 2020-5-12:新增&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述的阐述了移除Selenium中window.navigator.webdriver的值的方法：但有些网站，点击了它的页面超链接以后，会自动以新的标签页打开，这种情况下就无法使用上面提到的技巧了(即在webdriver测试控制阶段，若点击跳转链接后，浏览器会新开一个选项页，会重新请求所有的url) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决这个问题实际上非常简单，我们只需要知道一点点HTML知识和 JavaScript 的知识即可。如果要用一个a标签的链接在当前页面打开，我们只需要设置它的target属性值为_self。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们需要用 JavaScript 把当面页面上的所有a标签的target属性值全部改成_self。 将所有的a标签的target属性设置为_self: 123let a_list = document.getElementsByTagName('a');// 匿名函数,map函数以及“...”表示ES6的扩展运算符[...a_list].map((a)=&gt; &#123;a.setAttribute('target', '_self')&#125;); 使用这个方法有4个地方需要注意： 不适用于通过 JavaScript 的 window.open()函数打开新网址的情况 对于&lt;form&gt;标签的表单提交，也可以设置target=”_self”属性。 必须等页面完全加载完成才能执行这两行 JavaScript 语句。如果执行语句以后，页面通过 Ajax 或者其他途径又加载了新的 HTML，那么需要重新执行。 每次打开新的链接以后，需要再次执行这两行语句。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法可以与本文开始提到的那篇文章中的方法结合起来使用。首先通过Page.addScriptToEvaluateOnNewDocument让当前标签页的window.navigator.webdriver属性消失，等页面完全加载完成以后，再通过driver.execute_script()运行本文讲到的两行 JavaScript 代码，强迫网页在当前标签页打开新的链接。 4.12 selenium全屏截图 当我们对一些页面进行截图时，发现网页的宽高超出了我们的想象，那这个时候我们应该如何全截屏呢？通过set_window_size属性设置宽高 js获取可视区域高度：https://www.cnblogs.com/yonina/p/6019087.html 123456789width = browser.execute_script(&quot;return Math.max(document.body.scrollWidth, document.body.offsetWidth, &quot; &quot;document.documentElement.clientWidth, document.documentElement.scrollWidth, &quot; &quot;document.documentElement.offsetWidth);&quot;)height = browser.execute_script(&quot;return Math.max(document.body.scrollHeight, document.body.offsetHeight, &quot; &quot;document.documentElement.clientHeight, document.documentElement.scrollHeight, &quot; &quot;document.documentElement.offsetHeight);&quot;)browser.set_window_size(int(width), int(height)) 4.13 selenium添加cookies selenium的cookie不同于requests的cookie格式，我们可以使用requests库模拟登录后，将cookie存储为json文件，然后通过json.loads读取出来（严格按照这样做） selenium先访问一次想要携带cookie的网址，然后在删除所有由于当前登录所产生的cookies selenium的cookie添加是循环遍历添加的，每一组cookie都有name和value 添加完cookie后再一次访问目标网址 严格按照这样做，否则会报错（经过多次体验） 123456789101112131415161718# 载入cookie时效性文件with open(path, \"r\", encoding='utf-8') as f: cookies = json.load(f)# 尝试请求泛微OA主页，检测当前cookie是否有效url = \"http://IP/WorkflowRequestPictureInner.jsp?workflowid=&#123;&#125;\".format(workId)browser = webdriver.Chrome()# 第一次访问urlbrowser.get(url)# 往browser里添加cookies前，先删除所有cookiesbrowser.delete_all_cookies()for k, v in dict(cookies).items(): browser.add_cookie(&#123;\"name\": k, \"value\": v&#125;)# 再一次访问urlbrowser.get(url) 4.14 selenium的无头模式 无头模式，顾名思义，就是不会新开浏览器界面，而是调用其内核来执行，那如何设置呢？ 12345678# 声明谷歌浏览器对象driver = webdriver.Chrome()#设置浏览器无头模式option = webdriver.ChromeOptions()option.add_argument(&apos;--headless&apos;) # 启用无头模式option.add_argument(&apos;--disable-gpu&apos;) # 禁止使用GPUdriver = webdriver.Chrome(chrome_options=option) 5.HTTP状态码的理解 状态码304 Not Modified 当我们爬取某些网站时扑飞漫画中会遇到对浏览器缓存下请求资源返回304的情况流量的计费的情况，这里就需要了解HTTP 304的响应状态的资源更新机制。 这是因为该网站采取了强缓存验证， 服务器将要爬取的内容在本地做了缓存，再次请求的时候，会首先检查本地缓存中是否已存在，如果有就返回304 首先看一个关于304请求的响应头的信息，这里面有两个比较重要的请求头字段：If-Modified-Since 和 If-None-Match，这两个字段表示发送的是一个条件请求。 当客户端缓存了目标资源但不确定该缓存资源是否是最新版本的时候, 就会发送一个条件请求，这样就可以辨别出一个请求是否是条件请求，在进行条件请求时,客户端会提供给服务器一个If-Modified-Since请求头,其值为服务器上次返回的Last-Modified响应头中的Date日期值,还会提供一个If-None-Match请求头,值为服务器上次返回的ETag响应头的值。 服务器会读取到这两个请求头中的值,判断出客户端缓存的资源是否是最新的,如果是的话,服务器就会返回HTTP/304 Not Modified响应头, 但没有响应体.客户端收到304响应后,就会从本地缓存中读取对应的资源. 解决方案： 方案一：请求头里的 If-Modified-Since、If-None-Match和Cache-control，都必须禁用 方案二：请求头里User-Agent为动态的 12345678910headers = &#123; \"Host\": \"www.pufei8.com\", \"Referer\": \"http://www.pufei8.com/\", 'Accept': 'text/html', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'Upgrade-Insecure-Requests': \"1\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3945.88 Safari/537.36\"&#125; 参考文章 一日一技：如何正确移除Selenium中window.navigator.webdriver的值 （最新版）如何正确移除Selenium中的 window.navigator.webdriver","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"解析库","slug":"解析库","permalink":"https://ahrilove.top/tags/%E8%A7%A3%E6%9E%90%E5%BA%93/"}]},{"title":"兄弟萌！枯啦，要恰不了饭了","slug":"恰饭危机","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-08T10:49:30.000Z","comments":true,"path":"2019/12/08/恰饭危机/","link":"","permalink":"https://ahrilove.top/2019/12/08/%E6%81%B0%E9%A5%AD%E5%8D%B1%E6%9C%BA/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，怎么办？我要枯啦，要恰不了饭了，要吃红牌出场了","text":"&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，怎么办？我要枯啦，要恰不了饭了，要吃红牌出场了 最近一直没有什么活干，每天就是混吃等死，建彬哥说也没有什么我能做的项目，呀！糟了呀，以前一直打趣说“你有你的好果子吃”，现在才明白过来，原来是我才没有好果子吃。而且就目前的市场和我最近咸鱼，我也感觉我要直接吃红牌了，看不到生活的希望（55555。。。）算了吧！！走一步算一步，做好心理准备，每天使劲多学一些，也不至于打包回家的时候那么狼狈，现在回想起来，15年做决定的时候是不是选对了？是当时脑瘫了？","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"HTML+CSS易忘点","slug":"html与css(Ⅰ)","date":"2019-12-05T16:00:00.000Z","updated":"2021-06-23T02:03:56.000Z","comments":true,"path":"2019/12/06/html与css(Ⅰ)/","link":"","permalink":"https://ahrilove.top/2019/12/06/html%E4%B8%8Ecss(%E2%85%A0)/","excerpt":"HTML是网页内容的载体,CSS样式是表现,JavaScript是用来实现网页上的特效效果与交互。总结自己遇到的一些知识点，查漏补缺，学习犹如逆水行舟，不进则退。 本章内容： 1.HTML的音视频2.css知识点补充3.display与visibility4.多媒体查询5.flex弹性布局★★","text":"HTML是网页内容的载体,CSS样式是表现,JavaScript是用来实现网页上的特效效果与交互。总结自己遇到的一些知识点，查漏补缺，学习犹如逆水行舟，不进则退。 本章内容： 1.HTML的音视频2.css知识点补充3.display与visibility4.多媒体查询5.flex弹性布局★★ 1.HTML的音视频1.1 HTML视频Video播放最好的 HTML 解决方法：以下实例中使用了 4 种不同的视频格式。HTML 5 &lt;video&gt; 元素会尝试播放以 mp4、ogg 或 webm 格式中的一种来播放视频。如果均失败，则回退到 &lt;embed&gt; 元素。 HTML5 + &lt;object&gt; +&lt;embed&gt;mp3文件路径为相对路径 12345678910111213141516171819&lt;!--创建固定宽高的播放器标签--&gt;&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; &lt;source src=\"movie.webm\" type=\"video/webm\"&gt; &lt;object data=\"movie.mp4\" width=\"320\" height=\"240\"&gt; &lt;embed src=\"movie.swf\" width=\"320\" height=\"240\"&gt; &lt;/object&gt;&lt;/video&gt;``` #### 1.2 audio音频文件的播放设置src:MP3文件为相对路径```html&lt;audio controls style=\"height:100px; width=100px\"&gt; &lt;source src=\"../static_audio/yiluxiangbei.mp3\" type=\"audio/mpeg\"&gt; &lt;source src=\"../static_audio/yiluxiangbei.ogg\" type=\"audio/ogg\"&gt; &lt;embed height=\"50\" width=\"100\" src=\"../static_audio/yiluxiangbei.mp3\"&gt;&lt;/audio&gt; &lt;audio&gt;标签的属性值有： autoplay：如果设置该属性，音频将自动播放，值为：autoplay； controls：如果设置该属性，则显示音频控件（播放/暂停按钮），值：controls； loop：如果设置该属性，则音频重复播放，值为：loop； muted：如果设置该属性，则音频输出为静音，值：muted； preload：规定当网页加载时，音频是否默认被加载以及如何被加载。值：auto/metadata/none； src：规定音频文件的地址； 2.css知识点补充文本格式： text-align:center,right,justify :文本对齐方式 text-decoration :none 主要是用来删除链接的下划线 text-transform：uppercase，lowercase，capitalize 所有字句变成大写，小写或首字母大写 text-indent：50px 用来指定文本的第一行的缩进 css边框属性： border: 边框样式的简写，可同时包含颜色，宽度，样式 border-width ：属性为边框指定宽度 border-color ：设置边框的颜色 border-style： 定义边框样式（可以使得四个边框分别由四个不同样式，满足上右下左四个次序） border-（top，right，bottom，left）-style: 设置某一边的具体属性 border-radius ：用于创建边框圆角（拓：四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。） box-shadow： 在div中添加阴影属性，并设置阴影的颜色（10px 10px 5px #888888） css渐变属性： background-image：linear-gradient（direction，color1，color2… ）：线性渐变（linear-gradient(to bottom right, red , yellow)从左上方开始渐变） background-image：radial-gradient（direction，color1，color2… ）：径向渐变 css的透明度： rgba(a,b,c,d):rgba 是 CSS3 中的属性。rgba 括号中前 3 个数字代表着 red green blue 三种颜色的 rgb 值（0-255），最后一个是设定这个颜色的透明度即 alpha 值。范围从 0 到 1，越接近 1，代表透明度越低。 opacity: 0-1 设置透明度(&lt;body&gt;标签里面是不能直接设置背景图片的透明度的，要利用&lt;div&gt;标签) filter:alpha(opacity=10-100) IE和更早的版本使用 css的超出部分显示省略号(…)： 文字不换行，超出部分显示… 12345.father-div &#123; overflow:hidden; text-overflow:ellipsis; /*超出文本用省略号显示*/ white-space:nowrap; /*nowrap：只保留一个空白，文本不会换行*/&#125; div内文字显示N行，超出N行部分省略号显示 12345678/*使用了WebKit的CSS扩展属性，该方法适用于【WebKit浏览器及移动端】*/.father-div&#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; /*必须结合的属性，将对象作为弹性伸缩盒子模型显示*/ -webkit-line-clamp: 2; /*必须结合的属性，限制在一个块元素显示的文本的行数*/ -webkit-box-orient: vertical; /*必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式*/&#125; 3.display与visibilitydisplay通常可以设置为none、inline、block visibility通常可以设置为hidden、visible visibility：hidden 相当于display：none，能把元素隐藏起来，但是两者的区别在于： display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘） visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘） display会将元素隐藏掉，并且位置不再被占据，释放空间，而visibility则会依旧占据原来的位置 2020-4-20：关于display属性的补充之前我们已经在博客上大致描述了display属性（display与visibility） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有主流浏览器都支持 display 属性。其次，我们都知道display 属性规定元素应该生成的框的类型，我们常用的display属性值有： inline(默认值) block inline-block none 要先弄明白display，先要清楚行内元素与块级元素： 行内元素特点 1、和其他元素都在一行上； 2、元素的高度、宽度、行高及顶部和底部边距不可设置； 3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 块级元素特点 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道， 一个块级元素独占一行） 2、元素的高度、宽度、行高以及顶和底边距都可设置。 3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致）， 除非设定一个宽度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在html中，a , abbr , acronym , b , bdo , big , br , cite , code , dfn , em , font , i , img , input , kbd , label , q , s , samp , select , small , span, strike , strong , sub , sup ,textarea , tt , u , var就是典型的行内元素（inline）元素。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块级元素是可以设置宽高的，但是它的实际宽高是本身宽高+padding。block元素要单独占一行。内联元素不单独占一行，给他设置宽高是没有用的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在html中&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;就是块级元素。设置display:block就是将元素显示为块级元素。如下代码就是将行内元素a转换为块状元素，从页使用a元素具有块状元素特点。 重点： 在上面，我们已经阐述了行内元素是不独占一行的，更不可以设置宽高，那么为什么img、input等却可以设置宽高？ 这就涉及到一个新概念：置换元素(替换元素)和非置换元素(不可替换元素) 置换元素 一个内容不受CSS视觉格式化模型控制，CSS渲染模型不考虑对其内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。 浏览器会根据元素的标签和属性，来决定置换元素的具体显示内容。 它们所具有的特征为：在不使用css修饰时，元素的标签和属性也会影响元素的显示。 例如，浏览器会根据标签的src属性的值来读取图片信息并显示出来，而如果查看html代码，则看不到图片的实际内容；&lt;input&gt;标签的type属性决定是显示输入框，还是单选按钮等。 html5中的置换元素有 &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;、&lt;iframe&gt; 和 &lt;canvas&gt; 等。 置换元素在其显示中生成了框，这就是有些内联元素能够设置宽高的原因。 4.多媒体查询针对不同的媒体类型(包括显示器、便携设备、电视机，等等)设置不同的样式规则。多媒体查询可以做很多的事情，例如： viewport(视窗) 的宽度与高度 设备的宽度与高度 朝向 (智能手机横屏，竖屏) 。 分辨率 多媒体查询基本语法： 123@media and|not|only mediaType (media feature) &#123; CSS-Code;&#125; 对各个含义分析: not: not是用来排除掉某些特定的设备的，比如 @media not print（非打印设备）。 only: 用来定某种特别的媒体类型。对于支持Media Queries的移动设备来说，如果存在only关键字，移动设备的Web浏览器会忽略only关键字并直接根据后面的表达式应用样式文件。对于不支持Media Queries的设备但能够读取Media Type类型的Web浏览器，遇到only关键字时会忽略这个样式文件。 mediaType:多媒体类型，有如下四种：all(所有多媒体设备),print(打印机设备),screen(用于电脑屏幕，平板，智能手机等。),speech(用于屏幕阅读器) 举例说明： 在屏幕可视窗口尺寸小于480像素时修改背景颜色为lightgreen 12345@media screen and (max-width: 480px) &#123; body &#123; background-color: lightgreen; &#125;&#125; 屏幕可视窗口尺寸大于480像素时修改背景色为orange 12345@media screen and (min-width: 480px) &#123; body &#123; background-color: orange; &#125;&#125; 5.flex弹性布局★★★关于flex布局我们知道当并列书写多个div标签，它们会纵向向下排位，如果我们想将多个div并列成一排，就得借助position，float，或display属性，这便是传统的盒模型做法 flex布局则是一种新的布局方案，通过修改父div的display属性，让父元素成为一个flex容器，从而可以自由的操作容器中子元素(项目)的排列方式 例如我们让多个div横向排列，传统做法是使用浮动，但浮空后因为脱离文档流的缘故，父元素会失去高度，这又涉及了清除浮动等一系列的问题。 而flex布局相对简单很多，修改父元素display:flex，你会发现div自动就排列成了一行，而且没有浮动之后的副作用，从回流角度考虑，flex的性能更优于float；随着浏览器不断兼容以及旧版本的淘汰，flex布局注定会成为更为流行的布局方案。 Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 容器属性注：下述的子元素与项目为同一概念 flex-direction 用于控制子元素的排列方向与顺序 取值 描述 row 子元素横向排列（默认） row-reverse 子元素横向排列，但顺序倒序 column 子元素纵向排列 column-reverse 子元素纵向排列，但顺序倒序 flex-wrap属性 取值：nowrap(默认) | wrap | wrap-reverse 用于控制项目是否换行，nowrap表示不换行 justify-content属性 取值：flex-start(默认) | flex-end | center | space-between | space-around | space-evenly; 用于控制项目在横轴的对齐方式：默认flex-start即左对齐、center为居中、flex-end为右对齐、space-between为左右两端对齐，即左右两侧项目都紧贴容器，且项目之间间距相等 align-items属性 取值：flex-start | flex-end | center | baseline | stretch(默认) 用于控制项目在纵轴排列方式，默认stretch即如果项目没设置高度，或高度为auto，则占满整个容器，下面第一张图的项目没设置高度，其余图片中均为60px align-content 取值：flex-start | flex-end | center | space-between | space-around | space-evenly | stretch(默认); 用于控制多行项目的对齐方式，如果项目只有一行则不会起作用；默认stretch，即在项目没设置高度，或高度为auto情况下让项目填满整个容器，与align-items类似。注意，如下演示的12个项目我均没有设置高度。 子元素设置上述我们已经阐述了容器属性，容器属性相当于我们给父元素设置flex布局后，其一级子元素会按照设置的容器属性布局，是将所有的一级子元素作为一个整体布局。这时候我们想要子元素个性化布局时，就需要给子元素设置margin属性 因此我们需要铭记：容器属性是整体打包设置子元素，margin属性设置各个子元素 div标签里的子div标签左对齐，右对齐，全局居中:当margin属性设置为auto，排序与实际相反 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #content &#123; display: flex; height: 80px; &#125; .box&#123; width: 80px; height: 80px; margin: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;div id=\"content\"&gt; &lt;div class=\"box\" style=\"background-color: blueviolet;\"&gt;&lt;/div&gt; &lt;div class=\"box\" style=\"background-color: aquamarine;\"&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;/div&gt; &lt;div class=\"box\" style=\"background-color: brown;\"&gt;&lt;/div&gt; &lt;div class=\"box\" style=\"background-color: burlywood\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Flex布局语法教程 css display:flex 属性 一篇文章弄懂flex布局 参考文献 HTML-表单（非常详细）原创 北方的南先生 关于设置背景图片的透明度（html+css） HTML创建图片缩略图 CSS3 box-shadow 效果大全（内阴影，外阴影，三边阴影，双边阴影，单边阴影，细线描边…） 为什么有些内联（行内）元素可以设置宽高？ div的7种css居中方式","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://ahrilove.top/tags/html/"},{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（六）：装饰器","slug":"Python全栈系列章节更新（六）","date":"2019-12-04T16:00:00.000Z","updated":"2021-08-25T01:55:00.000Z","comments":true,"path":"2019/12/05/Python全栈系列章节更新（六）/","link":"","permalink":"https://ahrilove.top/2019/12/05/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AD%EF%BC%89/","excerpt":"装饰器原理：不修改已实现的功能代码块，不改变原函数调用方式，只对现有功能进行扩展","text":"装饰器原理：不修改已实现的功能代码块，不改变原函数调用方式，只对现有功能进行扩展 装饰器 装饰带有参数的函数 ps: 装饰器函数千万不要以test命名，否则会以测试方式运行 12345678910111213141516171819def decorator(func): # 装饰器接受一个函数作为参数，并返回一个函数 def wrapper(*args, **kwargs): # (*args, **kwargs)表示带参数的装饰器 print('call %s(): ' % func.__name__) # 魔法函数，返回函数名 func(*args, **kwargs) return wrapper@decorator # 运用@语法把装饰器放置在函数定义处def now(a,b): print(\"%s:%s\"%(a,b))if __name__ == '__main__': now(\"hello\", \"world\") \"\"\" :return call now(): hello:world \"\"\" 装饰带有返回值的函数 123456789101112131415def function(func): #定义了一个闭包 def func_in(*args,**kwargs): #闭包内的函数，因为装饰器运行的实则是闭包内的函数，所以这里将需要有形参用来接收原函数的参数。 print('这里是需要装饰的内容，就是需要添加的内容') num = func(*args,**kwargs) #调用实参函数，并传入一致的实参，并且用变量来接收原函数的返回值， return num #将接受到的返回值再次返回到新的now()函数中。 return func_in@functiondef now(a,b): # 定义一个函数 return a+b # 返回实参的和if __name__ == '__main__': print(now(985, 211)) 装饰带有传入参数和返回值的函数 1234567891011121314151617181920def decorator(func): def inner(*args, **kwargs): # (*args, **kwargs)表示带参数的装饰器 print(\"开始执行带有参数的返回值装饰函数！\") print(*args, **kwargs) result = func(*args, **kwargs) # 调用实参函数，并传入一致的实参 return result return inner@decoratordef now(a, b): if a &lt;= b: return b-a else: return a-bif __name__ == '__main__': c = now(985, 211) print(c) 参考文章 APScheduler（Python化的Cron）使用总结 定时任务 Python - APScheduler","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"https://ahrilove.top/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"}]},{"title":"Echarts","slug":"echarts","date":"2019-12-04T16:00:00.000Z","updated":"2020-08-15T09:28:40.000Z","comments":true,"path":"2019/12/05/echarts/","link":"","permalink":"https://ahrilove.top/2019/12/05/echarts/","excerpt":"简而言之，百度Echarts真的是数据展示的神器，官方给出的实例就能够满足实际基本要求 1.echarts创建实例2.异步加载3.移动端自适应4.Echarts的标题title设置大全5.echarts知识点6.Echarts解决的实际问题","text":"简而言之，百度Echarts真的是数据展示的神器，官方给出的实例就能够满足实际基本要求 1.echarts创建实例2.异步加载3.移动端自适应4.Echarts的标题title设置大全5.echarts知识点6.Echarts解决的实际问题 1.引入ECharts通过标签方式直接引入构建好的 echarts 文件 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 2.为 ECharts 准备一个具备高宽的 DOM 容器1234&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;&lt;/body&gt; 3. echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图完整案例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.static --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 let myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 let option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.异步加载123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/body&gt; &lt;div id=\"pie\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt;var myChart1 = echarts.init(document.getElementById('pie'));myChart1.showLoading();setInterval(function()&#123; myChart1.hideLoading(); &lt;!---这里面进行数据绑定与实例化图表 --&gt; myChart1.setOption(&#123; series : [ &#123; name: '访问来源', type: 'pie', radius: '55%', data:[ &#123;value:235, name:'视频广告'&#125;, &#123;value:274, name:'联盟广告'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:335, name:'直接访问'&#125;, &#123;value:400, name:'搜索引擎'&#125; ] &#125; ] &#125;);&#125;,1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.移动端自适应1.为Echarts准备一个具有宽高(有一个即可)的DOM，推荐使用bootstrap的栅栏系统来设置布局2.大部分的组件和系列的left/right/top/bottom/width/height的定位方式 绝对值，用number形式书写（已经固定写死了浏览器的像素） 百分比，表示占DOM容器的宽高的百分之多少，用string形式书写 位置描述，即center（水平居中），middle（垂直居中） 6.Echarts的标题title设置大全123456789101112131415161718192021222324252627282930313233var option = &#123; //标题 title : &#123; show:true,//显示策略，默认值true,可选为：true（显示） | false（隐藏） text: &apos;主标题&apos;,//主标题文本，&apos;\\n&apos;指定换行 link:&apos;&apos;,//主标题文本超链接,默认值true target: null,//指定窗口打开主标题超链接，支持&apos;self&apos; | &apos;blank&apos;，不指定等同为&apos;blank&apos;（新窗口） subtext: &apos;副标题&apos;,//副标题文本，&apos;\\n&apos;指定换行 sublink: &apos;&apos;,//副标题文本超链接 subtarget: null,//指定窗口打开副标题超链接，支持&apos;self&apos; | &apos;blank&apos;，不指定等同为&apos;blank&apos;（新窗口） x:&apos;center&apos;//水平安放位置，默认为&apos;left&apos;，可选为：&apos;center&apos; | &apos;left&apos; | &apos;right&apos; | &#123;number&#125;（x坐标，单位px） y: &apos;top&apos;,//垂直安放位置，默认为top，可选为：&apos;top&apos; | &apos;bottom&apos; | &apos;center&apos; | &#123;number&#125;（y坐标，单位px） textAlign: null,//水平对齐方式，默认根据x设置自动调整，可选为： left&apos; | &apos;right&apos; | &apos;center backgroundColor: &apos;rgba(0,0,0,0)&apos;,//标题背景颜色，默认&apos;rgba(0,0,0,0)&apos;透明 borderColor: &apos;#ccc&apos;,//标题边框颜色,默认&apos;#ccc&apos; borderWidth: 0,//标题边框线宽，单位px，默认为0（无边框） padding: 5,//标题内边距，单位px，默认各方向内边距为5，接受数组分别设定上右下左边距 itemGap: 10,//主副标题纵向间隔，单位px，默认为10 textStyle: &#123;//主标题文本样式&#123;&quot;fontSize&quot;: 18,&quot;fontWeight&quot;: &quot;bolder&quot;,&quot;color&quot;: &quot;#333&quot;&#125; fontFamily: &apos;Arial, Verdana, sans...&apos;, fontSize: 12, fontStyle: &apos;normal&apos;, fontWeight: &apos;normal&apos;, &#125;, subtextStyle: &#123;//副标题文本样式&#123;&quot;color&quot;: &quot;#aaa&quot;&#125; fontFamily: &apos;Arial, Verdana, sans...&apos;, fontSize: 12, fontStyle: &apos;normal&apos;, fontWeight: &apos;normal&apos;, &#125;, zlevel: 0,//一级层叠控制。默认0,每一个不同的zlevel将产生一个独立的canvas，相同zlevel的组件或图标将在同一个canvas上渲染。zlevel越高越靠顶层，canvas对象增多会消耗更多的内存和性能，并不建议设置过多的zlevel，大部分情况可以通过二级层叠控制z实现层叠控制。 z: 6,//二级层叠控制，默认6,同一个canvas（相同zlevel）上z越高约靠顶层。&#125;, 7.echarts知识点 legend默认不显示某些图例(selected属性) selected属性将目标图例设置为false 12345678legend: &#123; show: &apos;&apos;, icon:&quot;circle&quot;, //更改图列的默认样式 （ &apos;circle&apos;, &apos;rect&apos;, &apos;roundRect&apos;, &apos;triangle&apos;, &apos;diamond&apos;, &apos;pin&apos;, &apos;arrow&apos;）（全部的图例类型改变） selected:&#123; &quot;上期增长率&quot;:false //图例为‘上期增长率’的一项默认置灰 &quot;同比增长率&quot;:false //图例为‘同比增长率’的一项默认置灰 &#125;&#125;, 图例的列表布局与文本对齐方式 12345legend: &#123; orient:&apos;horizontal&apos; 或 &apos;vertical&apos; // 图例列表的布局朝向。 align: &apos;auto&apos;或 &apos;left&apos; 或&apos;right&apos; // 图例标记和文本的对齐 &#125;&#125; 这就是legend.align由right变为left的效果 legend的其它参数 1234567legend: &#123; orient: &apos;vertical&apos;, x:&apos;right&apos;, //可设定图例在左、右、居中 y:&apos;center&apos;, //可设定图例在上、下、居中 padding:[0,50,0,0], //可设定图例[距上方距离，距右方距离，距下方距离，距左方距离] data: [&apos;直接访问&apos;,&apos;微信&apos;,&apos;百度&apos;,&apos;其他文章&apos;,&apos;网页&apos;]&#125;, ①x : 可以设定图例在—-左（left）、右（right）、居中（center）、填写数字（如:100px）②y : 可以设定图例在—-上（top）、下（bottom）、居中（center）、填写数字（如:100px）③另外，可使用padding:padding:[0,50,0,0] [（距离上方距离），（距离右方距离）、（距离下方距离）、（距离左方距离）] series 系列列表。每个系列通过 type 决定自己的图表类型 12345678910111213141516171819202122series: [&#123; name: &apos;邮件营销&apos;, // 鼠标放在折线点上显示的名称 type: &apos;line&apos;, stack: &apos;总量&apos;, // 总量，每组数据的stack最好不要相同 yAxisIndex: 1, // 选择指定的y轴样式，默认为0，即选择第一个y轴样式，注意：当两组数据的stack相同时，数据会重叠，样式会变样 symbol:&apos;arrow&apos;, // 折线点样式：&apos;circle&apos;, &apos;rect&apos;, &apos;roundRect&apos;, &apos;triangle&apos;, &apos;diamond&apos;, &apos;pin&apos;, &apos;arrow&apos; symbolSize:15, // 折线点的大小 cursor:&apos;pointer&apos;, // 设置鼠标停置在图表上的显示样式 smooth:true, // 设置后折现会变得平滑 itemStyle: &#123; // 设置折线样式 normal: &#123; color: &quot;#386db3&quot;,//折线点的颜色 lineStyle: &#123;color: &quot;#386db3&quot;//折线的颜色 &#125;&#125;, data: [120, 132, 101, 134, 90, 230, 210] &#125;,&#123; name: &apos;联盟广告&apos;, type: &apos;line&apos;, stack: &apos;总量&apos;, data: [220, 182, 191, 234, 290, 330, 310] &#125;,&#123;&#125;,&#123;&#125;...] series数据集：是一个数组，表示可以在一张表上展示多个折线图type：表示图表类型。stack:折线图堆叠的重要参数。只要将stack的值设置不相同，两个图形就不会堆叠了 x，y轴的数据倾斜 12345678xAxis: &#123; type: &apos;category&apos;, data: [&apos;Mon&apos;, &apos;Tue&apos;, &apos;Wed&apos;, &apos;Thu&apos;, &apos;Fri&apos;, &apos;Sat&apos;, &apos;Sun&apos;], axisLabel:&#123; // 设置坐标轴刻度数据旋转 rotate:60 &#125;&#125; 关于x轴，y轴的xAxis，yAxis的使用说明 1234567891011121314151617181920212223242526272829303132xAxis : [&#123; type : &apos;category&apos;, // type:坐标轴类型。 // [ default: &apos;category&apos; ] /*可选： 1.&apos;value&apos; 数值轴，适用于连续数据； 2.&apos;category&apos; 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据； 3.&apos;time&apos; 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度； 4.&apos;log&apos; 对数轴。适用于对数数据。*/ data : [&apos;上海&apos;,&apos;北京&apos;], //x轴下面的数据 axisTick: &#123; show: false, //是否显示网状线 默认为true alignWithLabel: true &#125;, //用于设置x下面的字体 axisLabel:&#123; show:true, //这里的show用于设置是否显示x轴下的字体 默认为true interval:0, //可以设置成 0 强制显示所有标签（即类目category）。如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推。 rotate: 60 // 坐标轴刻度旋转 textStyle:&#123; //textStyle里面写x轴下的字体的样式 color:&apos;#333&apos;, fontSize:13 &#125; &#125;, axisLine:&#123; show:true, //这里的show用于设置是否显示x轴那一条线 默认为true lineStyle:&#123; //lineStyle里面写x轴那一条线的样式 color:&apos;#6FC6F3&apos;, width:2, //轴线的粗细 我写的是2 最小为0，值为0的时候线隐藏 &#125; &#125;&#125;] yAxis属性代表echarts图表的y轴，样式设置方式与x轴的方式是一样，就是设置的属性会有所差异 12345678910111213141516171819202122232425262728293031yAxis:[&#123; min:0, //y轴的最小值 max:100, //y轴最大值 interval:20, //值之间的间隔 //上面的三个值可以根据自己需求随意设置 不设置时会根据图中的值自动生成相应的值 position:&apos;left,right&apos; // 双y轴时设置y轴位置 type:&apos;value&apos;, /* type坐标轴类型:[ default: &apos;value&apos; ] 可选：1.&apos;value&apos; 数值轴，适用于连续数据。x 2.&apos;category&apos; 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。 3.&apos;time&apos; 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。 4.&apos;log&apos; 对数轴。适用于对数数据。*/ splitLine:&#123;show:false&#125;, //去除网状线 默认为true //用于设置y轴的字体 axisLabel:&#123; show:true, //这里的show用于设置是否显示y轴下的字体 默认为true rotate: 60 // 设置坐标轴数据旋转大小，Number类型 textStyle:&#123; //textStyle里面写y轴下的字体的样式 color:&apos;#333&apos;, fontSize:13 &#125;, &#125;, //用于设置y轴的那一条线 axisLine:&#123; show:true, //这里的show用于设置是否显示y轴那一条线 默认为true lineStyle:&#123; //lineStyle里面写y轴那一条线的样式 color:&apos;#6FC6F3&apos;, width:2, //轴线的粗细 我写的是2 最小为0，值为0的时候线隐藏 &#125; &#125;&#125;] datazoom区域缩放 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354dataZoom=[ //区域缩放 &#123; id: &apos;dataZoomX&apos;, show:true, //是否显示 组件。如果设置为 false，不会显示，但是数据过滤的功能还存在。 backgroundColor:&quot;rgba(47,69,84,0)&quot;, //组件的背景颜色 type: &apos;slider&apos;, //slider表示有滑动块的，inside表示内置的 dataBackground:&#123; //数据阴影的样式。 lineStyle:mylineStyle, //阴影的线条样式 areaStyle:myareaStyle, //阴影的填充样式 &#125;, fillerColor:&quot;rgba(167,183,204,0.4)&quot;, //选中范围的填充颜色。 borderColor:&quot;#ddd&quot;, //边框颜色。 filterMode: &apos;filter&apos;, //&apos;filter&apos;：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。 //&apos;weakFilter&apos;：当前数据窗口外的数据，被 过滤掉。即 会 影响其他轴的数据范围。每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。 //&apos;empty&apos;：当前数据窗口外的数据，被 设置为空。即 不会 影响其他轴的数据范围。 //&apos;none&apos;: 不过滤数据，只改变数轴范围。 xAxisIndex:0, //设置 dataZoom-inside 组件控制的 x轴,可以用数组表示多个轴 yAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 y轴,可以用数组表示多个轴 radiusAxisIndex:3, //设置 dataZoom-inside 组件控制的 radius 轴,可以用数组表示多个轴 angleAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 angle 轴,可以用数组表示多个轴 start: 30, //数据窗口范围的起始百分比,表示30% end: 70, //数据窗口范围的结束百分比,表示70% startValue:10, //数据窗口范围的起始数值 endValue:100, //数据窗口范围的结束数值。 orient:&quot;horizontal&quot;, //布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴。&apos;horizontal&apos;：水平。&apos;vertical&apos;：竖直。 zoomLock:false, //是否锁定选择区域（或叫做数据窗口）的大小。如果设置为 true 则锁定选择区域的大小，也就是说，只能平移，不能缩放。 throttle:100, //设置触发视图刷新的频率。单位为毫秒（ms）。 zoomOnMouseWheel:true, //如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。&apos;shift&apos;：表示按住 shift 和鼠标滚轮能触发缩放。&apos;ctrl&apos;：表示按住 ctrl 和鼠标滚轮能触发缩放。&apos;alt&apos;：表示按住 alt 和鼠标滚轮能触发缩放。 moveOnMouseMove:true, //如何触发数据窗口平移。true：表示不按任何功能键，鼠标移动能触发数据窗口平移。false：表示鼠标滚轮不能触发缩放。&apos;shift&apos;：表示按住 shift 和鼠标移动能触发数据窗口平移。&apos;ctrl&apos;：表示按住 ctrl 和鼠标移动能触发数据窗口平移。&apos;alt&apos;：表示按住 alt 和鼠标移动能触发数据窗口平移。 left:&quot;center&quot;, //组件离容器左侧的距离,&apos;left&apos;, &apos;center&apos;, &apos;right&apos;,&apos;20%&apos; top:&quot;top&quot;, //组件离容器上侧的距离,&apos;top&apos;, &apos;middle&apos;, &apos;bottom&apos;,&apos;20%&apos; right:&quot;auto&quot;, //组件离容器右侧的距离,&apos;20%&apos; bottom:&quot;auto&quot;, //组件离容器下侧的距离,&apos;20%&apos;&#125;,&#123; id: &apos;dataZoomY&apos;, type: &apos;inside&apos;, filterMode: &apos;empty&apos;, disabled:false, //是否停止组件的功能。 xAxisIndex:0, //设置 dataZoom-inside 组件控制的 x轴,可以用数组表示多个轴 yAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 y轴,可以用数组表示多个轴 radiusAxisIndex:3, //设置 dataZoom-inside 组件控制的 radius 轴,可以用数组表示多个轴 angleAxisIndex:[0,2], //设置 dataZoom-inside 组件控制的 angle 轴,可以用数组表示多个轴 start: 30, //数据窗口范围的起始百分比,表示30% end: 70, //数据窗口范围的结束百分比,表示70% startValue:10, //数据窗口范围的起始数值 endValue:100, //数据窗口范围的结束数值。 orient:&quot;horizontal&quot;, //布局方式是横还是竖。不仅是布局方式，对于直角坐标系而言，也决定了，缺省情况控制横向数轴还是纵向数轴。&apos;horizontal&apos;：水平。&apos;vertical&apos;：竖直。 zoomLock:false, //是否锁定选择区域（或叫做数据窗口）的大小。如果设置为 true 则锁定选择区域的大小，也就是说，只能平移，不能缩放。 throttle:100, //设置触发视图刷新的频率。单位为毫秒（ms）。 zoomOnMouseWheel:true, //如何触发缩放。可选值为：true：表示不按任何功能键，鼠标滚轮能触发缩放。false：表示鼠标滚轮不能触发缩放。&apos;shift&apos;：表示按住 shift 和鼠标滚轮能触发缩放。&apos;ctrl&apos;：表示按住 ctrl 和鼠标滚轮能触发缩放。&apos;alt&apos;：表示按住 alt 和鼠标滚轮能触发缩放。 moveOnMouseMove:true, //如何触发数据窗口平移。true：表示不按任何功能键，鼠标移动能触发数据窗口平移。false：表示鼠标滚轮不能触发缩放。&apos;shift&apos;：表示按住 shift 和鼠标移动能触发数据窗口平移。&apos;ctrl&apos;：表示按住 ctrl 和鼠标移动能触发数据窗口平移。&apos;alt&apos;：表示按住 alt 和鼠标移动能触发数据窗口平移。&#125; echarts双y轴设置 y轴的属性设置yAxis:[{},{}]，数组中每一个对象就是一个y轴设置，而series中的yAxisIndex属性可以选择指定的y轴样式。PS：注意：当多组数据的stack相同时，数据会叠加，样式会变得奇形怪状，最好不要设置一样 8.Echarts解决的实际问题 x轴xAxis配置 x轴显示全部文字，强制显示 改善项目 x轴显示全部文字，强制显示（参考Echarts x轴文本内容太长的几种解决方案） &nbsp;&nbsp;&nbsp;&nbsp;问题描述：当我们做一个月度报表时，展示1~12月份的数据，在某些分辨率较低的PC，mobile设备上，Echarts就会自适应调整，就有可能无法完全显示，比如只显示1，3，5，…,11月份数据，那这时我们想要完全展示怎么办呢？ 显示全部文字，强制显示 12345678910111213xAxis: &#123; data: [&quot;衬衫11111&quot;,&quot;羊毛二二&quot;,&quot;雪纺衫111&quot;,&quot;裤子111&quot;,&quot;高跟鞋11&quot;,&quot;袜子111&quot;],//x轴中的数据 name:&quot;123&quot;,//坐标轴名称。 nameLocation:&apos;end&apos;,//坐标轴名称显示位置。 axisLabel : &#123;//坐标轴刻度标签的相关设置。 interval:0, //强制显示文字 show: true, textStyle: &#123; color: &apos;black&apos;, fontSize:10, &#125; &#125;&#125; 文本字体倾斜 换行显示 文本文字竖直显示 隔一个换行 参考文章 Echarts图例位置 - legend属性：https://blog.csdn.net/woteafuck/article/details/91986313 ECharts图例组件配置: https://www.w3cschool.cn/echarts_tutorial/echarts_tutorial-vnga2cgx.html Echarts中的ROOT_PATH都表示：https://echarts.apache.org/examples/","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://ahrilove.top/tags/echarts/"}]},{"title":"Python全栈系列章节更新(五)：并发编程~多线程","slug":"Python全栈系列章节更新（五）","date":"2019-12-03T16:00:00.000Z","updated":"2021-09-06T09:01:20.000Z","comments":true,"path":"2019/12/04/Python全栈系列章节更新（五）/","link":"","permalink":"https://ahrilove.top/2019/12/04/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"1.线程与进程的区别2.为何会选择多线程3.创建多线程的方式4.线程对象的属性和方法5.守护线程6.线程池与进程池7.多线程，到底该设置多少个线程？8.队列","text":"1.线程与进程的区别2.为何会选择多线程3.创建多线程的方式4.线程对象的属性和方法5.守护线程6.线程池与进程池7.多线程，到底该设置多少个线程？8.队列 线程顾名思义，就是一条流水线工作的过程（流水线的工作需要电源，电源就相当于cpu），而一条流水线必须属于一个车间，一个车间的工作过程是一个进程，车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一条流水线。所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.线程与进程的区别1、每启动一个进程，进程内都至少有一个线程。 2、进程本身只是一个资源调度集合，并不能真正执行，进程内的线程才是真正的运行单位。 3、一个进程内可以启动多个线程，同一进程内线程间共享资源。 4、启动线程的开销远远小于开进程。 5、线程可以相当程度控制相同进程下的线程，进程只能控制其子进程。 6、对主线程的更改（取消、优先级更改等）可能会影响其他线程的行为，对父进程的修改则不会影响子进程。 7、进程之间是竞争关系，线程之间是协作关系 2.为何会选择多线程？ 同一个进程内的多个线程共享该进程内的地址资源 线程比进程更轻量级，线程比进程更容易创建可撤销 join方法：join 会卡住主线程，并让当前已经 start 的子线程继续运行，直到调用.join的这个线程运行完毕 3.创建线程的方式★★★Python创建多线程主要有两种方法：函数式，类创建 函数式创建在Python3中，Python提供了一个内置模块 threading.Thread，可以很方便地让我们创建多线程。threading.Thread() 一般接收两个参数： 线程函数名：要放置线程让其后台执行的函数，由我们自已定义，注意不要加()； 线程函数的参数：线程函数名所需的参数，以元组的形式传入。若不需要参数，可以不指定12345678910111213141516171819202122232425from threading import Thread, currentThread# 简单多线程，解释：# 1）一个工人只做一个任务，做完就撤了；# 2）有多少个任务就得有多少个工人；# 3）这个方式处理任务需要快，但人员成本开销高。def task(taskId): thread_name = currentThread().getName() print('工人【%s】正在处理任务【%d】：do something...' % (thread_name, taskId))if __name__ == '__main__': threads = [] # 这里弄5个线程（一个线程相当于一个工人） for i in range(5): # target 参数指定线程要处理的任务函数，args 参数传递参数到任务函数去 t = Thread(target=task, args=(i+1,)) threads.append(t) # 启动线程 for t in threads: t.start() # 阻塞线程 for t in threads: t.join() 类创建相比较函数而言，使用类创建线程，会比较麻烦一点。首先，我们要自定义一个类，对于这个类有两点要求: 必须继承 threading.Thread 这个父类 必须覆写 run 方法 这里的 run 方法，和我们上面线程函数的性质是一样的，可以写我们的业务逻辑程序。在 start() 后将会调用。 来看一下例子，为了方便对比，run函数我复用上面的main。 12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-import timefrom threading import Threadclass MyThread(Thread): def __init__(self, name=\"Python\"): \"\"\" 类的继承：写法一 super(父类名, self).__init__(父类的属性参数一，父类的属性参数二) eg： 1. 线程类的继承 super(MyThread, self).__init__() 2. 自定义类的继承 super(Animal, self).__init__(name, types) 类的继承：写法二 super().__init__(父类的属性参数一，父类的属性参数二) \"\"\" # 注意，super().__init__() 一定要写，而且要写在最前面，否则会报错。 # super(MyThread, self).__init__() super().__init__() self.name = name def run(self): for i in range(2): print(\"hello &#123;&#125; ==&gt; index: &#123;&#125;\".format(self.name, i + 1)) time.sleep(1)if __name__ == '__main__': print(\"这是主线程！\") start_time = time.time() # 创建线程01，不指定参数 thread_01 = MyThread() # 创建线程02，指定参数 thread_02 = MyThread(name=\"Badwoman\") thread_01.start() thread_02.start() print(\"主线程结束！\") print(time.time() - start_time) 4.线程对象的属性和方法 4.1 Thread实例对象的方法 isAlive():返回线程是否活动的getName():返回线程名setName():设置线程名 123456789101112131415161718192021from threading import Thread, currentThread # 得到线程对象的方法from threading import active_count # 得到活跃进程数from threading import enumerate # 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。import time# 需要注意的是线程没有子线程的概念，线程都是属于进程的def task(): print(\"%s is running\" % currentThread().getName()) # 对象下有一个getName()方法 time.sleep(2) print(\"%s is done\" % currentThread().getName())if __name__ == '__main__': # getName()方法返回线程名 t = Thread(target=task, name='子线程1') t.start() print(\"主进程\", currentThread().getName()) \"\"\" 子线程1 is running 主进程 MainThread 子线程1 is done \"\"\" 5.守护线程守护线程守护主线程，等到主线程死了才会被销毁。在有其他线程的情况下，主线程代码运行完后，等其他非守护线程结束，守护线程才会死掉。 无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行。运行完毕的真正含义：1、对主进程来说，运行完毕指的是主进程代码运行完毕。 2、对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才能运行完毕 123456# 创建一个线程t=Thread(target=func)# 守护线程设置：设置线程是否随主线程退出而退出，默认为Falset.daemon = Truet.daemon = False 6.进程池和线程池进程池和线程池的接口一模一样，用法也一样。池就是要对数目加以限制，保证机器一个可承受的范围，以一个健康的状态保证它的运行 concurrent.futures 模块提供了高度封装的异步调用接口ThreadPoolExecutor： 线程池，提供异步调用ProcessPoolExecutor: 进程池，提供异步调用 基本方法： 1、submit(fn, args, *kwargs)异步提交任务 2、map(func, *iterables, timeout=None, chunksize=1) 取代for循环submit的操作 3、shutdown(wait=True) 相当于进程池的pool.close()+pool.join()操作wait=True，等待池内所有任务执行完毕回收完资源后才继续wait=False，立即返回，并不会等待池内的任务执行完毕但不管wait参数为何值，整个程序都会等到所有任务执行完毕，submit和map必须在shutdown之前 4、result(timeout=None) 取得结果 5、add_done_callback(fn) 回调函数 线程池 123456789101112131415161718192021222324252627# 线程池# 解释：# 1）一个工人同一时间只做一个任务，但做完一个任务可以接着做下一个任务；# 2）可以分配多个任务给少量工人，减少人员成本开销。import threadingfrom concurrent.futures import ThreadPoolExecutor# 任务def task(taskId): thread_name = threading.current_thread().getName() print('工人【%s】正在处理任务【%d】：do something...' % (thread_name, taskId))def main(): # 初始化线程池(商会)，定义好池里最多有几个工人 pool = ThreadPoolExecutor(max_workers=5, thread_name_prefix='自定义线程前缀名Thread') # 准备10个任务 for i in range(10): # 提交任务到池子(商会)里（它会自动分配给工人） pool.submit(task, i+1)if __name__ == '__main__': main() shutdown()方法的使用 12345678910111213141516171819202122232425from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutorimport os, time, randomdef task(name): print(\"name: %s pid: %s run\" % (name, os.getpid())) time.sleep(random.randint(1,3))if __name__ == '__main__': pool = ProcessPoolExecutor(4) # 指定进程池大小，最大进程数，如果不指定默认是CPU核数 for i in range(10): \"\"\"从始至终四个进程解决这10个任务，谁没事了接新任务\"\"\" pool.submit(task, 'egon%s' %i) # 提交任务的方式————异步调用：提交完任务，不用在原地等任务执行拿到结果。 pool.shutdown() # 把提交任务入口关闭，默认参数wait=True；同时还进行了pool.join()操作，等任务提交结束，再结束主进程 print(\"主进程\")\"\"\"name: egon0 pid: 12502 runname: egon1 pid: 12503 run....name: egon9 pid: 12505 run主进程\"\"\" 7.多线程，到底该设置多少个线程？那我们如何分配线程？我们提供一个公式： 最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 我们继续上面的任务，我们的服务器CPU核数为4核，一个任务线程cpu耗时为20ms，线程等待（网络IO、磁盘IO）耗时80ms，那最佳线程数目：( 80 + 20 )/20 * 4 = 20。也就是设置20个线程数最佳。 从这个公式上面我们就得出，线程的等待时间越大，线程数就要设置越大，这个正好符合我们上面的分析，可提升CPU利用率。那从另一个角度上面说，线程数设置多大，是根据我们自身的业务的，需要自己去压力测试，设置一个合理的数值。 基础常规标准 我们可以尝试去猜想，因为很多业务集中到一个线程池中，不像上面的案例比较简单，事实上业务太多，怎么设置呢？这个就是要去压力测试去调整。不过我们的前辈已经帮我们总结了一个基础的值（最终还是要看运行情况自行调整） 1、CPU密集型：操作内存处理的业务，一般线程数设置为：CPU核数 + 1 或者 CPU核数*2。核数为4的话，一般设置 5 或 8 2、IO密集型：文件操作，网络操作，数据库操作，一般线程设置为：cpu核数 / (1-0.9)，核数为4的话，一般设置 40 8.队列Queue用于建立和操作队列，常和threading类一起用来建立一个简单的线程队列进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的 队列的创建 Queue.Queue(maxsize) FIFO（先进先出队列） Queue.LifoQueue(maxsize) LIFO（先进后出队列） Queue.PriorityQueue(maxsize) 优先级顺序创建队列 maxsize表示创建队列中允许的最大项数（队列总容量超过maxsize值时，将会截取至maxsize），如果设置的maxsize小于1，则表示队列的长度无限长 线程安全队列 在线程中，访问一些全局变量，加锁是一个经常的过程。Queue模块提供了一个适用于多线程编程的先进先出数据结构，可以用来安全的传递多线程信息。它本身就是线程安全的，使用put和get来处理数据，不会产生对一个数据同时读写的问题，所以是安全的Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用，可以使用队列来实现线程间的同步。 队列的主要方法 FIFO是常用的队列，其一些常用的方法有： Queue.qsize()：返回队列大小 Queue.empty()：判断队列是否为空 Queue.full()：判断队列是否满了 Queue.get([block[,timeout]])：从队列头删除并返回一个item，当队列为空时继续执行get取值时就会引发异常 Queue.put(item[,block[,timeout]])：向队尾插入一个item，同样若队列满时继续执行put填值时就会引发异常 Queue.task_done()：从场景上来说，处理完一个get出来的item之后，调用task_done将向队列发出一个信号，表示本任务已经完成 Queue.join()：监视所有item并阻塞主线程，直到所有item都调用了task_done之后主线程才继续向下执行。这么做的好处在于，假如一个线程开始处理最后一个任务，它从任务队列中拿走最后一个任务，此时任务队列就空了但最后那个线程还没处理完。当调用了join之后，主线程就不会因为队列空了而擅自结束，而是等待最后那个线程处理完成了。 Queue.unfinished_tasks： 返回队列q.task_done()后的队列的大小 简单举例队列与多线程的搭配使用：本示例是队列大小无限制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import timeimport queuefrom threading import Thread, currentThreaddef run_test(q): while not q.empty(): value = q.get() print(\"线程【&#123;&#125;】正在处理队列值【&#123;&#125;】\\n\".format(currentThread().name, value), end=\"\") time.sleep(0.8) # 本次队列任务处理完成，此处不可省略 q.task_done()def queue_demo(): # 创建线程列表 thread_list = [] # 声明队列 q = queue.Queue(25) # 队列长度 queue_len = 0 # 放入队列待处理值 for i in range(1, 9): q.put(i) queue_len += 1 # 【处理线程】可自定义创建多线程数目 for x in range(1, 3): t = Thread(target=run_test, args=(q, )) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join()if __name__ == '__main__': print(\"=-=-=-=-=-=\"*5) print(\"队列Queue多线程任务开始\") start_time = time.time() queue_demo() print(\"主线程结束！任务总耗时：&#123;&#125;秒！\".format(time.time() - start_time)) print(\"=-=-=-=-=-=\" * 5)\"\"\"程序执行结果：=-=-=-=-=-==-=-=-=-=-==-=-=-=-=-==-=-=-=-=队列Queue多线程任务开始线程【Thread-1】正在处理队列值【1】线程【Thread-2】正在处理队列值【2】线程【Thread-2】正在处理队列值【3】线程【Thread-1】正在处理队列值【4】线程【Thread-2】正在处理队列值【5】线程【Thread-1】正在处理队列值【6】线程【Thread-1】正在处理队列值【7】线程【Thread-2】正在处理队列值【8】主线程结束！任务总耗时：3.232334613800049秒！=-=-=-=-=-==-=-=-=-=-==-=-=-=-=-==-=-=-=-=\"\"\" 参考文章 Python简单queue队列与多线程使用演示 Python多线程控制台输出错乱","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://ahrilove.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（四）：并发编程~多进程","slug":"Python全栈系列章节更新（四）","date":"2019-12-03T16:00:00.000Z","updated":"2021-06-22T01:36:28.000Z","comments":true,"path":"2019/12/04/Python全栈系列章节更新（四）/","link":"","permalink":"https://ahrilove.top/2019/12/04/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"1.进程与程序2.并发与并行3.多进程创建方式4.互斥锁","text":"1.进程与程序2.并发与并行3.多进程创建方式4.互斥锁 假设在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务，但同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？备一会课，再去跟二娃子的女朋友聊聊天，再去打一会王者荣耀….这就保证了每个任务都在进行中 1.进程与程序程序仅仅是一堆代码，进程指的是程序的运行过程注意：同一个程序执行两次，也是两个进程进程：正在进行的一个过程，是一个任务，或者说是一个资源调度的集合。 2.并发与并行无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真实干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务。 一、并发：伪并行，即看起来多个进程像在同时运行。单个cpu+多道技术可实现并发。 二、并行：多个进程同时运行，只有具备多个cpu才能实现。 3.多进程创建方式注意：在windows中Process()必须放到# if __name__ == &#39;__main__&#39;:下进程创建格式：target表示函数名，args=(参数一,参数二,…,)，参数最后一定要保留一个逗号p = Process(target=task, args=(‘子进程1’,)) 123456789101112131415from multiprocessing import Processimport timedef task(name): print(\"%s is running\" % name) time.sleep(3) print(\"%s is done\" % name) if __name__ == '__main__': # 创建进程 p = Process(target=task, args=('子进程1',)) # 得到对象 # 启动进程 p.start() print(\"这是主进程\") 3.1 Process类的方法和属性介绍 方法 详解 p.start()： 启动进程，并调用该子进程中的p.run() p.run(): 进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 p.terminate(): 强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 p.is_alive(): 如果p仍然运行，返回True p.join([timeout]): 主线程等待p线程终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间 Process属性 详解 p.daemon： 默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置 p.name: 进程的名称 p.pid： 进程的pid p.exitcode: 进程在运行时为None、如果为–N，表示被信号N结束(了解即可) p.authkey: 进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串 3.2 进程之间的内存空间是隔离的3.3 Process对象的join方法 join方法：优先运行子进程，主进程卡在原地，子进程结束后，运行主进程后面的代码。案例如下： 1234567891011121314151617181920from multiprocessing import Processimport time, osdef task(): print('%s is running, parent id is &lt;%s&gt;' % (os.getpid(), os.getppid())) # 进程和父进程查看方式 time.sleep(3) print(\"%s is done, parent id is &lt;%s&gt;\" % (os.getpid(), os.getppid()))if __name__ == '__main__': p = Process(target=task, ) p.start() p.join() # 优先运行子进程，主进程卡在原地 print('主进程', os.getpid(), 'pycharm ID', os.getppid()) print(p.pid) # 子进程运行完，变为僵尸进程，主进程仍能够查到子进程的pid，当主进程结束后，所有僵尸子进程将被丢掉。\"\"\"is running, parent id is &lt;827&gt;is done, parent id is &lt;827&gt;主进程 827 pycharm ID 504\"\"\" 使用join方法实现并发执行 12345678910111213141516171819202122232425262728from multiprocessing import Processimport timedef task(name ,n): print('%s is running' % name) time.sleep(n)if __name__ == '__main__': start = time.time() p1 = Process(target=task, args=(\"子进程1\",5,)) p2 = Process(target=task, args=(\"子进程2\",3,)) p3 = Process(target=task, args=(\"子进程3\",2,)) p1.start() p2.start() p3.start() # 再添加join函数前，主程序的执行输出次序是完全随机的，需要加join()保证主程序等到在子进程之后执行完成 p1.join() p2.join() p3.join() # 以上并非串行执行，实际是并发执行，只是约束了主程序要等在子程序后结束 # print('主进程', os.getpid(), 'pycharm ID', os.getppid()) print(\"主进程\", (time.time()-start))\"\"\"子进程1 is running子进程2 is running子进程3 is running主进程 5.010260343551636 # 主程序只等了5秒，说明确实是并发执行\"\"\" 使用join方法实现多进程串行执行 123456789101112131415161718from multiprocessing import Processdef task(name ,n): passif __name__ == '__main__': p1 = Process(target=task, args=(\"子进程1\",5)) p2 = Process(target=task, args=(\"子进程2\",3)) p3 = Process(target=task, args=(\"子进程3\",2)) # 串行执行 p1.start() p1.join() p2.start() p2.join() p3.start() p3.join() print(\"我是主进程\") 守护进程 主进程创建守护进程： 一：守护进程会在主进程代码执行结束后就终止，主进程代码运行结束，守护进程立即死亡 二：守护进程内无法再开启子进程,否则抛出异常 12345if __name__ == &apos;__main__&apos;: p = Process(target=task, args=(&apos;子进程&apos;, )) p.daemon=True # 守护进程一定要在进程开启前,即p.start()开启前设置 p.start() print(&quot;我是主进程&quot;) 4.互斥锁进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,而共享带来的是竞争，竞争带来的结果就是错乱互斥锁的原理：就是把并发改成穿行，降低了效率，但保证了数据安全不错乱 1234567891011def task(): # 获得锁 lock.acquire() ... # 释放锁 lock.release()if __name__ == &apos;__main__&apos;: lock = Lock() # 只实例化一次，并传给子进程，要保证所有进程用同一把锁 for i in range(3): p = Process(target=task, args=(&apos;进程%s&apos; % i, lock,)) # 传递给子进程的锁 p.start()","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"多进程","slug":"多进程","permalink":"https://ahrilove.top/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"sql语句关于时间的讨论","slug":"sql系列更新(九)","date":"2019-12-03T16:00:00.000Z","updated":"2021-05-06T06:28:56.000Z","comments":true,"path":"2019/12/04/sql系列更新(九)/","link":"","permalink":"https://ahrilove.top/2019/12/04/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E4%B9%9D)/","excerpt":"进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.oracle时间和日期的处理2.mysql时间和日期的处理","text":"进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.oracle时间和日期的处理2.mysql时间和日期的处理 1.oracle时间和日期的处理 1.字符串转换为日期时分秒格式： to_date(字符串, &#39;yyyy-mm-dd hh24:mi:ss&#39;) select to_date(‘20180831154546’, ‘yyyy-mm-dd hh24:mi:ss’) from dual;结果为：2018-08-31 15:45:46 2.获取系统时间 SELECT SYSDATE FROM dual; – 系统时间:2019-12-04 21:40:15 SELECT SYSTIMESTAMP FROM dual; – 当前系统时间戳:2019-12-04 21:40:41.328000 +08:00 3.时间类型与字符串相互转换 字符串转换为时间类型：to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’); 123456-- 字符串转时间类型SELECT to_date('2018-08-23 00:00:00','yyyy-mm-dd hh24:mi:ss') FROM dual;-- 时间类型转字符串select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;select to_char(sysdate,'yyyy-mm-dd') from dual; 4.日期的加减 如果时间要进行加减，和现在的时间或者某个目标时间进行比较。 to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’)+1 后面为1的时候就是加1天，2的时候就是加两天，如果加一个小时，就是为1/24，如果加一分钟，就是为1/24/60,… 1234567-- 案例：select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1 from dual;-- 加一天 2019-02-19 23:59:00select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1/24 from dual;-- 加一个小时 2019-02-19 00:59:00select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1/24/60 from dual;-- 加一分钟 2019-02-19 00:00:00 2.MySQL的时间与日期的处理 mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写 – 今天SELECT 【想要的字段】 FROM 【表名】 WHERETO_DAYS(【时间字段名】) =TO_DAYS(now()); – 昨天SELECT 【想要的字段】 FROM 【表名】 WHERE TO_DAYS( NOW( ) ) - TO_DAYS(【时间字段名】) = 1; – 近七天SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;=DATE(【时间字段名】); – 本周内SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now()); – 上一周SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now())-1; – 30天内 注意这个不是本月是从当天起向前推30天SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;=DATE(【时间字段名】); – 本月SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) = DATE_FORMAT( CURDATE( ) , ‘%Y%m’ ); – 上一个月SELECT 【想要的字段】 FROM 【表名】 WHERE PERIOD_DIFF( DATE_FORMAT( now( ) , ‘%Y%m’ ) , DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) ) =1; – 本季度SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(now()); – 上一季度SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(DATE_SUB(now(),interval 1 QUARTER)); – 本年度SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(NOW()); – 上一年度SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(date_sub(now(),interval 1 YEAR)); 参考文章 oracle时间的相关操作","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://ahrilove.top/tags/Oracle/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（三）：数据库","slug":"Python全栈系列章节更新（三）","date":"2019-12-02T16:00:00.000Z","updated":"2021-12-04T00:36:43.682Z","comments":true,"path":"2019/12/03/Python全栈系列章节更新（三）/","link":"","permalink":"https://ahrilove.top/2019/12/03/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"1.数据库通用连接函数2.数据库批处理:execute/executemany3.数据库插入百万级数据优化4.DBUtils管理数据库连接池","text":"1.数据库通用连接函数2.数据库批处理:execute/executemany3.数据库插入百万级数据优化4.DBUtils管理数据库连接池 1.数据库通用连接函数连接模块视实际数据库决定，大同小异。将其封装成一个新的python文件，以便可以重复调用，命名为SqlConnectManage.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def executemany(self, sql,*args): print(\"-----插入数据-----\") try: self.cursor.executemany(sql,*args) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 1.1 MySQL通用封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# -*- coding:utf-8 -*-import pymysql'''===============================================@Project -&gt; File ：OAPlug -&gt; MySQLHelper.py@IDE ：PyCharm@Author ：Miss.BadWoman @Date ：2020/7/4 13：30@Desc ：MySQL通用连接函数==================================================='''class MySQLHelper(object): def __init__(self, username, password, host, port, database): self.username = username self.port = port self.password = password self.host = host self.database = database self.cursor = None self.conn = None def mysql_conn(self): \"\"\" 连接数据库并创建游标 :return: None \"\"\" self.conn = pymysql.connect(user=self.username, password=self.password, port=self.port, host=self.host, charset=\"utf8\", database=self.database) # 创建游标,以字典形式返回 self.cursor = self.conn.cursor(cursor=pymysql.cursors.DictCursor) def mysql_select(self, sql, *args): \"\"\" sql语言执行查询操作，返回单行数据 :param sql:sql语句 :return: rows 字典型列表 \"\"\" try: # 开始执行sql self.cursor.execute(sql, *args) rows = self.cursor.fetchone() return rows except Exception as e: print(e) def mysql_select_all(self, sql, *args): \"\"\" sql语言执行查询操作，返回数据集 :param sql:sql语句 :return: rows 字典型列表 \"\"\" try: # 开始执行sql self.cursor.execute(sql, *args) rows = self.cursor.fetchall() return rows except Exception as e: print(e) def execute(self, sql, *args): \"\"\" sql语言执行插入更新操作 :param sql: sql语句 :param args: 不定数据 :return: None \"\"\" print(\"-----插入更新数据-----\") try: self.cursor.execute(sql, *args) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def executemany(self, sql, *args): \"\"\" sql语言执行批次插入操作 :param sql: 不管字段为什么类型，占位符统一使用%s,且不能加上引号 :param args: 元组型列表或元组型元组[(1, '张三', '男'),(2, '李四', '女'),] :return:None \"\"\" print(\"-----插入数据-----\") try: self.cursor.executemany(sql, *args) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def commit(self): self.conn.commit() def close(self): self.cursor.close() self.conn.close() 1.2 Oracle通用封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# -*- coding:utf-8 -*-import cx_Oracle\"\"\"===================================================@IDE ：PyCharm@Author ：Miss.BadWoman @Date ：2020/7/4 13：30@Desc ：ORACLE通用连接函数===================================================\"\"\"class OracleHelper(object): def __init__(self, ora_username, ora_password, ora_host, ora_port, ora_sid): \"\"\" 初始化Oracle连接 :param ora_username: 用户名 :param ora_password: 密码 :param ora_host: 域名 :param ora_port: 端口号 :param ora_sid: 实例名 \"\"\" self.username = ora_username self.port = ora_port self.password = ora_password self.host = ora_host self.sid = ora_sid self.conn = None self.cursor = None def oracle_conn(self): \"\"\" 连接数据库并创建游标 :return: None \"\"\" self.conn = cx_Oracle.connect(self.username, self.password, self.host + ':' + self.port + '/' + self.sid) self.cursor = self.conn.cursor() def oracle_select(self, sql, mode=\"all\"): \"\"\" sql语言执行查询操作，返回单行数据 :param sql: sql语句 :param mode: (all/one) 返回单条或多条数据，查询类型 :return: 对象型数组 \"\"\" try: self.cursor.execute(sql) if mode == \"all\": rows = self.cursor.fetchall() elif mode == \"one\": rows = self.cursor.fetchone() else: rows = self.cursor.fetchall() cols = [d[0] for d in self.cursor.description] result = [] for row in rows: b = dict(zip(cols, row)) result.append(b) return result except Exception as e: print(e) def execute(self, sql, *args): \"\"\" sql语言执行插入更新操作 :param sql: sql语句 :param args: 不定数据 :return: None \"\"\" print(\"-----插入更新数据-----\") try: self.cursor.execute(sql, *args) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def executemany(self, sql, *args): \"\"\" sql语言执行批次插入操作 :param sql: 不管字段为什么类型，占位符统一使用%s,且不能加上引号 :param args: 元组型列表或元组型元组[(1, '张三', '男'),(2, '李四', '女'),] :return:None \"\"\" print(\"-----插入数据-----\") try: self.cursor.executemany(sql, *args) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def commit(self): self.conn.commit() def close(self): self.cursor.close() self.conn.close() 1.3 SQL Server通用封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# -*- coding:utf-8 -*-import pymssql'''==================================================@IDE ：PyCharm@Author ：Miss.BadWoman @Date ：2020/7/4 15：30@Version：2.1.4(pymssql推荐版本)@Desc ：SQL Server通用连接函数（有空完善，先写select）==================================================='''class SQLServerHelper(object): def __init__(self, host, user, password, database): \"\"\" 类的构造和初始化连接 :param host:ip地址 :param user:用户名 :param password:密码 :param database:数据库 \"\"\" try: self.conn = pymssql.connect(host, user, password, database, charset='utf8') self.cursor = self.conn.cursor() except Exception as e: print(\"连接数据库失败：\"+str(e)) def sqlserver_select(self, sql, mode=\"all\"): \"\"\" sql语言执行查询操作，返回数据集 :param sql: sql语句 :param mode: (all/one) 返回单条或多条数据，查询类型 :return: 对象型数组 \"\"\" try: self.cursor.execute(sql) if mode == \"all\": rows = self.cursor.fetchall() elif mode == \"one\": rows = self.cursor.fetchone() else: rows = self.cursor.fetchall() \"\"\" 获取字段名时要根据根据pymssql版本的决定 2.1.4及以下：参考下述方法 2.1.5及以上(推荐)： conn = pymssql.connect(server, user, password, \"tempdb\") cursor = conn.cursor(as_dict=True) \"\"\" cols = [d[0] for d in self.cursor.description] result = [] for row in rows: b = dict(zip(cols, row)) result.append(b) if len(result) &lt;= 0: # 为空返回False return False return result except Exception as e: print('\\033[1;31;0m\\t4---查询失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) return False def sqlserver_update(self, sql, *args): \"\"\" 语言执行update更新操作 :param sql :return: None \"\"\" try: # 开始执行sql self.cursor.execute(sql, *args) except Exception as e: print('\\033[1;31;0m\\t4---更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False def executemany(self, sql, *args): \"\"\" sql语言执行批次插入操作 :param sql: 不管字段为什么类型，占位符统一使用%s,且不能加上引号 :param args: 元组型列表或元组型元组[(1, '张三', '男'),(2, '李四', '女'),] :return:None \"\"\" print(\"-----插入数据-----\") try: self.cursor.executemany(sql, *args) except Exception as e: print('\\033[1;31;0m\\t4---批量插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def commit(self): self.conn.commit() def close(self): self.cursor.close() self.conn.close() 1.fetchall\\(\\):表示返回查询到的所有数据；fetchone\\(\\):表示返回查询到的第一行数据 2.python原生查询返回的所有数据类型为元组型列表，即\\[\\(\\)\\,\\(\\)\\,\\...\\(\\)\\] 3.元组的访问方式为：元组名\\[index\\] 2.数据分批次处理数据库分批次处理可以使用两种方法：execute()与executemany()方法 2.1 executemany在使用executemany方法时，需要注意的几个问题： 在写sql语句时，不管字段为什么类型，占位符统一使用%s,且不能加上引号 1sql=\"insert into tablename (id,name) values (%s,%s)\" 添加的数据的格式必须为元组型列表或元组型元组(并不是无限添加)：list[tuple(),tuple(),tuple()]或者tuple(tuple(),tuple(),tuple()) 123values=[(1,\"zhangsan\"),(2,\"lisi\")]#或者values=((1,\"zhangsan\"),(2,\"lisi\")) 不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理 最后通过executemany插入 12cursor.executemany(sql,values)connect.commit() 2.2 executeexecute()语法一次只能执行一个sql语句，分批次处理的原理是：循环执行批量语句，然后在commit，如下 12345for i in range(10): sql = \"insert into users(id,grand) values(i,i+10)\" cursor.execute(sql)# 批量执行数据后，然后提交 connect.commit() 3.数据库插入百万级数据优化最近做一个项目，需要插入和读取很多数据，所以就需要对数据库大量插入操作进行优化，还是以python为基石，不过在开始动工前，需要明确以下几点： 考虑是一条线程完整地执行数据库的连接、创建游标、然后插入数据、commit数据、断开连接这一系列操作，还是使用多线程执行获取数据的操作，然后单线程来插入整理好的数据？ 考虑是每执行一次insert，update或者delete，就执行一次commit，还是批量处理数据后，才执行一次commit 数据执行语句execute()与executemany()的选择 对我而言，我的设计是调用数据库的通用数据池连接文件SqlConnectManage.py，将数据库的连接和关闭函数作为全局使用，放在程序的首尾（就相当于不会重复连接数据库，减少IO开销）然后创建多线程+队列的方式获取数据，以单线程形式来插入数据，批量处理数据后，才commit提交。案例如下： 123456789101112131415161718192021222324252627282930313233343536373839from SqlConnectManage import sqlserverManager# 创建全局连接和游标(这里暂时不用DBUtils库)DB_CONN = pymssql.connect(SERVER , USER , PASSWORD, DATABASE)DB_CURSOR = DB_CONN.cursor()# ...# ...# ... if __name__ == \"__main__\": # 开始时间戳 s_time = time.time() # 设定最大队列数和线程数 q = Queue(maxsize=10) threads = [] starttime, endtime = get_date() # print(starttime,endtime) # 经测试，获取查询时间段成功 # 获取所有用户组列表 userid_all_list = get_user_list() # print(userid_all_list) # 经测试，获取所有用户组成功 # 循环每一个用户组列表并开启多线程采集企业微信考勤数据 while userid_all_list: user_list = userid_all_list.pop() t = Thread(target=gatherData, args=(starttime, endtime, user_list, )) q.put(t) if (q.full() == True or len(userid_all_list) == 0): while q.empty() == False: t = get() threads.append(t) t.start() for t in threads: t.join() # 单线程插入数据 insert_sql() 4.DBUtils管理数据库连接池当使用多线程，多进程将海量数据存入数据库时，每次执行一个sql的时候都单独建立一个mysql连接，执行完就close掉，很明显这样的问题在于，频繁连接，断开mysql，这样是相当消耗系统资源的，而且增加了mysql连接失败的几率，所以万一哪个线程没有连接成功 这个线程也over了。 4.1 连接池原理1.在程序创建连接的时候，可以从一个空闲的连接中获取，不需要重新初始化连接，提升获取连接的速度2.关闭连接的时候，把连接放回连接池，而不是真正的关闭，所以可以减少频繁地打开和关闭连接 安装DBUtils库 pip install DBUtils 参数解释 参数 详解 creator, # 使用链接数据库的模块(必须：pymssql，pymysql，cx_oralce,…) mincached=0, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=0, # 链接池中最多闲置的链接，0和None不限制 maxshared=0, # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用 maxconnections=0, # 连接池允许的最大连接数，0和None表示不限制连接数 blocking=False, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=None, # 开始会话前执行的命令列表。如：[“set datestyle to …”, “set time zone …”] reset=True, failures=None, ping=1, # ping MySQL服务端，检查是否服务可用 数据库设置(数据库连接模块不一样，其参数名也不同) 如creator=pymysql：host=&#39;localhost&#39;, port=3306,db=&#39;mydata&#39;,user=&quot;root&quot;,passwd=&quot;123456&quot;,charset=&#39;utf8&#39; 数据库通用连接函数（连接模块视实际数据库决定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 4.2 多线程/连接池操作MySQL插入每调用一次插入函数就从连接池中取出一个链接操作,完成后关闭链接;executemany批量操作,减少 commit 次数,提升效率; 参考文章 python连接各类数据库教程 Python连接Oracle数据库，以字典形式返回结果 python操作mysql数据-执行语句返回值直接返回字典类型 Python3 多线程(连接池)操作MySQL插入数据","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"通用连接","slug":"通用连接","permalink":"https://ahrilove.top/tags/%E9%80%9A%E7%94%A8%E8%BF%9E%E6%8E%A5/"}]},{"title":"Python全栈系列章节更新（二）：常见库模块","slug":"Python全栈系列章节更新（二）","date":"2019-11-28T16:00:00.000Z","updated":"2021-09-17T01:17:06.000Z","comments":true,"path":"2019/11/29/Python全栈系列章节更新（二）/","link":"","permalink":"https://ahrilove.top/2019/11/29/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.datetime模块3.ftplib模块4.os模块5.tqdm模块6.PrettyTable模块7.random模块8.execjs模块9.js2py模块10.string模块11.Logger模块12.文件存储","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.datetime模块3.ftplib模块4.os模块5.tqdm模块6.PrettyTable模块7.random模块8.execjs模块9.js2py模块10.string模块11.Logger模块12.文件存储 1.time模块time 模块是一个大的类，里面包含诸多重要的函数，这里列举几个说明，详细请参看官方文档 获取当前时间戳 12345678import time# 获取当前时间戳（秒级，浮点型）time.time()int(time.time())# 获取当前时间戳（毫秒级，十三位）int(round(time.time() * 1000)) 休眠 time.sleep(seconds) 时间戳转换为时间元组格式 time.localtime(seconds=None)，seconds为空时，默认为当前时间戳，最终会转换成这样时间元组 12345678910111213time.localtime(1460073600.66)# 执行结果time.struct_time(tm_year=2016, tm_mon=4, tm_mday=8, tm_hour=8, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=99, tm_isdst=0)属性 值tm_year（年） 比如2011 tm_mon（月） 1 - 12tm_mday（日） 1 - 31tm_hour（时） 0 - 23tm_min（分） 0 - 59tm_sec（秒） 0 - 59tm_wday（weekday） 0 - 6（0表示周日）tm_yday（一年中的第几天） 1 - 366tm_isdst（是否是夏令时） 默认为-1 获取自定义的时间格式 格式参数： 12345678910111213141516Commonly used format codes:%Y Year with century as a decimal number.%m Month as a decimal number [01,12].%d Day of the month as a decimal number [01,31].%H Hour (24-hour clock) as a decimal number [00,23].%M Minute as a decimal number [00,59].%S Second as a decimal number [00,61].%z Time zone offset from UTC.%a Locale&apos;s abbreviated weekday name.%A Locale&apos;s full weekday name.%b Locale&apos;s abbreviated month name.%B Locale&apos;s full month name.%c Locale&apos;s appropriate date and time representation.%I Hour (12-hour clock) as a decimal number [01,12].%p Locale&apos;s equivalent of either AM or PM. 语法 time.strftime(format, p_tuple=None) format：表示时间格式参数p_tuple：表示时间元组，为空则默认为当前时间 使用 123456789import time# 获取当前自定义时间格式print(time.strftime(\"%Y-%m-%d %H:%M:%S\")) # 2021-08-25 14:24:48# 时间戳转换为自定义时间格式value = time.localtime(1460073600.0)dt = time.strftime(\"%Y-%m-%d %H:%M:%S\", value)print(dt) # 2016-04-08 08:00:00 自定义时间格式转换为时间戳 123456import time# 必须要一一对应newTime = time.strptime(\"2021-08-25 23:59:59\", '%Y-%m-%d %H:%M:%S')s = time.mktime(newTime)print(s) # 1629907199.0 2.datetime模块 datetime.date：表示日期的类 datetime.datetime：表示日期时间的类 datetime.time：表示时间的类 datetime.timedelta：表示时间间隔，即两个时间点的间隔 datetime.tzinfo：时区的相关信息 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt;datetime.datetime.now()当前系统时间：datetime.datetime(2019, 12, 3, 20, 31, 10, 740869)&gt;&gt;&gt;datetime.datetime.now().year/month/day分别为：2019，12，3&gt;&gt;&gt;datetime.datetime.now().weekday()1 表示在第几周&gt;&gt;&gt;time1 = datetime.datetime(2016, 10, 20)&gt;&gt;&gt;time2 = datetime.datetime(2015, 11, 2) &quot;&quot;&quot;计算天数差值&quot;&quot;&quot;print(time1-time2).days &quot;&quot;&quot;计算两个日期之间相隔的秒数&quot;&quot;&quot;print (time1-time2).total_seconds()# 获取当前时间,并转化为字符串型&gt;&gt;&gt;time_new = str(datetime.datetime.now().date()) # &apos;2019-12-4&apos;# 以当天的09：00为开始时间（时间戳格式）&gt;&gt;&gt;time_on = time.mktime(time.strptime(time_new+ &apos; 09:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))# 以当天的18：00为结束时间（时间戳格式）&gt;&gt;&gt;time_off = time.mktime(time.strptime(time_new+ &apos; 18:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))# 当前星期几&gt;&gt;&gt;week_now = datetime.datetime.now().weekday()# 当前时间&gt;&gt;&gt;time_now = datetime.datetime.now() # datetime.datetime(2019, 12, 4, 14, 57, 48, 988520)# 当前第几小时（24小时制）&gt;&gt;&gt;hour_now = datetime.datetime.now().hour # 14 时间转换 datetime转str格式： 12&gt;&gt;&gt; datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&apos;2018-06-18 16:58:46&apos; str格式转datetime格式 1234&gt;&gt;&gt; print datetime.datetime.strptime(&quot;2018-06-18 16:58:46&quot;,&quot;%Y-%m-%d %H:%M:%S&quot;)2018-06-18 16:58:46&gt;&gt;&gt; print type(datetime.datetime.strptime(&quot;2018-06-18 16:58:46&quot;,&quot;%Y-%m-%d %H:%M:%S&quot;))&lt;type &apos;datetime.datetime&apos;&gt; 3.ftplib库ftplib模块是系统默认安装的，实现文件的上传与下载 1234567891011121314151617181920212223242526from ftplib import FTP #加载ftp模块ftp=FTP() #设置变量ftp.set_debuglevel(2) #打开调试级别2，显示详细信息ftp.connect(\"IP\",\"port\") #连接的ftp sever和端口ftp.login(\"user\",\"password\") #连接的用户名，密码print(ftp.getwelcome()) #打印出欢迎信息bufsize=1024 #设置的缓冲区大小filename=\"filename.txt\" #需要下载的文件file_handle=open(filename,\"wb\").write #以写模式在本地打开文件ftp.retrbinaly(\"RETR filename.txt\",file_handle,bufsize) #接收服务器上文件并写入本地文件ftp.set_debuglevel(0) #关闭调试模式ftp.quit() #退出ftp # ftp相关命令操作ftp.cwd(pathname) #设置FTP当前操作的路径ftp.dir() #显示目录下所有目录信息ftp.nlst() #获取目录下的文件ftp.mkd(pathname) #新建远程目录ftp.pwd() #返回当前所在位置ftp.rmd(dirname) #删除远程目录ftp.delete(filename) #删除远程文件ftp.rename(fromname, toname)#将fromname修改名称为toname。ftp.storbinary(\"STOR filename.txt\",file_content,bufsize) #上传目标文件ftp.retrbinary(\"RETR filename.txt\",file_content,bufsize) #下载FTP文件 4.os模块记下常用的os模块的操作指令 命令 含义 os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径,相当于shell的pwd os.chdir(“dirname”) 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: (‘.’) os.pardir 获取当前目录的父目录字符串名：(‘..’) os.makedirs(‘dirname1/dirname2’) 可生成多层递归目录 os.removedirs(‘dirname1’) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(‘dirname’) 生成单级目录；相当于shell中mkdir dirname os.rmdir(‘dirname’) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(‘dirname’) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove(path) 删除path指定的文件 os.rename(“oldname”,”newname”) 重命名文件/目录 os.stat(‘path/filename’) 获取文件/目录信息 os.name 输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’ os.system(“执行的命令”) 运行shell命令，直接显示,相当于直接在cmd命令中执行，Windows的cmd命令大全 os.environ 获取系统环境变量 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path/file) 如果路径或文件存在，返回True；如果path不存在，返回False os.path.getsize(file) 返回文件大小，如果文件不存在就返回错误 os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.join(path1,path2,…,pathN) 将多个路径组合后返回 简要样例说明： 123456789101112131415161718192021222324252627&gt;&gt;&gt; os.path.split(&quot;/Users/hqs/PycharmProjects/startMyPython3.0&quot;) (&apos;/Users/hqs/PycharmProjects&apos;, &apos;startMyPython3.0&apos;)&gt;&gt;&gt; os.path.dirname(&apos;/Users/hqs/PycharmProjects/startMyPython3.0&apos;)&apos;/Users/hqs/PycharmProjects&apos;&gt;&gt;&gt;os.system(&quot;ping 127.0.0.1&quot;)正在 Ping 127.0.0.1 具有 32 字节的数据:来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64127.0.0.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms &gt;&gt;&gt;os.path.abspath(__file__) 当前文件的绝对路径&gt;&gt;&gt;os.path.dirname(os.path.abspath(__file__))当前文件的上一层目录的绝对路径os.path.dirname(os.path.dirname(os.path.abspath(__file__)))当前文件的上上层目录的绝对路径 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(_ _file_ _))) 1234567891011__file__：表示当前文件名称os.path.abspath(__file__)：表示运行当前文件的完整绝对路径os.path.dirname：表示文件的上一级目录eg：目录结构：app| | ---core.py |---settings.json | ---mangage.py 运行core.py文件十，调用settings.py文件为: BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # 获取了app目录的相对目录 dir =os.path.join(BASE.DIR,&apos;settings.py&apos;) # app目录拼接就为settings.py文件目录：app/settings.py python路径拼接os.path.join()函数的用法 1234567891011121314151617181920212223os.path.join()函数：连接两个或更多的路径名组件 1.如果各组件名首字母不包含’/’，则函数会自动加上 2.如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃 3.如果最后一个组件为空，则生成的路径以一个’/’分隔符结尾import osPath1 = &apos;home&apos;Path2 = &apos;develop&apos;Path3 = &apos;code&apos;Path10 = Path1 + Path2 + Path3Path20 = os.path.join(Path1,Path2,Path3)print (&apos;Path10 = &apos;,Path10)print (&apos;Path20 = &apos;,Path20)输出Path10 = homedevelopcodePath20 = home\\develop\\code python遍历指定目录下的所有文件和目录 python遍历目录下的所有文件和目录详细介绍 glob模块 :用通配符来获取文件或目录 举例说明： 123456789for fname in glob.glob(&quot;**/*.py&quot;,recursive=True): print(fname)for fname in glob.glob(&quot;./file?.py&quot;): print(fname)# 删除指定目录下的文件for pic in glob.glob(&quot;static/images/workflow/*.png&quot;): os.remove(pic) 5.tqdm模块from tqdm import tqdm使用方法： 123456from tqdm import tqdmimport timeif __name__ == '__main__': for i in tqdm(range(1000)): time.sleep(0.5) 拓：如何解决tqdm一直向下滚动的问题？当我们使用控制台输出时，使用tqdm有可能会一直向下滚动，原因是进度条太长了，只能换行显示，此我们规定一下滚动条的长度for i in tqdm(range(1000), ncols = 80) :ncols规定长度为80 6.PrettyTable模块PrettyTable是python中的一个第三方库，可用来生成美观的ASCII格式的表格 安装方式 script1pip install prettytable 基本使用 如果你想要您的表格格式优美，请铭记【表头字段名称的长度一定要大于表行内容长度】 1234567891011121314151617181920212223from prettytable import PrettyTable# 创建表格对象tb = PrettyTable()# 设置表头tb.field_names = [\"field1\", \"fieldN\"]# 按行添加数据tb.add_row([\"colume1\", \"columeN\"])# 按列添加数据tb.add_column(\"row1\", \"rowN\")# 展示ASCII格式表格数据print(tb)\"\"\"+-----------+------+------------+-----------------+| City name | Area | Population | Annual Rainfall |+-----------+------+------------+-----------------+| Adelaide | 1295 | 1158259 | 600.5 || Brisbane | 5905 | 1857594 | 1146.4 || Darwin | 112 | 120900 | 1714.7 || Hobart | 1357 | 205556 | 619.5 |+-----------+------+------------+-----------------+\"\"\" 7.random模块 函数 说明 randint(a, b) 生成一个[a, b]之间的整数 randrange(m, n[, k]) 生成一个[m, n)之间以k为步长的随机整数 getrandbits(k) 生成一个k比特长的随机整数 uniform(a, b) 生成一个[a, b]之间的随机小数 choice(seq) 从序列seq中随机选择一个元素 choices(seq,k = n) 从序列seq中随机选择n个元素 shuffle(seq) 将序列seq中元素随机排列，返回打乱后的序列(类似于洗牌) random() 生成一个[0.0, 1.0)之间的随机小数 1234567891011121314151617import randomrandom.random()0.5random.randint(10, 100)64random.randrange(10, 100, 10)80random.getrandbits(16)37885random.uniform(10, 100)13.096321648808136random.choice([1,2,3,4,5,6,7,8,9])8s=[1,2,3,4,5,6,7,8,9];random.shuffle(s);print(s) # [3, 5, 8, 9, 6, 1, 2, 7, 4] 8.execjs模块针对现在大部分的网站都是使用js加密，js加载的，并不能直接抓取出来，这时候就不得不适用一些三方类库来执行js语句。执行JS的类库：execjs，PyV8，selenium，node安装： pip install PyExecJS js运行时环境：没有js环境会报错（Could not find an available JavaScript runtime），常见的js运行环境有PyV8，Node.js,PhantomJS 执行js脚本： 12345678910111213import execjs# compile 编译执行复杂的js源代码x = execjs.compile(''' // static 源代码 function get_time()&#123; let d = new Date(); return d.getTime() &#125;''')# 执行目标函数x.call(\"get_time\") # 1587110199832# 直接执行print(execjs.eval(' \"a、b、c、d、e\".split(\"、\") ')) 执行步骤： execjs执行函数 compile(js源代码)先编译js源代码 call(目标函数，实参) 开始执行目标函数，并传参 execjs执行变量 execjs.eval(js源代码) 9. js2py模块 基本使用 用途：js2py模块可用于处理 js的eval加密 12345678910import js2pyjs_eval = \"\"\"eval(function(p,a,c,k,e,r)&#123;e=String;if('0'.replace(0,e)==0)&#123;while(c--)r[e(c)]=k[c];k=[function(e)&#123;return r[e]||e&#125;];e=function()&#123;return'[02-4]'&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p&#125;('var newImgs=[\"0://p.2.3/4/1388c000067768f7a5d44\",\"0://p.2.3/4/138230001d1016dce93b9\",\"0://p.2.3/4/138720000b6221ac47f3c\",\"0://p.2.3/4/138420004939fe476ea69\"]',[],5,'https||pstatp|com|origin'.split('|'),0,&#123;&#125;))\"\"\"images = js2py.eval_js(js_eval) 注意：js2py的返回值是 JSobjectWrapper类型，并不是我们通常认知的Dict类型，那么如何转换成我们熟知的Dict字典类型呢？ js2py.eval_js(new_js_code).to_dict() 利用to_dict方法得到就是一个字典了。 参考： 使用js2py.eval_js()获得中的某一个变量的值，并转换为python中的字典 10.string模块 string.digits: 数字字符串集 string.ascii_letters: 字母字符串集 string.ascii_lowercase: 小写字母字符串集 string.ascii_uppercase: 大写字母字符串集 string.ascii_punctuation: 特殊字符集（!”#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~） 11. Logger模块新建一个logger.py文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding:utf-8 -*-import loggingfrom logging import handlers\"\"\"@IDE ：PyCharm@Author ：Miss.985@Date ：2021/8/12 16：30@Desc ：封装logging日志模块\"\"\"class Logger(object): def __init__(self, filename, level='info', when='S', backCount=3, fmt='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s'): \"\"\" 构造封装logging类 :param filename: 日志文件名 :param level: 日志级别 :param when: 时间间隔 :param backCount: 备份文件数 :param fmt: 日志记录格式 \"\"\" self.filename = filename self.level = level self.when = when self.backCount = backCount self.fmt = fmt self.level_relations = &#123; 'info': logging.INFO, 'error': logging.ERROR, 'debug': logging.DEBUG, 'warning': logging.WARNING, 'critical': logging.CRITICAL &#125; def mark(self): logger = logging.getLogger(self.filename) # 设置日志格式 format_str = logging.Formatter(self.fmt) # 设置日志级别 logger.setLevel(self.level_relations.get(self.level)) # 往屏幕上输出 sh = logging.StreamHandler() # 设置屏幕上显示的格式 sh.setFormatter(format_str) # 往文件里写入，指定间隔时间自动备份文件的处理器 \"\"\" 1. interval是时间间隔 2. backupCount是备份文件的个数（如果超过备份数，就会自动删除） 3. when是间隔的时间单位 - S 秒 - M 分 - H 小时 - D 天 - W&#123;0-6&#125; 每周N(e.g.,:W0-每周一，W6-每周日) - midnight 每天凌晨 \"\"\" th = handlers.TimedRotatingFileHandler(filename=self.filename, when=self.when, backupCount=self.backCount, encoding='utf-8') # 设置文件里写入的格式 th.setFormatter(format_str) # 把对象加到logger里 logger.addHandler(sh) logger.addHandler(th) return logger 那我们如何调用这个logger.py文件呢？ 12345678910# -*- coding:utf-8 -*-from logger import Logger# 对象实例化，设置日志登记log = Logger(\"./note.log\", level='debug', when=\"D\")# 开启日志记录ak = log.mark()# 日志写入for i in range(1, 11): ak.info(\"▉\" * i) 12. 文件存储CSV文件存储CSV文件以纯文本形式存储表格数据，它比Excel更加简洁，XLS文本是电子表格，它包含了文本、数值、公式和格式等内容，而CSV中不包含这些内容，就是特定字符分隔的纯文本。 Tips： Python3使用csv模块csv.writer().writerow(),保存csv文件，产生空行的问题 解决方案：在open()内增加一个参数newline=”” 即可，更改后代码结构如下 DictWriter结构化字典写入时，表头和每一行的键名必须要一一对应，每行的键名可少不可多 单行写入：writerow 123456import csvwith open(\"./data.csv\", 'a+', encoding=\"utf-8\", newline=\"\") as csvfile: writer = csv.writer(csvfile, delimiter=\" \") # 初始化写入对象，delimiter表示分隔符，默认为逗号 writer.writerow([\"id\", \"name\", \"age\"]) writer.writerow([\"9527\", \"chd\", \"18\"]) # 调用一次writerow，即可写入一行 多行写入：writerows writerows的传入参数格式为数组，但此数组中可以包含子数组（每一个子数组表示为一行） 123456import csvwith open(\"./data.csv\", 'a+', encoding=\"utf-8\", newline=\"\") as csvfile: writer = csv.writer(csvfile, delimiter=\" \") writer.writerow([\"id\", \"name\", \"age\"]) writer.writerows([[\"9527\", \"chd\", \"18\"],[\"4396\", \"lmm\", \"16\"], [\"0001\", \"sxc\", \"20\"]]) 以结构化数据（字典）写入: DictWriter 一般情况下，爬取的数据都是结构化的数据，在csv中仍支持字典的写入方式 1234567891011import csvwith open(\"./data.csv\", 'a+', encoding=\"utf-8\", newline=\"\") as csvfile: field_names = [\"id\", \"name\", \"age\"] writer = csv.DictWriter(csvfile, fieldnames = field_names) writer.writeheader() # 单行字典写入（键名与表头相比：可少不可多） writer.writerow(&#123;\"id\":\"chd\", \"age\": 18&#125;) # 多行字典写入 writer.writerows([&#123;\"id\": \"chd\", \"name\": \"lmm\"&#125;, &#123;\"age\": 18, \"id\": \"love\", \"name\": \"badwoman\"&#125;]) CSV读取 1234567891011import csvwith open(\"./data.csv\", 'r', encoding=\"utf-8\") as csvfile: reader = csv.writer(csvfile) for row in reader: print(row)\"\"\"Result:[\"id\", \"name\", \"age\"][\"9527\", \"chd\", \"18\"]\"\"\" Excel 两大库xlrd，xlwt 1).Python操作excel主要用到xlrd和xlwt这两个库 即xlrd是读excel，xlwt是写excel的库,,xl是excel的缩写,rd是read,wt是writexlrd可以解析微软的.xls and .xlsx两种各种的电子表格 2).如何安装 用pip install xlrd就可以安装xlrd模块 用pip install xlwt就可以安装xlwt模块 3).基本使用 123456789101112131415161718192021222324252627282930313233343536#-*-coding:utf-8-*-import xlrd # 定义读取并打印表格中数据的函数def read_excel(): # 打开excel文件读取数据 data = xlrd.open_workbook(\"1.xlsx\") # 获取book中所有工作表的名称 print(data.sheet_names()) # ['Sheet1'] # 根据工作表的名称获取工作表的内容 table = data.sheet_by_index(0) # 打印工作表的名称、行数和列数 print(table.name, table.nrows, table.ncols) # Sheet1 17 4 # 获取第4行的内容，以列表形式表示 row_4 = table.row_values(3) print(row_4) # [5.0, 6.0, 7.0, 8.0] # 获取第3列的内容，以列表形式表示 col_3 = table.col_values(2) print(col_3) # [3.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0, 7.0, '', ''] # 获取工作表中单元格的3种方法 print(table.cell(1, 0).value) # 5.0 print(table.cell_value(1, 0)) # 5.0 print(table.row(1)[0].value) # 5.0 openpyxl处理xlsx文件 我们目前以openpyxl为例，可以浏览参考文章python处理Excel文件的方法集合及性能对比 Excel文件三个对象 workbook： 工作簿，一个excel文件包含多个sheet。 sheet：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。 cell： 单元格，存储数据对象 1234567891011121314import openpyxl save_dir=\"D:\\\\python3_anaconda3\\\\学习\\\\test\\\\excel文件处理\\\\\"open_filename=\"openpyxl_test.xlsx\" out_workbook=openpyxl.Workbook()out_sheet=out_workbook.create_sheet(index=0,title=\"openpyxl_new\") # 注意，openpyxl中为了和Excel中的表达方式一致，并不和编程语言的习惯一样以0表示第一个值，在openpyxl中以1表示第一个值。for i in range(1,100): out_sheet.cell(row=i ,column=1).value=i # openpyxlout_workbook.save(open_filename) 参考文章 datetime模块 python处理Excel文件的方法集合及性能对比","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"常见库","slug":"常见库","permalink":"https://ahrilove.top/tags/%E5%B8%B8%E8%A7%81%E5%BA%93/"}]},{"title":"技术小白教你如何定位照片拍摄位置","slug":"照片的GPS信息定位","date":"2019-11-27T16:00:00.000Z","updated":"2019-12-05T09:04:12.000Z","comments":true,"path":"2019/11/28/照片的GPS信息定位/","link":"","permalink":"https://ahrilove.top/2019/11/28/%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动）","text":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动） 1.获取GPS信息&nbsp;&nbsp;&nbsp;&nbsp;将照片复制至电脑。点击照片，右键--“右键菜单”--“属性”--“详细信息”，下拉至“GPS”，将会看到经纬度信息。如下图所示： 2.经纬度计算方法&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到经纬度信息，是以度分秒的格式展示的（度分秒之间以“；”间隔），为了方便定位，我们需要将度分秒转换为度的格式。计算方法：经纬度同理（本例为32；49；49.942932000005413）经度：度+（分+秒/60）/60，即32+(49+49.9429/60)/60=32.8305; 3.测试在奥维地图上将计算后的经纬度（以英文格式书写）代入其中，就可以获得地理位置信息。","categories":[],"tags":[{"name":"定位照片拍摄位置","slug":"定位照片拍摄位置","permalink":"https://ahrilove.top/tags/%E5%AE%9A%E4%BD%8D%E7%85%A7%E7%89%87%E6%8B%8D%E6%91%84%E4%BD%8D%E7%BD%AE/"}]},{"title":"Nginx（二）：Nginx的命令和配置文件","slug":"Nginx(二)","date":"2019-11-26T16:00:00.000Z","updated":"2020-11-23T08:51:18.000Z","comments":true,"path":"2019/11/27/Nginx(二)/","link":"","permalink":"https://ahrilove.top/2019/11/27/Nginx(%E4%BA%8C)/","excerpt":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1","text":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1 1.理清概念docker创建Nginx容器很简单：共享数据卷，外部访问端口映射window下运行nginx，只需简单式一直点击“NEXT”安装，然后添加到环境变量即可在Linux下启动nginx相对比较麻烦，如果你采用其它两种方式，可以跳过本节，本节主要是介绍Linux下的运行命令无论哪种方式启动Nginx，其核心的配置文件以及接下来的几个配置实例都是通用的 2.Linux下Nginx的常用命令先关闭防火墙或者是开放目标端口 查看nginx是否启动 ps -ef | grep nginx 进入nginx目录中 cd /usr/local/nginx/sbin (前面路径有可能不同，主要是nginx内的nginx/sbin路径),当配置环境变量后，无需再输入./ 1、查看nginx版本号 ./nginx -v 2、启动nginx ./nginx 3、停止nginx ./nginx -s stop 4、重新加载nginx ./nginx -s reload 5、检查nginx.conf配置文件 ./nginx -t 3.ginx的基本配置文件nginx.conf3.1、nginx 配置文件位置cd /usr/local/nginx/conf/nginx.conf 3.2、配置文件中的内容 包含三部分内容（1）全局块：配置服务器整体运行的配置指令 比如 worker_processes 1;处理并发数的配置 （2）events 块：影响 Nginx 服务器与用户的网络连接 比如 worker_connections 1024; 支持的最大连接数为 1024 （3）http 块 还包含两部分： http 全局块 server 块 3.3 默认的nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; 404.md # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 4.Nginx 配置实例-反向代理实例 14.1、实现效果（1）打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到 liunx 系统 tomcat 主页 面中 4.2、准备工作（1）在 liunx 系统安装 tomcat，使用默认端口 8080 * tomcat 安装文件放到 liunx 系统中，解压 * 进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器 （2）对外开放访问的端口firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload （3）查看已经开放的端口号firewall-cmd –list-all （4）在 windows 系统中通过浏览器访问 tomcat 服务器(linux_IP + tomcat_Port) 4.3、访问过程分析 映射IP 假设域名www.123.com映射的IP为Linux上的nginx的ip地址（比如我的是192.168.17.129:80）,nginx也相当于一个分发器，将请求发送至tomcat服务器 123访问过程分析windows端 ----------&gt;Nginx（linux_IP：80）------&gt;tomcat(127.0.0.1:8080)（假设访问www.123.com） 在 nginx 进行请求转发的配置（反向代理配置） 123456789server&#123; listen 80; # 监听端口 server_name www.123.com; # 配置域名 location /&#123; proxy_pass http://127.0.0.1:8080; # 跳转到127.0.0.1：8080路径 index index.html index.htm index.jsp; &#125;&#125; 如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 www.123.com后，成功后直接跳转到tomcat主页 4.4 nginx开启ssl当我们进行反向代理时，遇到https请求会报错，原因是我们安装nginx时，没有配置ssl模块 1nginx: [emerg] the &quot;ssl&quot; parameter requires ngx_http_ssl_module in /usr/local/nginx/conf/nginx.conf: 解决方案参考 ：nginx安装ssl，使用前提是：nginx的配置文件正确，没有报错，nginx -t 检查配置文件","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ahrilove.top/tags/nginx/"}]},{"title":"Nginx（一）：基本概念","slug":"Nginx(一)","date":"2019-11-24T16:00:00.000Z","updated":"2020-04-08T08:41:10.000Z","comments":true,"path":"2019/11/25/Nginx(一)/","link":"","permalink":"https://ahrilove.top/2019/11/25/Nginx(%E4%B8%80)/","excerpt":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程","text":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程 1.正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。如图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结来说：正向代理，”它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正向代理的用途：（1）访问原来无法访问的资源，如Google（2） 可以做缓存，加速访问资源（3）对客户端访问授权，上网进行认证（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 2.反向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：http://tengine.taobao.org/。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理的作用：（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网（2）负载均衡，通过反向代理服务器来优化网站的负载 3.项目场景以及两者区别通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向代理服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：两者区别：图解： 在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息； 在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息； 实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了 4.负载均衡我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？ 这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。 请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。 所以，将服务器接收到的请求按照规则分发的过程，称为负载均衡。 负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。Nginx支持的负载均衡调度算法方式如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。 5.动静分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 6.nginx安装windows下安装与部署NginxLinux下安装与部署Nginx以后都推荐再docker下安装各式各样的环境Ubuntu+docker下安装与部署Nginx","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ahrilove.top/tags/nginx/"},{"name":"apache","slug":"apache","permalink":"https://ahrilove.top/tags/apache/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://ahrilove.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"Javascript篇章四：浏览器对象模型BOM","slug":"Javascript篇章四","date":"2019-11-22T16:00:00.000Z","updated":"2021-09-11T01:14:48.000Z","comments":true,"path":"2019/11/23/Javascript篇章四/","link":"","permalink":"https://ahrilove.top/2019/11/23/Javascript%E7%AF%87%E7%AB%A0%E5%9B%9B/","excerpt":"1.window2.navigator3.screen4.location5.history6.弹出框7.Timing事件8.cookie与storage","text":"1.window2.navigator3.screen4.location5.history6.弹出框7.Timing事件8.cookie与storage 浏览器对象包括window、navigator、screen、location、history 1.window所有浏览器都支持window对象，它代表浏览器的窗口。 所有全局 JavaScript 对象，函数和变量自动成为 window 对象的成员。 全局变量是window对象的属性，全局函数是window对象的方法，甚至（HTML DOM的）document对象也是 window 对象属性 123window.document.getElementById(&quot;header&quot;);等同于：document.getElementById(&quot;header&quot;); 常用事件：window.onresize()监听浏览器窗口高宽变化，注意要使用箭头函数 1234// window.onresize()官方定义window.onresize=function()&#123; console.log(\"浏览器窗口改变了!\");&#125;; 2.navigatorwindow.navigator对象表示浏览器信息，可以不带window前缀 navigator.appName：浏览器名称navigator.appVersion：浏览器版本navigator.language：浏览器设置的语言navigator.platform：操作系统类型navigator.userAgent：浏览器设定的User-Agent字符串navigator.webdriver:返回浏览器是否被WebDriver驱动的布尔值（即判断是否是selenium控制爬虫程序） 3.screenwindow.screen表示屏幕信息，可以不带window前缀 screen.width：屏幕宽度，以像素为单位screen.height：屏幕高度，以像素为单位screen.colorDepth：返回颜色位数，如8、16、24 拓：获取可视区域高度 12345678910111213141516171819202122232425262728293031323334document.body.clientWidth ==&gt; BODY对象宽度document.body.clientHeight ==&gt; BODY对象高度document.documentElement.clientWidth ==&gt; 可见区域宽度document.documentElement.clientHeight ==&gt; 可见区域高度document.documentElement.scrollTop ==&gt; 滚动条垂直方向滚动距离网页可见区域宽： document.body.clientWidth网页可见区域高： document.body.clientHeight网页可见区域宽： document.body.offsetWidth (包括边线的宽)网页可见区域高： document.body.offsetHeight (包括边线的高)网页正文全文宽： document.body.scrollWidth网页正文全文高： document.body.scrollHeight网页被卷去的高： document.body.scrollTop网页被卷去的左： document.body.scrollLeft网页正文部分上： window.screenTop网页正文部分左： window.screenLeft屏幕分辨率的高： window.screen.height屏幕分辨率的宽： window.screen.width屏幕可用工作区高度： window.screen.availHeight屏幕可用工作区宽度： window.screen.availWidthHTML精确定位:scrollHeight: 获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置event.clientX 相对文档的水平座标event.clientY 相对文档的垂直座标event.offsetX 相对容器的水平坐标event.offsetY 相对容器的垂直坐标event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量 4.locationwindow.location对象表示当前页面的URL信息（即地址栏），可不带window前缀书写 location.protocol; // ‘http’location.host; // ‘www.example.com&#39;location.port; // ‘8080’location.pathname; // ‘/path/index.html’location.search; // ‘?a=1&amp;b=2’（查询字符串，携带参数向浏览器发送数据，必须带有‘？’）location.hash; // ‘TOP’（锚点，url中的‘#’后面的数据）location.href 获取完整urlwindow.location.href=&quot;新的跳转url”：跳转到指定的页面location.assign(url)：加载一个新页面，在当前窗口跳转带这个urllocation.replace(url)：原页面替换成新页面，在当前窗口替换带这个url，但不会产生历史记录，即无法后退location.reload()：刷新当前窗口 5.historywindow.history对象包含浏览器历史，可以不带window前缀，为了保护用户的隐私，JavaScript访问此对象存在限制。 常用方法： history.back() - 等同于在浏览器点击后退按钮 history.forward() - 等同于在浏览器中点击前进按钮 6.弹出框JavaScript有三种类型的弹出框：警告框，确认框和提示框 警告框如果要确保信息传递给用户，通常会使用警告框。当警告框弹出时，用户将需要单击“确定”来继续window.alert(“some text”); 可以不带window前缀 确认框如果您希望用户验证或接受某个东西，则通常使用“确认”框。当确认框弹出时，用户将不得不单击“确定”或“取消”来继续进行。如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。 123456let r = confirm(\"请按按钮\");if (r === true) &#123; x = \"您按了确认！\";&#125; else &#123; x = \"您按了取消！\";&#125; 提示框如果您希望用户在进入页面前输入值，通常会使用提示框。当提示框弹出时，用户将不得不输入值后单击“确定”或点击“取消”来继续进行。如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL window.prompt(“some text”,”defaultText”); 可以不带window前缀 7.Timing事件setTimeout(function,milliseconds):等待指定的毫秒数后执行函数setInterval(function,milliseconds):等同于setTimeout()，但在每个给定的时间间隔内重复执行该函数 123456function myTimer() &#123; let d = new Date(); console.log(d.getFullYear())&#125;// setInterval在每隔3秒就打印一次当前的月份setInterval(myTimer, 3000); clearTimeout(变量名)方法停止执行setTimeout()中规定的函数 123&lt;!--使用setTimeout等待执行函数，clearTimeout停止执行函数---&gt;&lt;button onclick=\"myVar = setTimeout(myFunction, 3000)\"&gt;试一试&lt;/button&gt;&lt;button onclick=\"clearTimeout(myVar)\"&gt;停止执行&lt;/button&gt; 8.cookie与storage cookie cookie的基础知识 cookie是有大小限制的，每个cookie所存放的数据不能超过4kb，如果cookie字符串的长度超过4kb，则该属性将返回空字符串 每个cookie的格式都是这样的：&lt;cookie名&gt;=&lt;值&gt;; 名称和值都必须是合法的标示符 cookie是存在有效期的：在默认情况下，一个cookie的生命周期就是在浏览器关闭的时候结束。如果想要cookie能在浏览器关掉之后还可以使用，就必须要为该cookie设置有效期，也就是cookie的失效日期 cookie的数据类型为String 设置cookie 存储单个cookie值设置 12345// 设置单个键值对（推荐）document.cookie=\"username=chd\";// 设置多个键值对，使用分号加空格（; ） 隔开，经测试，只有第一对键值生效（废弃）document.cookie=\"userId=828; userName=hulk\"; 删除cookie 为了删除一个cookie，可以将其过期时间设定为一个过去的时间 1234567891011121314// 法一//获取当前时间let date=new Date();//将date设置为过去的时间date.setTime(date.getTime()-1);//将userId这个cookie删除document.cookie=\"userId=828; expire=\"+date.toGMTString();// 法二（更简练）let data = new Date(new Date().getTime() - 24*60*60*1000).toUTCString();/*new Date().getTime() 表示获取当前时间戳【毫秒级】toUTCString() 表示根据世界时 (UTC)把Date对象转换为字符串，并返回结果*/ 设置cookie的有效时间 cookie 的生命周期也就是有效期和失效期，即 cookie 的存在时间。在默认的情况下，cookie 会在浏览器关闭的时候自动清除，但是我们可以通过expires来设置 cookie 的有效期 date值为GMT(格林威治时间)格式的日期型字符串,我们这个函数是按照天数来设置cookie的有效时间，如果想以其他单位（如：小时）来设置，那么改变第三行代码即可 12345let _date = new Date();// _date.setDate(_date.getDate()+30);_date.setDate(_date.getHours()+2);_date.toGMTString();document.cookie = \"name=value;expires=\"+_date; 在vue或js中直接操作cookie 1234567891011121314151617let a = &#123; set: function (name, value, days) &#123; var d = new Date; d.setTime(d.getTime() + 24*60*60*1000*days); window.document.cookie = name + \"=\" + value + \";path=/;expires=\" + d.toGMTString(); &#125;, get: function (name)&#123; var v = window.document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)'); return v ? v[2] : null; &#125;, delete: function (name) &#123; this.set(name, '', -1); &#125;&#125; localStorage与sessionStorage HTML5种的web storage包含两种存储方式：localStorage和sessionStorage，这两种方式存储的数据不会自动发给服务器，仅仅是本地保存，有大小限制。 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。同源可以读取并修改localStorage。注意，在IE8以上的IE版本才支持localStorage这个属性，且不能被爬虫爬到，localStorage的使用也是遵循统一『同源策略』的，所以不同的网站直接是不能共用相同的localStorage。 sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问，并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅是会话级别的存储，只允许同一窗口访问。 localStorage与sessionStorage的封装（可设置过期时间）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//存储,可设置过期时间function set(key, value, expires) &#123; // console.log(key); let params = &#123; key, value, expires &#125;; if (expires) &#123; // 记录何时将值存入缓存，毫秒级 var data = Object.assign(params, &#123; startTime: new Date().getTime() &#125;); localStorage.setItem(key, JSON.stringify(data)); &#125; else &#123; if (Object.prototype.toString.call(value) === '[object Object]') &#123; value = JSON.stringify(value); &#125; if (Object.prototype.toString.call(value) === '[object Array]') &#123; value = JSON.stringify(value); &#125; localStorage.setItem(key, value); &#125;&#125;//取出function get(keys) &#123; let item = localStorage.getItem(keys); // 先将拿到的试着进行json转为对象的形式 try &#123; let obj = JSON.parse(item); if(typeof(obj) == 'object' &amp;&amp; obj )&#123; item = obj; &#125; &#125; catch (error) &#123; console.log('error：'+keys+'!!!'+error); return false; &#125; // 如果有startTime的值，说明设置了失效时间 if (item &amp;&amp; item.startTime) &#123; let date = new Date().getTime(); // 如果大于就是过期了，如果小于或等于就还没过期 if (date - item.startTime &gt; item.expires) &#123; localStorage.removeItem(item.key); return false; &#125; else &#123; return item.value; &#125; &#125; else &#123; return item; &#125;&#125;//导出module.exports = &#123; set, localGet:get&#125;;// 存值request.set('uid',option.uid,43200000); //时间单位毫秒级request.set('token',option.token,43200000);// 取值let uid = request.localGet('uid');let token = request.localGet('token'); 参考文章 JS Map对象排序 js判断客户端是PC端还是移动端访问 vue中操作cookie 关于js操作cookie localStorage使用总结 session和cookie的区别","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章三：基础知识","slug":"Javascript篇章三","date":"2019-11-21T16:00:00.000Z","updated":"2021-09-11T01:18:18.000Z","comments":true,"path":"2019/11/22/Javascript篇章三/","link":"","permalink":"https://ahrilove.top/2019/11/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%89/","excerpt":"1.日期类2.url编码和解码3.进制转换4.正则表达式","text":"1.日期类2.url编码和解码3.进制转换4.正则表达式 1.日期var d = new Date(); 获取当前系统时间d.getDate()/d.getFullYear()… 方法 描述 getDate() 以数值返回天数（1-31） getDay() 以数值获取周几（0-6） getFullYear() 获取四位的年（yyyy） getHours() 获取小时（0-23） getMilliseconds() 获取毫秒（0-999） getMinutes() 获取分（0-59） getMonth() 获取月（0-11） getSeconds() 获取秒（0-59） getTime() 获取时间戳（从 1970 年 1 月 1 日至今），毫秒级 2. url编码和解码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的信息网络都是数字的，很多东西要保存传输就得编码，比如你要保存一篇文章，里面的字就是一些二进制编码。编码就是如何把信息转换成数字序列，解码则是把数字序列转换成信息。简单理解为：1. 编码（encode）是将人能够认识的信息转换为看不懂的。 2. 解码（decode）是将经过加密的对象转换为我们能够认识的信息 1.encodeURI 和 decodeURI 原理：返回编码为有效的统一资源标识符(URI)的字符串，不会被编码的字符：!@#$&amp;*()=:/;?+&#39; encodeURI()是Javascript中真正用来对URL编码的函数。 encodeURI()是Javascript中真正用来对URL编码的函数。 2.encodeURIComponent 和 decodeURIComponent（推荐） 原理：对URL的组成部分进行个别编码，而不用于对整个URL进行编码 1234567- 编码：encodeURIComponent(&apos;http://www.baidu.com?name=zhang@xiao@jie&amp;order=1&apos;) 结果：http%3A%2F%2Fwww.baidu.com%3Fname%3Dzhang%40xiao%40jie%26order%3D1- 解码：decodeURIComponent(&quot;http%3A%2F%2F/www.baidu.com%3Fname%3Dzhang%40xiao%40jie%26order%3D1&quot;) 结果：http://www.baidu.com?name=zhang@xiao@jie&amp;order=1 3.escape编码URL特殊字符 当url地址中包含&amp;、+、%等特殊字符（主要是传递参数时，参数的内容中包含这些字符）时，地址无效。Javascript语言用于编码的函数，一共有三个，最古老的一个就是escape() url的Unicode编码：出现这种 \\uXXXX 就有可能是Unicode编码 1escape(\"\\u002F\"); // 结果为 / 3.进制转换 二进制前缀0b 八进制前缀0o 十进制不用前缀 十六进制前缀0x 数字转各进制字符串用num.toString(n),n为2-36的数字，表示2-36进制字符串转数字用parseInt(numString,n),n为2-36的数字，表示用2-36进制方式解析字符串得到数字，有0x前缀时可不用指定n=16, 12345678910111213141516//十进制转其他let x=110;alert(x.toString()); // 转换为字符串alert(x.toString(2));alert(x.toString(8));alert(x.toString(32));alert(x.toString(16));//其他转十进制x='110';alert(parseInt(x,2));alert(parseInt(x,8));alert(parseInt(x,16));//其他转其他//先用parseInt转成十进制再用toString转到目标进制 alert(String.fromCharCode(parseInt(141,8)));alert(parseInt('ff',16).toString(2)); 4.正则表达式 正则表达式的创建方式 直接创建方式（推荐） var reg = /pattern/flags 实例创建方式 12345678910111213141516let reg = new RegExp(pattern,flags);pattern:正则表达式flags：标识修饰符 i 忽略大小写匹配 m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项 g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项时停止方式一：var reg = /ab[a-z]/ig; var str = &apos;abd48515454奥比岛abk45&apos;;console.log(reg.test(str));方式二：let reg = new RegExp(&apos;ab[a-z]&apos;,&apos;ig&apos;);console.log(reg.test(str)); 元字符 1234567891011121314151617181920212223242526代表特殊含义的元字符：\\d : 0-9之间的任意一个数字 \\d只占一个位置\\w : 数字，字母 ，下划线 0-9 a-z A-Z _\\s : 空格或者空白等\\D : 除了\\d\\W : 除了\\w\\S : 除了\\s . : 除了\\n之外的任意一个字符 \\ : 转义字符 | : 或者() : 分组\\n : 匹配换行符\\b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 =&gt; 不占用字符串位数 ^ : 限定开始位置 =&gt; 本身不占位置 $ : 限定结束位置 =&gt; 本身不占位置[a-z] : 任意字母 []中的表示任意一个都可以[^a-z] : 非字母 []中^代表除了[abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符代表次数的量词元字符：* : 0到多个+ : 1到多个? : 0次或1次 可有可无&#123;n&#125; : 正好n次&#123;n,&#125; : n到多次&#123;n,m&#125; : n次到m次 正则方法 reg.test(str) 用来验证字符串是否符合正则 符合返回true 否则返回false 123// 匹配从18到65年龄段所有的人let reg = /(18|19)|([2-5]\\d)|(6[0-5])/;console.log(reg.test(\"65\")); str.match(reg) 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null 123456let str = 'abc123cba456aaa789';let reg = /\\d+/g;console.log(reg.exec(str));// [\"123\", index: 3, input: \"abc123cba456aaa789\"]console.log(str.match(reg));// [\"123\", \"456\", \"789\"] 举例说明：判断是否是mobile还是PC 123456789101112131415161718function IsPC()&#123; let userAgentInfo = navigator.userAgent; let Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; let flag = true; for (let v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125;if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123; //alert(navigator.userAgent); window.location.href =\"iPhone.html\";&#125; else if (/(Android)/i.test(navigator.userAgent)) &#123; //alert(navigator.userAgent); window.location.href =\"Android.html\";&#125; else &#123; window.location.href =\"pc.html\";&#125; 参考文章 escape 编码URL特殊字符 js正则表达式（RegExp） js数据类型转换","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"对象","slug":"对象","permalink":"https://ahrilove.top/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"属性与方法","slug":"属性与方法","permalink":"https://ahrilove.top/tags/%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"}]},{"title":"Javascript篇章一：基本数据类型","slug":"Javascript篇章一","date":"2019-11-19T16:00:00.000Z","updated":"2021-09-11T01:26:18.000Z","comments":true,"path":"2019/11/20/Javascript篇章一/","link":"","permalink":"https://ahrilove.top/2019/11/20/Javascript%E7%AF%87%E7%AB%A0%E4%B8%80/","excerpt":"1.变量声明及命名规范2.基本数据类型3.字符串4.对象5.数值6.数组","text":"1.变量声明及命名规范2.基本数据类型3.字符串4.对象5.数值6.数组 1. 变量及命名规范在javascript中有三种声明变量的方式：var、let、const JS中作用域有：全局作用域、函数作用域，但没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。 声明变量 js在创建变量或对象时，一定要声明其数据类型，否者会默认设置为全局变量，这是我们导入其它js等文件时就会造成污染数据 var var 声明全局变量，换个角度理解：声明在for循环中的变量，跳出for循环同样可以使用，var在ES5，ES6中也同样适用。var 定义的变量可以修改，如果不初始化会输出undefined，不会报错 123456789var a = 1;// var a; //不会报错console.log('函数外var定义a：' + a);//可以输出a=1function change()&#123; a = 4; console.log('函数内var定义a：' + a);//可以输出a=4&#125; change();console.log('函数调用后var定义a为函数内部修改值：' + a);//可以输出a=4 let 必须先定义再使用，否则会报错 循环体中可以用let，let声明的变量只在let命令所在的代码块内有效 不能定义同名变量，否则会报错 let是块级作用域，函数内部使用let定义后，对函数外部无影响 12345678let c = 3;console.log('函数外let定义c：' + c);//输出c=3function change()&#123; let c = 6; console.log('函数内let定义c：' + c);//输出c=6&#125; change();console.log('函数调用后let定义c不受函数内部定义影响：' + c);//输出c=3 const const 声明一个只读的常量，一旦声明，常量的值就不能改变，而且必须初始化 命名规范 一般很多代码语言的命名规则都是类似的，例如: 变量和函数为小驼峰法标识, 即除第一个单词之外，其他单词首字母大写（ lowerCamelCase） 全局变量为大写 (UPPERCASE ) 常量 (如 PI) 为大写 (UPPERCASE ) 构造函数名与class名均使用大驼峰标识 2. 基本数据类型在 JavaScript 中有 6 种不同的数据类型： string number boolean object function symbol 3 种对象类型： Object Date Array 2 个不包含任何值的数据类型： null undefined typeof无法判断数组，null和对象，因为他会把这些都判断为Object，其余都可以正常判断最理想的检测数组类型的方法 12345function isArrayFn (o) &#123;return Object.prototype.toString.call(o) === '[object Array]';&#125;let arr = [1,2,3,1];alert(isArrayFn(arr));// true 实例 测试结果 [1,2,3,1] [object Array] {a:”chenhaodong”,age:18} [object Object] function a(){return null} [object Function] “hello world” [object String] null [object Null] 3. 字符串 3.1 js字符串长度 易混点：JavaScript字符串长度：str.lengthphp的字符串长度：count(string)Java的字符串的长度：str.length()python的字符串长度：len(string)jQuery中的length：表示query对象中元素个数 $(“div”).siblings().length=&gt;表示div标签的兄弟节点元素个数 3.2 使用 \\ 转义字符 转义字符是字符的一种间接表示方式。在特殊语境中，无法直接使用字符自身。例如，在字符串中包含说话内容，由于js已经赋予了双引号为字符串直接量的标识符，如果在字符串中包含双引号，就必须使用转义字符表示。 12&quot;子曰：&quot;学而不思则罔，思而不学则殆。&quot;&quot;&quot;子曰：\\&quot;学而不思则罔，思而不学则殆。\\&quot;&quot; 列举常见的JavaScript转义字符： 序列 代表字符 \\0 Null字符（\\u0000） \\b 退格符（\\u0008） \\t 水平制表符（\\u0009） \\n 换行符（\\u000A） \\v 垂直制表符（\\u000B） \\f 换页符（\\u000C） \\r 回车符（\\u000D） \\“ 双引号（\\u0022） \\‘ 撇号或单引号（\\u0027） \\\\ 反斜杠（\\u005C） \\xXX 由 2 位十六进制数值 XX 指定的 Latin-1 字符 \\uXXXX 由 4 位十六进制数值 XXXX 指定的 Unicode 字符 3.3 字符串的截取 str.slice(start，end)方法：提取字符串的某个部分并在新字符串中返回被提取的部分(起始索引值为0，且满足左闭右开)。该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。 str.substring()方法：类似于 slice()，不同之处在于 substring() 无法接受负的索引 str.substr(start,length)：start表示起始的索引值，默认为0。第二个参数规定被提取部分的长度，如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。 123456789let name = \"this girl that i fall in love with her sister is about 18 years old\";console.log(typeof(name)); // 判断数据类型：\"string\"name.length; // 判断字符长度：67name.slice(0,4); // 满足左闭右开，索引值默认从0开始：\"this\"name.slice(-3,-1); // 从右至左，索引值默认为-1开始：\"ol\"name.substring(-8,2); // 不接受负索引值：\"th\"name.substring(-8,-2); // \"\"name.substr(2,5); // \"is gi\" 3.4 字符串的替换 简单替换：str.replace(a,b) 在字符串str中用b替换a，但只会替换字符串中第一次出现的目标 123let str = \"dog is our friends, dog is cute!\";let str2 = str.replace(\"dog\",\"cat\");console.log(str2); // cat is our friends, dog is cute! js中是没有replaceAll方法的(其实也有，不过要版本很高的浏览器)，那么如何实现替换所有匹配的字符串呢 使用具有全局标志g的正则表达式: 123let str = \"dog and cat are cute, we all love dog and cat!\";let str2 = str.replace(/dog|cat/g,\"pig\");console.log(str2); // pig and pig are cute, we all love pig and pig! 使用另一种具有全局标志g的正则表达式的定义方法 123var str = \"dogdogdog\";var str2 = str.replace(new RegExp(\"dog\",\"gm\"),\"cat\");console.log(str2); 这里g表示执行全局匹配，m表示执行多次匹配 给string对象添加原型方法replaceAll() 12345678String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, \"gm\"), s2);&#125;;// 调用var str = \"dogdogdog\";var str2 = str.replaceAll(\"dog\", \"cat\");console.log(str2); 3.5 转换为大小写 str.toUpperCase()str.toLowerCase() 3.6 str.trim() str.trim() 方法仅能删除字符串两端的空白符，并不能删除指定的字符 12let name = \" i love you\";name.trim(\"you\") // 返回结果\"i love you\"去除了首位的空格 3.7 str.split()：切割字符串，返回数组的形式 这里有一个小知识点， 当split()里面什么都不加时，会把整个字符串当作一个数组 当写法为split(&quot;&quot;)时，表示将原字符串的每一个字符进行切割 当写法为split(&quot;指定字符串&quot;)时，将原字符串按照指定字符串进行切割 举例说明： 12345678let quote = \"i love you because of you\";console.log(quote.split()); // [\"i love you because of you\"]console.log(quote.split(\"\")); /*[\"i\", \" \", \"l\", \"o\", \"v\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"b\", \"e\", \"c\", \"a\", \"u\", \"s\", \"e\", \" \", \"o\", \"f\", \" \", \"y\", \"o\", \"u\"]*/console.log(quote.split(\"you\")); //[\"i love \", \" because of \", \"\"] 3.8 转换为字符串 Numbers.toFixed(number):保留小数点位数，并将数值型转换为字符串型 Numbers.toString():将数值型转换为字符串型 String(Number):将数值型转换为字符串类型 3.9 查询目标字符串索引 indexOf() 方法：可以检索目标字符串在源字符串中首次出现的位置。如果没有在源字符串中检索到指定字符或者子字符串，则返回 -1 。 字符串与数组类似，字符位置是从 0 开始计算。特别说明：此方法对大小写敏感。 123let a = \"hello world\";console.log(a.indexOf(\"h\")); // 0console.log(a.indexOf(\"cg\")); // -1 拓展：查找字符串中是否包含指定的字符串， includes()方法区分大小写string.includes(search_value):用于判断字符串是否包含指定的字符串，如果找到匹配的字符串则返回 true，否则返回 false。 3.10 字符串判断开头或结尾是否是指定的字符 str.startsWith(&quot;&quot;):判定一个字符串是否以另一个字符串开头 str.endsWith(&quot;&quot;):判定一个字符串是否以另一个字符串结尾 123456let str = \"hello world\";let result = str.startsWith(\"he\");console.log(result); //true//当为两个参数时，第二个表示开始位数。result = str.startsWith(\"he\",1);console.log(result); //false 3.11 返回指定位置的字符 str.charAt(index) 返回在指定index位置的字符，且起始索引为0 str.charCodeAt(index) 返回在指定index位置字符的Unicode编码，且起始索引为0 12\"HELLO WORLD!\".charAt(0); // H\"HELLO WORLD!\".charCodeAt(0); // 72 (a:65 A:97) 3.12 复制字符串指定次数，并将它们连接在一起返回 string.repeat(count) =&gt; “woman”.repeat(2); 3.13 fromCharCode生成字符串 可接受一个或多个指定的 Unicode 值，然后返回其字符串组合语法：String.fromCharCode(numX,numX,…,numX) 1console.log(String.fromCharCode(72,69,76,76,79)); // HELLO 4. 对象对象的值以名称:值对的方式来书写（名称和值由冒号分隔） 123456789101112let person = &#123; //这里的person称为对象 firstName:\"Bill\", // 这是属性 lastName:\"Gates\", age:62, eyeColor:\"blue\", fullName : function() &#123; // 这就是方法 return this.firstName + \" \" + this.lastName; &#125;&#125;;// 对person对象中进行新增实例person.sex = \"man\";person.fullName(); JavaScript中的this关键词 12345在函数定义中，this 引用该函数的“拥有者”。在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。换言之，this.firstName 的意思是 this 对象的 firstName 属性。 对象的访问方式 对象名.属性名 或者对象名[&quot;属性名&quot;] 遍历js对象 obj.hasOwnProperty(key):判断对象中是否含有目标属性名 for…in循环 Object.keys() 是 ES5 新增的一个对象方法，该方法返回对象自身属性名组成的数组 Object.getOwnPropertyNames() 是 ES5 新增的一个对象方法，该方法返回对象自身属性名组成的数组 123456789for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; console.log(obj[key]); &#125;&#125;Object.keys(obj).forEach((key) =&gt; &#123; console.log(obj[key]) // foo&#125;) 5. 数值 number.toString():将数值型转化为字符串型 123var n = 15;console.log(typeof(n)); // 为字数值类型numbera = n.toString(); // a为字符串类型 toFixed(number) 将数值保留为指定的小数位数，并再转化为String类型 123456var x = 9.656;x.toFixed(0); // 返回 10x.toFixed(2); // 返回 9.66x.toFixed(4); // 返回 9.6560x.toFixed(6); // 返回 9.656000console.log(typeof(x.toFixed(2))) // 返回\"String\" 把变量转换为数值 这三种 JavaScript 方法可用于将变量转换为数字： Number()方法 parseFloat(string)方法：指定字符串的首个字符是否是数字。如果首字符为数字，则对其进行解析直到完整取出第一个数值，并返回首个数值，如果首字符不是数字则直接返回NaN parseInt(string，radix)方法：指定字符串的首个字符是否是数字。如果首字符为数字，将字符串取出首个完整数值，并转化为指定radix进制，如果首字符不是数字，就直接返回NaN 1234567891011parseInt(\"10.008\"); // 返回 10parseInt(\"10 20 30\"); // 返回 10parseInt(\"10 years\"); // 返回 10parseInt(\"years 10\"); // 返回 NaNparseInt(\"30\",8); // 返回24，将30转化为8进制parseFloat(\"10\"); // 返回 10parseFloat(\"10.33\"); // 返回 10.33parseFloat(\"10 20 30\"); // 返回 10parseFloat(\"10 years\"); // 返回 10parseFloat(\"years 10\"); // 返回 NaN 6. 数组 创建方式 123456789// 第一种(推荐)let A=[12,78,78,78,89];console.log(A);// 第二种let B=new Array();B[0]=12;B[1]=34;console.log(B); 数组访问与修改 访问数组元素：通过索引（从0开始）来引用某个数组元素 var name=car[0] 访问数组值var car[0] = “Benz” 修改数组值，即新数组为[“Benz”,”Volvo”,”BMW”] 数组属性和方法 length:返回数组元素的数目 遍历数组元素：最安全是使用for循环 123456let fruits;fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];for (i = 0; i &lt; fruits.length; i++) &#123; console.log(fruits[i]);&#125; push()和pop() push(): 把里面的内容添加到数组末尾，并返回修改后的长度 pop(): 移除数组最后一个元素，并返回该值 123let fruits = [\"Banana\"];fruits.push(\"Lemon\");console.log(fruits) // [\"Banana\", \"Lemon\"] shift()和unshift() shift(): 移除数组第一个元素，并返回该值 unshift(): 把里面的内容添加到数组开头，并返回修改后的长度 join()格式：数组.join(“指定拼接符”) 将所有数组元素结合为一个字符串 123var fruits = [\"Banana\", \"Orange\",\"Apple\", \"Mango\"];console.log(fruits.join(\" * \"));// Banana * Orange * Apple * Mango reverse()反转数组中的元素 123let fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.sort(); // 对 fruits 中的元素进行排序fruits.reverse(); // 对数组元素进行反转 isNaN()全局函数来判断一个值是否是NaN值isNaN(1000/“apple”) trueisNaN(1000) false slice()截取数组，返回从原数组中指定开始下标到结束下标之间的项组成的新数组、不改变原数组、支持负索引(负索引加上数组长度就是正索引)、满足区间左闭右开原则 12345678910let arr = [1,3,5,7,9,11];let arrCopy = arr.slice(1);let arrCopy2 = arr.slice(1,4);let arrCopy3 = arr.slice(1,-2);let arrCopy4 = arr.slice(-4,-1);console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)console.log(arrCopy); //[3, 5, 7, 9, 11]console.log(arrCopy2); //[3, 5, 7]console.log(arrCopy3); //[3, 5, 7]console.log(arrCopy4); //[5, 7, 9] sort(fun)方法以字母或数值对数组进行排序语法：array.sort(fun)；参数fun可选，规定排序顺序，必须是函数。 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照ascii编码顺序进行排序。 如果想按照其他规则进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，比较函数两个参数a和b，返回a-b 升序，返回b-a 降序 数组中的对象也可按照某个属性值进行排列 原数组会发生改变 不传参数，将不会按照数值大小排序，按照字符编码的顺序进行排序 1234567let arr = ['General','Tom','Bob','John','Army'];let resArr = arr.sort();console.log(resArr); //输出 [\"Army\", \"Bob\", \"General\", \"John\", \"Tom\"]let arr2 = [30,10,111,35,1899,50,45];let resArr2 = arr2.sort();console.log(resArr2); //输出 [10, 111, 1899, 30, 35, 45, 50] 传入参数，实现升序，降序 12345678910111213// 实现升序let arr3 = [30,10,111,35,1899,50,45];arr3.sort(function(a,b)&#123; return a - b;&#125;);console.log(arr3);//输出 [10, 30, 35, 45, 50, 111, 1899]// 实现降序let arr4 = [30,10,111,35,1899,50,45];arr4.sort((a,b) =&gt; &#123; return b - a;&#125;);console.log(arr4);//输出 [1899, 111, 50, 45, 35, 30, 10] 根据数组中的对象的某个属性值排序 123456let arr5 = [&#123;id:10&#125;,&#123;id:5&#125;,&#123;id:6&#125;,&#123;id:9&#125;,&#123;id:2&#125;,&#123;id:3&#125;];arr5.sort(function(a,b)&#123; return a.id - b.id&#125;);console.log(arr5);// 输出新的排序 [&#123;id: 2&#125;,&#123;id: 3&#125;,...,&#123;id: 10&#125;] 根据数组中的对象的某个属性值排序(字符串类型):localeCompare 场景：localeCompare()方法实现中文排序、sort方法实现数字英文混合排序 12345let arr6 = [&#123;id: \"General\"&#125;,&#123;id:\"Tom\"&#125;,&#123;id:\"Alice\"&#125;,&#123;id:\"Bob\"&#125;,&#123;id:\"Ahri\"&#125;,&#123;id:\"Kiko\"&#125;];arr6.sort(function(a,b)&#123; return a.id.localeCompare(b.id);&#125;);console.log(arr6); 参考文章 JavaScript基本数据类型以及详细使用","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/tags/javascript/"}]},{"title":"Memcached","slug":"Memcache","date":"2019-11-19T16:00:00.000Z","updated":"2020-12-19T10:34:32.000Z","comments":true,"path":"2019/11/20/Memcache/","link":"","permalink":"https://ahrilove.top/2019/11/20/Memcache/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached 1.安装memcached&nbsp;&nbsp;&nbsp;Memcached是通过在内存里维护一个统一的巨大的hash表，memcached能存储各种各样的数据，包括图像、视频(但是极不推荐来保存二进制文件)、文件、以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。参考docker创建memecached容器windows下ThinkPHP3.2.3使用memcache缓存 2.创建memcached镜像docker run -di –name=”memcached” -m 256m -p 11211:11211 memcached:[tag] 123456-d是启动一个守护进程；-m是分配给Memcache使用的内存数量，单位是MB；-u是运行Memcache的用户；-l是监听的服务器IP地址，可以有多个地址；-p是设置Memcache监听的端口，，最好是1024以上的端口；-c是最大运行的并发连接数，默认是1024； 3.测试并进入docker容器 测试是否启动成功 netstat -luntp|grep 11211或者docker ps 安装telnet yum install -y telnet 或 sudo apt-get install telnet 通过telnet方式连接memcached telnet 127.0.0.1 11211 或者使用 telnet ubuntu_ip docker_memcached_port 设置值，age是key，0是标志位，900是生命周期，8代表所占字节数，回车之后的10是value set age 0 900 810 获取值 get age 退出 exitquit 4.telnet操作memcached：1.添加数据 set语法：12345678 set key flas(是否压缩,默认为0，不压缩) timeout value_length value示例： set username 0 60 7 zhiliao``` + add语法： add key flas(0) timeout value_lengthvalue示例：add username 0 60 7xiaotuoset和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。 2.获取数据：get key_name 3.删除数据：delete key_name 4.删除memcached所有数据：flush_all 5. memcached安全性memcached的操作不需要任何用户名和密码，只需要知道memcached服务器的ip地址和端口号即可。因此memcached使用的时候尤其要注意他的安全性。这里提供两种安全的解决方案。分别来进行讲解： &nbsp;&nbsp;&nbsp;&nbsp;1.使用-l参数设置为只有本地可以连接：这种方式，就只能通过本机才能连接，别的机器都不能访问，可以达到最好的安全性。&nbsp;&nbsp;&nbsp;&nbsp;2.使用防火墙，关闭11211端口，外面也不能访问 未完待续…","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"Memcached","slug":"Memcached","permalink":"https://ahrilove.top/tags/Memcached/"}]},{"title":"docker开发环境系列部署","slug":"docker容器虚拟技术(Ⅱ)","date":"2019-11-18T16:00:00.000Z","updated":"2021-06-01T09:25:00.000Z","comments":true,"path":"2019/11/19/docker容器虚拟技术(Ⅱ)/","link":"","permalink":"https://ahrilove.top/2019/11/19/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF(%E2%85%A1)/","excerpt":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡","text":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡 1.Django项目集群1.1 创建工程目录site1234567项目目录结构：site |__achievements |__db |__Dockerfile |__doocker-compose.yml |__requirements.txt 1.2 参考两篇优秀博文离未罔两|Docker—-搭建python3+django+mysql开发环境冰凉的枷锁lax|Docker搭建Python+Django+mysql开发环境 2. Docker实现Nginx和Tomcat负载均衡暗夜猎手-大魔王|使用docker搭建高并发网站架构实践2–Docker实现Nginx和Tomcat负载均衡 菲宇|Docker下Nginx+Tomcat实现负载均衡","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"}]},{"title":"Git命令总结","slug":"git命令大全","date":"2019-11-17T16:00:00.000Z","updated":"2020-11-23T07:36:40.000Z","comments":true,"path":"2019/11/18/git命令大全/","link":"","permalink":"https://ahrilove.top/2019/11/18/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"1.git命令大全总结一下自己常用的git命令","text":"1.git命令大全总结一下自己常用的git命令 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash” git config –global user.name “Your Name”git config –global user.email “email@example.com“ cd F: (打开F盘)mkdir (创建子目录)pwd (显示当前目录) git init (把这个目录变成Git可以管理的仓库) git add :改动文件添加到本地仓库中的暂存区 1234关于git add的一点说明：git add . # 把新增的、修改的都加到缓存git add &lt;file&gt; # 提交文件，可多次提交 git add -A # 把新增、和修改的、和删除的都加到缓存，即提交所有的更改 git commit -m “说明” git status (仓库当前的状态) git diff (查看不同) git log [–pretty=oneline {缩略版,可选}] (查看历史记录) git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id) git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本) git diff HEAD – (查看工作区和版本库里面最新版本的区别) git checkout – (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除) git reset HEAD (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本) git rm (用于删除一个文件) ssh-keygen -t rsa -C “youremail@example.com“ (创建SSH Key) git remote add origin git@github.com:Bruce333/other.git (关联github远程库) git push -u origin master/git push origin master：提交到远程仓库 (推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改) git clone git@github.com:Bruce333/other.git (克隆远程仓库到本地库) ps:比如GitHub，gitlab克隆仓库时就有显著性不同GitHub克隆时，各个分支都可以直接clone；而gitlab克隆时，只能clone主分支的仓库，切换到目标分支后，使用git pull拉取目标分支更新到本地仓库 git checkout -b dev: 创建并切换目标分支 创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支] git merge dev (合并指定分支到当前分支) git checkout master (切换到master分支) git branch ：列出本地所有分支，当前分支前面会标一个*号 git branch -d 分支名 ：删除本地分支 git push origin –delete 分支名：git删除远程仓库分支 git merge –no-ff -m “merge with no-ff” dev (通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去) git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作) git stash list (查看工作现场) / git stash apply stash@{0} () git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除]) git branch -D (强行删除一个没有被合并过的分支) git remote (查看远程库的信息) / git remote -v (显示更详细的信息) git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致) 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 git pull：抓取远程仓库下某个分支的更新，再与本地的指定分支合并（更新本地分支代码） 把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建.用命令git branch –set-upstream branch-name origin/branch-name) git tag &lt;commit id 可无&gt; 打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签 git show (查看标签信息) git tag (查看所有标签) git tag -a -m “blablabla…” (指定标签信息) git tag -s -m “blablabla…” (用PGP签名标签) git tag -d (删除本地标签tag) git push origin (推送某个标签到远程) git push origin –tags (一次性推送全部尚未推送到远程的本地标签) git tag -d (删除一个本地标签) git push origin –delete (删除一个远端标签) git config –global color.ui true (让Git适当地显示不同的颜色) 忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 git config –global alias.st status 告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中) git log –graph (查看分支合并图) 2019-12-16 新增：当自己的账户有私人的GitHub和企业的gitlab时，不经意间就会将不同的用户名，邮箱搞混，幸得建彬哥真传，终于搞懂了。1.在自己的项目文件下直接”git bash here”2.查看当前项目所属的用户名与邮箱 git remote show origin查看当前仓库基本信息git remote -v 查看当前项目远程地址git branch -a 查看远程项目所有分支，红颜色分支代表当前所在分支git config user.name 查看当前项目的用户名git config user.email 查看当前项目的邮箱 3.设置用户名和邮件git config [–global] user.name “用户名”git config [–global] user.email “邮箱”git config命令的-- global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 删除远程仓库目标分支 1234git branch -a : 查看所有的分支git checkout 其它分支： 切换到其它分支才能删除目标分支git push origin --delete 删除的远程仓库名git branch -a : 再次查看所有的分支，确认是否已经删除了 2.git clone的说明&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git一般有很多分支，我们clone到本地的时候一般都是master分支，那么如何切换到其他分支呢？ 查看所有远程分支：git branch -a 切换分支：git checkout 目标分支 同步分支：git pull &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再思考一会：首先，你需要使用 git clone 这个命令克隆一个本地库。之后它会自动克隆一个master分支（这个貌似是必须的）。之后不会克隆任何一个分支下来的。假定你需要一个dev（此处假定远程库中已经存在此分支，也就是你需要克隆的）分支用于开发的话，你需要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是用这个命令创建本地dev分支：$ git checkout -b dev origin/dev 再同步下：$ git pull 这样就实现了克隆dev分支。 3.git pull与pushgit 为什么要先commit，然后pull，最后再push？而不是commit然后直接push？情况是这样的，现在远程有一个仓库，分支就一个，是master。然后我本地的仓库是从远程的master上clone下来的。大家都是clone下来，再在自己本地改好，再commit然后pull然后push，大家都是这么做的。那么现在问题来了： 那我本地这个也算是个分支？还是就是一个本地仓库？ 答：本地和远程的关系相当于两个分支,你感觉一样是因为你git pull 的时候已经自动给绑定好对应关系了, set-upstream..balbala 如果我在远程新建了个分支，然后我pull了下来，那我本地到底有分支这个说法吗？我本地的分支是不是就是那个远程新建的分支？ 答：你远程新建了一个分支拉到本地的道理是一样的,属于复制了一份,但是本地分支和远程分支已经是两个东西了 本地仓库和本地分支有什么区别？ 答：本地分支属于本地仓库里,是包含关系,一个仓库里可以有很多分支 commit是提交到本地仓库，然后push，这个push是把所有代码推到远程仓库，还是只是把commit的地方推到远程仓库？ 答：肯定不会全量推送到远程的,是通过对比 commit 的记录,如果本地高于远程就直接把多出来的commit 给怼上去,如果本地分支的最新版本和远程的 commit 有冲突，就需要解决冲突。 那为什么要先commit，然后pull，然后再push，我pull了，岂不是把自己改的代码都给覆盖掉了嘛，因为远程没有我改的代码，我pull，岂不是覆盖了我本地的改动好的地方了？那我还怎么push？ 答：这个先 commit 再 pull 最后再push 的情况就是为了应对多人合并开发的情况, commit 是为了告诉 git 我这次提交改了哪些东西,不然你只是改了但是 git 不知道你改了,也就无从判断比较; pull是为了本地 commit 和远程commit 的对比记录,git 是按照文件的行数操作进行对比的,如果同时操作了某文件的同一行那么就会产生冲突,git 也会把这个冲突给标记出来,这个时候就需要先把和你冲突的那个人拉过来问问保留谁的代码,然后在 git add &amp;&amp; git commit &amp;&amp; git pull 这三连,再次 pull 一次是为了防止再你们协商的时候另一个人给又提交了一版东西,如果真发生了那流程重复一遍,通常没有冲突的时候就直接给你合并了,不会把你的代码给覆盖掉 出现代码覆盖或者丢失的情况:比如A B两人的代码pull 时候的版本都是1,A在本地提交了2,3并且推送到远程了,B 进行修改的时候没有commit 操作,他先自己写了东西,然后 git pull 这个时候 B 本地版本已经到3了,B 在本地版本3的时候改了 A 写过的代码,再进行了git commit &amp;&amp; git push 那么在远程版本中就是4,而且 A 的代码被覆盖了,所以说所有人都要先 commit 再 pull,不然真的会覆盖代码的 两个分支A和B，A合并B和B合并A，有区别吗？ 答：两个互相合并的唯一区别就是 A-&gt;B 的时候 B 分支上会产生一个 merge_commit ，被改变的分支是 B ；如果现在没有发生任何改动执行 B-&gt;A ，则A和B两分支才会完全相同。 4.git的整个执行流程★★★ 有时候我们开发需要开一个分支,这样可以有效的并行开发，开分支有两种方式: 一种是在远程开好分支,本地直接拉下来（推荐：根据具体issue，创建相应的分支） 一种是本地开好分支,推送到远程 git clone目标仓库 git checkout -b feature-branch origin/feature-branch 检出远程的feature-branch分支到本地，创建与远程仓库同名的本地仓库 git branch 检查当前分支是否切换的目标分支 轻微修改代码提交测试一下 看是否能够提交成功，以免白做了 提交测试通过后，正式开始写代码 git status 检查当前仓库状态 先commit，然后pull，最后再push","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"git","slug":"git","permalink":"https://ahrilove.top/tags/git/"},{"name":"git pull/push","slug":"git-pull-push","permalink":"https://ahrilove.top/tags/git-pull-push/"}]},{"title":"ThinkPHP","slug":"php(三)","date":"2019-11-14T16:00:00.000Z","updated":"2021-05-06T06:31:40.000Z","comments":true,"path":"2019/11/15/php(三)/","link":"","permalink":"https://ahrilove.top/2019/11/15/php(%E4%B8%89)/","excerpt":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push(),clone()ThinkPHP的变量输出memcached缓存机制ThinkPHP通用项目结构","text":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push(),clone()ThinkPHP的变量输出memcached缓存机制ThinkPHP通用项目结构 ThinkPHP3.2 笔记 1.js的clone()与push函数的一些生活纠纷 push()函数：向数组的末尾添加一个或多个元素，并返回新的长度。返回值是把指定的值添加到数组后的新长度语法：arrayObject.push(newelement1,newelement2,….) push() 方法可把它的参数顺序添加到 arrayObject（数组对象）的尾部。它直接修改 arrayObject，而不是创建一个新的数组，而是在原数组基础上修改。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能，该方法会改变数组的长度。 案例1：push() 1234567var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\"; console.log(arr);//输出原素组 ['chd','sjb','sgx']console.log(arr.push(\"badwoman\")); // 输出 4 PS:来了，push添加元素之后没有直接输出添加元素之后的数组，只显示了数组的个数（长度） 12345678// 展示push后的新数组var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\";arr.push('badwoman');console.log(arr);//输出结果为：['chd','sjb','sgx','badwoman'] js的clone()函数 js对象之间的赋值，如果直接用”=”会发现来两个对象还是同一个对象，改变其中一个另外的一个也会做出对应的改变。为了解决这个问题，可以利用java里面的clone的原理。假设有这样一个场景：当存在一个公共数组(对象型)时，一个需要加{“name”:”chd”,”age”:18}另一个需要在数组尾加上{“name”:”sgx”,”age”:108} 12345let commonCondition=[&#123;\"id\":15&#125;];let a=&#123;\"name\":\"chd\",\"age\":18&#125;;let b=&#123;\"name\":\"sgx\",\"age\":108&#125;;// 当我们利用a = commonCondition.push(a)时，此时原来的commonCondition也会跟着改变// 赋值b = commonCondition.push(b)。此时，b中也会包含a的数据，此刻js的clone函数就出现了 js的clone()函数源代码: 1234567891011121314151617181920212223function clone(Obj)&#123; var o; if (typeof obj == \"object\") &#123; if (obj === null) &#123; o = null; &#125; else &#123; if (obj instanceof Array) &#123; o = []; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; o.push(this.clone(obj[i])); // 有可能不要this &#125; &#125; else &#123; o = &#123;&#125;; for (var j in obj) &#123; o[j] = this.clone(obj[j]); // 有可能不要this &#125; &#125; &#125; &#125; else &#123; o = obj; &#125; return o; &#125; 即此刻，我们才有如下最正确的式子 1234let new_a = clone(commonCondition);a = new_a.push(a);let new_b = clone(commonCondition);b = new_b.push(b); 2. thinkphp项目调用Vue扩展函数方式2.1 导入vue扩展包.js文件 1&lt;script src=\"./cf.js\"&gt;&lt;/script&gt; 2.2 声明方法：新建一个与项目名同名的js文件，新增如下内容 123456789101112Vue.prototype.项目名 = &#123; // 这里表示扩展函数 函数名一:function(obj)&#123; ... &#125;, 函数名二:function(obj)&#123; ... &#125;, ...&#125; 2.3 调用方法：Vue实例化名. 项目名.函数名()Vue实力化名即：let app = new Vue({})中的app,经过测试后，调用方法为 项目名.函数名（） 3.thinkPHP的变量输出知识&lt;{:函数名/变量名}&gt; 中的冒号&quot;:&quot;表示引用调用函数，获取变量值 &lt;{:U(query)}&gt;:URL生成http://serverName/projectName/当前模块/当前控制器/声明的方法 123默认的模板标签为：在config.php文件下更改设置&apos;TMPL_L_DELIM&apos;=&gt;&apos;&lt;&#123;&apos;,&apos;TMPL_R_DELIM&apos;=&gt;&apos;&#125;&gt;&apos;, &lt;{:I(‘name’,’chd’)}&gt;中的I方法获取自定义参数值，不存在时，自定义默认值 I(‘get.name’); // 相当于 $_GET[‘name’]支持默认值： 2019-12-8 新增：查看thinkphp3.2手册存在变量输出方式二：在模板（即HTML文件）中输出变量的方式很简单，只需要我们在控制器给模板变量赋值： 1234567$name = \"ThinkPHP\";/*@param $this-&gt;assign() 绑定，分配数据@param （'name',$name）参数一：表示要在模板中引用的变量名，在不加$符号时，也要使用引号括起来*/$this-&gt;assign('name',$name); $this-&gt;display(); // 将分配的数据在HTML页面展示 然后再模板中使用（注意模板标签的{和$之间不能有任何的空格，否则标签无效,普通标签默认开始标记是{，结束标记是 }。也可以通过设置TMPL_L_DELIM和TMPL_R_DELIM进行更） 12345hello,&lt;&#123;$name&#125;&gt;&lt;!-- 在模板编译后结果为：--&gt;Hello,&lt;?php echo($name);?&gt;&lt;!--这样就在HTML页面显示为：--&gt;hello,ThinkPHP 4. ThinkPHP的memcached缓存机制 4.1 下载安装memcached，并启动其服务 参考docker创建memecached容器 windows下ThinkPHP3.2.3使用memcache缓存 4.2thinkphp3.2中其实已经加入了memcached缓存机制，只需要在Conf/config.php配置数据缓存类型即可使用Memcache: 1234567&lt;? php return array( 'DATA_CACHE_TYPE' =&gt; 'Memcache', // 数据缓存类型 'MEMCACHE_HOST' =&gt; 'tcp://127.0.0.1:11211', 'DATA_CACHE_TIME' =&gt; '3600' )?&gt; 5.ThinkPHP项目模块结构，参考此文章1234567891011121314151617project项目名: |---Application:应用模块 |Admin后台模块 |Home前台模块 |---Controller控制器 |---IndexController.class.php |---Model模型 |---IndexModel.class.php |---View视图 |---index.html |Common公共配置模块（不能直接访问） |Runtime缓存模块 |---Public静态资源文件 |---ThinkPHP框架 |---index.php：入口文件 |---favicon.ico：网站图标 |---.htaccess:Apache配置文件（重写URL，修改访问权限） 未完待续。。。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://ahrilove.top/categories/PHP/"}],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://ahrilove.top/tags/ThinkPHP/"}]},{"title":"JSON通常用于与服务端交换数据,在向服务器发送数据时一般是字符串","slug":"json","date":"2019-11-13T16:00:00.000Z","updated":"2021-06-24T06:32:02.000Z","comments":true,"path":"2019/11/14/json/","link":"","permalink":"https://ahrilove.top/2019/11/14/json/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则(PS:json键值对一定要用双引号包裹起来) 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组本文内容： 1.Python的json规则2.js中的json规则3.Python一般脚本文件编写规则","text":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则(PS:json键值对一定要用双引号包裹起来) 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组本文内容： 1.Python的json规则2.js中的json规则3.Python一般脚本文件编写规则 1.Python的json规则python程序中的json有一点点区别于JavaScript中的json，它是通过对象和数组的组合来表示数据 1.1 对象型数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它在JavaScript是使用花括号{}包裹起来的内容，数据结构为{key1:value1,key2:value2…}的键值对结构，key为对象的属性，value为对应的值。键名可以使用整数和字符串来表示，所以，一个json对象跨用写作如下格式(对象型数组) 123456789[&#123; \"name\": \"chd\", \"age\": 18, \"sex\": \"man\" &#125;,&#123; \"name\": \"Monica\", \"gender\": \"woman\", \"birthday\": \"1997-1-25\"&#125;] 调用方式:通过中括号加0索引，可以得到第一个字典元素，然后调用其键名即可得到相应的键值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式一：中括号加键名data[index][“键名”] =&gt; data[0][‘name’]，结果为‘chd’&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式二：get()方法传入键名，如果键名不存在，不会报错，会返回none（python中推荐使用）data[index].get(‘键名’) =&gt; data[1].get(“birthday”),结果为”1997-1-25” 1.2 键值对形式（类似于字典） 1234567891011121314&#123; \"code\": 1, \"msg\": \"success\", \"data\": &#123; \"name\": \"pig\", \"age\": \"18\", \"sex\": \"man\", \"hometown\": &#123; \"province\": \"江西省\", \"city\": \"抚州市\", \"county\": \"崇仁县\" &#125; &#125;&#125; 1.3 需要注意到点 JSON的键名和字符串都必须使用双引号引起来，而Python中单引号也可以表示为字符串，所以这是个比较容易犯的错误！Python类型与JSON相互转换的时候到底是用load//dump还是用loads\\dumps？他们之间有什么区别？什么时候该加s什么时候不该加s？这个我们可以通过查看源码找到答案：不加s的方法入参多了一个fp表示filepath，最后多了一个写入文件的操作。 加s表示转成字符串(str)，不加s表示转成文件。 loads、dumps读写json 123456789101112import jsonwith open(\"./info.json\", \"r\", encoding=\"utf-8\") as f: data = json.load(f)print(type(data)) # dictprint(data)params = &#123; \"name\": \"chd\", \"gender\": \"man\"&#125;with open(\"./info.json\", \"w\", encoding=\"utf-8\") as f: json.dump(params, f) loads、dumps读写json(习惯此种方法) 12345678910111213import jsonwith open(\"./info.json\", \"r\", encoding=\"utf-8\") as f: data = json.loads(f.read())print(data)print(type(data))params = &#123; \"name\": \"chd\", \"gender\": \"man\", \"school\": \"清华大学\"&#125;with open(\"./info.json\", \"w\", encoding=\"utf-8\") as f: f.write(json.dumps(params, ensure_ascii=False, indent=2)) # indent表示缩进个数 2.javascript中的jsonjavascript的访问方式与python大同小异，但也有细分之处访问方式一：变量名[“键名”]访问方式二：变量名.键名 json是js的原生内容，也就意味着js可以直接读取出json对象中的数据 1234567891011let stu = &#123; //stu 对象包含student的key,值为一个数组 \"student\":[//数组的每一个值为一个具体的学生对象 &#123;\"name\": \"Tom\", \"Grade\":1, \"age\":11, \"gender\": \"M\"&#125;, &#123;\"name\": \"Bob\", \"Grade\":1, \"age\":10, \"gender\": \"W\"&#125; ], \"classroom\": &#123;\"class1\": \"room1\", \"class2\": \"room2\"&#125;&#125;;console.log(stu[\"classroom\"][\"class1\"]); // room1console.log(stu.classroom.class1); // room1 json.parse()：是从一个字符串中解析出 json 对象 12345678//定义一个字符串let data='&#123;\"name\":\"chd\"&#125;';let a = JSON.parse(data);console.log(typeof(a)) // 对象类型/*结果是：*Object* &#123;name:\"chd\"&#125;*/ json.stringify() 是从一个对象中解析出字符串 123456789let data=&#123;name:'chd'&#125;;let a = JSON.stringify(data);typeof(a) // 对象类型/** 结果是：* '&#123;\"name\":\"chd\"&#125;'* 字符串类型* */ 3.Python一般脚本文件编写流程12345678910111213141516171819202122232425261.文件配置一般在config.json中，比如：用户名，账号，密码，人员信息等等2.在settings.py 文件中导入.json文件中的配置 # 载入配置文件 BASE_DIR = os.path.dirname(os.path.abspath(__file__)) # 返回当前path文件的上一级目录 with open(os.path.join(BASE_DIR,&quot;settings.json&quot;),&quot;r&quot;) as f: SETTINGS = json.load(f) # 配置文件的内容获取 SERVER = SETTINGS[&quot;DB_CONFIG&quot;][&quot;DB_SERVER&quot;] # json格式新的调用方法：json.load(f)的变量名[&quot;对象名&quot;][&quot;键名&quot;]3.在主文件.py 中导入文件import settings 文本格式内容为：settings.SERVER，settings.PASSWORD等等脚本目录： | |--core.py | |--settings.py | |--config.json | |--a.py |--b.py | |--.gitignore 参考文章 10分钟学分js处理json常用方法","categories":[{"name":"json","slug":"json","permalink":"https://ahrilove.top/categories/json/"}],"tags":[{"name":"json","slug":"json","permalink":"https://ahrilove.top/tags/json/"}]},{"title":"数据库存储引擎与索引,视图","slug":"sql系列更新(二)","date":"2019-11-11T16:00:00.000Z","updated":"2021-03-03T03:34:32.000Z","comments":true,"path":"2019/11/12/sql系列更新(二)/","link":"","permalink":"https://ahrilove.top/2019/11/12/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E4%BA%8C)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引视图事务视图的操作","text":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引视图事务视图的操作 1.索引index索引在创建表的时候可以同时创建，也可以随时增加新的索引 查询索引是否已创建 12-- 如果没创建过的话应该默认有一条主键的索引(有主键的前提下)select index_name from all_indexes where table_name = '你的表名' 创建新索引的语法 12create [unique|fulltext|spatial] index index_name [using index_type] on table_name( col_name [(length)] [asc|desc] ) 删除索引 1DROP INDEX index_name on table_name 索引创建原则 在经常用作过滤器where的字段上建立索引 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引 在某个字段field的不同值较少(即散列度较小)应避免建立索引，如性别字段(只有男女两个参数) 对于经常存取的列应避免建立索引，即增删改查 表的主键、外键必须有索引 不应该在小表上（数据量很小的表）创建索引 索引应该建在选择性高的字段上 索引应该建在小字段上，对于大的文本字段甚至超长字段，对于定义为text、image和bit等数据类型的列应避免创建索引 经常与其他表进行连接(join,left join,right join)的表，在连接字段上应建立索引 删除无用的索引，避免对执行计划造成负面影响 确定针对该表的操作是大量的查询操作还是大量的增删改操作。若为后者，则应避免创建索引 索引作用合理的创建索引是提高查询速度最有效的方式之一： 在没有建立索引的情况下，查询一条数据的过程是这样：MySQL是从第一条记录开始查表，在某一个地方查到了匹配的数据，停止？NO，继续查询剩下的数据，直到查完整张表。 在建立合适索引的情况下，查询一条数据的过程又是这样：MySQL先根据索引快速到达一个位置去搜索数据文件，然后查出数据，而不必查看整张表的数据。 tips: 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。 索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 通过创建唯一索引，可以保证某一列的值具有唯一性。 当一个表的索引达到4个以上时，ORACLE的性能可能还是改善不了，因为OLTP系统每表超过5个索引即会降低性能，而且在一个sql 中， Oracle 从不能使用超过 5个索引 索引可能产生碎片,因为记录从表中删除时,相应也从表的索引中删除.表释放的空间可以再用,而索引释放的空间却不能再用.频繁进行删除操作的被索引的表,应当阶段性地重建索引,以避免在索引中造成空间碎片,影响性能.在许可的条件下,也可以阶段性地truncate表,truncate命令删除表中所有记录,也删除索引碎片. （建立索引影响了删除和更新操作） 1234567891011/*添加唯一索引：*/ALTER TABLE studentsADD UNIQUE INDEX unique_name(name);/*只添加唯一约束而不添加唯一索引：*/ALTER TABLE studentsADD CONSTRAINT unique_name UNIQUE(name); 因此，为了提高查询速度，合理建立索引是非常有必要的。 类型 描述 普通索引 基本的索引类型，允许定义索引的列中插入重复值和空值 唯一索引 索引列值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 主键索引 特殊的唯一索引，不允许有空值 全文索引 类型为FULLTEXT,支持值的全文查找，允许在索引列中插入重复值和空值 组合索引 在表的多个字段组合上创建的索引 索引执行情况1234567891011121314 单一索引:Create Index &lt;Index-Name&gt; On &lt;Table_Name&gt;(Column_Name); 复合索引:Create Index &lt;Index-Name&gt; On emp(deptno,job); —&gt;在emp表的deptno、job列建立索引。 select * from emp where deptno=66 and job=&apos;sals&apos; -&gt;走索引。 select * from emp where deptno=66 OR job=&apos;sals&apos; -&gt;将进行全表扫描。不走索引 select * from emp where deptno=66 -&gt;走索引。 select * from emp where job=&apos;sals&apos; -&gt;进行全表扫描、不走索引。 如果在where 子句中有OR 操作符或单独引用Job 列(索引列的后面列) 则将不会走索引，将会进行全表扫描。同时在Oracle里用PL/SQL的F5可以对整个SQL查询来判断没加索引前和加完索引后的用时。 索引失效情况当索引失效的情况下时，数据库会进行全表扫描 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描 索引列上不能进行数学计算 :SELECT Col FROM tbl WHERE col / 10 &gt; 10 则会使索引失效，应该改成SELECT Col FROM tbl WHERE col &gt; 10 * 10 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描 更多的索引失效情况 参考网址： MySQL 索引建立原则及注意事项 ORACLE 数据库需要创建索引的规则 3.视图（5.0.1提供视图功能）&nbsp;&nbsp;&nbsp;&nbsp;视图是一种虚拟存在的表，它存储的是查询语句，显示出来的是查询的结果；更直白的说就是当我们需要从表中查询一些信息时需要编写相关SQL语句，将这些SQL语句存储为视图，那么我们调用这些视图的时候就相当于执行了SQL语句，从而可以得到想要的结果eg:创建视图并执行查询操作 create view view_name as select qty,price,qty*price as value from temp; 视图有什么作用 1.视图就像是一个封装了很多功能的函数，我们把一系列复杂的查询语句存储为一个视图，这样在需要频繁使用这些语句时不必反复编写，直接使用视图代替即可 12345678如果要频繁获取表user的name和表goods的name。就应该使用以下sql语句：select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;但有了视图就不一样了，创建视图other。示例create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;创建好视图后，就可以这样获取user的name和goods的name： select * from other; 2.对数据库进行重构但仍不会影响程序运行 12345678假如因为某种需求，需要将user表拆成表usera和表userb，该两张表的结构如下： 测试表:usera有id，name，age字段 测试表:userb有id，name，sex字段这时如果程序端一直使用的sql语句是：select * from user;那就会报错提示该表不存在，这时要么去更改程序的查询语句要么就创建视图。显然，创建视图更简单，成本更低。以下sql语句创建视图：create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;以上假设name都是唯一的。这时程序端端使用的sql语句：select * from user;就不会报错。这就实现了更改数据库结构，而不用更改脚本程序的功能。 4.视图的操作 4.1 创建或修改视图 create [ or replace ] [ algorithm = { undefined | merge | temptable } ] view view_name [ (column_list) ] as select_statement [ with [ cascaded | local ] check option ] 使用了OR REPLACE可以修改视图，或者直接就CREATE OR REPLACE 替换为ALTER 即变成修改语法； UNDEFINED：未定义指定算法；MERGE：更新视图表数据的同时会更新真实表的数据（默认）；TEMPTABLE：只能查询不能更新； CASCADED(默认)：必须满足所有针对该视图的所有视图的条件才可以更新；LOCAL：只需满足本视图的条件就可以更新； WITH CHECK OPTION：需要满足相关的检查条件才能进行更新12345--常量视图create or replace view pi as select 3.1415926 as pi; --select中包含子查询create or replace view city_view as select (select city from city where city_id=1); 4.2 查看当前数据库下所有视图 show full tables where table_type like ‘view’; 5.优化SQL语句一般步骤 5.1 通过show status 查看各语句的频率 6.数据库Leetcode1.求薪水第二高，不存在就返回null 123select ifnull((select distinct(Salary) from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary; 超过5名学生的课(having用法) 1234select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5 DATEDIFF是两个日期的天数差集 123select a.Id as newIdfrom Weather a left join Weather b on datediff(a.RecordDate,b.RecordDate)=1 where a.Temperature&gt;b.Temperature 5.事务事务：一个事务是由一条或多条sql语句构成，这一条或者多条sql语句要么全部执行成功，要么全部执行失败 默认情况下，每条单独的sql语句就是一个单独的事务。例：银行转账，A要向B转账1000元，这需要两条sql语句：①A的账户减去1000元 ②B的账户加上1000元。设想如果在第一条sql语句执行成功后，在执行第二条sql语句之前程序被中断了，那么B的账户没有增加而A的账户却减少了1000，这肯定不是我们想要的结果。因此我们需要事务来解决此类问题。 123456-- 转账案例SET autocommit = 0;START TRANSACTION;UPDATE account SET money=money-1000 WHERE NAME = 'A';UPDATE account SET money=money+1000 WHERE NAME = 'B';COMMIT; 查看MySQL的隔离级别 查看MySQL隔离级别 123SELECT @@global.tx_isolation; SELECT @@session.tx_isolation; SELECT @@tx_isolation; 修改MySQL隔离级别 12SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125; 事务的特性ACID 原子性：事务中所有操作是不可分割的原子单位，事务中的所有操作要么全部执行成功，要么全部执行失败 一致性：事务执行后，数据库状态与其他业务规则保持一致。如转账案例中，无论事务成功与否，参与转账的两个账户的金额之和应保持不变。 隔离性：在并发操作中，不同事务之间是互相隔离的，不会互相干扰。 持久性：一旦事务提交成功，事务中所有的数据都必须被持久化到数据库中，即使提交数据后数据库崩溃，在数据库重启时，也必须保证通过某种机制恢复数据。 MySQL中的事务 隐式事务:事务自动提交 没有明显的开始和结束标记例如DML语句的 INSERT,UPDATE,DELETE 语句本身就是一条事务（一条DML增删改语句会自动提交一次事务，即执行sql语句后会即刻生效） 显式事务：事务手动提交 具有明显的开始和结束标记,一般由多条sql语句组成，必须具有明显的开始和结束标记 代码里使用事务的步骤： 前需要先关闭自动提交 然后开启事务， 执行操作数据的SQL 如果中间SQL语句抛异常了，就调rollback 回滚，将数据恢复到事务开始前的状态，事务结束 如果中间SQL语句没有抛异常，就commit 提交，事务结束 显式事务用begin或start transaction开始事务后，若没有手动commit，或者遇错rollback回滚，执行后即使立马查询，所看见的数据都是临时的，并不是执行后真正写入磁盘里的数据。 PS：Oracle的事务默认是手动提交的，一定要注意 12345678910111213141516171819202122232425262728# 查看事务自动提交的模式show [session] variables like 'autocommit'; //会话级别show global variables like 'autocommit'; // 全局级别# 关闭自动提交：set global autocommit=0;set [session] autocommit=0;# 开启自动提交：set global autocommit=1;set [session] autocommit=1;# 设置事务【可选】(这些事务是互斥的，不能同时设置两个以上选项)set transaction read only set transaction read writeSet transaction isolation level read committedSet transaction isolation level serializable# 开启事务begin; 或：start transaction;# 提交commit; # 回滚rollback; set transaction只对当前事务有效,事务终止,事务当前的设置将会失效 MySQL的事务隔离级别 Read Uncommitted（读未提交） 所有事务都可以看到其他未提交事务的执行结果，会产生脏读（读取未提交的数据），（存在脏读、不可重复读、幻读） Read Committed（读提交） 一个事务只能看见已经提交事务所做的改变，会产生不可重复读问题，（解决脏读，存在不可重复读和幻读） Repeatable Read（可重读） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read），（默认，解决脏读，不可重复读，存在幻读） Serializable（串行化） 这是最高的隔离级别，读加共享锁，写加排他锁，读写互斥，从而解决幻读问题。在这个级别，可能导致大量的超时现象和锁竞争，如果业务并发的特别少，同时又要求数据及时可靠的话，可以使用。（解决所有并发问题，但效率较低） 隔离级别产生的问题 脏读(Dirty Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据不正确了 不可重复读(Non-repeatable read)：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read)：在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 参考文章 oracle事务处理 MySQL基础入门总结笔记 深入理解MySQL索引原理和实现——为什么索引可以加速查询？ Oracle事务的提交（commit）与回滚（rollback） 关于事务，隔离级别讲的比较好的b站视频","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ahrilove.top/tags/mysql/"},{"name":"InnoDB","slug":"InnoDB","permalink":"https://ahrilove.top/tags/InnoDB/"},{"name":"index","slug":"index","permalink":"https://ahrilove.top/tags/index/"}]},{"title":"Python全栈系列章节更新（一）：基本数据类型","slug":"Python全栈系列章节更新（一）","date":"2019-11-10T16:00:00.000Z","updated":"2021-09-02T02:58:24.000Z","comments":true,"path":"2019/11/11/Python全栈系列章节更新（一）/","link":"","permalink":"https://ahrilove.top/2019/11/11/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 数字：数字数据类型用于存储数值字符串：是 Python 中最常用的数据类型列表：作为一个方括号内的逗号分隔值出现元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象集合：集合（set）是一个无序的不重复元素序列","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 数字：数字数据类型用于存储数值字符串：是 Python 中最常用的数据类型列表：作为一个方括号内的逗号分隔值出现元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象集合：集合（set）是一个无序的不重复元素序列 1.字符串Python中的可迭代对象有：列表、元组、字典、字符串，常结合for循环使用 不可变数据（3个）：Number（数字）、String（字符串）、Tuple（元组） 可变数据（3个）：List（列表）、Dictionary（字典）、Set（集合） zip()函数：将可迭代对象所包含的元素是由原列表元素组成的元组 语法：zip(Iterable1, Iterable2, …) 12345678a = [\"a\", \"b\", \"c\"]b = [1, 2, 3]c = \"CHD\"d = [x for x in zip(a,b)] # [(\"a\", 1, \"C\"), (\"b\", 2, \"H\"), (\"c\", 3, \"D\")]# another waye = list(zip(a, b))f = tuple(zip(a, b)) 结果为元祖型列表 format():位置参数，参数索引从0开始，format里填写{}对应的参数值 msg = “my name is {}, and age is {}”.format(‘chd’,18)渲染结果：my name is chd, and age is 18 str.index()字符串索引: 索引值从0开始,不存在就会报错 s=’index’ s[0]=is.index(‘i’) = 0 : 查找目标字符串索引值 str.find(‘目标字符串’)查找目标字符串,不存在就返回数值-1(推荐使用find) “i am iron man”.find(“man”) =&gt; 1 移除指定字符串 str.strip() s = ‘ hello,world! ‘s.strip()s.lstrip()s.rstrip() len(str)字符串长度 len(‘hello,world’) =&gt; 11 str.replace(a,b)替换：在字符串str中，用b来替换a ‘hello,world’.replace(‘o’,’a’) =&gt; ‘hella,warld’ str[a:b:c] 切片操作(左闭右开) [a:b:c]：a表示为索引起始位置（索引以0开始）；b表示为索引结束位置；c表示为跳跃间隔案例如下： 1234567891011&gt;&gt;&gt; test=&quot;1234hello-world56789&quot;&gt;&gt;&gt; type(test)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; test[:]&apos;1234hello-world56789&apos;&gt;&gt;&gt; test[0:1]&apos;1&apos;&gt;&gt;&gt; test[0:5:2]&apos;13h&apos;&gt;&gt;&gt; test[0:5]&apos;1234h&apos; string.capitalize() 把字符串的第一个字符大写 str.startswith/endswith(‘目标字符串’) 检查字符串是否以目标字符串开始或结束 str.count(‘目标字符串’): 返回 str 在 string 里面出现的次数 str.join(seq序列):将序列中的元素以指定的字符连接生成一个新的字符串 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 sequence(序列)是一组有顺序的元素的集合,序列有两种：tuple和list str.lower()/upper() 将字符串全部转换为小写/大写 “hello world”.lower()/upper() =&gt;”hello world” / “HELLO WORLD” str.split(指定字符串) 以指定字符串来分割目标字符串，以列表形式返回 1234url = \"http://www.baidu.com/python/image/123456.jpg\"#以“.” 进行分隔path =url.split(\".\")path1=['http://www', 'baidu', 'com/python/image/123456', 'jpg'] 2019-11-28 新增：当split的参数为空时，即string.split():表示以空格作为分割符，并将换行符也去掉 2.列表 列表截取（索引从0开始，且满足左闭右开原则）与拼接:从右至左取值，则索引默认从-1开始 123L = ['Google', 'Runoob', 'Taobao']# L[2]='Taobao' L[-1]='Taobao'# L[0:2] = ['Google', 'Runoob'] 列表函数和方法 函数和方法 描述 len(list) 列表元素个数 list(seq) 将元组或字符串转换为列表 max/min(list) 返回列表元素最大/最小值 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) 将对象插入列表 list.pop([index=n]) 移除指定索引的元素值（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中某个值的第一个匹配项 list.reverse() 反向列表中元素 list.sort( key=None, reverse=False) 对原列表进行排序 常见案例：列表拆分，列表破开 1234567891011121314151617181920# 将obj数组分割成每100个一组numbers=[1,2,3,4,5,6,7,8,...,10000]number =[]for i in range(0, len(numbers), 100): number.append(numbers[i:i + 100])# 列表破开平叠（递归）def flatten(arr): res = [] for i in arr: if isinstance(i, list): # 递归破开数组 res.extend(flatten(i)) else: res.append(i) return restarget_list = [[12, 5, 6], 2, 6, [13], [66, [[1, 0]]], 99]result = flatten(arr=target_list)# [12, 5, 6, 2, 6, 13, 66, 1, 0, 99] 列表的list.remove(obj)使用说明：移除列表的指定的某一项（PS：不是索引，是具体的值） a = [1,2,3,8,10,56,110] c = a.remove(8) (c为None) 👇 a = [1, 2, 3, 10, 56, 110] ---------------------------- a = [1,2,3,8,10,56,110] b = a.pop(3) (b为8，pop返回该元素的值) 👇 a = [1, 2, 3, 10, 56, 110] 2021-04-28 新增：列表排序汇总sort与sorted方法区别： 列表的sort方法在执行后，会需要改源列表 sort()是列表的私有方法，是只能对列表使用 sorted()是Python的内置方法，适用于所有的可迭代对象，且会返回新列表，不修改源列表 修改原列表，不创建新列表的方法 12345678a = [3, 2, 8, 4, 6]print(id(a)) # 2180873605704a.sort() # 默认升序print(a) # [2, 3, 4, 6, 8]print(id(a)) # 2180873605704a.sort(reverse=True)print(a) # [8, 6, 4, 3, 2] 创建新列表的排序 通过内置函数sorted(iterable, cmp=None, key=None, reverse=False)进行排序，这个方法返回新列表，不对原列表做修改 12345a = [3, 2, 8, 4, 6]b = sorted(a) # 默认升序c = sorted(a, reverse=True) # 降序print(b) # [2, 3, 4, 6, 8]print(c) # [8, 6, 4, 3, 2] 3.元组 3.1元组的创建 元组使用小括号，而列表使用方括号，只需要在括号中添加元素，并使用逗号隔开即可 1tup1 = ('a','b','c',336) 3.2 元组的访问使用下脚标索引来访问元组中的值，下标索引从0开始 tup1[0] =&gt; &#39;a&#39; ,tup[1] =&gt; &#39;b&#39; 3.3 元组的修改 元组中的元素是不允许修改或删除的，但我们可以使用+对其进行拼接组合tuple(seq)：将列表转换为元组。 4.字典 4.1字典的创建 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号&nbsp;&nbsp;,&nbsp;&nbsp;分割，整个字典包括在花括号 {} 1d = &#123;key1 : value1, key2 : value2 &#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258',9527:'badwoman',6394:998&#125; 4.2 字典的访问 访问方式：字典名[&quot;键名&quot;] 或者字典名.get(&quot;键名&quot;,自定义数据)：当目标键名不存在时，使用自定义数据值作为默认值，注意此刻不会修改原字典 4.3 字典的更新 1234567dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; dict['Age'] = 8 # 更新dict['School'] = \"RUNOOB\" # 添加 print(\"dict['Age']: \", dict['Age'])print(\"dict['School']: \", dict['School']) 4.4 内置函数和方法 函数和方法 描述 len(dict) 计算字典元素个数，即键的总数 key [not] in dict 键在字典里返回true，否则返回false dict.keys() 获取包含字典所有的key的列表 dict.values() 获取包含字典所有的value的列表 dict.items() 将字典的键值一一对应组合成一个元组，以列表的形式返回值 dict1.update(dict2) 合并字典，将dict2合并至dict1,键名相同时，会覆盖原值 dict.pop(key) 删除字典给定键key所对应的值，返回值为被删除的值，key不可为空 拓：Python遍历字典，获得字典键、值的函数有：items/ iteritems/ keys/ iterkeys/ values/ itervalues 通常情况下较常用，效率也能满足一般需要 1234a_dict = &#123;\" name\": \"sir\", \"lang\": \"python\", \"email\": \"sir@ gmail.com\"&#125;for k in a_dict(): print k, a_dict[k] items,iteritems 1234567891011121314151617 for k, v in a_dict.items(): print k, v lang python website www.it.com name sir email sir@ gmail.com for k, v in a_dict.iteritems(): print k, v demo=&#123;'Name': 'Zara', 'Age': 8, 'Class': 'First', 'School': 'RUNOOB'&#125;demo.items() # dict_items([('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')])a = [x for x in demo.items()]print(a) # a=[('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')] 以 上 两 种 方 法 也 能 够 实 现 同 样 的 效 果， 特 别 是 第 二 个 iteritems() 效 率 挺 高 keys: 效果跟前面一样，但不太提倡，因为效率比较低。 1234567for k in a_dict.keys(): print k, a_dict[k]lang pythonwebsite www.it.comname siremail sir@ gmail.com 5.NumberPython3 支持 int、float、bool、complex（复数）等数字类型。对数字类型常见的操作为： 数字类型转换：int(x),float(x),complex(x,y)表示将x转换为相应的数据类型 数学函数运算：abs,exp,log,sqrt,round 随机数函数：choice，randrange ([start,] stop [,step]),random,shuffle 三角函数：sin，cos，tan 数学常量：pi，e 6.集合集合set是一个无序的不重复的序列，可以使用大括号{}或者set()函数创建集合。创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典 创建格式： 123456789101112param = &#123;&apos;apple&apos;,&apos;orange&apos;,&apos;pear&apos;&#125;或者set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))因为集合的不重复性，也可用来去重：&gt;&gt;&gt; basket = &#123;&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;&#125;&gt;&gt;&gt; print(basket) # 这里演示的是去重功能&#123;&apos;orange&apos;, &apos;pear&apos;, &apos;apple&apos;&#125;&gt;&gt;&gt; &apos;orange&apos; in basket # 快速判断元素是否在集合内True&gt;&gt;&gt; &apos;crabgrass&apos; in basketFalse 集合的基本操作： add():添加元素到集合中，如元素已存在，不进行任何操作 remove():将目标元素移出集合中 pop()：随机删除集合中的一个元素 len():计算集合的元素个数 in：判断元素是否在集合中存在 集合之间的运算（并集，交集，补集） 123456789101112&gt;&gt;&gt; a = set(&apos;abracadabra&apos;)&gt;&gt;&gt; b = set(&apos;alacazam&apos;)&gt;&gt;&gt; a &#123;&apos;a&apos;, &apos;r&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;&#125;&gt;&gt;&gt; a - b # 集合a中包含而集合b中不包含的元素&#123;&apos;r&apos;, &apos;d&apos;, &apos;b&apos;&#125;&gt;&gt;&gt; a | b # 集合a或b中包含的所有元素&#123;&apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;&#125;&gt;&gt;&gt; a &amp; b # 集合a和b中都包含了的元素&#123;&apos;a&apos;, &apos;c&apos;&#125;&gt;&gt;&gt; a ^ b # 不同时包含于a和b的元素&#123;&apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;&#125; 7.直接赋值，浅拷贝和深拷贝 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 解析： b = a 赋值引用，a与b都指向同一个对象，即共有同一块内存地址 123456a = &#123;1: [1, 2, 3]&#125;b = a # b = &#123;1: [1, 2, 3]&#125;# 更新a的值a[1]=[1,2,3,4]print(b) # b = &#123;1: [1, 2, 3, 4]&#125;# 即直接赋值也属于浅拷贝，共用同样一块地址 b = a.copy():浅拷贝，a与b是一个独立的对象，但他们的子对象还是指向统一对象（是引用） 12345a = &#123;1: [1,2,3]&#125;b = a.copy()print(a,b) # (&#123;1: [1, 2, 3]&#125;, &#123;1: [1, 2, 3]&#125;)a[1].append(4) # 字典更新print(a, b) #(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;) b = copy.deepcopy(a) 深拷贝：深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的,是两块独立的地址。 1234567&gt;&gt;&gt; import copy&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;)&gt;&gt;&gt; a[1].append(5)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4, 5]&#125;, &#123;1: [1, 2, 3, 4]&#125;) 8.map与reduce函数 map map()函数接收两个参数，一个是函数，一个是Iterable（可迭代对象），map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator（迭代器）返回(可以使用list转换为数组)，而python2返回的是一个数组 12345def f(x): return x * xr = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])list(r) # [1, 4, 9, 16, 25, 36, 49, 64, 81] Python3使用map返回结果是迭代器，需要使用list将其转换为列表 reduce reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 filter filter()也接收一个函数和一个序列。从一个序列中筛出符合条件的元素。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素 12345678# 获取列表内所有的整数类型元素def only_int(x): if isinstance(x, int): return True else: return Falsedt = filter(only_int, [1, 2, 3, 3, '3232', -34.5, 34.5])print(list(dt)) # [1, 2, 3, 3] 9.Python的遍历技巧 在字典中遍历时，关键字和对应的值使用item()方法同时解读出来 knights = {‘name’: ‘chd’, ‘age’: 18 } for k, v in knights.items(): 枚举函数，在序列遍历时，索引值和对应值使用enumerate()函数得到 for i, v in enumerate([‘tic’, ‘tac’, ‘toe’]): zip()函数：同时遍历两个或更多的序列 参考文章 Python中字符串List按照长度排序 python 对字符串list中的元素进行排序★★","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"https://ahrilove.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"jQuery学习","slug":"html与css(Ⅵ)","date":"2019-11-10T16:00:00.000Z","updated":"2021-05-06T06:42:40.000Z","comments":true,"path":"2019/11/11/html与css(Ⅵ)/","link":"","permalink":"https://ahrilove.top/2019/11/11/html%E4%B8%8Ecss(%E2%85%A5)/","excerpt":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题 本文要点：1.选择器2.jQuery的事件3.jQuery异步Ajax","text":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题 本文要点：1.选择器2.jQuery的事件3.jQuery异步Ajax 1. 选择器id选择器 $(“#div”)类选择器 $(“.div”)标签选择器 $(“div”)并集选择器 $(“selector1,selector2,…,selectN”)：使用逗号连接，以数组形式返回所有的合并元素后代选择器 $(“div p”):div标签下的p标签，包含子孙节点过滤选择器 $(“div:eq(n)”) :eq(index)获取给定索引值的元素 从0开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:gt(index) 匹配所有大于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:lt(index) 匹配所有小于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:even 匹配所有索引值为偶数的元素，从 0 开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:odd 匹配所有索引值为奇数的元素，从 0 开始计数属性选择器 $(“div[attribute=”value”]”) :匹配给定的属性是某个特定值的元素 表单的选择器:$(‘input:radio/checkbox/text/password/…’),即: type值为radio、checkbox、password等的input元素 筛选选择器 : $(‘div’).eq(n) 获取第n个元素 数值从0开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.first()获取第一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.last()获取最后一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.parent() 选择父亲元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.siblings()选择兄弟元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.find() 查找目标元素值 PS:注意筛选选择器与过滤选择器的函数位置 2.jQuery的事件常见的DOM事件: 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload hover 1.click鼠标点击事件:选择目标元素 123$(&quot;p&quot;).click(function()&#123; // 动作触发后执行的代码!!&#125;); 2.dblclick(),当双击元素时，会发生 dblclick 事件。 12345dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数： 实例$(&quot;p&quot;).dblclick(function()&#123; $(this).hide();&#125;); 3.mouseenter():当鼠标指针穿过元素时，会发生 mouseenter 事件 123$(&quot;#p1&quot;).mouseenter(function()&#123; alert(&apos;您的鼠标移到了 id=&quot;p1&quot; 的元素上!&apos;);&#125;); 4.mouseleave():当鼠标指针离开元素时，会发生 mouseleave 事件。 12345mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数：实例$(&quot;#p1&quot;).mouseleave(function()&#123; alert(&quot;再见，您的鼠标离开了该段落。&quot;);&#125;); 5.mousedown():当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 12345mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数：实例$(&quot;#p1&quot;).mousedown(function()&#123; alert(&quot;鼠标在该段落上按下！&quot;);&#125;); 6.hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave) 1234567$(&apos;p&apos;).hover(function()&#123; alert(&apos;你的鼠标在段落上&apos;);&#125;,function()&#123; alert(&apos;你的鼠标已经离开了段落&apos;);&#125;) 3.jQuery异步Ajax3.1 jQuery $.get()方法，通过 HTTP GET 请求从服务器上请求数据。 12345678910语法：$.get(URL,callback);必需的 URL 参数规定您希望请求的 URL。可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：$(&quot;button&quot;).click(function()&#123; $.get(&quot;demo_test.php&quot;,function(data,status)&#123; alert(&quot;数据: &quot; + data + &quot;\\n状态: &quot; + status); &#125;);&#125;); 3.2 jQuery $.post() 方法,通过 HTTP POST 请求向服务器提交数据。 1234567891011121314151617181920212223语法:$.post(URL,data,callback,data_type);url (String) : 发送请求的URL地址.data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示。callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法)。type (String) : (可选)官方的说明是：Type of data to be sent。其实应该为客户端请求的类型(JSON,XML,等等) 下面的例子使用 $.post() 连同请求一起发送数据： $(&quot;button&quot;).click(function()&#123; $.post(&quot;/try/ajax/demo_test_post.php&quot;, &#123; &quot;name&quot;:&quot;菜鸟教程&quot;, &quot;age&quot;:18, &quot;url&quot;:&quot;http://www.runoob.com&quot; &#125;, function(data,status)&#123; alert(&quot;数据: \\n&quot; + data + &quot;\\n状态: &quot; + status); &#125;); &#125;,&quot;json&quot;); 4.jQuery内容文本值 获取设置元素内容 .html()：获取元素html内容 获取设置元素文本内容 .text(): 仅仅是获取文本内容，若存在参数，则表示将其渲染到目标元素中（$(‘#box2’).text(‘路飞学城‘) 值为标签的时候 不会被渲染为标签元素 只会被当做值渲染到浏览器中） 获取设置表单值 .val()：仅获取到表单标签的value值 获取属性值.attr(“属性名”)：attr()不存在参数时，表示获取属性值;若attr()存在参数值，表示设置属性值，$(“img”).attr({ src: “test.jpg”, alt: “Test Image” });表示为img标签赋予src属性，alt属性","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"选择器","slug":"选择器","permalink":"https://ahrilove.top/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"数据库：DDL，DML，DCL","slug":"sql系列更新(一)","date":"2019-11-10T16:00:00.000Z","updated":"2021-05-27T09:22:18.000Z","comments":true,"path":"2019/11/11/sql系列更新(一)/","link":"","permalink":"https://ahrilove.top/2019/11/11/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0(%E4%B8%80)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式本文要点： 1.数据库基础2.DDL&amp;&amp;DML3.DCL语句4.多数据库实际业务解决方案★★★","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式本文要点： 1.数据库基础2.DDL&amp;&amp;DML3.DCL语句4.多数据库实际业务解决方案★★★ 1.数据库基础MySQL基础 服务启动 net start 服务器名（Windows）service start 服务器名（linux） 登录与修改密码 命令 含义 mysql -u root -p -h localhost 登录MySQL（p表示密码；u表示用户名；h表示主机地址） mysqladmin -u用户名 -p旧密码 password新密码 修改用户名密码 基本命令使用 命令 含义 show databases; 用于显示所有的数据库 use 数据库名; 使用目标数据库 select database()/version()/now()/user(); 显示当前连接的信息 show tables; 用于显示选中数据库下的所有的表 desc table_Name; 查看表结构 show create table table_name \\G; 查看到创建时的SQL语句及更多详细信息 \\G使记录按照字段竖向排列，易于阅读 创建数据库并指定编码格式:create database if not exists 数据库名 character set utf8;删除数据库：drop database [if exists] 数据库名; Oracle基础 Oracle数据库、实例、用户、表空间、表之间的关系★★★ 数据库：Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。 实例： 一个Oracle实例（Oracle Instance）有一系列的后台进程和内存结构组成。一个数据库可以有n个实例。实例名同时也叫SID 用户：用户是在实例下建立的，不同实例可以建相同名字的用户。 表空间：是一个用来管理数据存储逻辑概念，表空间只是和数据文件（ORA或者DBF文件）发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。 数据文件（dbf、ora）：是数据库的物理存储单位。数据库的数据是存储在表空间中的，真 正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行 理解：Oracle数据库可以创建多个实例（但我们一般使用默认的orcl实例），每个实例可以创建多个表空间，每个表空间下可以创建多个用户（同时用户也属于表空间对应的实例）和数据库文件，用户可以创建多个表（每个表随机存储在一个或多个数据库文件中）。由于Oracle就只有一个大的数据库，我们平时说的dw，bi等都是指代的用户。而MySQL是存在数据库的概念的，而我们平时常说的“entchat”，“mdm”都是指代的数据库 12345查询当前数据库实例名：select instance_name from v$instance;数据库实例名(instance_name)用于对外部连接。**在操作系统中要取得与数据库的联系，必须使用数据库实例名**。比如我们作开发，要连接数据库，就得连接数据库实例名：jdbc:oracle:thin:@localhost:1521:orcl（orcl就为数据库实例名） sqlplus基础命令 使用前提：先安装Oracle，安装完成之后在dos窗口中，输入 sqlplus 再输入用户名和密码即可登录 命令 含义 sqlplus 用户名/密码 启动sqlplus show user 查看当前连接用户 conn 用户名/密码 切换(连接)用户 exit或quit 退出sqlplus password [用户名] 更改用户口令 创建表空间 1234567891011121314151617create tablespace waterbossdatafile &apos;c:\\waterboss.dbf&apos;size 100mautoextend onnext 10mwaterboss 为表空间名称datafile 用于设置物理文件名称size 用于设置表空间的初始大小autoextend on 用于设置自动增长，如果存储量超过初始大小，则开始自动扩容next 用于设置扩容的空间大小-- 查看当前用户的每个表所占空间大小select segment_name,sum(bytes)/1024/1024 size_M from user_extents group by segment_name order by size_M desc; 创建用户 1234567create user wateruseridentified by itcastdefault tablespace waterbosswateruser 为创建的用户名identified by 用于设置用户的密码default tablesapce 用于指定默认表空间名称 Oracle版本说明 12345678910Oracle 8iOracle 9iOracle 10gOracle 11gOracle 12cI：i 代表 Internet。8i 版本开启对 Internet 的支持。所以，在版本号之后，添加了标识 i。G：g 代表 Grid 网格。10g 加入了网格计算的功能，因此版本号之后的标识使用了字母g。C：c 代表云(cloud)计算设计。12c 版本表示对云计算的支持。 2.DDL&amp;DMLDDL:数据定义语言仅对数据库，表，列，索引起作用（create、drop、alter）DML:数据操纵语言仅对table中的具体数据起作用（select、insert、delete、update） DDL数据定义语言 1.创建表 创建表 create table 表名( ​ 列名 数据类型 列级约束, ​ 列名 数据类型 列级约束 ​ )【表类型】【表字符集】【表注释】 12345678910#创建学生表，并设置表类型、字符集CREATE TABLE `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &apos;主键、学号&apos;, `psd` VARCHAR(20) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;123456&apos; COMMENT &apos;密码&apos;, `name` VARCHAR(30) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;匿名&apos; COMMENT &apos;学生姓名&apos;, `sex` VARCHAR(2) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;男&apos; COMMENT &apos;性别&apos;, `birsday` DATETIME DEFAULT NULL, `email` VARCHAR(20) COLLATE utf8_estonian_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_estonian_ci 数据类型 约束条件： not null unique primary key 主键名 foreign key (Id_P) references Persons(Id_P) :一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY default 默认值 auto increment:在每次插入新记录时，自动地创建主键字段的值 主键 &nbsp;&nbsp;&nbsp;&nbsp;对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 &nbsp;&nbsp;&nbsp;&nbsp;由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。&nbsp;&nbsp;&nbsp;&nbsp;使用BIGINT，会占用更大的磁盘和内存空间，内存空间毕竟有限，无效的占用会导致更多的数据换入换出，额外增加了IO的压力，对性能是不利的。因此推荐自增主键使用int unsigned类型，但不建议使用bigint。&nbsp;&nbsp;&nbsp;&nbsp;所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键,而应该使用INT UNSINGED自增或者GUID类型。主键也不应该允许NULL。可以使用多个列作为联合主键，但联合主键并不常用。&nbsp;&nbsp;&nbsp;&nbsp;如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 12345create table user( id INT UNSIGNED NOT NULL AUTO_INCREMENT primary key , /*数据类型 非空 自增 主码约束*/ name varchar(200) /*主码，外码约束条件写法二：primary key(id) */ ) 2.删除表：drop table table_name 3.修改表 命令 含义 修改表中列的数据类型 alter table table_name modify 列名 column_definition 增加表字段 alter table table_name add [column] 列名 column_definition 删除表字段表字段 alter table table_name drop [column] 列名 表的字段改名 alter table table_name change [column] old_col_name new_col_name 表字段改名同时也可修改字段类型 alter table table_name change [column] old_col_name new_col_name column_definition 更改表名 alter table table_name rename [to] new_tablename DML数据操纵语句 命令 含义 插入数据 insert into table_name ( field1, field2,…) values (value1,value2,….); 一次性插入多条数据 insert into table_name ( field1, field2,…) values (value1,value2,..),(value1,value2,..)…; 更新记录 update table_name set field1=value1，field2=value2，… [ WHERE CONDITION ] 删除某一项记录 delete from table_name [WHERE CONDITION ] 排序和限制 select * from table_name [ WHERE CONDITION ] [ order by field1 [ DESC\\ASC ], field2 [ DESC\\ASC], ..] 表连接 select ename,deptname from emp1 left join dept on emp1.deptno=dept.deptno; 子查询 关键字主要有in、not in、=、!=、exists、not exists,between and等等 1.可以不用指定字段名称，但此时后面的values应该与表的字段顺序保持一致2.对于某些字段允许空值、非空但是有指定的默认值、自增长等，这些字段在insert时如果没有指定value，那么将会右系统自动配置 3.DCL语句 创建数据库用户，并声明权限 创建操作数据库的专用用户，格式：grant 权限 on 数据库名.数据表名 to 用户名@主机IP IDENTIFIED BY 密码 1234说明：权限：ALL PRIVILEGES(所有权限),select,insert,update,delete,create,alter,drop主机IP： &apos;%&apos; 匹配所有主机，localhost表名： * 表示所有表 刷新权限 flush privileges 这里向大家拓展一个知识点，那就是主机IP指的是该用户只能在对应的主机IP上进行登录。例如：假如user用户设置的主机IP为localhost，那么其他人就将无法从本地以外的地方使用user用户进行登录。 4.实际业务解决方案★★★ distinct 查询不重复的记录 select distinct id from emp1; 加distinct关键字使得查出的结果中去掉了重复记录 条件查询 判断条件可以使用=、&gt;、&lt;、&gt;=、&lt;=、!=等等，同时多个条件还可以使用and、or等进行连接 聚合函数（它对其应用的每个行集返回一个值） 1234567891011select [ field1, field2,...,fieldn] fun_name from tablename [ where condition ] [ group by field1, field2,..., fieldn [ with rollup ] ] [ having condition ]参数说明：fun_name 聚合函数，表示要做的聚合操作，常用的有sum（求和）、count(*)（计数）、max、min等。 GROUP BY 表示对后面的字段进行分类聚合（也常叫分组）； WITH ROLLUP 可选语法，在ORDER BY 语句内出现，表示是否对分类聚合后的结果进行再汇总； HAVING 表示对分类后的结果再进行条件过滤； 同样是条件过滤，having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤。因此，为了提高聚合效率，一般先用where过滤不相干的记录后，在进行聚合，最后再用having进行二次过滤 12select gender，count(gender) from tab_teacher group by gender having gender=\"woman\";-- 含义为：按性别分组，查询出女老师人数的总数:先执行group by，再聚合函数，最后having筛选 聚合函数：补充说明 AVG(表达式) 返回表达式中所有的平均值。仅用于数字列并自动忽略NULL值。 COUNT(表达式) 返回表达式中非NULL值的数量。可用于数字和字符列。 COUNT() 返回表中的行数( *包括有NULL值的列** )。 MAX(表达式) 返回表达式中的最大值,忽略NULL值。可用于数字、字符和日期时间列。 MIN(表达式) 返回表达式中的最小值,忽略NULL值。可用于数字、字符和日期时间列。 SUM(表达式) 返回表达式中所有的总和,忽略NULL值。仅用于数字列。———————————————— 避免使用通配符“*” 实际开发中，要避免使用通配符”*”（通配符代表所有字段），因为系统要先解析出所有的字段名，将其还原为真实的名字，然后再进行操作。如果记录数据库内容特别多，会影响效率。 查询表的总记录数(推荐使用主键的方式查询) 因为主键唯一，且不能为空,此时id总数则代表总记录数select count(id) from table_teacher; 别名as的用法 MySQL的列，表别名都可以使用as，但Oracle的表别名禁止使用as 参考StackOverflow的问题回复：You can use AS for table aliasing on many SQL servers (at least MsSQL, MySQL, PostrgreSQL) but it’s always optional and on Oracle it’s illegal. so just remove the as 分页查询方式（limit与rownum） 查询老师记录的前三条（从0位置开始找出3条）： limit后面有两个参数：第一个参数是起始位置，初始记录行的偏移量是 0(而不是 1)；第二个参数是偏移量（即数据个数） select * from tab_teacher limit 0,3; 查询第1条到第10条数据的sql是：select * from table limit 0,10; 即索引值为[0,9],不同于其它编程语言左闭右开原则 查询第10条到第20条数据的sql是：select * from table limit 10,20; 分页查询计算公式：limit (page-1)*size,size oracle的sql语句中没有limit,limit是mysql中特有的,在oracle中可用rownum来表示,用于查询结果中的前N行数据。如要查询emp表中的前5行数据,可用如下语句: &nbsp;&nbsp;select * from emp where rownum","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"database","slug":"database","permalink":"https://ahrilove.top/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://ahrilove.top/tags/mysql/"},{"name":"DDL","slug":"DDL","permalink":"https://ahrilove.top/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"https://ahrilove.top/tags/DML/"}]},{"title":"docker容器虚拟化技术","slug":"docker容器虚拟技术(Ⅰ)","date":"2019-11-09T16:00:00.000Z","updated":"2021-08-18T08:42:54.000Z","comments":true,"path":"2019/11/10/docker容器虚拟技术(Ⅰ)/","link":"","permalink":"https://ahrilove.top/2019/11/10/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF(%E2%85%A0)/","excerpt":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题","text":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题 1.docker适用环境其实docker本身也没有太多在Windows下花功夫。目前，docker仅支持Linux与Windows企业版、专业版、教育版。ps：家庭版不支持docker,并且win10下可以安装docker-for-windows,这个安装包是专门适用于win10，安装简单，而对于win7/8则可以使用Docker Toolbox下载地址 2.端口映射的问题 问题详情 在Windows10系统服务器中安装了docker和docker-compose，并尝试在其中运行Nginx服务，映射也做好。在主机的浏览器中，打开localhost:port无法访问对应的Web服务 问题解析docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows10 解决办法启动docker命令行窗口，输入命令 docker-machine ip default 然后在Windows的浏览器中，输入 http://IP:port 即可启用 3.hyper-v与VMware不可兼容&nbsp;&nbsp;&nbsp;在Windows下安装docker，第一步就是要打开Hyper-V(打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V),开启win自带的虚拟管理技术。但是若想要使用VMware，则必须关闭Hyper-V，鱼和熊掌不可兼得呀！(′д｀ )…彡…彡 1、请移除hyper-v角色。2、 以管理员身份（win + x）运行命令提示符；3、执行命令：bcdedit /set hypervisorlaunchtype off4、重启系统，运行vm即可。5、如果想要恢复hyper启动： bcdedit / set hypervisorlaunchtype auto 注意：当我们的Windows电脑开启Hyper-V时，此刻我们启动安卓模拟器(夜神)时就会蓝屏 5.bin/sh和bin/bash的区别这是两种不同的Linux shell，有的container两种都有，有的只有sh，有的只有bash。比如我们要获取一个nginx镜像，同一镜像存在有不同的tags /bin/sh命令仅适用于tags带alpine标签的： nginx:1.17-alpine； /bin/bash命令仅适用于tags不带alpine标识的：nginx:latest、nginx:1.8… 6.数据卷挂载式创建容器12345守护式：docker run -di [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine交互式：docker run -it [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine含义： a） 以-v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw 带rw(read,write)权限来将宿主机与容器进行数据卷挂载 b) docker run 以新容器名和端口号以及守护式或者交互式来创建容器 7.宿主机与docker容器权限纠纷问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它来了！问题又出现了！哭啦。数据卷挂载时，即使声明了rw权限，在宿主机中创建文件，数据共享后，容器内能够具有正常的rw权限；但在容器内新建了文件后，宿主机就只有只读权限，无法修改文件内容。 解决方案：宿主机的权限不够&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在（7）式中的万能公式中添加：docker run ··· --privileged=true ··· 8.docker配置nginx的配置文件我都想把它杀了，部署nginx太多坑了，不过参考了此博文，最终解决了问题，解决方法： 1.创建三个根目录根据情况创建：/docker/nginx/conf www logs docker run -d -p 80:80 --name=”nginx” --net host -v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/logs:/var/log/nginx nginx:1.17.5 2.不对配置文件进行数据挂载即 -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf 这个 3.进入容器 获取文件 docker exec -it nginx /bin/bash 4.cd /etc/nginx/ （这里主要获取配置文件路径的）,然后exit 5.数据拷贝 进入宿主机目录文件 cd /docker/nginx/conf/将已经运行成功的容器的配置文件拷贝到宿主机的配置文件目录：docker cp 容器ID:/etc/nginx/nginx.conf .（ps：“.”表示拷贝到当前目录） ps：文件copy成功后 把nginx容器先删除掉 6.创建最终的nginx容器 script123456789docker run -di -p 80:80 --name nginx # [--net host] :再思考一下有没有必要写，使用–net = host时,它告诉容器使用主机网络堆栈.# 因此无法将端口暴露给主机,因为它是主机(就网络堆栈而言).-v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf-v /docker/nginx/logs:/var/log/nginx nginx:1.17.5ps:成功后就代表部署成功 2019-11-29 新增：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里宿主机的nginx.conf其实是挂载了一个文件，docker是不推荐这样使用的，可以尝试在宿主机上创建目录为：/docker/nginx/conf/nginx.conf/nginx.conf(当前conf文件是一个具体的配置文件，不是一个目录)，这样上式就不会出现docker warning，结合此篇文章 。 PS：访问可能会403 因为/docker/nginx/www/ 里面没有index.html放进去就好了 7.权限赋予 挂载成功后，给宿主机上的www目录（或整个文件目录）增加权限，不然一直无法读写：&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod -R 777 目标目录 ：给目标目录赋予最大管理员权限&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod +/-rwx 文件名|目录 给文件或目录的赋予权限 9.docker配置MySQLscript123456docker run -di -p 12345:3306 --name=\"mysql\" -v /lnmp/mysql/conf:/etc/mysql/conf.d -v /lnmp/mysql/logs:/logs -v /lnmp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456:rw mysql:5.6 命令说明：-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。--name mysql：运行服务名字-v /lnmp/mysql/conf:/etc/mysql/conf.d ：将主机/lnmp/mysql录下的conf/my.cnf 挂载到容器的 /etc/mysql/conf.d-v /lnmp/mysql/logs:/logs：将主机/lnmp/mysql目录下的 logs 目录挂载到容器的 /logs。-v /lnmp/mysql/data:/var/lib/mysql ：将主机/lnmp/mysql目录下的data目录挂载到容器的 /var/lib/mysql-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。-d mysql:5.6 : 后台程序运行mysql5.6 10.容器管理工具portainer使用 这个数据卷用于持久化Portainer数据 docker volume create portainer_data 创建相关portainer容器 script12345docker run -di \\-p 9000:9000 \\-v /var/run/docker.sock:/var/run/docker.sock \\-v portainer_data:/data \\portainer/portainer 12.外部Windows如何访问docker内的容器 1.基本架构：Windows，Dockers，Linux三者关系 2.相关操作 2.1 关闭Linux防火墙：systemctl stop firewalld.service 2.2 查看Linux，Docker的IP地址:ifconfig(区别于Windows的ipconfig命令) 2.3 Windows访问测试: 思想：docker作为一个容器虚拟技术，创建并启动相关的容器服务，并把端口映射到Linux系统中。比如MySQL：docker启动MySQL服务后，并映射了一个外部访问的某端口（比如还是3306），则此刻Linux就具有了3306这个一个端口=&gt;外界访问方式应该是：访问虚拟机Linux上与之相绑定docker容器映射出的端口。 2019-11-27 新增：Linux:在 windows 系统中访问 linux 中 nginx，默认不能访问的，因为防火墙问题,即我们可以有两种解决方法（1）关闭防火墙：参考上述相关操作（2）开放访问的端口号，比如80端口，操作如下： 查看开放的端口号 firewall-cmd --list-all 设置开放的端口号 firewall-cmd --add-service=http --permanentfirewall-cmd --add-port=80(或其它开放端口号)/tcp --permanent 重启防火墙 firewall-cmd --reload Ubuntu:Ubuntu与linux对于防火墙的操作存在很大的区别：注意区分1、查看端口开启状态（inactive表示已经关闭了防火墙）sudo ufw status 2、开启某个端口，比如我开启的是3306sudo ufw allow 3306 3、开启防火墙sudo ufw enable 4、关闭防火墙sudo ufw disable 5、重启防火墙sudo ufw reload 6、禁止外部某个端口比如80sudo ufw delete allow 80 7、查看端口ipnetstat -ltn 参考文章 docker上启动nginx,并配置修改nginx的配置文件 Portainer容量管理工具的基本使用","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"}]},{"title":"Vue(一):基础知识","slug":"Vue(一)","date":"2019-11-07T16:00:00.000Z","updated":"2021-09-18T02:10:06.000Z","comments":true,"path":"2019/11/08/Vue(一)/","link":"","permalink":"https://ahrilove.top/2019/11/08/Vue(%E4%B8%80)/","excerpt":"1.vue基础2.vue指令3.vue的组件","text":"1.vue基础2.vue指令3.vue的组件 1.vue基础结构如何创建一个Vue示例：new Vue()实例化，其传入参数是一个对象，我们回忆一下js中的对象到底应该怎样规范书写？ 1234567891011// javascript对象的规范写法let person = &#123; //这里的person称为对象 firstName:\"Bill\", // 这是属性 lastName:\"Gates\", age:62, eyeColor:\"blue\", fullName : function() &#123; // 这就是对象中方法的标准写法 return this.firstName + \" \" + this.lastName; &#125;&#125;;person.fullName(); vue配置常用的属性和方法： el: Vue实例挂载的元素节点，值可以是 CSS 选择符，或实际 HTML 元素，或返回 HTML 元素的函数。 data: 数据存储地方，data的类型可以是object，但在组件（component）里的定义的data必须是方法类型的，且需要使用return返回包裹的数据 =&gt; 详细缘由 computed:数据类型是对象object，也称为计算属性。计算属性允许我们对指定的视图，复杂的值计算。这些值将绑定到依赖项值，只在需要时更新。 created: 在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 mounted: 数据类型是function。在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。 methods: 必须要有一定的触发条件才能执行，如点击事件 watch: 它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。所以他们的执行顺序为：默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。 1234567891011121314// 实例化一个Vue示例对象，并介绍基本结构let app = new Vue(&#123; el:\"#app\", data:&#123;&#125;, computed:&#123;&#125;, created()&#123; // vue的函数写法一 &#125;, mounted:function() &#123; // vue的函数写法二 &#125;, methods:&#123;&#125;, watch:&#123;&#125; &#125;) 2.vue指令指令(Directives)是带有v-前缀的特殊attribute，常用指令： v-bind单向绑定 属性绑定，语法 v-bind:属性名=&quot;常量||变量名&quot; 1234&lt;!--元素绑定：这里的href是参数，是将url的值绑定到href上，类似于赋值--&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt; HTML Class绑定：将v-bind用于class和style时，表达式结果的类型除了字符串之外，还可以是对象或数组 对象语法： 12345678910html:&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt;Vue.js:data: &#123; isActive: true, hasError: false&#125;结果渲染为：&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; 数组语法： 1234567&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125;渲染结果为：&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 同时，单向绑定的数组语法也支持使用三元表达式 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; 绑定内联样式Style 对象语法：CSS property名可以用驼峰式(camelCase)或短横线分隔(kebab-case，记得用引号括起来)来命名 1234567891011121314&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125;# 写法二：这样会让模板更清晰&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; 数组语法 v-bind:style的数组语法可以将多个样式对象应用到同一个元素上： 12345678910&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;data: &#123; baseStyles: &#123; color: &apos;green&apos;, fontSize: &apos;30px&apos; &#125;, overridingStyles: &#123; &apos;font-weight&apos;: &apos;bold&apos; &#125;&#125; v-if/show条件渲染 语法：v-if...v-else-if...v-else v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；而v-show只是进行简单的CSS样式display切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好 1234&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;data: &#123; ok: false&#125; v-for循环指令 v-for 指令需要以 site in sites 形式的特殊语法，它可以适用于数组，对象和整数 1234567891011# 循环数组&lt;li v-for=&quot;site in sites&quot;&gt;值：&#123;&#123; site &#125;&#125;&lt;/li&gt;&lt;li v-for=&quot;(site, index) in sites&quot;&gt;索引：&#123;&#123;index&#125;&#125; - 值：&#123;&#123; site &#125;&#125;&lt;/li&gt;# 循环对象：注意，参数分配有（值，键名，索引）&lt;li v-for=&quot;site in sites&quot;&gt;值：&#123;&#123; site &#125;&#125;&lt;/li&gt;&lt;li v-for=&quot;(site, key) in sites&quot;&gt;值：&#123;&#123; site &#125;&#125; - 键名:&#123;&#123;key&#125;&#125;&lt;/li&gt;&lt;li v-for=&quot;(site, key, index) in sites&quot;&gt;值：&#123;&#123; site &#125;&#125; - 键名:&#123;&#123;key&#125;&#125; - 索引值：&#123;&#123;index&#125;&#125;&lt;/li&gt;# 循环整数：注意，起始值为1&lt;li v-for=&quot;site in 10&quot;&gt;值：&#123;&#123; site &#125;&#125;&lt;/li&gt; v-on事件监听指令 在开发过程中经常需要监听用户的输入，比如：用户的点击事件、拖拽事件、键盘事件等等，这就需要用到v-on指令，它也可以缩写为@，v-on指令监听DOM事件，并在触发时运行一些JavaScript代码。 常用事件：click，change，focus，blur，keyup，keydown等等 事件修饰符： stop修饰符，可以阻止事件向上级标签的冒泡行为 self修饰符，表示被该修饰符修饰的父元素不接收子元素的事件冒泡行为 prevent修饰符，可以阻止一些html标签的默认行为，比如a标签 enter修饰符（按键监听修饰符的一种），可以监听回车按键的操作 once修饰符，表示事件只可以被触发监听一次，以后再操作则无效 capture修饰符，表示开启事件传播的捕获模式，事件由父元素向子元素传播，较少用到 v-model双向绑定 v-model 指令在表单&lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;元素上创建双向数据绑定 v-model 在内部为不同的输入元素type使用不同的 property 并抛出不同的事件： text，password和 textarea 元素使用 value property 和 input 事件 checkbox 和 radio 使用 checked property 和 change 事件 select 字段将 value 作为 prop 并将 change 作为事件 12345678910111213141516171819202122232425262728# 单行文本&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;# 多行文本&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;# 单选按钮&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;# 复选框&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;data: &#123; checkedNames: []&#125;# 下拉框&lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt;data: &#123; selected: &quot;&quot;&#125; 3.vue的组件 1.组件创建方式分为全局组件与局部组件： &nbsp;&nbsp;&nbsp;全局组件：可以被多个APP进行调用,在APP实例外创建;定义一个名为 button-counter 的新组件:组件名称若使用驼峰原则，引用组件时需要全部小写，并且两个单词之间用“-”连接;若不使用驼峰原则时，直接使用原组件名 全局组件创建方式一： 12345678910Vue.component('buttonCounter', &#123; data: function () &#123; // 1.组件可以有自己的data数据，组件中的data必须是一个方法，且这个方法内部必须返回一个对象才行，而实例中的data可以为一个对象 return &#123; count: 0, info: 'hello world' &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;&#123;&#123;message&#125;&#125; clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;' // 2. 全局组件有template属性 &#125;) 全局组件创建方式二：调用公共模板对象 12345678910111213&lt;script&gt; let project=&#123; template:&apos;&apos;, data:function()&#123; // 组件中的data必须是一个方法 return &#123; info:&apos;hello world&apos;, message:&apos;badwoman&apos; &#125;, methods:&#123;&#125; &#125; Vue.component(&apos;组件名&apos;,project); &#125;&lt;/script&gt; 全局组件创建方式三：调用公共模板对象–其实这也是全局组件的一种创建方式，将template绑定到自身data函数中，此刻的data不同于实例中的data，此刻为一个函数 123456789101112131415161718192021222324&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj = &#123; count: 0 &#125;; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component('counter', &#123; data: function () &#123; // return dataObj return &#123; count: 0 &#125; &#125;, template: '#tmpl', methods: &#123;&#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;) &lt;/script&gt; 参考文章 Vue标准写法以及关于computed、methods、watch，mounted的区别 v-on事件监听指令的基本用法","categories":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://ahrilove.top/tags/vue/"}]},{"title":"Hexo主体设置知识点","slug":"Hexo主体设置知识点","date":"2019-10-26T13:28:53.000Z","updated":"2020-04-03T02:16:00.000Z","comments":true,"path":"2019/10/26/Hexo主体设置知识点/","link":"","permalink":"https://ahrilove.top/2019/10/26/Hexo%E4%B8%BB%E4%BD%93%E8%AE%BE%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法","text":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法 1.Hexo创建文章、标签、分类的Front-matter方法 Ⅰ&nbsp;&nbsp; Front-matter ⅡFront-matter 是md文件最上方以 — 分隔的区域，用于指定个别文件的变量 其实Front-matter就是在\\Hexo\\source_posts下的.md文件中书写文章标题，上传时间，分类名，标签名等等 字段 含义 值类型 默认值 layout 布局模版 String - title 标题 String - date 创建时间 Date 文件创建时间 description 页面描述、摘要 String - cover 是否显示封面 Bool true 2.Markdown标题页的写法 --- layout: 页面布局（配合主题文档使用） title: 文章名称 date: 文章日期 comments: 文章是否开启评论 photos: 文章封面图（仅部分主题支持） tags: - 文章标签一 - 文章标签二 categories: # 文章分类（文章分类等级） - 父分类 - 子分类 - 孙分类 description: 文章描述，即要在首页显示的摘要（仅部分主题支持） --- 这里是摘要 这里是正文 注意：description 和 方式显示摘要二选一即可，部分主题不支持description， 每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档 3.md文件的基本写法【Markdown写法大全】 3.1. ``` 代码段 ``` : 表示以原格式展示代码片段。比如 1234567891011121314$(function () &#123; ...... //鼠标进入的时候,其他的li标签透明度：0.5 $(&quot;.wrap li&quot;).hover(function() &#123; $(this).siblings().stop().fadeTo(400, 0.5); //.stop():停止所有在指定元素上正在运行的动画。 &#125;, function() &#123; // 鼠标离开，其他li 透明度改为 1 $(this).siblings().stop().fadeTo(400, 1); &#125;); console.log($(&apos;.attr a&apos;).prop(&apos;href&apos;)); console.log($(&apos;.attr a&apos;).prop(&apos;title&apos;)); console.log($(&apos;input:checkbox&apos;).attr(&apos;id&apos;)); console.log($(&apos;.office p:eq(0)&apos;).scrollTop());&#125;) 3.2. &lt;img src=”url” width=” “&gt; &nbsp;&nbsp;&nbsp;表示在md文件中展示图片，若不想破坏图片原格式，就只需要写width或者height其中一个，另一个会自适应变化 3.3. 文本修饰:粗体，斜体… &nbsp;&nbsp;&nbsp;粗体文本用两个*或_包含，斜体文本用两个_或*包含 3.4. 表格(注意其格式) 语法说明： 第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 3.5. 颜色RGB和字体以及背景颜色 12345678910&lt;font face=\"Tahoma\"&gt;这是一串Tahoma字体&lt;/font&gt;&lt;br/&gt;&lt;font face=\"黑体\"&gt;这是一串黑体字&lt;/font&gt;&lt;br/&gt;&lt;font face=\"微软雅黑\"&gt;这是一串微软雅黑&lt;/font&gt;&lt;br/&gt;&lt;font face=\"STCAIYUN\"&gt;这是一串华文彩云&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ced1 size=7 face=\"黑体\"&gt;背景色+字体+字的size&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ffff size=72&gt;颜色设置&lt;/font&gt;&lt;br/&gt;&lt;font color=gray size=72&gt;灰色处理&lt;/font&gt;&lt;br/&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#bfe1f1&gt;背景色是：#bfe1f1&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 这是一串Tahoma字体这是一串黑体字这是一串微软雅黑这是一串华文彩云背景色+字体+字的size颜色设置灰色处理 3.6. 转义字符 &lt;br&gt; : 换行\\ : 转义字符，原生字符，不加修饰&amp;nbsp; : 空格 3.7 每一篇博文设置图片 只需要在文章前面配置 photos 关键字即可，若没有这种配置，可以选择在正文插入图片，然后使用 将图片显示在摘要里 3.8 Markdown的todo list写法 代码： 12345678近期任务安排:- [x] 整理Markdown手册- [ ] 改善项目 - [x] 优化首页显示方式 - [x] 修复闪退问题 - [ ] 修复视频卡顿- [ ] A3项目修复 - [x] 修复数值错误 显示效果： 3.9 hexo-matrix主题支持图片缩放设置 &lt;fancybox&gt;图片设置&lt;/fancybox&gt; 3.10 列表嵌套 上一级和下一级之间敲三个空格即可 1234567891011+ 一级无序列表内容 * 二级无序列表内容(三个空格) * 二级无序列表内容 * 二级无序列表内容+ 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容 4.Hexo的搜索search功能设置问题描述： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的博客中点击search，输入相关关键字后，点击查询到的相关文章，会出现404错误 解决方法： 1.检查是否安装文档要求正确的安装了依赖包。2.检查根目录配置文件是否有search字段冲突（我的根目录配置文件中没有search字段）。3.检查我们的主题（我使用的是Material X主题）的配置文件是否开启search功能 1234567891011121314151617# 搜索配置search: enable: true service: hexo # google google_api_key: google_engine_id: # algolia algolia_app_id: algolia_api_key: algolia_index_name: # azure azure_service_name: azure_index_name: azure_query_key: # baidu baidu_api_id: 4.这是最容易忽略的，但往往也是问题出现的源头，请检查根目录配置文件中的链接是否正确，如： 1234url: https://fioralove.github.io# 这里似乎存在一个bug，推荐填写GitHub Page的访问地址，不要使用自己在阿里云以及其它的域名注册服务商所提供的地址# 比如我在阿里云所注册的https:AhriLove.top，填上依旧会出现404错误root: / 5.封面轮播图封面幻灯片轮播图片怎么引入本地的照片？？修改主题下_config.yml文件，里面有个banner改一下，多加几行即可 6.front-matter设置123456789101112131415161718192021222324252627282930313233front-matter是指两个\\---之间的内容\\---title: Javascript篇章四：快速入门// 小图标icons: [fas fa-fire accent]date: 2019-11-21toc: true #是否显示文章目录categories: #分类 - javascript// 是否显示封面 cover: truetags: #标签// 是否置顶文章top: true// 文章右边的音乐块music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID// 作者相关信息块author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.commeta: header: \\[title, author, date, categories, counter, top] footer: \\[updated, tags, share]---// 文章描述&lt;!-- more --&gt;","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"https://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"front-matter","slug":"front-matter","permalink":"https://ahrilove.top/tags/front-matter/"}]},{"title":"Hello Hexo","slug":"hello-world","date":"2019-10-24T16:00:00.000Z","updated":"2019-11-10T07:53:26.000Z","comments":true,"path":"2019/10/25/hello-world/","link":"","permalink":"https://ahrilove.top/2019/10/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"初次见面，请多关照","slug":"初次见面_请多关照","date":"2019-10-20T13:01:24.000Z","updated":"2019-12-08T10:45:38.000Z","comments":true,"path":"2019/10/20/初次见面_请多关照/","link":"","permalink":"https://ahrilove.top/2019/10/20/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2_%E8%AF%B7%E5%A4%9A%E5%85%B3%E7%85%A7/","excerpt":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示","text":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示 大家好–^^__^^–，我叫陈浩东 &nbsp;&nbsp;&nbsp;作为GP-12线,滚齿磨齿操作员，目前正学习清洗包装流程、磨齿、滚齿、齿轮生产工艺以及安全生产。&nbsp;&nbsp;&nbsp;对网站开发的有关知识几乎为零，这也是我搭建好自己的不完全博客之后写的第一篇博客，刚开始搭建博客的时候自己也是网上各种百度，由于自己属于小白那种，历经了千辛万苦才弄好，所以借这个机会会一直坚持下去分析自己的知识，一起走向成功的彼岸！","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"https://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"Github Page","slug":"Github-Page","permalink":"https://ahrilove.top/tags/Github-Page/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ahrilove.top/tags/Hexo/"}]},{"title":"Maven的安装搭建补充点","slug":"Maven","date":"2019-04-10T16:00:00.000Z","updated":"2020-04-11T02:37:30.000Z","comments":true,"path":"2019/04/11/Maven/","link":"","permalink":"https://ahrilove.top/2019/04/11/Maven/","excerpt":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。 本文要点：1.理清Maven概念2.安装教程点","text":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。 本文要点：1.理清Maven概念2.安装教程点 1.理清概念 Maven是Apache下的一个纯java开发的开源项目，它是一个项目管理工具，使用maven对java项目进行构建、依赖管理。 通俗的来说Maven就是一款帮助程序员构建项目的工具，我们只需要告诉Maven需要哪些Jar 包，它会帮助我们下载所有的Jar，极大提升开发效率 2.安装易错点最主要的步骤： 配置环境变量 解压后的conf/settings.xml文件进行配置 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--配置镜像文件--&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;!--配置本地仓库（指定依赖下载的文件目录）--&gt; &lt;localRepository&gt;D:\\data\\MavenRepository&lt;/localRepository&gt;&lt;!--声明jdk版本--&gt; &lt;profiles&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profiles&gt; 将配置的settings.xml文件必须要复制一份到&lt;localRepository&gt;的本地仓库中","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://ahrilove.top/tags/Maven/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}}]}