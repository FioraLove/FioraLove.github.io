{"meta":{"title":"AhriLove","subtitle":null,"description":null,"author":"AhriLove","url":"https://ahrilove.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-06T07:08:15.056Z","updated":"2019-12-06T07:08:15.008Z","comments":true,"path":"404.html","permalink":"https://ahrilove.top/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2019-12-23T14:19:55.741Z","updated":"2019-12-23T14:19:55.677Z","comments":true,"path":"about/index.html","permalink":"https://ahrilove.top/about/index.html","excerpt":"","text":"君の名は .container { margin: 0 auto; } .content { max-width: 800px; margin: 0 auto; } .content img { max-width: 100%; } @media (max-width: 900px) { .content { max-width: 100%; margin: 20px; } } 我一路向北，离开有你的季节 慢慢的写，好好的活 起笔： 人们常说，心中有梦，不怕天涯路远，眼里有情，何惧秋风寒呢！一直向前拼命走着，也时刻在做着虚幻的梦，不肯醒来。当时光偷换了年华，光阴在疯长，一切却如同昨日云烟，转瞬即逝，刹那的一念起，缘起缘灭，转身的一瞬间，便是沧海桑田，那些青春年少的时光曾经飘荡在云端上的梦，与我隔着那样遥远的距离。 蓦然回首这半生走过的足迹，层层叠叠于时光的转角处，虽已模糊不清，却依旧感慨万千。角落里的花，悄然绽放，无需观众，也同样精彩。一直认为，一个真正内心富有的人，不需要太张扬的个性，看重浮华名利的背后，鲜花和掌声再多么热情，也和价值无关。 时间可以改变一切，比如年轮，容貌，却无法改变一个人思乡情结。离别故乡多年，漂泊在外的脚步疲惫不堪，乡愁也日益浓郁。时常独自站在深夜里，举目眺望深邃的夜空，遥望故乡的方向，一幕幕的往事总会浮现在眼前。故乡的一草一木，一屋一舍，亲人们的笑脸和嘱托，儿时的时光总能勾起深深的回忆。 随着年轮的增长，岁月的叠加，我被时光无情的隔在了这头。如今，童年的玩伴早已长大，昔日嬉戏玩耍的画面早已被光阴无情的掩埋，成了名副其实的沙漏。 记得上次回故乡的时候，路上遇到了邻里的大叔一下子愣住了。以前一口气能扛几十个麻袋粮食都面不改色的大叔，硬朗的身板，如今已经驼背了，走路蹒跚，满脸皱纹，鬓角斑白，面对面的时候我们似乎都愣在原地，一时间名字在嘴边却说不出来了。迟疑了片刻才缓过神来，热情的打起了招呼。大叔憨厚的笑声依旧爽朗，拉住我的手亲切的问候着，眼神里却带着些许的生疏和感动。 2019-6-5 : 今天我毕业啦 我们只是老师送走的其中一届，但是老师们确实我们的唯一一批 多希望有一天突然惊醒，发现自己在高三的一节课上睡着了，现在经历的一切都是一场梦，桌上满是你的口水。你告诉同桌，说做了个好长的梦。同桌骂你白痴，叫你好好听课。你看着窗外的球场，一切都那么熟悉，一切还充满希望... 大学似乎是中了单身魔咒，1号楼东 111寝室，简直不能再邪乎了，但也可以叫做龙潭，因为我们寝室出了两条龙，他们都在各自的领域取得了不小的成就，努力向他们靠拢。我的大学室友：胡某，张先生，家义123，周队，还有我自己陈某... 这是我们大一冬天的合照，好像是因为寝管阿姨叫每一个寝室都拍一张，发在寝室管理群里... 这就是我们最后离校最后几天，一起合照 如果你喜欢这个相册，那么你可能也喜欢: Hi-Si ？？？ 英雄联盟"},{"title":"所有分类","date":"2019-11-05T14:21:22.930Z","updated":"2019-10-25T13:05:49.103Z","comments":true,"path":"categories/index.html","permalink":"https://ahrilove.top/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-12-19T08:36:45.312Z","updated":"2019-12-19T08:36:45.279Z","comments":true,"path":"friends/index.html","permalink":"https://ahrilove.top/friends/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;欢迎大家留言分享自己发掘的优秀博文、微信文章、GitHub开源项目、二次元、摄影、运动、读书、影视…-留言请告诉我你的名称、主页、头像、标签或者简介哦～-如果想定制你的卡片颜色，也可以留言告诉我哦～（十六进制颜色码，如：#FF0000）"},{"title":"","date":"2019-12-06T12:22:18.383Z","updated":"2019-12-06T12:22:18.262Z","comments":true,"path":"game/index.html","permalink":"https://ahrilove.top/game/index.html","excerpt":"","text":"轻松一刻 body{ background-image:url(http://pic1.win4000.com/wallpaper/2019-09-20/5d84387f09a52.jpg); } 开始 简单 简单 入门 阿三 外星人 仙人"},{"title":"","date":"2019-12-06T05:56:16.124Z","updated":"2019-12-06T05:56:16.093Z","comments":true,"path":"mylist/index.html","permalink":"https://ahrilove.top/mylist/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;我从来不记在辞典上已经印有的东西。我的记忆力是运用来记忆书本上还没有的东西。 ——爱因斯坦&nbsp;&nbsp;在这主题页中我将分享自己收集的一些资料以及文档 优秀博客或文章 链接 RGB颜色对照表 https://www.114la.com/other/rgb.htm 比较柔和的配色表 https://www.geticsen.cn/Index/article/content/151.html Hexo的ico图标 http://www.wapadd.cn/icons/awesome/index.htm bilibili视频收藏 https://space.bilibili.com/215893581/favlist git详细教程 https://blog.csdn.net/u011535541/article/details/83379151 Django2.0详细资料文档 https://pan.baidu.com/s/1ppN8GSDdOdcd3ew0e7SxMQ 开发书籍电子版大全 https://pan.baidu.com/s/1HJtB9EieaMZPU0fSK2kgkQ docker详情mindmanage https://pan.baidu.com/s/1nUE4pfe2wThYVGMEYqADXw 网络用语大全~小鸡词典 https://jikipedia.com/ Vue-Devtools最简单的配置，有手就行 https://blog.csdn.net/weixin_38654336/article/details/80790698 Jetbrains全家桶注册码 http://www.medeming.com/ 阿里中间件团队博客 http://jm.taobao.org/ font-awesome ico小图标 https://fontawesome.com/icons?d=gallery&amp;m=free 亲测可用：navicat premium12 破解教程 https://blog.csdn.net/u013162035/article/details/89456708 小马视频码云仓库 https://gitee.com/komavideo/projects 服务端高并发分布式架构演进之路(天猫) https://segmentfault.com/a/1190000018626163 看完这篇还不了解Nginx，那我就哭了！ https://www.cnblogs.com/wcwnina/p/8728391.html#!comments Nginx笔记一 http://www.edrawsoft.cn/viewer/public/s/e194d338895116 Nginx安装配置笔记二（完整版） 链接：https://pan.baidu.com/s/1bTVdjwFl-kyd93C2GksZQQ 提取码：63x6 将table转变为Makedown,CSV,json,sql,yaml,html,excle https://tableconvert.com/"},{"title":"所有标签","date":"2019-11-05T14:21:22.945Z","updated":"2019-10-25T13:06:22.321Z","comments":true,"path":"tags/index.html","permalink":"https://ahrilove.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-06T14:22:21.947Z","updated":"2019-12-06T14:22:21.853Z","comments":true,"path":"cv/index.html","permalink":"https://ahrilove.top/cv/index.html","excerpt":"","text":"AhriLove'S BLOG | OFFER document.onkeydown = function () { if (window.event && window.event.keyCode == 123) { event.keyCode = 0; event.returnValue = false; return false; } }; 您的浏览器不支持audio标签，无法播放音乐！ 自称：陈某（师从盛建彬） 籍贯：中国 | 四川 | 绵阳 （俺木拆里斯） 生辰：1997（98年是真滴牛批，玩不过她，5555） 兴趣爱好：健身 | 编程 | 土味 | 钓鱼 技能 | Skill HTML/CSS/JS 35% PHP 10% 数据分析/爬虫 52% PYTHON 75% SQL 38% PS/剪辑 45% 简介 | Introduction ● 学历：高中文凭 ● 现况：脑瘫前端 | 学js逆向爬虫中 | 学习后端方向； ● 目标：不脑瘫前端 | 全栈 | 专升本，完成大学学业； ● 博客：只有能被明日的我们所铭记，今日才有意义（--源计划·艾希）； ● 兴趣：先打一拳，打的时候再把问题问遍（-- 源计划·蔚） ● 其他：虽然我学历低，但是在努力学习中！ 联系我 | Contact me Copyright © 2019 AhriLove'S BLOG. All rights reserved. if ('addEventListener' in window) { window.addEventListener('load', function () { document.body.className = document.body.className.replace(/\\bis-loading\\b/, ''); }); document.body.className += (navigator.userAgent.match(/(MSIE|rv:11\\.0)/) ? ' is-ie' : ''); } uniform mat4 uProjection; uniform mat4 uModelview; uniform vec3 uResolution; uniform vec3 uOffset; uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start attribute vec3 aPosition; attribute vec3 aEuler; attribute vec2 aMisc; //x:size, y:fade varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; void main(void) { // Projection is based on vertical angle vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0); gl_Position = uProjection * pos; gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5; pposition = pos.xyz; psize = aMisc.x; pdist = length(pos.xyz); palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z); vec3 elrsn = sin(aEuler); vec3 elrcs = cos(aEuler); mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, elrcs.x, elrsn.x, 0.0, -elrsn.x, elrcs.x ); mat3 roty = mat3( elrcs.y, 0.0, -elrsn.y, 0.0, 1.0, 0.0, elrsn.y, 0.0, elrcs.y ); mat3 rotz = mat3( elrcs.z, elrsn.z, 0.0, -elrsn.z, elrcs.z, 0.0, 0.0, 0.0, 1.0 ); mat3 rotmat = rotx * roty * rotz; normal = rotmat[2]; mat3 trrotm = mat3( rotmat[0][0], rotmat[1][0], rotmat[2][0], rotmat[0][1], rotmat[1][1], rotmat[2][1], rotmat[0][2], rotmat[1][2], rotmat[2][2] ); normX = trrotm[0]; normY = trrotm[1]; normZ = trrotm[2]; const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237); float tmpdfs = dot(lit, normal); if(tmpdfs < 0.0) { normal = -normal; tmpdfs = dot(lit, normal); } diffuse = 0.4 + tmpdfs; vec3 eyev = normalize(-pos.xyz); if(dot(eyev, normal) > 0.0) { vec3 hv = normalize(eyev + lit); specular = pow(max(dot(hv, normal), 0.0), 20.0); } else { specular = 0.0; } rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0); rstop = pow(rstop, 0.5); //-0.69315 = ln(0.5) distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y)); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start const vec3 fadeCol = vec3(0.08, 0.03, 0.06); varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; float ellipse(vec2 p, vec2 o, vec2 r) { vec2 lp = (p - o) / r; return length(lp) - 1.0; } void main(void) { vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0; vec3 d = vec3(0.0, 0.0, -1.0); float nd = normZ.z; //dot(-normZ, d); if(abs(nd) < 0.0001) discard; float np = dot(normZ, p); vec3 tp = p + d * np / nd; vec2 coord = vec2(dot(normX, tp), dot(normY, tp)); //angle = 15 degree const float flwrsn = 0.258819045102521; const float flwrcs = 0.965925826289068; mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs); vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm; float r; if(flwrp.x < 0.0) { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5); } else { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5); } if(r > rstop) discard; vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r); float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35)); col *= vec3(1.0, grady, grady); col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3)); col = col * diffuse + specular; col = mix(fadeCol, col, distancefade); float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0; alpha = smoothstep(0.0, 1.0, alpha) * palpha; gl_FragColor = vec4(col * 0.5, alpha); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec2 uTimes; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec3 col; float c; vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0); c = exp(-pow(length(tmpv) * 1.8, 2.0)); col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c); gl_FragColor = vec4(col * 0.5, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; uniform vec4 uBlurDir; //dir(x, y), stride(z, w) varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta); col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta); gl_FragColor = col / 5.0; } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_FragColor = texture2D(uSrc, texCoord); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform sampler2D uBloom; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 srccol = texture2D(uSrc, texCoord) * 2.0; vec4 bloomcol = texture2D(uBloom, texCoord); vec4 col; col = srccol + bloomcol * (vec4(1.0) + srccol); col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5); col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2) gl_FragColor = vec4(col.rgb, 1.0); gl_FragColor.a = 1.0; }"},{"title":"逆水行舟用力撑，一篙松劲退千寻","date":"2019-12-16T07:41:46.457Z","updated":"2019-12-16T07:41:46.389Z","comments":true,"path":"sport/index.html","permalink":"https://ahrilove.top/sport/index.html","excerpt":"","text":"Daily PLAN1.每天两则HTML，jQuery，Vue，PHP，docker，服务器，ThinkPHP，读英语 2019-11-12 planning: 1.数据库基础2.python的字符串，字典，列表，元组，序列 2019-11-14 planning: 1.学习归纳json知识2.json_decode3.json_encode与thinkPHP 2019-12-2 planning: 1.pyhton的ftp库 2.python的time，datetime库 3.python的多线程，多进程 4.DBUtils管理数据库连接池 5.未完待续… 2019-12-9 planning: 1.温习一下php，vue2.完成PHP防止SQL注入3.温习python爬虫解析库4.开始学习js5.逐渐学习Java起来 2019-12-11 planning: 1.完成博客的轮播图片2.完成博客的简历3.继续js的学习和vue4.ps AhriLove博客首页5.数学 2019-12-16 summarize: 最近很迷茫，不知道在干什么，总结一下自己用到的知识，与此对比，查漏补缺：1.Pyhton2.html,css,javascript3.jQuery4.PHP,ThinkPHP5.Vue6.Bootstrap7.Echarts8.git，hexo9.SQl:mysql,oracle,Memcached,redis10.docker11.Ubuntu&amp;&amp;Linux"}],"posts":[{"title":"2020 新年快乐  \\﻿ (•◡•) /","slug":"HappyNewYear","date":"2020-01-23T16:00:00.000Z","updated":"2019-12-16T01:53:42.342Z","comments":true,"path":"2020/01/24/HappyNewYear/","link":"","permalink":"https://ahrilove.top/2020/01/24/HappyNewYear/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章一：TypeScript基本知识","slug":"TypeScript篇章（一）","date":"2019-12-22T16:00:00.000Z","updated":"2019-12-23T06:19:44.948Z","comments":true,"path":"2019/12/23/TypeScript篇章（一）/","link":"","permalink":"https://ahrilove.top/2019/12/23/TypeScript%E7%AF%87%E7%AB%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS作为一门动态弱类型语言,对变量类型非常宽容,使得语言具有极大”灵活性”,同时这也是JS的一种”缺陷”.如果在一年前,可能TypeScript还不是刚需,但按目前的趋势看,不管是对于JS语言本身还是开发者类型思维的塑造,TypeScript已经是开发者的必备技能,ES6,TypeScript等也都是面试中经常会被问到的点. 本文要点：1.变量及数据类型2.对象3.javascript小知识点","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS作为一门动态弱类型语言,对变量类型非常宽容,使得语言具有极大”灵活性”,同时这也是JS的一种”缺陷”.如果在一年前,可能TypeScript还不是刚需,但按目前的趋势看,不管是对于JS语言本身还是开发者类型思维的塑造,TypeScript已经是开发者的必备技能,ES6,TypeScript等也都是面试中经常会被问到的点. 本文要点：1.变量及数据类型2.对象3.javascript小知识点 1.TS的数据类型6种基本数据类型：boolean，number，string，symbol，undefined，null，void，any，never，元组，枚举，高级类型 3种引用类型：array，function，object 2.变量声明 1.简单数据类型定义 语法:变量修饰符 变量名/函数:数据类型 = value 123456// Boolean类型let flag:boolean = true;// number数值类型let age:number = 18;// string字符串类型let username:string = \"chd\"; 2.数组类型 数组定义方法:let array1:Array&lt;number|string|object…&gt;;let array2:number[];let array3:any[]; 1234567// arr:number[]要加一个[]表示一维数组，数组创建方式一：基本数组定义var arr1:number[] = [1,2,3];var arr2:string[] = [\"chd\",\"sgx\",\"lmm\"];// 数组创建方式二：数组泛型定义var arr3:Array&lt;number|string|object&gt; =[\"蒙\",18,&#123;school:\"Tinghua\",height:1.75&#125;];// 数组创建方式三：anylet arr4:any[] = ['Xcat Liu', 25, &#123; website: 'http://xcatliu.com', port:3306&#125;]; 3.元组类型 元组是一种限制数组的元素类型和个数的数组,此时,如果改变数组的元素类型或添加元素数量,编辑器都会报错: 1let tuple: [number, string,object] = [0, '1', &#123; website: 'http://xcatliu.com', port:3306&#125;] 元组越界问题:虽然元组限制了数组元素的类型和数量,过多的元素声明会报错,但TS允许向元组中使用数组的push方法插入新元素(但不允许访问) 4.函数 12345function fun(a:number,b:string) &#123; console.log(\"数值型a:\",a); console.log(\"字符串型b:\",b);&#125;let a = fun(18,\"hello world\"); 5.对象 在JS中，可以任意修改对象属性，但在TS中不允许 12let obj: object = &#123;x: 'a', y: 'b'&#125;;obj.x = 3 // Property 'x' does not exist on type 'object'. 6.symbol 具有唯一的值，可以显式声明，也可以创建 1234let symbol1:Symbol = Symbol(); // 显示声明let symbol2 = Symbol() ; // 直接创建// 验证:是否是同一个对象console.log(symbol1 === symbol2) // fasle","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://ahrilove.top/categories/TypeScript/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Vue(三)：组件与webpack","slug":"Vue(三)","date":"2019-12-21T16:00:00.000Z","updated":"2019-12-22T07:10:08.799Z","comments":true,"path":"2019/12/22/Vue(三)/","link":"","permalink":"https://ahrilove.top/2019/12/22/Vue(%E4%B8%89)/","excerpt":"本文要点：1.父子组件之间的访问方式2.前端模块化3.计算属性computed","text":"本文要点：1.父子组件之间的访问方式2.前端模块化3.计算属性computed 1.父子组件之间的访问方式Vue基础知识&nbsp;&nbsp;&nbsp;&nbsp;之前我们已经了解到组件的创建方式（三种全局组件创建方式和两种局部组建方式），props属性使用以及接受动态数据和静态数据。那我们今天就要学习一下关于： 有时候我们需要父组件访问子组件，子组件直接访问父组件，或者是子组件访问跟组件 父组件访问子组件：使用$children或$refs(reference引用之意) $refs =&gt; 对象类型，默认为空的对象，必须要加ref=”xxxx” ：在组件中使用ref（即，即表示给组件添加唯一的id属性）相当于给标签添加一个id，使得开发者可以知道我们操作的是那个DOM，用来获取DOM元素和组建引用 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;div id=\"app\"&gt; &lt;cpn ref=\"aaa\"&gt;&lt;/cpn&gt; &lt;button @click=\"btnClick('hello woman')\" value=\"click\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/template&gt; &lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; message:'hello man' &#125;, methods:&#123; btnClick(hi)&#123; console.log(hi); /* *调用子组件的name返回值 * 经测试：this必须添加，否则会出现$refs未定义的报错 * $refs.aaa.name中的aaa相当于id属性，也必须需要，否则会弹出name未定义的错误undefined * */ console.log(this.$refs.aaa.name); console.log(this.$refs.aaa.num) &#125; &#125;, components:&#123; 'cpn':&#123; template:'#cpn' , data()&#123; return &#123; name:\"我是子组件的name\", num:18 &#125; &#125;, methods: &#123; showMessage()&#123; console.log(\"showMessage\") &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 子组件访问父组件：使用$parent（不常用） 未完待续。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/tags/Vue/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（八）：js逆向爬虫的奇技淫巧","slug":"Python全栈系列章节更新(八)","date":"2019-12-18T16:00:00.000Z","updated":"2019-12-20T06:13:19.597Z","comments":true,"path":"2019/12/19/Python全栈系列章节更新(八)/","link":"","permalink":"https://ahrilove.top/2019/12/19/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E5%85%AB)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：微信公众平台反爬机制：用户名不变，密码加密相关技术：selenium，requests，execjs技术难度：★★☆☆☆☆爬取目标：模拟登陆公共号，获取页面的所有信息源代码：本页面（selenium代码还在测试更新当中）说明：第一次玩js逆向爬虫，如有不足，多多指教","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：微信公众平台反爬机制：用户名不变，密码加密相关技术：selenium，requests，execjs技术难度：★★☆☆☆☆爬取目标：模拟登陆公共号，获取页面的所有信息源代码：本页面（selenium代码还在测试更新当中）说明：第一次玩js逆向爬虫，如有不足，多多指教 1.分析js，找到目标接口函数F12打开 开发者工具, 按照一般逻辑步骤，先输入一个错误账号密码，找到真正的入口接口函数,案例如下：继续向下翻动，我们可以看到请求参数表单数据的pwd密码是明显经过加密的 2.破解在Search功能栏下搜索pwd 很快可以定位到以下代码 12345678910_loginPost: function(e, i) &#123; n.post(&#123; url: i.url, data: &#123; username: i.account, pwd: o(i.pwd.substr(0, 16)), // 关键代码 imgcode: i.verify, f: \"json\", userlang: i.currentLang, redire 我们在pwd: o(i.pwd.substr(0, 16))行处下断点。然后步入进去. 1234567t.exports = function(n, r, t) &#123; return r ? t ? c(r, n) : function(n, r) &#123; return e(c(n, r)) &#125;(r, n) : t ? o(n) : function(n) &#123; return e(o(n)) // ***** &#125;(n)&#125; 继续步入一次，代码最后会走到我标****的地方。这就是我们需要的关键函数,扣代码吧。 扣下代码。然后自己编写一个Js function 123function JsKiller(pwd)&#123; return e(o(pwd));&#125; js逆向加密源代码：pwd.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091function d(n, r) &#123; var t = (65535 &amp; n) + (65535 &amp; r); return (n &gt;&gt; 16) + (r &gt;&gt; 16) + (t &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; t&#125;function f(n, r, t, e, u, o) &#123; return d(function (n, r) &#123; return n &lt;&lt; r | n &gt;&gt;&gt; 32 - r &#125;(d(d(r, n), d(e, o)), u), t)&#125;function g(n, r, t, e, u, o, c) &#123; return f(r &amp; t | ~r &amp; e, n, r, u, o, c)&#125;function l(n, r, t, e, u, o, c) &#123; return f(r &amp; e | t &amp; ~e, n, r, u, o, c)&#125;function v(n, r, t, e, u, o, c) &#123; return f(r ^ t ^ e, n, r, u, o, c)&#125;function s(n, r, t, e, u, o, c) &#123; return f(t ^ (r | ~e), n, r, u, o, c)&#125;function i(n, r) &#123; n[r &gt;&gt; 5] |= 128 &lt;&lt; r % 32; n[14 + (r + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = r; var t, e, u, o, c, f = 1732584193, i = -271733879, a = -1732584194, h = 271733878; for (t = 0; t &lt; n.length; t += 16) i = s(i = s(i = s(i = s(i = v(i = v(i = v(i = v(i = l(i = l(i = l(i = l(i = g(i = g(i = g(i = g(u = i, a = g(o = a, h = g(c = h, f = g(e = f, i, a, h, n[t], 7, -680876936), i, a, n[t + 1], 12, -389564586), f, i, n[t + 2], 17, 606105819), h, f, n[t + 3], 22, -1044525330), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 4], 7, -176418897), i, a, n[t + 5], 12, 1200080426), f, i, n[t + 6], 17, -1473231341), h, f, n[t + 7], 22, -45705983), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 8], 7, 1770035416), i, a, n[t + 9], 12, -1958414417), f, i, n[t + 10], 17, -42063), h, f, n[t + 11], 22, -1990404162), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 12], 7, 1804603682), i, a, n[t + 13], 12, -40341101), f, i, n[t + 14], 17, -1502002290), h, f, n[t + 15], 22, 1236535329), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 1], 5, -165796510), i, a, n[t + 6], 9, -1069501632), f, i, n[t + 11], 14, 643717713), h, f, n[t], 20, -373897302), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 5], 5, -701558691), i, a, n[t + 10], 9, 38016083), f, i, n[t + 15], 14, -660478335), h, f, n[t + 4], 20, -405537848), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 9], 5, 568446438), i, a, n[t + 14], 9, -1019803690), f, i, n[t + 3], 14, -187363961), h, f, n[t + 8], 20, 1163531501), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 13], 5, -1444681467), i, a, n[t + 2], 9, -51403784), f, i, n[t + 7], 14, 1735328473), h, f, n[t + 12], 20, -1926607734), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 5], 4, -378558), i, a, n[t + 8], 11, -2022574463), f, i, n[t + 11], 16, 1839030562), h, f, n[t + 14], 23, -35309556), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 1], 4, -1530992060), i, a, n[t + 4], 11, 1272893353), f, i, n[t + 7], 16, -155497632), h, f, n[t + 10], 23, -1094730640), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 13], 4, 681279174), i, a, n[t], 11, -358537222), f, i, n[t + 3], 16, -722521979), h, f, n[t + 6], 23, 76029189), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 9], 4, -640364487), i, a, n[t + 12], 11, -421815835), f, i, n[t + 15], 16, 530742520), h, f, n[t + 2], 23, -995338651), a = s(a, h = s(h, f = s(f, i, a, h, n[t], 6, -198630844), i, a, n[t + 7], 10, 1126891415), f, i, n[t + 14], 15, -1416354905), h, f, n[t + 5], 21, -57434055), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 12], 6, 1700485571), i, a, n[t + 3], 10, -1894986606), f, i, n[t + 10], 15, -1051523), h, f, n[t + 1], 21, -2054922799), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 8], 6, 1873313359), i, a, n[t + 15], 10, -30611744), f, i, n[t + 6], 15, -1560198380), h, f, n[t + 13], 21, 1309151649), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 4], 6, -145523070), i, a, n[t + 11], 10, -1120210379), f, i, n[t + 2], 15, 718787259), h, f, n[t + 9], 21, -343485551), f = d(f, e); i = d(i, u); a = d(a, o); h = d(h, c); return [f, i, a, h]&#125;function a(n) &#123; var r, t = \"\"; for (r = 0; r &lt; 32 * n.length; r += 8) t += String.fromCharCode(n[r &gt;&gt; 5] &gt;&gt;&gt; r % 32 &amp; 255); return t&#125;function h(n) &#123; var r, t = []; for (t[(n.length &gt;&gt; 2) - 1] = void 0, r = 0; r &lt; t.length; r += 1) t[r] = 0; for (r = 0; r &lt; 8 * n.length; r += 8) t[r &gt;&gt; 5] |= (255 &amp; n.charCodeAt(r / 8)) &lt;&lt; r % 32; return t&#125;function e(n) &#123; var r, t, e = \"0123456789abcdef\", u = \"\"; for (t = 0; t &lt; n.length; t += 1) r = n.charCodeAt(t); u += e.charAt(r &gt;&gt;&gt; 4 &amp; 15) + e.charAt(15 &amp; r); return u&#125;function u(n) &#123; return unescape(encodeURIComponent(n))&#125;function o(n) &#123; return function (n) &#123; return a(i(h(n), 8 * n.length)) &#125;(u(n))&#125;function c(n, r) &#123; return function (n, r) &#123; var t, e, u = h(n), o = [], c = []; for (o[15] = c[15] = void 0, 16 &lt; u.length &amp;&amp; (u = i(u, 8 * n.length)), t = 0; t &lt; 16; t += 1) o[t] = 909522486 ^ u[t]; c[t] = 1549556828 ^ u[t]; return e = i(o.concat(h(r)), 512 + 8 * r.length); a(i(c.concat(e), 640)) &#125;(u(n), u(r))&#125;function JsKiller(pwd) &#123; return e(o(pwd))&#125; 3.执行破解出的js123456789101112import execjsdef parseJS(pwd): # 读取pwd.js文件内容 with open(\"pwd.js\", 'r') as f: js_code = f.read() # 编译js函数 ctx = execjs.compile(js_code) # 执行js中的JsKiller函数，参数为pwd result = ctx.call('JsKiller', pwd) return result 比如我们来执行一下这个python代码，测试一下结果：令pwd=”Github” ctx.call(‘JsKiller’, pwd) ==&gt; &quot;e1adbcbb92c622d0b3e619f9d0730abf”,即将GitHub加密成32位。 4.模拟登陆 这里直接列出来模拟登录的源代码，这里需要注意一定要加referer 12345678910111213141516171819202122232425262728293031323334353637383940414243import execjsimport requestsurl = \"https://mp.weixin.qq.com/cgi-bin/bizlogin?action=startlogin\" # 这就是真正的入口urldef get_content(username, pwd): headers = &#123; \"referer\": \"https://mp.weixin.qq.com/\", # 必须要写 \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36\" &#125; data = &#123; \"username\": username, \"pwd\": pwd, \"f\": \"json\", \"imgcode\": \"\", \"userlang\": \"zh_CN\", \"lang\": \"zh_CN\", \"ajax\": 1 &#125; try: response = requests.post(url=url, headers=headers, data=data, timeout=10) if (response.status_code == 200): return response.text return None except Exception as e: print(e)def parseJS(pwd): with open(\"pwd.js\", 'r') as f: js_code = f.read() ctx = execjs.compile(js_code) result = ctx.call('JsKiller', pwd) return resultif __name__ == '__main__': username = \"980710425@qq.com\" pwd = \"XXXXXXXX\" pwd = parseJS(pwd) print(get_content(username, pwd)) 5.结果分析得到返回结果：这里返回了一个json格式数据，并且我们可以得知，这里其实是重定向到了这个新的URL地址 12345&#123;\"base_resp\":&#123; \"err_msg\":\"ok\", \"ret\":0&#125;, \"redirect_url\":\"/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account=980710425%40qq.com\"&#125; https://mp.weixin.qq.com/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account=980710425%40qq.com这个链接其实是需要微信扫码登陆认证的链接，我也不知道怎么去绕过这个扫码认证，如果有大神巨佬知道，请带带我。我的笨办法是通过selenium自动化测试，还是不可避免要扫码，然后扫码登陆，获取目标数据 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"逆向爬虫","slug":"逆向爬虫","permalink":"https://ahrilove.top/tags/%E9%80%86%E5%90%91%E7%88%AC%E8%99%AB/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章五：常见函数和属性","slug":"Javascript篇章五","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-22T06:42:57.165Z","comments":true,"path":"2019/12/18/Javascript篇章五/","link":"","permalink":"https://ahrilove.top/2019/12/18/Javascript%E7%AF%87%E7%AB%A0%E4%BA%94/","excerpt":"1.isFinite()函数2.循环3.Math(算术对象)4.数据类型判断5.arguments参数属性","text":"1.isFinite()函数2.循环3.Math(算术对象)4.数据类型判断5.arguments参数属性 1.isFinite()函数isFinite() 函数用于检查其参数是否是无穷大。（如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。） 123456document.write(isFinite(123)+ \"&lt;br&gt;\"); //truedocument.write(isFinite(-1.23)+ \"&lt;br&gt;\"); // truedocument.write(isFinite(5-2)+ \"&lt;br&gt;\"); // truedocument.write(isFinite(0)+ \"&lt;br&gt;\"); // truedocument.write(isFinite(\"Hello\")+ \"&lt;br&gt;\"); // falsedocument.write(isFinite(\"2005/12/12\")+ \"&lt;br&gt;\"); // false 2.jQuery中的$.inArray（）$.inArray( value, array)判断参数值是否存在数组中，并返回索引值（默认从0开始）如果不存在就返回-1 12345678910&lt;script&gt;$(function () &#123; var arr = [ 4, \"Pete\", 8, \"John\" ]; var $spans = $( \"span\" ); $spans.eq( 0 ).text( jQuery.inArray( \"John\", arr ) ); $spans.eq( 1 ).text( jQuery.inArray( 4, arr ) ); $spans.eq( 2 ).text( jQuery.inArray( \"Karl\", arr ) ); $spans.eq( 3 ).text( jQuery.inArray( \"Pete\", arr, 2 ) );&#125;)&lt;/script&gt; 3.Math(算术对象)Math对象，提供科学数学计算，也同样具有属性与方法，案例如下： 12345678&lt;script&gt; let mypi = Math.PI; let myabs = Math.abs(-15.88963); console.log(mypi); console.log(myabs); document.getElementById(\"kajima\").innerHTML=mypi; document.getElementById(\"bady\").innerHTML=myabs;&lt;/script&gt; Math对象属性 Math 对象方法 4.数据类型判断PS:typeof无法判断数组，null和对象，因为他会把这些都判断为Object，其余都可以正常判断。最完美的检测数组类型的方法： 12345function isArrayFn (o) &#123;return Object.prototype.toString.call(o) === '[object Array]';&#125;var arr = [1,2,3,1];alert(isArrayFn(arr));// true 其实这个函数可以改进一下，使得同样能够判断其它数据类型：数组，null，function，String，object等等 123function isArrayFn (o) &#123;return Object.prototype.toString.call(o);&#125; 实例 测试结果 [1,2,3,1] [object Array] {a:”chenhaodong”,age:18} [object Object] function a(){return null} [object Function] “hello world” [object String] null [object Null] 5.arguments参数属性arguments.length 属性返回函数调用过程接收到的参数个数arguments[0]:获取传入的第一个参数值arguments[1]:获取传入的第二个参数值","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Vue(二)：生命周期函数","slug":"Vue(二)","date":"2019-12-16T16:00:00.000Z","updated":"2019-12-18T02:45:32.587Z","comments":true,"path":"2019/12/17/Vue(二)/","link":"","permalink":"https://ahrilove.top/2019/12/17/Vue(%E4%BA%8C)/","excerpt":"本文要点：1.生命周期函数2.Watch方法3.计算属性computed","text":"本文要点：1.生命周期函数2.Watch方法3.计算属性computed 1.生命周期函数（与el，data，methods，computed等等同级） 创建阶段 1234567891.beforeCreate():表示实例完全被创建时，会执行它 /ps：在beforCreate生命周期函数执行时，data和methods中的数据均未被初始化2.created():在created中，data与methods都已经被实例化了，3.beforeMount(): 表示模板已经在内存中编译好了，只是未渲染到真正要展示的页面上4.mounted():是实例创建期间最后一个生命周期函数，当执行完mounted就表示，实例已经完全创建好了， 此时，如果没有其它操作的话，这个实例就静静地躺在内存中 组件运行阶段： 12341.beforeUpdate(): 表示我们的界面还没有更新，但数据肯定被更新了 结论：运行beforeUpdate，页面上显示的数据还没有被更新，但数据已经更新了，页面与数据更新不同步2.updated():页面都data数据已经保持同步了，都是最新的 销毁过程 1231.beforeDestroy：Vue示例已经从运行阶段，进入到销毁阶段，实例身上的所有data，methods以及过滤器，指令都处于可用状态，未执行真正的销毁动作2.destroyed：组件已经完全销毁了，一切data，方法，指令，过滤器均不可使用 2.Watch属性Watch，可以监听data属性域中的数据变化，主要有handler方法，immediate属性，deep属性handler方法就是你watch中需要具体执行的方法；immediate为true时则立即触发回调函数；如果为false，则和上面的例子一样，不会立即执行回调deep顾名思义就是深入监听，也就是在对象中层层遍历，并在监听对象上的每一个属性上都添加监听，固然也会损耗性能 123456789watch: &#123; orgBarChartData: &#123; // 监听的目标属性 handler(newVal,oldVal)&#123; this.renderOrgBarChart(); //重设图表，这两个都是动作体 this.orgBarChart.resize(); //重新设置图表高宽 &#125;, deep: true // deep:true &#125;,&#125; 3.methods与computed的区别： computed 和 methods虽然都可以实现对数据的计算,但两者有一定的区别: methods:使用methods方法可以接受外部传参,使用更加灵活；computed:计算属性，computed的亮点在于:它能够依赖缓存，当计算属性所依赖的数据发生改变时，才会重新触发计算属性方法执行。所以对于较复杂或消耗效率的计算,一定要采用计算属性。计算属性computed里面也可以写函数，并且调用函数时使用的mustache语法不用加括号，案例如下： 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;!--这里的mustache语法调用函数时没有声明括号---&gt; &lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;script &gt; const vm = new Vue(&#123; el: '#app', data:&#123; firstName:\"浩东\", lastName:\"陈\" &#125;, computed:&#123; fullname () &#123; return this.lastName+this.firstName; &#125; &#125;, methods:&#123;&#125; &#125;)&lt;/script&gt; 使用methods的方法,每次页面刷新都会触发方法的执行，使用计算属性,只要依赖的数据没有变化,就会直接从缓存中读取结果,不需要重新计算,这种做法可以提升效率更可以带来更好的用户体验","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/tags/Vue/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"ThinkPHP项目（三）：常见函数和属性","slug":"ThinkPHP(三)","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-19T08:36:45.243Z","comments":true,"path":"2019/12/16/ThinkPHP(三)/","link":"","permalink":"https://ahrilove.top/2019/12/16/ThinkPHP(%E4%B8%89)/","excerpt":"还是紧接前面的知识展开，本章节列举出遇到的一些项目相关函数与属性 1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单","text":"还是紧接前面的知识展开，本章节列举出遇到的一些项目相关函数与属性 1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单 1. is_array(search_value,array,type)in_array() 函数搜索数组中是否存在指定的值。type是可选的，如果设置该参数为true，则又要检查搜索的数据与数组的值的类型是否相同 12345678&lt;?php $people = array(\"Bill\", \"Steve\", \"Mark\", \"David\"); if (in_array(\"Mark\", $people))&#123; echo \"匹配已找到\";&#125; else&#123; echo \"匹配未找到\";&#125;?&gt;","categories":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://ahrilove.top/categories/ThinkPHP/"}],"tags":[{"name":"thinkPHP","slug":"thinkPHP","permalink":"https://ahrilove.top/tags/thinkPHP/"}],"author":{"name":"憨批龟","avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png"}},{"title":"数据分析章节（一）：初始数学之美","slug":"数据分析章节（一）","date":"2019-12-14T16:00:00.000Z","updated":"2019-12-15T11:26:58.502Z","comments":true,"path":"2019/12/15/数据分析章节（一）/","link":"","permalink":"https://ahrilove.top/2019/12/15/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学是一门美丽的学科，是美丽的，也充满悲剧的！ 本文要点：直角坐标系与极坐标方程科学运算基本三大库Matplotlib，Numpy，Pandas一个浪漫又悲情的爱情故事——笛卡尔心形线执子之魂，与子共生——玫瑰线给我一个支点——阿基米德螺线","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学是一门美丽的学科，是美丽的，也充满悲剧的！ 本文要点：直角坐标系与极坐标方程科学运算基本三大库Matplotlib，Numpy，Pandas一个浪漫又悲情的爱情故事——笛卡尔心形线执子之魂，与子共生——玫瑰线给我一个支点——阿基米德螺线 1.直角坐标与极坐标方程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较直角坐标系方程y=x，它表示平面上的一条线，而极坐标方程ρ=θ表示螺线。用极坐标系描述的曲线方程称作极坐标方程，通常用来表示ρ为自变量θ的函数(ρ,θ)=0。 两坐标系之间的转换 极坐标系中的两个坐标r和θ可以由下面的公式转换为直角坐标系下的坐标值。x = rcos（θ），y = rsin（θ），由上述二公式，可得到从直角坐标系中x和y两坐标如何计算出极坐标下的坐标：角度θ = arctan(y/x)总结如下： 2.科学运算三大基本库基本知识点参考我的GitHub补充一点：PYTHON使用MATPLOTLIB绘图时出现的中文乱码问题,设置代码如下 1234from matplotlib import pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 3.一个浪漫又悲情的爱情故事——笛卡尔心形线【转载】1650年，斯德哥尔摩的街头，52岁的笛卡尔邂逅了18岁的瑞典公主克里斯汀。 那时，落魄、一文不名的笛卡尔过着乞讨的生活，全部的财产只有身上穿的破破烂烂的衣服和随身所带的几本数学书籍。生性清高的笛卡尔从来不开口请求路人施舍，他只是默默地低头在纸上写写画画，潜心于他的数学世界。 一个宁静的午后，笛卡尔照例坐在街头，沐浴在阳光中研究数学问题。他如此沉溺于数学世界，身边过往的人群，喧闹的车马队伍。都无法对他造成干扰。 突然，有人来到他旁边，拍了拍他的肩膀，“你在干什么呢？”扭过头，笛卡尔看到一张年轻秀丽的睑庞，一双清澈的眼睛如湛蓝的湖水，楚楚动人，长长的睫毛一眨一眨的，期待着他的回应。她就是瑞典的小公主，国王最宠爱的女儿克里斯汀。 她蹲下身，拿过笛卡尔的数学书和草稿纸，和他交谈起来。言谈中，他发现，这个小女孩思维敏捷，对数学有着浓厚的兴趣。 和女孩道别后，笛卡尔渐渐忘却了这件事，依旧每天坐在街头写写画画。 几天后，他意外地接到通知，国王聘请他做小公主的数学老师。满心疑惑的笛卡尔跟随前来通知的侍卫一起来到皇宫，在会客厅等候的时候，他听到了从远处传来的银铃般的笑声。转过身，他看到了前儿天在街头偶遇的女孩子。慌忙中，他赶紧低头行礼。 从此，他当上了公主的数学老师。 公主的数学在笛卡尔的悉心指导下突飞猛进，他们之间也开始变得亲密起来。笛卡尔向她介绍了他研究的新领域——直角坐标系。通过它，代数与几何可以结合起来，也就是日后笛卡尔创立的解析几何学的雏形。 在笛卡尔的带领下，克里斯汀走进了奇妙的坐标世界，她对曲线着了迷。每天的形影不离也使他们彼此产生了爱慕之心。 在瑞典这个浪漫的国度里，一段纯粹、美好的爱情悄然萌发。 然而，没过多久，他们的恋情传到了国王的耳朵里。国王大怒，下令马上将笛卡尔处死。在克里斯汀的苦苦哀求下，国王将他放逐回国，公主被软禁在宫中。 当时，欧洲大陆正在流行黑死病。身体孱弱的笛卡尔回到法国后不久，便染上重病。在生命进入倒计时的那段日子，他日夜思念的还是街头偶遇的那张温暖的笑脸。他每天坚持给她写信，盼望着她的回音。然而，这些信都被国王拦截下来，公主一直没有收到他的任何消息。 在笛卡尔给克里斯汀寄出第十三封信后，他永远地离开了这个世界。此时，被软禁在宫中的小公主依然徘徊在皇宫的走廊里，思念着远方的情人。 这最后一封信上没有写一句话，只有一个方程：r=a(1-sinθ)。 国王看不懂，以为这个方程里隐藏着两个人不可告人的秘密，便把全城的数学家召集到皇宫，但是没有人能解开这个函数式。他不忍看着心爱的女儿每天闷闷不乐，便把这封信给了她。 拿到信的克里斯汀欣喜若狂，她立即明白了恋人的意图，找来纸和笔，着手把方程图形画了出来，一颗心形图案出现在眼前，克里斯汀不禁流下感动的泪水，这条曲线就是著名的“心形线”。 国王去世后，克里斯汀继承王位，登基后，她便立刻派人去法国寻找心上人的下落，收到的却是笛卡尔去世的消息，留下了一个永远的遗憾…… 这封享誉世界的另类情书，至今，还保存在欧洲笛卡尔的纪念馆里。———————————————— 4.三大曲线图像展示 极坐标方程： 心形线：r=a(1-cosθ) (a&gt;0)玫瑰线：r=asin(3θ) (a&gt;0)阿基米德螺线：r=aθ(a&gt;0,θ&gt;=0) 成品展示 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import numpy as npfrom matplotlib import pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号def draw(): plt.title(\"数学其实很美\") pi = np.pi a = 1 # 生成0到2pi的数据集 datas = np.linspace(0, 2 * pi, 100) # 绘制极坐标r = a(1-cosθ)(a&gt;0)的心形图 x = a * (1 - np.cos(datas)) * (np.cos(datas)) y = a * (1 - np.cos(datas)) * (np.sin(datas)) plt.plot(x, y, label='心形线', color='red', linewidth='1.0') # 绘制极坐标r = a(1-cosθ)(a&gt;0)的心形图 x1 = a * (np.sin(3 * datas)) * (np.cos(datas)) y1 = a * (np.sin(3 * datas)) * (np.sin(datas)) plt.plot(x1, y1, label='玫瑰线', color='blue', linewidth='2.0', linestyle=\"--\") # 绘制极坐标r = a(1-cosθ)(a&gt;0)的阿基米德螺线图 x2 = a * datas * (np.cos(datas)) y2 = a * datas * (np.sin(datas)) plt.plot(x2, y2, label='阿基米德螺线', color='black', linewidth='1.0', linestyle=\"-.\") # # 使用plt.xlim设置x坐标轴范围： # plt.ylim((-10, 10)) # # 使用plt.ylim设置x坐标轴范围： # plt.ylim((-10, 10)) # 定义x轴名称 plt.xlabel('x轴') # 定义y轴名称 plt.ylabel('y轴') new_ticks = np.arange(-5, 10, 1) # 使用plt.xticks设置x轴刻度：范围是(-2,2);个数是8. plt.xticks(new_ticks) \"\"\" plt.gca获取当前坐标轴信息. 使用.spines设置边框；使用.set_color设置边框颜色 \"\"\" # 坐标轴中移 ax = plt.gca() # 隐藏上边和右边 ax.spines['top'].set_color('none') ax.spines['right'].set_color('none') # 移动另外两个轴 ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) plt.legend() plt.savefig(\"math.png\") plt.show()if __name__ == '__main__': draw()","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://ahrilove.top/tags/numpy/"}]},{"title":"docker安装使用redis","slug":"docker的redis","date":"2019-12-11T16:00:00.000Z","updated":"2019-12-12T05:14:04.397Z","comments":true,"path":"2019/12/12/docker的redis/","link":"","permalink":"https://ahrilove.top/2019/12/12/docker%E7%9A%84redis/","excerpt":"docker系列章节更新（三），这一章节主要学习docker安装redis以及非关系型数据库redis学习 docker安装redis redis学习笔记","text":"docker系列章节更新（三），这一章节主要学习docker安装redis以及非关系型数据库redis学习 docker安装redis redis学习笔记 1.docker安装redis 拉取镜像 docker search redisdocker pull redis:[version] 创建容器 docker run -di -p 6379:6379 -p指定端口,-d以守护式形式-v /zzyyuse/myredis/data:/data-v /zzyyuse/myredis/conf/redis.conf:/usr/local/etc/redis/redis.confredis-server /usr/local/etc/redis/redis.confredis:3.2 指定redis版本--appendonly yes 新建redis.conf文件 在宿主机/zzyyuse/myredis/conf/redis.conf目录下新建redis.conf文件（文件内容） 进入容器并以命令行交互 docker exec -it container_id redis-cli(区分其它容器的/bin/bash或者/bin/sh) 退出命令 SHUTDOWN 2.redis的基础知识【转载】羊松林博客的redis讲解就很详细了，不重复造轮子，先抄他一手再说","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://ahrilove.top/tags/redis/"}]},{"title":"ALL MY LIFE","slug":"2020","date":"2019-12-10T16:00:00.000Z","updated":"2019-12-19T09:33:54.894Z","comments":true,"path":"2019/12/11/2020/","link":"","permalink":"https://ahrilove.top/2019/12/11/2020/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做她的战士，跟她一起经历&nbsp;&nbsp;&nbsp;失败！！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做她的战士，跟她一起经历&nbsp;&nbsp;&nbsp;失败！！ 自我介绍&nbsp;&nbsp;&nbsp;兄弟萌，您们好，我叫陈浩东，浩东陈的陈，你也可以叫我陈某。97年的四川绵阳人，于2019年6月5日毕业于中国计量大学信息与计算科学专业。虽然口头上一直在说~不会再爱了( ﹁ ﹁ ) ~→，但是我还是忘不了那个badwoman,试问，如果不是真心喜欢，谁愿意当舔狗呢？☹ ☹ ☹ 她不是漂不漂亮的问题，她真的就是那种，很少见，很冷艳的漂亮…&nbsp;&nbsp;&nbsp;你们有可能会说：你那叫喜欢吗？你那是馋她的身子，你下贱 &nbsp;&nbsp;&nbsp;作为一个正能量，儒雅随和的知识分子，兴趣爱好当然必不可少。喜欢羽毛球、乒乓球、登山、游泳（仅能浮起来☹ ☹）、钓鱼以及英雄联盟，当然作为一个资深的土味鉴定师,文艺复兴模仿者,能够快速洞察每一个土味视频背后的正能量思想，有内味了。 2020年职业技术规划： XXXXXXXXX(终极目标，可以决定是否可以改变未来轨迹的) Python进阶，web框架以及爬虫框架~js逆向解密爬虫 Python爬取抓包app数据 Vue基础知识与微信小程序MVVM（两者大同小异） java ThinkPHP以及PHP学习 HTML+CSS+JavaScript Jquery进阶以及bootstrap Docker容器虚拟技术 Linux的Ubuntu要经常多用 数据库进阶以及存储过程 数据分析与深度学习 完成一个简单的健康指数的微信小程序 完成一个GitHub开源项目，暂时有一点想法 每日作息安排：1.早上7:25-7:50起床2.中午早点休息，下午一点上班3.五点下班：会寝室吃饭并休息到6:00-6:30,继续学习4.晚上10:40到11:00开始收拾收拾准备下班5.回到寝室，做10-15分钟的Keep，锻炼胸肌腹肌6.周六周日特殊安排：早上9-10点起床，其余正常安排 7.周而复始，学会坚持，每天多学一点，未来会好很多，兄弟萌，不甘碌碌无为，那就，冲，杀！！ 推荐学习方法： 渗透科学学习法 晚上睡觉前，把文献放在脑袋和枕头之间，知识会从浓度较高的的书本向浓度较低的脑袋渗透。书本越多，外界知识浓度越高，夜间复习的效果越好！ 奋斗目标 1.翻新/二手iPhone 16年买的iPhone6s 32G，现在内存不到5个G。可以买但没必要☹ ☹ ☹，还不卡，让手机再奋斗个两三年吧，先存钱买房吧 2.翻新/二手Macbook Pro 16年5月买的联想小新700，有点重，不方便携带，但换个内存条也超神。可以买，但没必要☹ ☹ ☹，让电脑再奋斗个三四年吧，存钱买房 3.Audi 直接想就完事了，买不起，也没必要☹ ☹ ☹ 4.买房 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红颜一春树,流年一掷梭，一瞬为白骨","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（七）：爬虫解析库","slug":"Python全栈系列章节更新（七）","date":"2019-12-09T16:00:00.000Z","updated":"2019-12-20T06:47:24.317Z","comments":true,"path":"2019/12/10/Python全栈系列章节更新（七）/","link":"","permalink":"https://ahrilove.top/2019/12/10/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列举几个常用的python爬虫解析库 正则表达式XpathBeautifulSouppyqueryScrapy的selector的用法Selenium自动测试库学习","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列举几个常用的python爬虫解析库 正则表达式XpathBeautifulSouppyqueryScrapy的selector的用法Selenium自动测试库学习 1.正则表达式123456789101112131415161718192021&apos;.&apos; 默认匹配除\\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行&apos;^&apos; 匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r&quot;^a&quot;,&quot;\\nabc\\neee&quot;,flags=re.MULTILINE)&apos;$&apos; 匹配字符结尾， 若指定flags MULTILINE ,re.search(&apos;foo.$&apos;,&apos;foo1\\nfoo2\\n&apos;,re.MULTILINE).group() 会匹配到foo1&apos;*&apos; 匹配*号前的字符0次或多次， re.search(&apos;a*&apos;,&apos;aaaabac&apos;) 结果&apos;aaaa&apos;&apos;+&apos; 匹配前一个字符1次或多次，re.findall(&quot;ab+&quot;,&quot;ab+cd+abb+bba&quot;) 结果[&apos;ab&apos;, &apos;abb&apos;]&apos;?&apos; 匹配前一个字符1次或0次 ,re.search(&apos;b?&apos;,&apos;alex&apos;).group() 匹配b 0次&apos;&#123;m&#125;&apos; 匹配前一个字符m次 ,re.search(&apos;b&#123;3&#125;&apos;,&apos;alexbbbs&apos;).group() 匹配到&apos;bbb&apos;&apos;&#123;n,m&#125;&apos; 匹配前一个字符n到m次，re.findall(&quot;ab&#123;1,3&#125;&quot;,&quot;abb abc abbcbbb&quot;) 结果&apos;abb&apos;, &apos;ab&apos;, &apos;abb&apos;]&apos;|&apos; 匹配|左或|右的字符，re.search(&quot;abc|ABC&quot;,&quot;ABCBabcCD&quot;).group() 结果&apos;ABC&apos;&apos;(...)&apos; 分组匹配， re.search(&quot;(abc)&#123;2&#125;a(123|45)&quot;, &quot;abcabca456c&quot;).group() 结果为&apos;abcabca45&apos;&apos;[...]&apos; 用来表示一组字符，单独列出，比如匹配[amk]匹配a,m或k &apos;\\A&apos; 只从字符开头匹配，re.search(&quot;\\Aabc&quot;,&quot;alexabc&quot;) 是匹配不到的，相当于re.match(&apos;abc&apos;,&quot;alexabc&quot;) 或^&apos;\\Z&apos; 匹配字符结尾，同$&apos;\\d&apos; 匹配数字0-9&apos;\\D&apos; 匹配非数字&apos;\\w&apos; 匹配[A-Za-z0-9],还包括下划线‘_’&apos;\\W&apos; 匹配非[A-Za-z0-9]&apos;s&apos; 匹配空白字符、\\t、\\n、\\r , re.search(&quot;\\s+&quot;,&quot;ab\\tc1\\n3&quot;).group() 结果 &apos;\\t&apos;&apos;(.*?)&apos; 贪婪匹配，用来获取目标字符&apos;.*?&apos; 非贪婪匹配，用来替换任意非目标字符 常用方法： re.match() re.match()方法会从字符串的起始位置开始匹配正则表达式，如果匹配，就返回匹配成功的结果，一旦开头不匹配，直接返回None，整个匹配失败 re.search() re.search()：扫描整个字符串，然后返回第一个成功匹配的结果 re.findall() re.findall()：把所有匹配到的字符放到以列表中的元素返回，返回的列表中的每一个元素都是元组类型 re.sub() re.sub(‘a’,’b’,content) ,即在content中，用b替换a的内容 re.compile() compile()方法将正则表达式字符串编译成正则表达式对象，以便在后面的匹配中复用 修饰符 修饰符 描述 re.I 使匹配对大小写不敏感 re.M 多行匹配 re.S 使.匹配包括换行在内的所有字符 2.xpath1.导入相关库包from lxml import etree2.初始化html = etree.HTML(response.text)3.常用规则 表达式 描述 nodename 选取此节点的所有子节点 / 从根节点选取 // 从匹配选择的当前节点选择文档的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 路径表达式 描述 bookstore 选取 bookstore 元素的所有子节点 /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。索引默认从1开始 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 3.pyquery 导入相关库包 from pyquery import PyQuery as pq 初始化工作 doc = pq(html)字符串初始化doc = pq(url)URL初始化doc = pq(filename=””)文件初始化print(doc(‘li’)) css选择器 表达式 说明 id选择器 使用# class选择器 使用. 标签选择器 直接使用标签，什么都不加 * 选择所有元素 p 选择所有p标签 div,p 选择所有的div和p标签（并集） div p 选择div下的所有p标签（子集） pyquery获取信息 1.获取属性值：变量名.attr(属性名) 或者 变量名.attr.属性名2.获取文本内容：变量名.text()3.获取html： 变量名.html()4.找寻某一特定标签：变量名.find(标签名).eq(n) n从0开始，表示find某标签，并选择第n个目标值 4.Selenium库学习动态渲染页面不仅仅涉及到Ajax技术，绝大多数的网页是通过Javascript计算生成新页面的，比如说百度Echarts，淘宝，中国青年网。。。 4.1基本库导入 12345678from selenium import webdrivefrom selenium.webdrive.common.by import By# 若想要模拟键盘，就需要导入keys()类from selenium.webdrive.common.keys import Keys# 等待条件类from selenium.webdrive.support import expected_conditions as EC# 等待条件from selenium.webdrive.support.wait import WebDriverWait 4.2 声明浏览器对象 browser = webdriver.Chrome()/Firefox()/PhantomJS() 等等 4.3 访问目标页面 123456# 访问目标网址browser.get(\"https://www.taobao.com\")# 打印页面源代码print(browser.page_source)# 关闭浏览器browser.close() 4.4 获取单个节点的方法find_element(By.xx) 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"解析库","slug":"解析库","permalink":"https://ahrilove.top/tags/%E8%A7%A3%E6%9E%90%E5%BA%93/"}]},{"title":"兄弟萌！枯啦，要恰不了饭了","slug":"恰饭危机","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-08T10:49:29.305Z","comments":true,"path":"2019/12/08/恰饭危机/","link":"","permalink":"https://ahrilove.top/2019/12/08/%E6%81%B0%E9%A5%AD%E5%8D%B1%E6%9C%BA/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，怎么办？我要枯啦，要恰不了饭了，要吃红牌出场了","text":"&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，怎么办？我要枯啦，要恰不了饭了，要吃红牌出场了 最近一直没有什么活干，每天就是混吃等死，建彬哥说也没有什么我能做的项目，呀！糟了呀，以前一直打趣说“你有你的好果子吃”，现在才明白过来，原来是我才没有好果子吃。而且就目前的市场和我最近咸鱼，我也感觉我要直接吃红牌了，看不到生活的希望（55555。。。）算了吧！！走一步算一步，做好心理准备，每天使劲多学一些，也不至于打包回家的时候那么狼狈，现在回想起来，15年做决定的时候是不是选对了？是当时脑瘫了？","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"探究密码加salt原理以及PHP防止SQL注入","slug":"浅谈密码加盐原理","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-08T14:01:25.487Z","comments":true,"path":"2019/12/08/浅谈密码加盐原理/","link":"","permalink":"https://ahrilove.top/2019/12/08/%E6%B5%85%E8%B0%88%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%8E%9F%E7%90%86/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，一些小网站，小公司对于用户的账号密码很大概率是对其进行散列处理。我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如某MD5密码破解网站），得到某用户的密码。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，一些小网站，小公司对于用户的账号密码很大概率是对其进行散列处理。我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如某MD5密码破解网站），得到某用户的密码。 1.加salt原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，以确定密码是否正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的“佐料”被称作“Salt值”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。 2.加密示例（以PHP为例，python同理调用hashlib库）12345678&lt;?phpfunction hash($a) &#123; $salt=”Random_KUGBJVY”; //定义一个salt值，程序员规定下来的随机字符串 $b=$a.$salt; //把密码和salt连接, $b=md5($b); //执行MD5散列 return $b; //返回散列 &#125;?&gt; 这里的加salt处理方式有很多种，程序员按要求自定义，比如： 12345$salt=”Random_KUGBJVY”;$b=$a.$salt;$b1=$salt.$a.$salt;$b2=$salt.md5($a.$salt);... 调用方式：$new_password=hash($_POST[password]); //这里接受表单提交值，并进行加密 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户注册时：用户输入【账号】和【密码】（以及其他用户信息）；系统为用户生成【Salt值】；系统将【Salt值】和【用户密码】连接到一起；对连接后的值进行散列，得到【Hash值】；将【Hash值1】和【Salt值】分别放到数据库中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户登录时：用户输入【账号】和【密码】；系统通过用户名找到与之对应的【Hash值】和【Salt值】；系统将【Salt值】和【用户输入的密码】连接到一起；对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值 3.php基本语法知识,参考FioraLove的GitHub 1.为什么要使用PDO：增加数据库连接扩展，是程序连接数据库的方法之一 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDO是PHP5新加入的一个重大功能，我们的数据库服务器为MySQL，所有的程序代码的数据库操作全是一mysql(）或者mysqli()函数来操作，当我们的数据库 需要更换时比如换成，SQL、SERVER、PostgreSQL、MS 等，我们不可能去修改所有的程序代码！所以就要用到PDO，PDO很好的帮我们解决了这个问题，使用PDO操作非常方便，只需要修改数据源格式，和加载相应的驱动文件到PHP.ini即可； 2.PDO连接数据库`PDO(php data object)连接MySQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 方式一：借由mysqli &lt;?php $servername = 'localhost'; $username = 'username'; $password = 'password'; $db_name = 'NMSL'; // 创建连接 $conn = mysqli($servername, $username, $password,$db_name); // 检测连接 if (!$conn) &#123; die(\"Connection failed: \" . mysqli_error()); &#125; echo \"连接成功\"; ?&gt; 方式二：PDO $DSN = 'mysql:host=localhost;dbname=demo;charset=utf-8'; $pdo = new PDO($DSN,'username','password'); // 表示已连接了数据库 ``` &gt;3.设置PDO在处理数据的过程中采用什么方式去处理 ```html setAttribute()方法是设置部分属性，主要属性有：PDO::ATTR_CASE、PDO::ATTR_ERRMODE等，我们设置的是PDO::ATTR_CASE(使用关联索引获取数据) PDO::ATTR_CASE：强制列名为指定的大小写。他的$value可为： PDO::CASE_LOWER：强制列名小写。 PDO::CASE_NATURAL：保留数据库驱动返回的列名。 PDO::CASE_UPPER：强制列名大写。 PDO::ATTR_ERRMODE：错误报告。他的$value可为： PDO::ERRMODE_SILENT： 仅设置错误代码。 PDO::ERRMODE_WARNING: 引发 E_WARNING 错误 PDO::ERRMODE_EXCEPTION: 抛出 exceptions 异常。 PDO::ATTR_ORACLE_NULLS （在所有驱动中都可用，不仅限于Oracle）： 转换 NULL 和空字符串。他的$value可为： PDO::NULL_NATURAL: 不转换。 PDO::NULL_EMPTY_STRING： 将空字符串转换成 NULL 。 PDO::NULL_TO_STRING: 将 NULL 转换成空字符串。``` &gt; 4.数据库操作：exec(不返回数据集，即insert，update，delete)与query(仅执行带结果返回的，即select)方法```html &lt;?php /* 连接数据库*/ $DSN = 'mysql:host=localhost;dbname=demo;charset=utf-8'; $pdo = new PDO($DSN,'username','password'); /* 删除 FRUIT 数据表中满足条件的所有行~exec方法 */ $count = $pdo-&gt;exec(\"DELETE FROM fruit WHERE colour = 'red'\"); /* 返回被删除的行数 */ print(\"Deleted $count rows.\\n\"); ?&gt; 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"salt","slug":"salt","permalink":"https://ahrilove.top/tags/salt/"},{"name":"PHP","slug":"PHP","permalink":"https://ahrilove.top/tags/PHP/"}]},{"title":"HTML+CSS易忘点","slug":"html与css","date":"2019-12-05T16:00:00.000Z","updated":"2019-12-06T03:10:21.119Z","comments":true,"path":"2019/12/06/html与css/","link":"","permalink":"https://ahrilove.top/2019/12/06/html%E4%B8%8Ecss/","excerpt":"HTML是网页内容的载体。CSS样式是表现。JavaScript是用来实现网页上的特效效果与交互。","text":"HTML是网页内容的载体。CSS样式是表现。JavaScript是用来实现网页上的特效效果与交互。 1.postion属性 postion:relative是相对定位 是相对于前面的容器定位的。这个时候不能用top left在定位,应该用margin。它可以随窗口大小变化。但大小仍然不会变。要是你设置成width:100%;height:100%;这样就会随着窗口变大变小 postion:absolute是绝对定位 是相对于浏览器的定位，释放自己的位置，以网页坐标原点做一个新的坐标，它不会随着窗口大小变化，只是固定在一个特定的坐标轴上比如：position：absolute；left:20px;top:80px; 这个容器始终位于距离浏览器左20px,距离浏览器上80px的这个位置。","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://ahrilove.top/tags/html/"},{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}]},{"title":"Python全栈系列章节更新（六）：装饰器","slug":"Python全栈系列章节更新（六）装饰器","date":"2019-12-04T16:00:00.000Z","updated":"2019-12-05T01:01:36.547Z","comments":true,"path":"2019/12/05/Python全栈系列章节更新（六）装饰器/","link":"","permalink":"https://ahrilove.top/2019/12/05/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AD%EF%BC%89%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让爬虫像人一样打卡工作，工作还得有快有慢，wtf，想了半天，写个装饰器算了，也顺便复习下装饰器，也能基本能满足需求：其实也可以使用1.轻量级的Python定时任务调度框架（APSchedule库）2.Linux的定时任务3.文件数多，还要做监控和扩展之类的话，用 Flask 写一个服务，将 Apscheduler 和 Scrapyd 继承到服务中，这样就是一个完整的爬虫项目部署和调度管理平台了","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让爬虫像人一样打卡工作，工作还得有快有慢，wtf，想了半天，写个装饰器算了，也顺便复习下装饰器，也能基本能满足需求：其实也可以使用1.轻量级的Python定时任务调度框架（APSchedule库）2.Linux的定时任务3.文件数多，还要做监控和扩展之类的话，用 Flask 写一个服务，将 Apscheduler 和 Scrapyd 继承到服务中，这样就是一个完整的爬虫项目部署和调度管理平台了 装饰器原理：不修改已实现的功能代码块，不改变原函数调用方式，只对现有功能进行扩展 装饰器案例举一个简单的装饰器 12345678910111213141516171819def test(func): # 装饰器接受一个函数作为参数，并返回一个函数 def wrapper(*args, **kwargs): # (*args, **kwargs)表示带参数的装饰器 print('call %s(): ' % func.__name__) # 魔法函数，返回函数名 func(*args, **kwargs) return wrapper@test # 运用@语法把装饰器放置在函数定义处def now(a,b): print(\"%s:%s\"%(a,b))if __name__ == '__main__': now(\"hello\",\"world\") \"\"\" :return call now(): hello:world \"\"\" 爬虫波动性工作装饰器函数1234567891011121314151617181920212223242526272829303132333435import time,datetime,randomdef jobstatus(func): \"\"\" 爬虫的工作状态装饰器 周一至周五 09:00-18:00 小时数是偶数 每分钟请求30次左右 小时数是奇数 每分钟请求10次左右 其余时间等待 \"\"\" def inner(*args, **kwargs): while 1: week_now = datetime.datetime.now().weekday() hour_now = datetime.datetime.now().hour # 14 # 判断当前星期是否为工作日 if week_now in list(range(1,6)): # 判断当前时间是否为工作时间 if 9 &lt;= hour_now &lt;= 18: if hour_now % 2 == 0: time.sleep(random.choice([1,2])) return func(*args, **kwargs) else: time.sleep(random.choice([3,4])) return func(*args, **kwargs) else: # time.sleep(3600*16) # 休眠24小时 else: time.sleep(86400) return inner","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"https://ahrilove.top/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"定时任务","slug":"定时任务","permalink":"https://ahrilove.top/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"Echarts","slug":"echarts","date":"2019-12-04T16:00:00.000Z","updated":"2019-12-06T02:20:22.948Z","comments":true,"path":"2019/12/05/echarts/","link":"","permalink":"https://ahrilove.top/2019/12/05/echarts/","excerpt":"简而言之，百度Echarts真的是数据展示的神器，官方给出的实例就能够满足实际基本要求 1.echarts创建实例2.","text":"简而言之，百度Echarts真的是数据展示的神器，官方给出的实例就能够满足实际基本要求 1.echarts创建实例2. 1.引入ECharts通过标签方式直接引入构建好的 echarts 文件 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 2.为 ECharts 准备一个具备高宽的 DOM 容器1234&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;&lt;/body&gt; 3. echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图完整案例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.异步加载123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/body&gt; &lt;div id=\"pie\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt;var myChart1 = echarts.init(document.getElementById('pie'));myChart1.showLoading();setInterval(function()&#123; myChart1.hideLoading(); &lt;!---这里面进行数据绑定与实例化图表 --&gt; myChart1.setOption(&#123; series : [ &#123; name: '访问来源', type: 'pie', radius: '55%', data:[ &#123;value:235, name:'视频广告'&#125;, &#123;value:274, name:'联盟广告'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:335, name:'直接访问'&#125;, &#123;value:400, name:'搜索引擎'&#125; ] &#125; ] &#125;);&#125;,1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.移动端自适应1.为Echarts准备一个具有宽高(有一个即可)的DOM，推荐使用bootstrap的栅栏系统来设置布局2.大部分的组件和系列的left/right/top/bottom/width/height的定位方式 绝对值，用number形式书写（已经固定写死了浏览器的像素） 百分比，表示占DOM容器的宽高的百分之多少，用string形式书写 位置描述，即center（水平居中），middle（垂直居中）","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://ahrilove.top/tags/echarts/"}]},{"title":"Python全栈系列章节更新（五）：并发编程~多线程","slug":"Python全栈系列章节更新（五）","date":"2019-12-03T16:00:00.000Z","updated":"2019-12-23T02:25:40.545Z","comments":true,"path":"2019/12/04/Python全栈系列章节更新（五）/","link":"","permalink":"https://ahrilove.top/2019/12/04/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"线程顾名思义，就是一条流水线工作的过程（流水线的工作需要电源，电源就相当于cpu），而一条流水线必须属于一个车间，一个车间的工作过程是一个进程，车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一条流水线。所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.线程与进程的区别2.为何会选择多线程3.创建多线程的方式4.线程对象的属性和方法5.守护线程6.线程池与进程池7.多线程，到底该设置多少个线程？","text":"线程顾名思义，就是一条流水线工作的过程（流水线的工作需要电源，电源就相当于cpu），而一条流水线必须属于一个车间，一个车间的工作过程是一个进程，车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一条流水线。所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.线程与进程的区别2.为何会选择多线程3.创建多线程的方式4.线程对象的属性和方法5.守护线程6.线程池与进程池7.多线程，到底该设置多少个线程？ 1.线程与进程的区别1、每启动一个进程，进程内都至少有一个线程。 2、进程本身只是一个资源调度集合，并不能真正执行，进程内开的线程才是真正的运行单位。 3、一个进程内可以启动多个线程，同一进程内线程间共享资源。 4、启动线程的开销远远小于开进程。 5、线程可以相当程度控制相同进程下的线程，进程只能控制其子进程。 6、对主线程的更改（取消、优先级更改等）可能会进程的其他线程的行为；对父进程的修改则不会影响子进程。 7、进程之间是竞争关系，线程之间是协作关系 2.为何会选择多线程？ 同一个进程内的多个线程共享该进程内的地址资源 线程比进程更轻量级，线程比进程更容易创建可撤销 3.创建线程的方式12345678910111213141516171819import time, randomfrom threading import Threaddef piao(name): print('%s piaoing' % name) time.sleep(random.randrange(1, 5)) print('%s piao end' % name)if __name__ == '__main__': t1 = Thread(target=piao, args=('egon', )) t1.start() # 主线程向操作系统发信号，又开了一个线程 print(\"主线程\") # 执行角度看是主线程，从资源角度看是主进程# 这个程序总体是一个进程、两个线程\"\"\"egon piaoing主线程egon piao end\"\"\" 4.线程对象的属性和方法 4.1 Thread实例对象的方法 isAlive():返回线程是否活动的getName():返回线程名setName():设置线程名 5.守护线程守护线程守护主线程，等到主线程死了才会被销毁。在有其他线程的情况下，主线程代码运行完后，等其他非守护线程结束，守护线程才会死掉。 无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行。运行完毕的真正含义： 1、对主进程来说，运行完毕指的是主进程代码运行完毕。 2、对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才能运行完毕。 6.进程池和线程池进程池和线程池的接口一模一样，用法也一样。池就是要对数目加以限制，保证机器一个可承受的范围，以一个健康的状态保证它的运行基本方法：1、submit(fn, args, *kwargs)异步提交任务 2、map(func, *iterables, timeout=None, chunksize=1)取代for循环submit的操作 3、shutdown(wait=True)相当于进程池的pool.close()+pool.join()操作wait=True，等待池内所有任务执行完毕回收完资源后才继续wait=False，立即返回，并不会等待池内的任务执行完毕但不管wait参数为何值，整个程序都会等到所有任务执行完毕submit和map必须在shutdown之前 4、result(timeout=None)取得结果 5、add_done_callback(fn)回调函数 进程池 1234567891011121314151617181920212223242526from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutorimport os, time, randomdef task(name): print(\"name: %s pid: %s run\" % (name, os.getpid())) time.sleep(random.randint(1,3))if __name__ == '__main__': pool = ProcessPoolExecutor(4) # 指定进程池大小，最大进程数，如果不指定默认是CPU核数 for i in range(10): \"\"\"从始至终四个进程解决这10个任务，谁没事了接新任务\"\"\" pool.submit(task, 'egon%s' %i) # 提交任务的方式————异步调用：提交完任务，不用在原地等任务执行拿到结果。 print(\"主进程\")\"\"\"name: egon0 pid: 12445 runname: egon1 pid: 12444 runname: egon2 pid: 12446 runname: egon3 pid: 12447 run主进程name: egon4 pid: 12445 runname: egon5 pid: 12444 runname: egon6 pid: 12446 run\"\"\" shutdown()方法的使用 12345678910111213141516171819202122232425from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutorimport os, time, randomdef task(name): print(\"name: %s pid: %s run\" % (name, os.getpid())) time.sleep(random.randint(1,3))if __name__ == '__main__': pool = ProcessPoolExecutor(4) # 指定进程池大小，最大进程数，如果不指定默认是CPU核数 for i in range(10): \"\"\"从始至终四个进程解决这10个任务，谁没事了接新任务\"\"\" pool.submit(task, 'egon%s' %i) # 提交任务的方式————异步调用：提交完任务，不用在原地等任务执行拿到结果。 pool.shutdown() # 把提交任务入口关闭，默认参数wait=True；同时还进行了pool.join()操作，等任务提交结束，再结束主进程 print(\"主进程\")\"\"\"name: egon0 pid: 12502 runname: egon1 pid: 12503 run....name: egon9 pid: 12505 run主进程\"\"\" 7.多线程，到底该设置多少个线程？那我们如何分配线程？我们提供一个公式： 最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 备注：这个公式也是前辈们分享的，当然之前看了淘宝前台系统优化实践的文章，和上面的公式很类似，不过在CPU数目那边，他们更细化了，上面的公式只是参考。不过不管什么公式，最终还是在生产环境中运行后，再优化调整。 我们继续上面的任务，我们的服务器CPU核数为4核，一个任务线程cpu耗时为20ms，线程等待（网络IO、磁盘IO）耗时80ms，那最佳线程数目：( 80 + 20 )/20 * 4 = 20。也就是设置20个线程数最佳。 从这个公式上面我们就得出，线程的等待时间越大，线程数就要设置越大，这个正好符合我们上面的分析，可提升CPU利用率。那从另一个角度上面说，线程数设置多大，是根据我们自身的业务的，需要自己去压力测试，设置一个合理的数值。 基础常规标准 我们可以尝试去猜想，因为很多业务集中到一个线程池中，不像上面的案例比较简单，事实上业务太多，怎么设置呢？这个就是要去压力测试去调整。不过我们的前辈已经帮我们总结了一个基础的值（最终还是要看运行情况自行调整） 1、CPU密集型：操作内存处理的业务，一般线程数设置为：CPU核数 + 1 或者 CPU核数*2。核数为4的话，一般设置 5 或 8 2、IO密集型：文件操作，网络操作，数据库操作，一般线程设置为：cpu核数 / (1-0.9)，核数为4的话，一般设置 40","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://ahrilove.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Python全栈系列章节更新（四）：并发编程~多进程","slug":"并发编程（多进程）","date":"2019-12-03T16:00:00.000Z","updated":"2019-12-04T12:51:06.647Z","comments":true,"path":"2019/12/04/并发编程（多进程）/","link":"","permalink":"https://ahrilove.top/2019/12/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/","excerpt":"","text":"1.进程与程序程序仅仅是一堆代码，进程指的是程序的运行过程注意：同一个程序执行两次，也是两个进程进程：正在进行的一个过程，是一个任务，或者说是一个资源调度的集合。 2.并发与并行无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真实干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务。 一、并发：伪并行，即看起来多个进程像在同时运行。单个cpu+多道技术可实现并发。 二、并行：多个进程同时运行，只有具备多个cpu才能实现。 3.多进程的创建：Process类注意：在windows中Process()必须放到# if __name__ == &#39;__main__&#39;:下进程创建格式：target表示函数名，args=(参数一,参数二,…,)，参数最后一定要保留一个逗号p = Process(target=task, args=(‘子进程1’,)) 123456789101112131415from multiprocessing import Processimport timedef task(name): print(\"%s is running\" % name) time.sleep(3) print(\"%s is done\" % name) if __name__ == '__main__': # 创建进程 p = Process(target=task, args=('子进程1',)) # 得到对象 # 启动进程 p.start() print(\"这是主进程\") 3.1 Process类的方法和属性介绍 方法 详解 p.start()： 启动进程，并调用该子进程中的p.run() p.run(): 进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 p.terminate(): 强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 p.is_alive(): 如果p仍然运行，返回True p.join([timeout]): 主线程等待p线程终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间 Process属性 详解 p.daemon： 默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置 p.name: 进程的名称 p.pid： 进程的pid p.exitcode: 进程在运行时为None、如果为–N，表示被信号N结束(了解即可) p.authkey: 进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串 3.2 进程之间的内存空间是隔离的3.3 Process对象的join方法 join方法：优先运行子进程，主进程卡在原地，子进程结束后，运行主进程后面的代码。案例如下： 1234567891011121314151617181920from multiprocessing import Processimport time, osdef task(): print('%s is running, parent id is &lt;%s&gt;' % (os.getpid(), os.getppid())) # 进程和父进程查看方式 time.sleep(3) print(\"%s is done, parent id is &lt;%s&gt;\" % (os.getpid(), os.getppid()))if __name__ == '__main__': p = Process(target=task, ) p.start() p.join() # 优先运行子进程，主进程卡在原地 print('主进程', os.getpid(), 'pycharm ID', os.getppid()) print(p.pid) # 子进程运行完，变为僵尸进程，主进程仍能够查到子进程的pid，当主进程结束后，所有僵尸子进程将被丢掉。\"\"\"is running, parent id is &lt;827&gt;is done, parent id is &lt;827&gt;主进程 827 pycharm ID 504\"\"\" 使用join方法实现并发执行 12345678910111213141516171819202122232425262728from multiprocessing import Processimport timedef task(name ,n): print('%s is running' % name) time.sleep(n)if __name__ == '__main__': start = time.time() p1 = Process(target=task, args=(\"子进程1\",5,)) p2 = Process(target=task, args=(\"子进程2\",3,)) p3 = Process(target=task, args=(\"子进程3\",2,)) p1.start() p2.start() p3.start() # 再添加join函数前，主程序的执行输出次序是完全随机的，需要加join()保证主程序等到在子进程之后执行完成 p1.join() p2.join() p3.join() # 以上并非串行执行，实际是并发执行，只是约束了主程序要等在子程序后结束 # print('主进程', os.getpid(), 'pycharm ID', os.getppid()) print(\"主进程\", (time.time()-start))\"\"\"子进程1 is running子进程2 is running子进程3 is running主进程 5.010260343551636 # 主程序只等了5秒，说明确实是并发执行\"\"\" 使用join方法实现多进程串行执行 123456789101112131415161718from multiprocessing import Processdef task(name ,n): passif __name__ == '__main__': p1 = Process(target=task, args=(\"子进程1\",5)) p2 = Process(target=task, args=(\"子进程2\",3)) p3 = Process(target=task, args=(\"子进程3\",2)) # 串行执行 p1.start() p1.join() p2.start() p2.join() p3.start() p3.join() print(\"我是主进程\") 4.守护进程主进程创建守护进程： 一：守护进程会在主进程代码执行结束后就终止，主进程代码运行结束，守护进程立即死亡 二：守护进程内无法再开启子进程,否则抛出异常 12345if __name__ == &apos;__main__&apos;: p = Process(target=task, args=(&apos;子进程&apos;, )) p.daemon=True # 守护进程一定要在进程开启前,即p.start()开启前设置 p.start() print(&quot;我是主进程&quot;) 4.互斥锁进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,而共享带来的是竞争，竞争带来的结果就是错乱互斥锁的原理：就是把并发改成穿行，降低了效率，但保证了数据安全不错乱 1234567891011def task(): # 获得锁 lock.acquire() ... # 释放锁 lock.release()if __name__ == &apos;__main__&apos;: lock = Lock() # 只实例化一次，并传给子进程，要保证所有进程用同一把锁 for i in range(3): p = Process(target=task, args=(&apos;进程%s&apos; % i, lock,)) # 传递给子进程的锁 p.start() 5.队列进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的 队列的创建 Queue（maxsize）：创建队列中允许的最大项数 队列的主要方法 q.put(value)方法用以插入数据到队列中。q.get(value)方法可以从队列读取并且删除一个元素。q.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。q.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样q.close():关闭队列PS:使用q.get()从空队列中再取值时与使用q.put()在队列为满时继续插入数据，都会出现程序卡在原地的结果 队列的使用 123456789101112131415161718from multiprocessing import Queue# 队列中应该放消息，不应该放大文件大数据# 队列可以不设置长度，但是队列是受制于内存大小的，不可能无限存放q = Queue(3) # 指定队列大小q.put('hello')q.put(&#123;'a': 1&#125;)q.put([3,3,3,])print(q.full()) # 查看队列是否满了 # True# q.put(123) # 队列满了再往里面放时，被锁住，只能在原地卡着。print(q.get()) # helloprint(q.get()) # &#123;'a':1&#125;print(q.get()) # [3,3,3]print(q.empty()) # 判断队列是否全部清空 # True# print(q.get()) # 由于已经空了，程序也卡在原处","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"多进程","slug":"多进程","permalink":"https://ahrilove.top/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"}]},{"title":"sql语句关于时间的讨论","slug":"ThinkPHP(二)","date":"2019-12-03T16:00:00.000Z","updated":"2019-12-05T08:31:06.477Z","comments":true,"path":"2019/12/04/ThinkPHP(二)/","link":"","permalink":"https://ahrilove.top/2019/12/04/ThinkPHP(%E4%BA%8C)/","excerpt":"进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.oracle时间和日期的处理2.mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写","text":"进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.oracle时间和日期的处理2.mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写 1.oracle时间和日期的处理，详情请点击此处 1.字符串转换为日期时分秒格式：to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’) select to_date(‘20180831154546’, ‘yyyy-mm-dd hh24:mi:ss’) from dual;结果为：2018-08-31 15:45:46 2.获取系统时间 SELECT SYSDATE FROM dual; – 系统时间:2019-12-04 21:40:15 SELECT SYSTIMESTAMP FROM dual; – 当前系统时间戳:2019-12-04 21:40:41.328000 +08:00 3.时间类型与字符串相互转换 字符串转换为时间类型：to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’); 1234567891011121314151617181920212223-- 字符串转时间类型SELECT to_date('2018-08-23 00:00:00','yyyy-mm-dd hh24:mi:ss') FROM dual;-- 时间类型转字符串select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;select to_char(sysdate,'yyyy-mm-dd') from dual;``` &gt; 4.日期的加减如果时间要进行加减，和现在的时间或者某个目标时间进行比较。to_date(字符串, 'yyyy-mm-dd hh24:mi:ss')+1后面为1的时候就是加1天，2的时候就是加两天，如果加一个小时，就是为1/24，如果加一分钟，就是为1/24/60,...```sql-- 案例：select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1 from dual;-- 加一天 2019-02-19 23:59:00select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1/24 from dual;-- 加一个小时 2019-02-19 00:59:00select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1/24/60 from dual;-- 加一分钟 2019-02-19 00:00:00 2.MySQL的时间与日期的处理 mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写 – 今天SELECT 【想要的字段】 FROM 【表名】 WHERETO_DAYS(【时间字段名】) =TO_DAYS(now()); – 昨天SELECT 【想要的字段】 FROM 【表名】 WHERE TO_DAYS( NOW( ) ) - TO_DAYS(【时间字段名】) = 1; – 近七天SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;=DATE(【时间字段名】); – 本周内SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now()); – 上一周SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now())-1; – 30天内 注意这个不是本月是从当天起向前推30天SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;=DATE(【时间字段名】); – 本月SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) = DATE_FORMAT( CURDATE( ) , ‘%Y%m’ ); – 上一个月SELECT 【想要的字段】 FROM 【表名】 WHERE PERIOD_DIFF( DATE_FORMAT( now( ) , ‘%Y%m’ ) , DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) ) =1; – 本季度SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(now()); – 上一季度SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(DATE_SUB(now(),interval 1 QUARTER)); – 本年度SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(NOW()); – 上一年度SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(date_sub(now(),interval 1 YEAR)); - 未完待续。。。","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://ahrilove.top/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"}]},{"title":"Python全栈系列章节更新（三）：数据库分批次处理和数据库通用连接函数","slug":"Python全栈系列章节更新（三）","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-13T11:24:53.449Z","comments":true,"path":"2019/12/03/Python全栈系列章节更新（三）/","link":"","permalink":"https://ahrilove.top/2019/12/03/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"数据库分批次处理:execute,executemany数据库通用连接函数数据库插入百万级数据优化","text":"数据库分批次处理:execute,executemany数据库通用连接函数数据库插入百万级数据优化 1.数据库通用连接函数（连接模块视实际数据库决定，大同小异）将其封装成一个新的python文件，以便可以重复调用，命名为SqlConnectManage.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def executemany(self, sql,*args): print(\"-----插入数据-----\") try: self.cursor.executemany(sql,*args) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 2.数据分批次处理数据库分批次处理可以使用两种方法：execute()与executemany()方法 2.1 executemany()在使用executemany方法时，需要注意的几个问题： 1.在写sql语句时，不管字段为什么类型，占位符统一使用%s,且不能加上引号。例如 1sql=\"insert into tablename (id,name) values (%s,%s)\" 2.添加的数据的格式必须为元组型列表或元组型元组(并不是无限添加):list[tuple(),tuple(),tuple()]或者tuple(tuple(),tuple(),tuple())例如 123values=[(1,\"zhangsan\"),(2,\"lisi\")]#或者values=((1,\"zhangsan\"),(2,\"lisi\")) 3.最后通过executemany插入 12cursor.executemany(sql,values)connect.commit() 2.2 execute()execute()语法一次只能执行一个sql语句，分批次处理的原理是：循环执行批量语句，然后在commit，如下 12345for i in range(10): sql = \"insert into users(id,grand) values(i,i+10)\" cursor.execute(sql)# 批量执行数据后，然后提交 connect.commit() 3.数据库插入百万级数据优化,参考此文章：Python3 多线程(连接池)操作MySQL插入数据最近做一个项目，需要插入和读取很多数据，所以就需要对数据库大量插入操作进行优化，还是以python为基石，不过在开始动工前，需要明确以下几点：1.考虑是一条线程完整地执行数据库的连接、创建游标、然后插入数据、commit数据、断开连接这一系列操作，还是使用多线程执行获取数据的操作，然后单线程来插入整理好的数据？2.考虑是每执行一次insert，update或者delete，就执行一次commit，还是批量处理数据后，才执行一次commit3.数据执行语句execute()与executemany()的选择 对我而言，我的设计是调用数据库的通用数据池连接文件SqlConnectManage.py，将数据库的连接和关闭函数作为全局使用，放在程序的首尾（就相当于不会重复连接数据库，减少IO开销）然后创建多线程+队列的方式获取数据，以单线程形式来插入数据，批量处理数据后，才commit提交。案例如下： 123456789101112131415161718192021222324252627282930313233343536373839from SqlConnectManage import sqlserverManager# 创建全局连接和游标(这里暂时不用DBUtils库)DB_CONN = pymssql.connect(SERVER , USER , PASSWORD, DATABASE)DB_CURSOR = DB_CONN.cursor()# ...# ...# ... if __name__ == \"__main__\": # 开始时间戳 s_time = time.time() # 设定最大队列数和线程数 q = Queue(maxsize=10) threads = [] starttime, endtime = get_date() # print(starttime,endtime) # 经测试，获取查询时间段成功 # 获取所有用户组列表 userid_all_list = get_user_list() # print(userid_all_list) # 经测试，获取所有用户组成功 # 循环每一个用户组列表并开启多线程采集企业微信考勤数据 while userid_all_list: user_list = userid_all_list.pop() t = Thread(target=gatherData, args=(starttime, endtime, user_list, )) q.put(t) if (q.full() == True or len(userid_all_list) == 0): while q.empty() == False: t = q.get() threads.append(t) t.start() for t in threads: t.join() # 单线程插入数据 insert_sql() 4.python 一个.py文件如何调用另一个.py文件中的类和函数类和文件名相同","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"数据库分批次处理","slug":"数据库分批次处理","permalink":"https://ahrilove.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E6%89%B9%E6%AC%A1%E5%A4%84%E7%90%86/"},{"name":"数据库通用连接函数","slug":"数据库通用连接函数","permalink":"https://ahrilove.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0/"}]},{"title":"关于数据库返回值的讨论","slug":"关于数据库返回值的讨论","date":"2019-12-01T16:00:00.000Z","updated":"2019-12-02T13:55:39.070Z","comments":true,"path":"2019/12/02/关于数据库返回值的讨论/","link":"","permalink":"https://ahrilove.top/2019/12/02/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E8%AE%A8%E8%AE%BA/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;每到深夜，打开音乐，带上耳机，周围很安静，只有到这个时候我才感觉到自己是一个学者，而此刻头脑中只有两件事罢了：1.记下今天所用到的知识 2.安安静静听歌最近做一个python获取考勤数据的小脚本，一直没有怎么用到数据库，今天就来探讨一下获取数据库的返回值 关于数据库返回值的讨论python文件打开方式详解fetchall(),fetchone()","text":"&nbsp;&nbsp;&nbsp;&nbsp;每到深夜，打开音乐，带上耳机，周围很安静，只有到这个时候我才感觉到自己是一个学者，而此刻头脑中只有两件事罢了：1.记下今天所用到的知识 2.安安静静听歌最近做一个python获取考勤数据的小脚本，一直没有怎么用到数据库，今天就来探讨一下获取数据库的返回值 关于数据库返回值的讨论python文件打开方式详解fetchall(),fetchone() 1.关于数据库返回值的讨论1.1.构造简单sql语句假设存在这样一个简单的数据库,获取每一行的数据，并保存为txt格式 构造sql语句 select * from dbo.userlist where user_serial&lt;100010 1.2.python连接数据库（SQL server）1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-import pymssql# 获取考勤系统数据def demo(): server = \"\" user = \"\" password = \"\" database = \"\" conn = pymssql.connect( server=server, user=user, password=password, database=database ) # 创建游标 cursor = conn.cursor() # 构造查询sql语句 sql =\"select * from dbo.kt_dev where user_serial&lt;100010\" cursor.execute(sql) numbers = cursor.fetchall() print(numbers[0]) # 元组(100002, '0010014', '00101') print(type(numbers[0])) # tuple元组类型 # 元组访问方式与拼接 print(str(str(numbers[1][0]))+\":\"+str(numbers[1][1])) # 100002:0010002 print(type(numbers)) # list 列表 print('总列表：',numbers) cursor.execute(sql) loan_count = 0 # 获取所有的查询数据(1.区别于fetchone() 2.fetchall/fetchone()的返回值均为元组型列表，即[(第一行数据),(第二行数据),...()]) with open(\"test_demo.txt\",'a+',encoding='utf-8') as f: for number in numbers: f.write(str(number[0])+\" \"+str(number[1]) + \" \"+str(number[2]+\"\\n\")) # 元组数据number=(\"考勤卡号”，\"刷卡时间\") loan_count += 1 # 断开连接 cursor.close() conn.close() print(\"写入完成,共写入%d条数据！\" % loan_count)if __name__ == '__main__': demo() 数据库查询后返回的所有数据 12# 总列表： [(100002, '0010014', '00101'), (100002, '0010002', '00101'),..., (100006, '0010014', '00101')] 由上式案列可知：1.fetchall():表示返回查询到的所有数据；fetchone():表示返回查询到的第一行数据2.python查询返回的所有数据类型为元组型列表，即[(),(),...()]3.元组的访问方式为：元组名[&quot;index&quot;] 2.python文件打开方式详解 打开方式 详解 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"fetchall()","slug":"fetchall","permalink":"https://ahrilove.top/tags/fetchall/"},{"name":"fetchone()","slug":"fetchone","permalink":"https://ahrilove.top/tags/fetchone/"}]},{"title":"Python全栈系列章节更新（二）：常见库模块","slug":"python(二)常见库函数","date":"2019-11-28T16:00:00.000Z","updated":"2019-12-15T04:48:28.677Z","comments":true,"path":"2019/11/29/python(二)常见库函数/","link":"","permalink":"https://ahrilove.top/2019/11/29/python(%E4%BA%8C)%E5%B8%B8%E8%A7%81%E5%BA%93%E5%87%BD%E6%95%B0/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.DBUtils管理数据库连接池3.ftplib模块4.os模块5.datetime模块6.tqdm模块7.控制台输出带颜色文字的方法","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.DBUtils管理数据库连接池3.ftplib模块4.os模块5.datetime模块6.tqdm模块7.控制台输出带颜色文字的方法 1.time模块Unix时间戳转与时间的转换 将时间戳转换成时间，首先需要将时间戳转换成localtime，再转换成时间的具体格式： 利用localtime()函数将时间戳转化成localtime的格式利用strftime()函数重新格式化时间 123456789101112131415161718192021222324# -*- coding:utf-8 -*-import time# 将时间戳转化为目标时间格式def timestamp_datatime(value): format = '%Y-%m-%d %H:%M' # format = '%Y-%m-%d %H:%M:%S' # value 为时间戳值,如:1460073600.0 value = time.localtime(value) dt = time.strftime(format, value) return dt# 将目标时间格式转化为时间戳def datetime_timestamp(dt): newTime = time.strptime(dt, '%Y-%m-%d %H:%M') s = time.mktime(newTime) return sif __name__ == '__main__': s = timestamp_datatime(1460073600.0) print(s) # 2016-04-08 08:00 d = datetime_timestamp('2019-06-05 08:00') print(d) # 1559692800.0 按指定的格式获取当前时间利用time()获取当前时间，再利用localtime()函数转换为localtime，最后利用strftime()函数重新格式化时间。 1234567891011#coding:UTF-8import time#获取当前时间time_now = int(time.time())#转换成localtimetime_local = time.localtime(time_now)#转换成新的时间格式(2016-05-09 18:59:20),时间连接符号可改变dt = time.strftime(\"%Y-%m-%d %H:%M:%S\",time_local)print(dt) 2.DBUtils管理数据库连接池当使用多线程，多进程将海量数据存入数据库时，每次执行一个sql的时候都单独建立一个mysql连接，执行完就close掉，很明显这样的问题在于，频繁连接，断开mysql，这样是相当消耗系统资源的，而且增加了mysql连接失败的几率，所以万一哪个线程没有连接成功 这个线程也over了。 2.1 连接池原理1.在程序创建连接的时候，可以从一个空闲的连接中获取，不需要重新初始化连接，提升获取连接的速度2.关闭连接的时候，把连接放回连接池，而不是真正的关闭，所以可以减少频繁地打开和关闭连接 安装DBUtils库 pip install DBUtils 参数解释 参数 详解 creator, # 使用链接数据库的模块(必须：pymssql，pymysql，cx_oralce,…) mincached=0, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=0, # 链接池中最多闲置的链接，0和None不限制 maxshared=0, # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用 maxconnections=0, # 连接池允许的最大连接数，0和None表示不限制连接数 blocking=False, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=None, # 开始会话前执行的命令列表。如：[“set datestyle to …”, “set time zone …”] reset=True, failures=None, ping=1, # ping MySQL服务端，检查是否服务可用 数据库设置(数据库连接模块不一样，其参数名也不同) 如creator=pymysql：host=&#39;localhost&#39;, port=3306,db=&#39;mydata&#39;,user=&quot;root&quot;,passwd=&quot;123456&quot;,charset=&#39;utf8&#39; 数据库通用连接函数（连接模块视实际数据库决定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 2.2 多线程（连接池）操作MySQL插入数据 启动线程任务 每调用一次插入函数就从连接池中取出一个链接操作,完成后关闭链接;executemany 批量操作,减少 commit 次数,提升效率; 3.ftplib操作ftp实现上传和下载的ftplib模块是系统默认安装的，实现文件的上传与下载 3.1 ftp登陆连接1234567891011121314151617181920212223242526from ftplib import FTP #加载ftp模块ftp=FTP() #设置变量ftp.set_debuglevel(2) #打开调试级别2，显示详细信息ftp.connect(\"IP\",\"port\") #连接的ftp sever和端口ftp.login(\"user\",\"password\") #连接的用户名，密码print(ftp.getwelcome()) #打印出欢迎信息bufsize=1024 #设置的缓冲区大小filename=\"filename.txt\" #需要下载的文件file_handle=open(filename,\"wb\").write #以写模式在本地打开文件ftp.retrbinaly(\"RETR filename.txt\",file_handle,bufsize) #接收服务器上文件并写入本地文件ftp.set_debuglevel(0) #关闭调试模式ftp.quit() #退出ftp # ftp相关命令操作ftp.cwd(pathname) #设置FTP当前操作的路径ftp.dir() #显示目录下所有目录信息ftp.nlst() #获取目录下的文件ftp.mkd(pathname) #新建远程目录ftp.pwd() #返回当前所在位置ftp.rmd(dirname) #删除远程目录ftp.delete(filename) #删除远程文件ftp.rename(fromname, toname)#将fromname修改名称为toname。ftp.storbinary(\"STOR filename.txt\",file_content,bufsize) #上传目标文件ftp.retrbinary(\"RETR filename.txt\",file_content,bufsize) #下载FTP文件 3.2 ftp上传或下载文件/目录4.os模块记下常用的os模块的操作指令 命令 含义 os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径,相当于shell的pwd os.chdir(“dirname”) 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: (‘.’) os.pardir 获取当前目录的父目录字符串名：(‘..’) os.makedirs(‘dirname1/dirname2’) 可生成多层递归目录 os.removedirs(‘dirname1’) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(‘dirname’) 生成单级目录；相当于shell中mkdir dirname os.rmdir(‘dirname’) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(‘dirname’) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(“oldname”,”newname”) 重命名文件/目录 os.stat(‘path/filename’) 获取文件/目录信息 os.name 输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’ os.system(“执行的命令”) 运行shell命令，直接显示,相当于直接在cmd命令中执行 os.environ 获取系统环境变量 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path/file) 如果路径或文件存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.join(path1,path2,…,pathn) 将多个路径组合后返回 简要样例说明： 123456789101112131415161718192021222324252627&gt;&gt;&gt; os.path.split(&quot;/Users/hqs/PycharmProjects/startMyPython3.0&quot;) (&apos;/Users/hqs/PycharmProjects&apos;, &apos;startMyPython3.0&apos;)&gt;&gt;&gt; os.path.dirname(&apos;/Users/hqs/PycharmProjects/startMyPython3.0&apos;)&apos;/Users/hqs/PycharmProjects&apos;&gt;&gt;&gt;os.system(&quot;ping 127.0.0.1&quot;)正在 Ping 127.0.0.1 具有 32 字节的数据:来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64127.0.0.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms &gt;&gt;&gt;os.path.abspath(__file__) 当前文件的绝对路径&gt;&gt;&gt;os.path.dirname(os.path.abspath(__file__))当前文件的上一层目录的绝对路径os.path.dirname(os.path.dirname(os.path.abspath(__file__)))当前文件的上上层目录的绝对路径 5 datetime模块1.datetime.date：表示日期的类2.datetime.datetime：表示日期时间的类3.datetime.time：表示时间的类4.datetime.timedelta：表示时间间隔，即两个时间点的间隔5.datetime.tzinfo：时区的相关信息 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt;datetime.datetime.now()当前系统时间：datetime.datetime(2019, 12, 3, 20, 31, 10, 740869)&gt;&gt;&gt;datetime.datetime.now().year/month/day分别为：2019，12，3&gt;&gt;&gt;datetime.datetime.now().weekday()1 表示在第几周&gt;&gt;&gt;time1 = datetime.datetime(2016, 10, 20)&gt;&gt;&gt;time2 = datetime.datetime(2015, 11, 2) &quot;&quot;&quot;计算天数差值&quot;&quot;&quot;print(time1-time2).days &quot;&quot;&quot;计算两个日期之间相隔的秒数&quot;&quot;&quot;print (time1-time2).total_seconds()# 获取当前时间,并转化为字符串型&gt;&gt;&gt;time_new = str(datetime.datetime.now().date()) # &apos;2019-12-4&apos;# 以当天的09：00为开始时间（时间戳格式）&gt;&gt;&gt;time_on = time.mktime(time.strptime(time_new+ &apos; 09:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))# 以当天的18：00为结束时间（时间戳格式）&gt;&gt;&gt;time_off = time.mktime(time.strptime(time_new+ &apos; 18:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))# 当前星期几&gt;&gt;&gt;week_now = datetime.datetime.now().weekday()# 当前时间&gt;&gt;&gt;time_now = datetime.datetime.now() # datetime.datetime(2019, 12, 4, 14, 57, 48, 988520)# 当前第几小时（24小时制）&gt;&gt;&gt;hour_now = datetime.datetime.now().hour # 14 5.tqdm模块（最优雅的进度条）from tqdm import tqdm使用方法： 123456from tqdm import tqdmimport timeif __name__ == '__main__': for i in tqdm(range(1000)): time.sleep(0.5) 6.控制台输出带颜色文字的方法设置颜色开始 ：\\033[显示方式;前景色;背景色m 文本内容 \\033[0m（此处为结束语） 12345print('\\033[1;31m我以我血荐轩辕\\033[0m')print('\\033[4;35m我以我血荐轩辕\\033[0m')print('\\033[5;37;40m我以我血荐轩辕\\033[0m')print('\\033[0;32m我以我血荐轩辕\\033[0m')print('\\033[1;32m我以我血荐轩辕\\033[0m') 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"time","slug":"time","permalink":"https://ahrilove.top/tags/time/"},{"name":"datetime","slug":"datetime","permalink":"https://ahrilove.top/tags/datetime/"},{"name":"DBUtils","slug":"DBUtils","permalink":"https://ahrilove.top/tags/DBUtils/"}]},{"title":"技术小白教你如何定位照片拍摄位置","slug":"照片的GPS信息定位","date":"2019-11-27T16:00:00.000Z","updated":"2019-12-05T09:04:11.808Z","comments":true,"path":"2019/11/28/照片的GPS信息定位/","link":"","permalink":"https://ahrilove.top/2019/11/28/%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动）","text":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动） 1.获取GPS信息&nbsp;&nbsp;&nbsp;&nbsp;将照片复制至电脑。点击照片，右键--“右键菜单”--“属性”--“详细信息”，下拉至“GPS”，将会看到经纬度信息。如下图所示： 2.经纬度计算方法&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到经纬度信息，是以度分秒的格式展示的（度分秒之间以“；”间隔），为了方便定位，我们需要将度分秒转换为度的格式。计算方法：经纬度同理（本例为32；49；49.942932000005413）经度：度+（分+秒/60）/60，即32+(49+49.9429/60)/60=32.8305; 3.测试在奥维地图上将计算后的经纬度（以英文格式书写）代入其中，就可以获得地理位置信息。","categories":[],"tags":[{"name":"定位照片拍摄位置","slug":"定位照片拍摄位置","permalink":"https://ahrilove.top/tags/%E5%AE%9A%E4%BD%8D%E7%85%A7%E7%89%87%E6%8B%8D%E6%91%84%E4%BD%8D%E7%BD%AE/"}]},{"title":"Nginx（二）：Nginx的命令和配置文件","slug":"Nginx(二)","date":"2019-11-26T16:00:00.000Z","updated":"2019-12-05T14:28:10.699Z","comments":true,"path":"2019/11/27/Nginx(二)/","link":"","permalink":"https://ahrilove.top/2019/11/27/Nginx(%E4%BA%8C)/","excerpt":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1","text":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1 1.理清概念docker创建Nginx容器很简单：共享数据卷，外部访问端口映射window下运行nginx，只需简单式一直点击“NEXT”安装，然后添加到环境变量即可在Linux下启动nginx相对比较麻烦，如果你采用其它两种方式，可以跳过本节，本节主要是介绍Linux下的运行命令无论哪种方式启动Nginx，其核心的配置文件以及接下来的几个配置实例都是通用的 2.Linux下Nginx的常用命令先关闭防火墙或者是开放目标端口 进入nginx目录中 cd /usr/local/nginx/sbin (前面路径有可能不同，主要是nginx内的nginx/sbin路径) 1、查看nginx版本号 ./nginx -v 2、启动nginx ./nginx 3、停止nginx ./nginx -s stop 4、重新加载nginx ./nginx -s reload 3.ginx的基本配置文件nginx.conf3.1、nginx 配置文件位置cd /usr/local/nginx/conf/nginx.conf 3.2、配置文件中的内容 包含三部分内容（1）全局块：配置服务器整体运行的配置指令 比如 worker_processes 1;处理并发数的配置 （2）events 块：影响 Nginx 服务器与用户的网络连接 比如 worker_connections 1024; 支持的最大连接数为 1024 （3）http 块 还包含两部分： http 全局块 server 块 3.3 默认的nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; 404.md # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 4.Nginx 配置实例-反向代理实例 14.1、实现效果（1）打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到 liunx 系统 tomcat 主页 面中 4.2、准备工作（1）在 liunx 系统安装 tomcat，使用默认端口 8080 * tomcat 安装文件放到 liunx 系统中，解压 * 进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器 （2）对外开放访问的端口firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload （3）查看已经开放的端口号firewall-cmd –list-all （4）在 windows 系统中通过浏览器访问 tomcat 服务器(linux_IP + tomcat_Port) 4.3、访问过程分析 映射IP 假设域名www.123.com映射的IP为Linux上的nginx的ip地址（比如我的是192.168.17.129:80）,nginx也相当于一个分发器，将请求发送至tomcat服务器 123访问过程分析windows端 ----------&gt;Nginx（linux_IP：80）------&gt;tomcat(127.0.0.1:8080)（假设访问www.123.com） 在 nginx 进行请求转发的配置（反向代理配置） 123456789server&#123; listen 80; # 监听端口 server_name www.123.com; # 配置域名 location /&#123; proxy_pass http://127.0.0.1:8080; # 跳转到127.0.0.1：8080路径 index index.html index.htm index.jsp; &#125;&#125; 如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 www.123.com后，成功后直接跳转到tomcat主页","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nginx.conf","slug":"nginx-conf","permalink":"https://ahrilove.top/tags/nginx-conf/"},{"name":"nginx","slug":"nginx","permalink":"https://ahrilove.top/tags/nginx/"}]},{"title":"Nginx（一）：基本概念","slug":"Nginx","date":"2019-11-24T16:00:00.000Z","updated":"2019-11-28T00:31:56.883Z","comments":true,"path":"2019/11/25/Nginx/","link":"","permalink":"https://ahrilove.top/2019/11/25/Nginx/","excerpt":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程","text":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程 1.正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。如图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结来说：正向代理，”它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正向代理的用途：（1）访问原来无法访问的资源，如Google（2） 可以做缓存，加速访问资源（3）对客户端访问授权，上网进行认证（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 2.反向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：http://tengine.taobao.org/。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理的作用：（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网（2）负载均衡，通过反向代理服务器来优化网站的负载 3.项目场景以及两者区别通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：两者区别：图解： 在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息； 在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息； 实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了 4.负载均衡我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？ 这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。 请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。 所以，将服务器接收到的请求按照规则分发的过程，称为负载均衡。 负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。Nginx支持的负载均衡调度算法方式如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。 5.动静分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 6.nginx安装windows下安装与部署NginxLinux下安装与部署Nginx以后都推荐再docker下安装各式各样的环境Ubuntu+docker下安装与部署Nginx","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ahrilove.top/tags/nginx/"},{"name":"apache","slug":"apache","permalink":"https://ahrilove.top/tags/apache/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://ahrilove.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"Javascript篇章四：快速入门","slug":"Javascript篇章四","date":"2019-11-22T16:00:00.000Z","updated":"2019-12-22T06:54:44.071Z","comments":true,"path":"2019/11/23/Javascript篇章四/","link":"","permalink":"https://ahrilove.top/2019/11/23/Javascript%E7%AF%87%E7%AB%A0%E5%9B%9B/","excerpt":"1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单6.前端模块化","text":"1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单6.前端模块化 1.条件判断以及prompt() 方法多条件判断：if…else if…else if…elseprompt(text,defaultText)方法用于显示可提示用户进行输入的对话框（即输入数据）,参数一表示提示文本，参数二表示默认值var name=prompt(“Please enter your name”,”ritian zhao”) 2.循环 for(i=1;i&lt;=1000;i++){} 2.for…in… 3.while(){} 3. return终止函数1.return后面的语句不执行2.JavaScript里的return只能返回一个数值（区别于python可以返回多个） 4.Map与Set运用Map是一组键值对的结构，具有很快的查找速度举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 Map的方法（初始化Map需要一个二维数组，或者直接初始化一个空Map） 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67,获取值m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，map函数会把后面的值会把前面的值冲掉 Set() Set和Map类似，也是一组key的集合，但不存储value。 由于key不能重复，所以，在Set中，没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); //一个Array含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 全局作用域1.不在任何函数内定义的变量就具有全局作用域，实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。window.属性/window.方法2.ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量3.ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域 浏览器对象：window,navigator,screen,Location，document window对象不仅充当全局作用域，而且表示浏览器的窗口 window.innerWidth和window.innerHeight:可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高 windows.outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高 navigator对象表示浏览器信息 navigator.appName：浏览器名称；navigator.appVersion：浏览器版本；navigator.language：浏览器设置的语言；navigator.platform：操作系统类型；navigator.userAgent：浏览器设定的User-Agent字符串 screen表示屏幕信息 screen.width：屏幕宽度，以像素为单位；screen.height：屏幕高度，以像素为单位；screen.colorDepth：返回颜色位数，如8、16、24。 Location对象表示当前页面的URL信息 location.protocol; // ‘http’location.host; // ‘www.example.com&#39;location.port; // ‘8080’location.pathname; // ‘/path/index.html’location.search; // ‘?a=1&amp;b=2’location.hash; // ‘TOP’location.href 获取完整urlwindow.location.href=&quot;新的跳转url”：跳转到指定的页面location.assign()：加载一个新页面，可以调用location.reload()：如果要重新加载当前页面 document对象表示当前页面 高阶函数 map/reduce函数，与python的map，reduce作用相同 1234var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]// 对于reduce函数：函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) instanceof关键字 这个关键字的用法是：A instanceof B ，返回值为boolean类型。用来判断A是否是B的实例对象或者B子类的实例对象。如果是则返回true,否则返回false 1234567//Man是Person的子类p = new Person() ; //m = new Man() ; a = new Animal() ;m instanceof Man //返回truem instanceof Animal//返回falsem instanceof Person//返回true 操作表单文本框，对应的&lt;input type=”text”&gt;，用于输入文本； 口令框，对应的&lt;input type=”password”&gt;，用于输入口令； 单选框，对应的&lt;input type=”radio”&gt;，用于选择一项； 复选框，对应的&lt;input type=”checkbox”&gt;，用于选择多项； 下拉框，对应的&lt;select&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=”hidden”&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 获取值 如果我们获得了一个&lt;input&gt;节点的引用，就可以直接调用value获得对应的用户输入值，使用样例：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量名.value可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： 12345678// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.value; // '1'tue.value; // '2'mon.checked; // true或者falsetue.checked; // true或者false 面向对象编程 构造函数 构造函数与普通函数的区别就是调用方式不同：普通函数是直接调用，而构造函数需要使用new关键字来调用PS:构造函数的函数名一般默认首字母大写；构造函数里可以使用this;参考：本质与python的构造函数相同 12345678910function Person(name,age) &#123; this.name=name; this.age = age; this.sayHi = function() &#123; alert(this.name) &#125;&#125;// 创建一个对象pervar per = new Person();console.log(per); indexOf()方法strings.indexOf(“目标字符串”):可返回某个指定的字符串值在字符串中首次出现的位置 123456789var str=\"Hello world!\";document.write(str.indexOf(\"Hello\") + \"&lt;br /&gt;\");document.write(str.indexOf(\"World\") + \"&lt;br /&gt;\");document.write(str.indexOf(\"world\"));/** 0*-1*6 */ indexOf() 方法对大小写敏感！:如果要检索的字符串值没有出现，则该方法返回 -1,而且索引值默认起始值为0 Timing事件setTimeout(function,milliseconds):等待指定的毫秒数后执行函数setInterval(function,milliseconds):等同于setTimeout()，但在每个给定的时间间隔内重复执行该函数 1234567var myVar = setInterval(myTimer, 3000); function myTimer() &#123; var d = new Date(); console.log(d.getFullYear())&#125;// setInterval在每隔3秒就打印一次当前的月份 clearTimeout(变量名) 方法停止执行 setTimeout() 中规定的函数。 1234&lt;!--使用setTimeout等待执行函数，clearTimeout停止执行函数---&gt;&lt;button onclick=\"myVar = setTimeout(myFunction, 3000)\"&gt;试一试&lt;/button&gt;&lt;button onclick=\"clearTimeout(myVar)\"&gt;停止执行&lt;/button&gt; 5.前端模块化(node.js) 1.模块暴露 我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块 123456789'use strict';var s = 'Hello';function greet(name) &#123; console.log(s + ', ' + name + '!');&#125;module.exports = greet; module.exports把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了 2.模块引入 12345678'use strict';// 引入hello模块:var greet = require('./hello');var s = 'Michael';greet(s); // Hello, Michael! 3.多模块暴露 我们不妨深入♂一下：将某个模块暴露出来，并访问该模块内的多个函数 12345678910111213141516171819// hello.js'use strict';var s = \"hello python\";function conn(name)&#123; console.log(s+','+name+'!'); return(s+\",\"+name+\"!\") &#125;function printer(n)&#123; let ab = []; if(n&gt;=1)&#123; for(var i = 0;i&lt;n;i++)&#123; ab.push(i)&#125; console.log(ab) &#125;else&#123; console.log(\"输入错误\") &#125;&#125;// 将模块暴露出来，以便于其它模块调用，采用对象的形式module.exports =&#123;conn:conn,printer:printer&#125;; 然后我们来访问hello模块，来玩♂一♀玩(注意模块里的函数调用方式) 123456// 主模块mian.js'use strict';var greet = require('./hello');var s = \"chd\";greet.conn(s);greet.printer(10)","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章三：js数字，数组与日期","slug":"Javascript篇章三","date":"2019-11-21T16:00:00.000Z","updated":"2019-12-23T00:51:31.253Z","comments":true,"path":"2019/11/22/Javascript篇章三/","link":"","permalink":"https://ahrilove.top/2019/11/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%89/","excerpt":"关关雎鸠，在河之洲。窈窕淑女，君子好逑 本文要点：1.数值方法2.数组以及数组属性和方法3.日期","text":"关关雎鸠，在河之洲。窈窕淑女，君子好逑 本文要点：1.数值方法2.数组以及数组属性和方法3.日期 1.数值方法 number.toString():将数值型转化为字符串型 123var n = 15; console.log(typeof(n)); // 为字数值类型numbera = n.toString(); // a为字符串类型 toFixed(number) 返回保留指定小数位数的数值 12345var x = 9.656;x.toFixed(0); // 返回 10x.toFixed(2); // 返回 9.66x.toFixed(4); // 返回 9.6560x.toFixed(6); // 返回 9.656000 把变量转换为数值 这三种 JavaScript 方法可用于将变量转换为数字： Number() 方法 parseFloat(string) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，则对其进行解析直到完整取出第一个数值，并返回首个数值，如果首字符不是数字则直接返回NaN parseInt(string，radix) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，将字符串取出首个完整数值，并转化为指定radix进制，如果首字符不是数字，就直接返回NaN 123456789101112parseInt(\"10.008\"); // 返回 10parseInt(\"10.33\"); // 返回 10parseInt(\"10 20 30\"); // 返回 10parseInt(\"10 years\"); // 返回 10parseInt(\"years 10\"); // 返回 NaNparseInt(\"30\",8); // 返回24，将30转化为8进制parseFloat(\"10\"); // 返回 10parseFloat(\"10.33\"); // 返回 10.33parseFloat(\"10 20 30\"); // 返回 10parseFloat(\"10 years\"); // 返回 10parseFloat(\"years 10\"); // 返回 NaN 2.数组 数组是一种特殊的变量，它能够一次存放一个以上的值。 var cars=[“Saab”,”Volov”,”BMW”]; 访问数组元素：通过索引（从0开始，下标号）来引用某个数组元素 var name=car[0] 访问数组值var car[0] = “Benz” 修改数组值，即新数组为[“Benz”,”Volov”,”BMW”] 数组属性和方法 length:返回数组元素的数目 遍历数组元素：最安全是使用for循环 123456var fruits;fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];for (i = 0; i &lt; fruits.length; i++) &#123; console.log(fruits[i]);&#125; 向数组添加新元素的最佳方法是使用 push() 方法 12let fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.push(\"Lemon\"); // 向 fruits 添加一个新元素 (Lemon),并返回数组元素个数 join() 方法也可将所有数组元素结合为一个字符串 格式：数组名.join(“指定拼接符”) 123var fruits = [\"Banana\", \"Orange\",\"Apple\", \"Mango\"];console.log(fruits.join(\" * \"));// Banana * Orange * Apple * Mango pop()从数组中删除最后一个元素,并返回该值（shift()从数组中删除第一个元素,并返回该值）var fruits = [“Banana”, “Orange”, “Apple”, “Mango”];var x = fruits.pop(); // x 的值是 “Mango” 123拓：push()+pop():可以构成栈方法，先进后出push()+shift()：可以构成队列方法，先进先出 sort()方法以字母顺序对数组进行排序 reverse()反转数组中的元素 123var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.sort(); // 对 fruits 中的元素进行排序fruitS.reverse(); // 对数组元素进行反转 JavaScript的数组可以包含任意数据类型创建方式一(推荐使用)：[1, 2, 3.14, ‘Hello’, null, true];创建方式二：通过Array()函数实现b = new Array(1, 2, 3); 3.日期使用方法：var d = new Date(); 获取系统时间d.getDate()/d.getFullYear()… 方法 描述 getDate() 以数值返回天数（1-31） getDay() 以数值获取周几（0-6） getFullYear() 获取四位的年（yyyy） getHours() 获取小时（0-23） getMilliseconds() 获取毫秒（0-999） getMinutes() 获取分（0-59） getMonth() 获取月（0-11） getSeconds() 获取秒（0-59） getTime() 获取时间戳（从 1970 年 1 月 1 日至今） 未完待续…","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"对象","slug":"对象","permalink":"https://ahrilove.top/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"属性与方法","slug":"属性与方法","permalink":"https://ahrilove.top/tags/%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"}]},{"title":"Javascript篇章二：js计算精度丢失","slug":"Javascript篇章二","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-26T08:57:12.309Z","comments":true,"path":"2019/11/21/Javascript篇章二/","link":"","permalink":"https://ahrilove.top/2019/11/21/Javascript%E7%AF%87%E7%AB%A0%E4%BA%8C/","excerpt":"若教眼底无离恨，不信人间有白头 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript中没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失。 本文要点：1.js精确度丢失缘由2.精确度丢失解决方案","text":"若教眼底无离恨，不信人间有白头 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript中没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失。 本文要点：1.js精确度丢失缘由2.精确度丢失解决方案 js精确度丢失出现缘由 1.我们先看几个四舍五入的实例 12alert(Number(0.009).toFixed(2)); alert(Number(162.295).toFixed(2)); 按正常结果，应该分别弹出0.01和162.30。但实际测试结果却是在不同浏览器中得到的是不同的结果：在ie6、7、8下得到0.00和162.30，第一个数截取不正确；在firefox中得到0.01和162.29，第二个数截取不正确；在opera下得到0.01和162.29，第二个数截取不正确 2.再看有关于四则运算的实例 12345alert(1/3);//弹出: 0.3333333333333333 alert(0.1 + 0.2);//弹出: 0.30000000000000004 alert(-0.09 - 0.01);//弹出: -0.09999999999999999 alert(0.012345 * 0.000001);//弹出: 1.2344999999999999e-8 alert(0.000001 / 0.0001);//弹出: 0.009999999999999998 按正常结果，除第一行外(因为其本身就不能除尽)，其他都应该要得到精确的结果，从弹出的结果我们却发现不是我们想要的正确结果。是因为没有转换成Number类型吗？我们转换成Number后再计算看看： 12345alert(Number(1)/Number(3));//弹出: 0.3333333333333333 alert(Number(0.1) + Number(0.2));//弹出: 0.30000000000000004 alert(Number(-0.09) - Number(0.01));//弹出: -0.09999999999999999 alert(Number(0.012345) * Number(0.000001));//弹出: 1.2344999999999999e-8 alert(Number(0.000001) / Number(0.0001));//弹出: 0.009999999999999998 还是一样的结果，看来javascript默认把数字识别为number类型。为了验证这一点，我们用typeof弹出类型看看： 123alert(typeof(1));//弹出: number alert(typeof(1/3));//弹出: number alert(typeof(-0.09999999));//弹出: number 3.计算机原理 回忆一下大学时学过的计算机原理，计算机执行的是二进制算术，当十进制数不能准确转换为二进制数时，这种精度误差就在所难免。从上述的推演过程我们知道，这种误差是难免的，c#的decimal和Java的BigDecimal之所以没有出现精度差异，只是因为在其内部作了相应处理，把这种精度差异给屏蔽掉了，而javascript是一种弱类型的脚本语言，本身并没有对计算精度做相应的处理，这就需要我们另外想办法处理了 解决JS计算精确度丢失&nbsp;&nbsp;&nbsp;&nbsp;创建calc.js文件，其调用方法参考&nbsp;&nbsp;thinkphp项目调用Vue扩展函数方式 参考文章 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137Vue.prototype.calc = &#123; /** * 千分位格式化函数 * @param &#123;*&#125; number 要格式化的数字 * @param &#123;*&#125; decimals 保留几位小数 * @param &#123;*&#125; dec_point 小数点符号 * @param &#123;*&#125; thousands_sep 千分位符号 */ number_format(number, decimals, dec_point, thousands_sep) &#123; if(parseFloat(number) == 0) return \" - \"; number = (number + '').replace(/[^0-9+-Ee.]/g, ''); var n = !isFinite(+number) ? 0 : +number, decimals = (typeof decimals === 'undefined') ? 2 : decimals, prec = !isFinite(+decimals) ? 0 : Math.abs(decimals), sep = (typeof thousands_sep === 'undefined') ? ',' : thousands_sep, dec = (typeof dec_point === 'undefined') ? '.' : dec_point, s = '', toFixedFix = function (n, prec) &#123; var k = Math.pow(10, prec); return '' + Math.ceil(n * k) / k; &#125;; s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.'); var re = /(-?\\d+)(\\d&#123;3&#125;)/; while (re.test(s[0])) &#123; s[0] = s[0].replace(re, \"$1\" + sep + \"$2\"); &#125; if ((s[1] || '').length &lt; prec) &#123; s[1] = s[1] || ''; s[1] += new Array(prec - s[1].length + 1).join('0'); &#125; return s.join(dec); &#125;, /** * 加法函数，用来得到精确的加法结果 * 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 * 调用：accAdd(arg1,arg2) * 返回值：arg1加上arg2的精确结果 **/ accAdd: function(arg1, arg2) &#123; var r1, r2, m, c; try &#123; r1 = arg1.toString().split(\".\")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(\".\")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; c = Math.abs(r1 - r2); m = Math.pow(10, Math.max(r1, r2)); if (c &gt; 0) &#123; var cm = Math.pow(10, c); if (r1 &gt; r2) &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")); arg2 = Number(arg2.toString().replace(\".\", \"\")) * cm; &#125; else &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")) * cm; arg2 = Number(arg2.toString().replace(\".\", \"\")); &#125; &#125; else &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")); arg2 = Number(arg2.toString().replace(\".\", \"\")); &#125; return (arg1 + arg2) / m; &#125;, /** * 减法函数，用来得到精确的减法结果 * 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。 * 调用：accSub(arg1,arg2) * 返回值：arg1加上arg2的精确结果 **/ accSub: function(arg1, arg2) &#123; var r1, r2, m, n; try &#123; r1 = arg1.toString().split(\".\")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(\".\")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度 n = (r1 &gt;= r2) ? r1 : r2; return parseFloat(((arg1 * m - arg2 * m) / m).toFixed(n)); &#125;, //乘法函数，用来得到精确的乘法结果 //说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 //调用：accMul(arg1,arg2) //返回值：arg1乘以arg2的精确结果 accMul: function(arg1,arg2) &#123; var m = 0, s1 = arg1.toString(), s2 = arg2.toString(); try &#123; m += s1.split(\".\")[1].length &#125; catch (e) &#123;&#125; try &#123; m += s2.split(\".\")[1].length &#125; catch (e) &#123;&#125; return Number(s1.replace(\".\", \"\")) * Number(s2.replace(\".\", \"\")) / Math.pow(10, m); &#125;, //除法函数，用来得到精确的除法结果 //说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 //调用：accDiv(arg1,arg2) //返回值：arg1除以arg2的精确结果 accDiv: function(arg1, arg2) &#123; var t1 = 0, t2 = 0, r1, r2; try &#123; t1 = arg1.toString().split(\".\")[1].length &#125; catch (e) &#123;&#125; try &#123; t2 = arg2.toString().split(\".\")[1].length &#125; catch (e) &#123;&#125; with(Math) &#123; r1 = Number(arg1.toString().replace(\".\", \"\")); r2 = Number(arg2.toString().replace(\".\", \"\")); return (r1 / r2) * pow(10, t2 - t1); &#125; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js精确度丢失","slug":"js精确度丢失","permalink":"https://ahrilove.top/tags/js%E7%B2%BE%E7%A1%AE%E5%BA%A6%E4%B8%A2%E5%A4%B1/"}]},{"title":"Javascript篇章一：JavaScript基本知识","slug":"Javascript篇章一","date":"2019-11-19T16:00:00.000Z","updated":"2019-12-09T07:43:17.205Z","comments":true,"path":"2019/11/20/Javascript篇章一/","link":"","permalink":"https://ahrilove.top/2019/11/20/Javascript%E7%AF%87%E7%AB%A0%E4%B8%80/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的，一个前端项目必离不开HTML+CSS+JavaScript。 本文要点：1.变量及数据类型2.对象3.javascript小知识点","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的，一个前端项目必离不开HTML+CSS+JavaScript。 本文要点：1.变量及数据类型2.对象3.javascript小知识点 1. 变量及数据类型：JavaScript变量是数据值的容器变量修饰符：var,let,constvar car=”BMW”;var age=18; JavaScript数据类型分为：数值、字符串值、数组、对象等等 1234let length = 7; // 数字let lastName = \"Gates\"; // 字符串let cars = [\"Porsche\", \"Volvo\", \"BMW\"]; // 数组let x = &#123;firstName:\"Bill\", lastName:\"Gates\"&#125;; // 对象 2.对象对象的值以名称:值对的方式来书写（名称和值由冒号分隔） 123456789var person = &#123; //这里的person称为对象 firstName:\"Bill\", // 这是属性 lastName:\"Gates\", age:62, eyeColor:\"blue\", fullName : function() &#123; // 这就是方法 return this.firstName + \" \" + this.lastName; &#125;&#125;; JavaScript中的this关键词 12345在函数定义中，this 引用该函数的“拥有者”。在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。换言之，this.firstName 的意思是 this 对象的 firstName 属性。 对象的访问方式： 对象名.属性名 或者对象名[“属性名”] 案例：数据集构造12345678910111213141516let dimensions = []; //维度let source = []; //数据集let series = []; //图系列dimensions.push(\"groupcus_name\");dimensions.push(\"剩余发出商品\");for(let i=0;i&lt;response.Rows.length;i++)&#123; let obj = &#123;&#125;; obj[\"groupcus_name\"] = response.Rows[i].groupcus_name; // 对象的调用方式obj[\"key_name\"]或obj.key_name obj[\"剩余发出商品\"] = response.Rows[i].surplusp; source.push(obj); // 记住push只适用于数组的元素添加，并返回数组元素个数&#125; 3.javascript小知识点 函数语法 function function_name(param1,param2,…){code}PS:不使用 () 访问函数将返回函数声明而不是函数结果 3.1 js字符串长度 易混点：JavaScript字符串长度：str.lengthphp的字符串长度：count(string)python的字符串长度：len(string)jQuery中的length：表示query对象中元素个数 $(“div”).siblings().length=&gt;表示div标签的兄弟节点元素个数 3.2 使用\\ 转义字符 \\n表示换行 3.3 比较运算符与逻辑运算符 &quot;==&quot;:表示值相等&quot;===&quot;:表示值相等基础上，数据类型也相同&amp;&amp; :表示与运算|| :表示或运算! : 表示非运算 str.slice(start，end)方法 slice() 提取字符串的某个部分并在新字符串中返回被提取的部分(起始索引值为0，且满足左闭右开)。 该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。 substring()方法 substring() 类似于 slice()，不同之处在于 substring() 无法接受负的索引 substr(start,length) 第二个参数规定被提取部分的长度，如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。 str.replace(a,b) 用b替换a &#39;hello java&#39;.replace(&#39;java&#39;,&#39;python&#39;) 转换为大小写 str.toUpperCase()str.toLowerCase() str.trim(“指定字符”) trim() 方法删除字符串两端的空白符或指定字符 str.split(“指定字符”) 以指定字符切割字符串，返回数组的形式 未完待续…","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"clone","slug":"clone","permalink":"https://ahrilove.top/tags/clone/"},{"name":"push","slug":"push","permalink":"https://ahrilove.top/tags/push/"}]},{"title":"Memcached","slug":"Memcache","date":"2019-11-19T16:00:00.000Z","updated":"2019-12-03T00:19:21.382Z","comments":true,"path":"2019/11/20/Memcache/","link":"","permalink":"https://ahrilove.top/2019/11/20/Memcache/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached……","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached…… 1.安装memcached&nbsp;&nbsp;&nbsp;Memcached是通过在内存里维护一个统一的巨大的hash表，memcached能存储各种各样的数据，包括图像、视频(但是极不推荐来保存二进制文件)、文件、以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。参考docker创建memecached容器windows下ThinkPHP3.2.3使用memcache缓存 2.创建memcached镜像docker run -di –name=”memcached” -m 256m -p 11211:11211 memcached:[tag] 123456-d是启动一个守护进程；-m是分配给Memcache使用的内存数量，单位是MB；-u是运行Memcache的用户；-l是监听的服务器IP地址，可以有多个地址；-p是设置Memcache监听的端口，，最好是1024以上的端口；-c是最大运行的并发连接数，默认是1024； 3.测试并进入docker容器 测试是否启动成功 netstat -luntp|grep 11211或者docker ps 安装telnet yum install -y telnet 或 sudo apt-get install telnet 通过telnet方式连接memcached telnet 127.0.0.1 11211 或者使用 telnet ubuntu_ip docker_memcached_port 设置值，age是key，0是标志位，900是生命周期，8代表所占字节数，回车之后的10是value set age 0 900 810 获取值 get age 退出 exitquit 4.telnet操作memcached：1.添加数据 set语法：12345678 set key flas(是否压缩,默认为0，不压缩) timeout value_length value示例： set username 0 60 7 zhiliao``` + add语法： add key flas(0) timeout value_lengthvalue示例：add username 0 60 7xiaotuoset和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。 2.获取数据：get key_name 3.删除数据：delete key_name 4.删除memcached所有数据：flush_all 5. memcached安全性memcached的操作不需要任何用户名和密码，只需要知道memcached服务器的ip地址和端口号即可。因此memcached使用的时候尤其要注意他的安全性。这里提供两种安全的解决方案。分别来进行讲解： &nbsp;&nbsp;&nbsp;&nbsp;1.使用-l参数设置为只有本地可以连接：这种方式，就只能通过本机才能连接，别的机器都不能访问，可以达到最好的安全性。&nbsp;&nbsp;&nbsp;&nbsp;2.使用防火墙，关闭11211端口，外面也不能访问 未完待续…","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"Memcached","slug":"Memcached","permalink":"https://ahrilove.top/tags/Memcached/"}]},{"title":"docker开发环境系列部署","slug":"docker开发环境部署","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-19T01:31:11.425Z","comments":true,"path":"2019/11/19/docker开发环境部署/","link":"","permalink":"https://ahrilove.top/2019/11/19/docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","excerpt":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡","text":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡 1.python3+Django+MySQL部署Django项目集群1.1 宿主机上创建工程目录site，并进入该目录1234567项目目录结构：site |__achievements |__db |__Dockerfile |__doocker-compose.yml |__requirements.txt 1.2 参考两篇优秀博文离未罔两|Docker—-搭建python3+django+mysql开发环境冰凉的枷锁lax|Docker搭建Python+Django+mysql开发环境 2. Docker实现Nginx和Tomcat负载均衡暗夜猎手-大魔王|使用docker搭建高并发网站架构实践2–Docker实现Nginx和Tomcat负载均衡 菲宇|Docker下Nginx+Tomcat实现负载均衡","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"},{"name":"python+Django+MySQL","slug":"python-Django-MySQL","permalink":"https://ahrilove.top/tags/python-Django-MySQL/"}]},{"title":"Python模拟登录淘宝(Ⅰ)","slug":"requests库模拟登录淘宝(Ⅰ)","date":"2019-11-18T05:45:34.494Z","updated":"2019-11-18T05:45:34.496Z","comments":true,"path":"2019/11/18/requests库模拟登录淘宝(Ⅰ)/","link":"","permalink":"https://ahrilove.top/2019/11/18/requests%E5%BA%93%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E6%B7%98%E5%AE%9D(%E2%85%A0)/","excerpt":"讲模拟登录淘宝之前，我们来回顾一下之前用requests库模拟登录GitHub和新浪微博的过程:这一类模拟登录是比较简单的登录，只需要在请求登录时将用户名和密码上传验证通过就成功了，也就是说一步到位！而淘宝登录就比较复杂，为什么说复杂呢？因为淘宝登录涉及参数多且请求不止一次！","text":"讲模拟登录淘宝之前，我们来回顾一下之前用requests库模拟登录GitHub和新浪微博的过程:这一类模拟登录是比较简单的登录，只需要在请求登录时将用户名和密码上传验证通过就成功了，也就是说一步到位！而淘宝登录就比较复杂，为什么说复杂呢？因为淘宝登录涉及参数多且请求不止一次！ 参考文章~裸睡的猪 淘宝系列欲更新文章内容： 第一篇：Python模拟登录淘宝，详细讲解如何使用requests库登录淘宝pc端。 第二篇：淘宝自动登录2.0，新增Cookies序列化，教大家如何将cookies保存起来。 第三篇：Python爬取淘宝商品避孕套，教大家如何爬取淘宝pc端商品信息。 第四篇：Python分析2000款避孕套，教大家如何做数据分析得出结论。 ———————————————— 1.淘宝登录流程","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"Requests","slug":"Requests","permalink":"https://ahrilove.top/tags/Requests/"},{"name":"POST请求","slug":"POST请求","permalink":"https://ahrilove.top/tags/POST%E8%AF%B7%E6%B1%82/"},{"name":"token","slug":"token","permalink":"https://ahrilove.top/tags/token/"}]},{"title":"Git命令总结","slug":"git命令大全","date":"2019-11-17T16:00:00.000Z","updated":"2019-12-16T12:59:31.428Z","comments":true,"path":"2019/11/18/git命令大全/","link":"","permalink":"https://ahrilove.top/2019/11/18/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"总结一下自己常用的git命令","text":"总结一下自己常用的git命令 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash” git config –global user.name “Your Name”git config –global user.email “email@example.com“ cd F: (打开F盘)mkdir (创建子目录)pwd (显示当前目录) git init (把这个目录变成Git可以管理的仓库) git add git commit -m “说明” git status (仓库当前的状态) git diff (查看不同) git log [–pretty=oneline {缩略版,可选}] (查看历史记录) git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id) git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本) git diff HEAD – (查看工作区和版本库里面最新版本的区别) git checkout – (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除) git reset HEAD (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本) git rm (用于删除一个文件) ssh-keygen -t rsa -C “youremail@example.com“ (创建SSH Key) git remote add origin git@github.com:Bruce333/other.git (关联github远程库) git push -u origin master/git push origin master(推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改) git clone git@github.com:Bruce333/other.git (克隆一个本地库) git checkout -b dev(创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支]) git branch (列出所有分支，当前分支前面会标一个*号) git checkout master (切换到master分支) git merge dev (合并指定分支到当前分支) git branch -d dev (删除dev分支) git log –graph (查看分支合并图) git merge –no-ff -m “merge with no-ff” dev(通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去) git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作) git stash list (查看工作现场) / git stash apply stash@{0} () git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除]) git branch -D (强行删除一个没有被合并过的分支) git remote (查看远程库的信息) / git remote -v (显示更详细的信息) git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致) 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 git pull(把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name) git tag &lt;commit id 可无&gt;(打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签) git show (查看标签信息) git tag (查看所有标签) git tag -a -m “blablabla…” (指定标签信息) git tag -s -m “blablabla…” (用PGP签名标签) git tag -d (删除标签) git push origin (推送某个标签到远程) git push origin –tags (一次性推送全部尚未推送到远程的本地标签) git tag -d (删除一个本地标签) git push origin :refs/tags/ (删除一个远程标签) git config –global color.ui true (让Git适当地显示不同的颜色) 忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 git config –global alias.st status(告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中) 2019-12-16 新增：当自己的账户有私人的GitHub和企业的gitlab时，不经意间就会将不同的用户名，邮箱搞混，幸得建彬哥真传，终于搞懂了。1.在自己的项目文件下直接”git bash here”2.查看当前项目所属的用户名与邮箱 git remote show origin查看当前仓库基本信息git remote -v 查看当前项目远程地址git branch -a 查看远程项目所有分支，红颜色分支代表当前所在分支git config user.name 查看当前项目的用户名git config user.email 查看当前项目的邮箱 3.设置用户名和邮件git config [–global] user.name “用户名”git config [–global] user.email “邮箱”git config命令的-- global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://ahrilove.top/tags/git/"},{"name":"git pull/push","slug":"git-pull-push","permalink":"https://ahrilove.top/tags/git-pull-push/"}]},{"title":"ThinkPHP","slug":"ThinkPHP","date":"2019-11-14T16:00:00.000Z","updated":"2019-12-08T12:58:13.469Z","comments":true,"path":"2019/11/15/ThinkPHP/","link":"","permalink":"https://ahrilove.top/2019/11/15/ThinkPHP/","excerpt":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push(),clone()ThinkPHP的变量输出memcached缓存机制ThinkPHP通用项目结构","text":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push(),clone()ThinkPHP的变量输出memcached缓存机制ThinkPHP通用项目结构 ThinkPHP3.2 笔记 1.js的clone()与push函数的一些生活纠纷 push()函数：向数组的末尾添加一个或多个元素，并返回新的长度。返回值是把指定的值添加到数组后的新长度语法：arrayObject.push(newelement1,newelement2,….) push() 方法可把它的参数顺序添加到 arrayObject（数组对象）的尾部。它直接修改 arrayObject，而不是创建一个新的数组，而是在原数组基础上修改。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能，该方法会改变数组的长度。 案例1：push() 1234567var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\"; console.log(arr);//输出原素组 ['chd','sjb','sgx']console.log(arr.push(\"badwoman\")); // 输出 4 PS:来了，push添加元素之后没有直接输出添加元素之后的数组，只显示了数组的个数（长度） 12345678// 展示push后的新数组var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\";arr.push('badwoman');console.log(arr);//输出结果为：['chd','sjb','sgx','badwoman'] js的clone()函数 js对象之间的赋值，如果直接用”=”会发现来两个对象还是同一个对象，改变其中一个另外的一个也会做出对应的改变。为了解决这个问题，可以利用java里面的clone的原理。假设有这样一个场景：当存在一个公共数组(对象型)时，一个需要加{“name”:”chd”,”age”:18}另一个需要在数组尾加上{“name”:”sgx”,”age”:108} 12345let commonCondition=[&#123;\"id\":15&#125;];let a=&#123;\"name\":\"chd\",\"age\":18&#125;;let b=&#123;\"name\":\"sgx\",\"age\":108&#125;;// 当我们利用a = commonCondition.push(a)时，此时原来的commonCondition也会跟着改变// 赋值b = commonCondition.push(b)。此时，b中也会包含a的数据，此刻js的clone函数就出现了 js的clone()函数源代码: 1234567891011121314151617181920212223function clone(Obj)&#123; var o; if (typeof obj == \"object\") &#123; if (obj === null) &#123; o = null; &#125; else &#123; if (obj instanceof Array) &#123; o = []; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; o.push(this.clone(obj[i])); // 有可能不要this &#125; &#125; else &#123; o = &#123;&#125;; for (var j in obj) &#123; o[j] = this.clone(obj[j]); // 有可能不要this &#125; &#125; &#125; &#125; else &#123; o = obj; &#125; return o; &#125; 即此刻，我们才有如下最正确的式子 1234let new_a = clone(commonCondition);a = new_a.push(a);let new_b = clone(commonCondition);b = new_b.push(b); 2. thinkphp项目调用Vue扩展函数方式2.1 导入vue扩展包.js文件 1&lt;script src=\"./cf.js\"&gt;&lt;/script&gt; 2.2 声明方法：新建一个与项目名同名的js文件，新增如下内容 123456789101112Vue.prototype.项目名 = &#123; // 这里表示扩展函数 函数名一:function(obj)&#123; ... &#125;, 函数名二:function(obj)&#123; ... &#125;, ...&#125; 2.3 调用方法：Vue实例化名. 项目名.函数名()Vue实力化名即：let app = new Vue({})中的app,经过测试后，调用方法为 项目名.函数名（） 3.thinkPHP的变量输出知识&lt;{:函数名/变量名}&gt; 中的冒号&quot;:&quot;表示引用调用函数，获取变量值 &lt;{:U(query)}&gt;:URL生成http://serverName/projectName/当前模块/当前控制器/声明的方法 123默认的模板标签为：在config.php文件下更改设置&apos;TMPL_L_DELIM&apos;=&gt;&apos;&lt;&#123;&apos;,&apos;TMPL_R_DELIM&apos;=&gt;&apos;&#125;&gt;&apos;, &lt;{:I(‘name’,’chd’)}&gt;中的I方法获取自定义参数值，不存在时，自定义默认值 I(‘get.name’); // 相当于 $_GET[‘name’]支持默认值： 2019-12-8 新增：查看thinkphp3.2手册存在变量输出方式二：在模板（即HTML文件）中输出变量的方式很简单，只需要我们在控制器给模板变量赋值： 1234567$name = \"ThinkPHP\";/*@param $this-&gt;assign() 绑定，分配数据@param （'name',$name）参数一：表示要在模板中引用的变量名，在不加$符号时，也要使用引号括起来*/$this-&gt;assign('name',$name); $this-&gt;display(); // 将分配的数据在HTML页面展示 然后再模板中使用（注意模板标签的{和$之间不能有任何的空格，否则标签无效,普通标签默认开始标记是{，结束标记是 }。也可以通过设置TMPL_L_DELIM和TMPL_R_DELIM进行更） 12345hello,&lt;&#123;$name&#125;&gt;&lt;!-- 在模板编译后结果为：--&gt;Hello,&lt;?php echo($name);?&gt;&lt;!--这样就在HTML页面显示为：--&gt;hello,ThinkPHP 4. ThinkPHP的memcached缓存机制 4.1 下载安装memcached，并启动其服务 参考docker创建memecached容器 windows下ThinkPHP3.2.3使用memcache缓存 4.2thinkphp3.2中其实已经加入了memcached缓存机制，只需要在Conf/config.php配置数据缓存类型即可使用Memcache: 1234567&lt;? php return array( 'DATA_CACHE_TYPE' =&gt; 'Memcache', // 数据缓存类型 'MEMCACHE_HOST' =&gt; 'tcp://127.0.0.1:11211', 'DATA_CACHE_TIME' =&gt; '3600' )?&gt; 5.ThinkPHP项目模块结构，参考此文章1234567891011121314151617project项目名: |---Application:应用模块 |Admin后台模块 |Home前台模块 |---Controller控制器 |---IndexController.class.php |---Model模型 |---IndexModel.class.php |---View视图 |---index.html |Common公共配置模块（不能直接访问） |Runtime缓存模块 |---Public静态资源文件 |---ThinkPHP框架 |---index.php：入口文件 |---favicon.ico：网站图标 |---.htaccess:Apache配置文件（重写URL，修改访问权限） 未完待续。。。","categories":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://ahrilove.top/categories/ThinkPHP/"}],"tags":[{"name":"$.post()","slug":"post","permalink":"https://ahrilove.top/tags/post/"},{"name":"thinkPHP","slug":"thinkPHP","permalink":"https://ahrilove.top/tags/thinkPHP/"},{"name":"API","slug":"API","permalink":"https://ahrilove.top/tags/API/"},{"name":"Ajax","slug":"Ajax","permalink":"https://ahrilove.top/tags/Ajax/"},{"name":"CSS","slug":"CSS","permalink":"https://ahrilove.top/tags/CSS/"}]},{"title":"JSON通常用于与服务端交换数据,在向服务器发送数据时一般是字符串","slug":"json","date":"2019-11-13T16:00:00.000Z","updated":"2019-12-23T01:15:50.740Z","comments":true,"path":"2019/11/14/json/","link":"","permalink":"https://ahrilove.top/2019/11/14/json/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组PS:json键值对一定要用双引号包裹起来","text":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组PS:json键值对一定要用双引号包裹起来 1.Python的json规则python程序中的json有一点点区别于JavaScript中的json，它是通过对象和数组的组合来表示数据 1.1 对象型数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它在JavaScript是使用花括号{}包裹起来的内容，数据结构为{key1:value1,key2:value2…}的键值对结构，key为对象的属性，value为对应的值。键名可以使用整数和字符串来表示，所以，一个json对象跨用写作如下格式(对象型数组) 123456789[&#123; \"name\": \"chd\", \"age\": 18, \"sex\": \"man\" &#125;,&#123; \"name\": \"Monica\", \"gender\": \"woman\", \"birthday\": \"1997-1-25\"&#125;] 调用方式:通过中括号加0索引，可以得到第一个字典元素，然后调用其键名即可得到相应的键值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式一：中括号加键名data[index][“键名”] =&gt; data[0][‘name’]，结果为‘chd’&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式二：get()方法传入键名，如果键名不存在，不会报错，会返回none（python中推荐使用）data[index].get(‘键名’) =&gt; data[1].get(“birthday”),结果为”1997-1-25” 1.2 键值对形式（类似于字典） 1234567891011121314&#123; \"code\": 1, \"msg\": \"success\", \"data\": &#123; \"name\": \"pig\", \"age\": \"18\", \"sex\": \"man\", \"hometown\": &#123; \"province\": \"江西省\", \"city\": \"抚州市\", \"county\": \"崇仁县\" &#125; &#125;&#125; 1.3 需要注意到点 JSON的键名和字符串都必须使用双引号引起来，而Python中单引号也可以表示为字符串，所以这是个比较容易犯的错误！Python类型与JSON相互转换的时候到底是用load//dump还是用loads\\dumps？他们之间有什么区别？什么时候该加s什么时候不该加s？这个我们可以通过查看源码找到答案：不加s的方法入参多了一个fp表示filepath，最后多了一个写入文件的操作。所以我们在记忆的时候可以这样记忆：加s表示转成字符串(str)，不加s表示转成文件。 2.javascript中的json1234567var stu = &#123;&quot;student&quot;: //stu 对象包含student的key,值为一个数组 [ //数组的每一个值为一个具体的学生对象 &#123;&quot;name&quot;: &quot;Tom&quot;,&quot;Grade&quot;:1, &quot;age&quot;:11, &quot;gender&quot;: &quot;M&quot;&#125;, //学生对象的键为名字,值为对应属性 &#123;&quot;name&quot;: &quot;Jerry&quot;, &quot;Grade&quot;:1, &quot;age&quot;:10, &quot;gender&quot;: &quot;M&quot;&#125; //每个属性对应的是一个key,value对 ], &quot;classroom&quot;: &#123;&quot;class1&quot;: &quot;room1&quot;, &quot;class2&quot;: &quot;room2&quot;&#125; //对象的值,嵌套对象 &#125;; json.parse()：是从一个字符串中解析出 json 对象 123456789//定义一个字符串var data='&#123;\"name\":\"goatling\"&#125;';//解析对象​​var a = JSON.parse(data);typeof(a) // 对象类型/*结果是：*Object* &#123;name:\"goatling\"&#125;*/ json.stringify() 是从一个对象中解析出字符串 123456789let data=&#123;name:'goatling'&#125;;let a = JSON.stringify(data);typeof(a) // 对象类型/** 结果是：* '&#123;\"name\":\"goatling\"&#125;'* 字符串类型* */","categories":[{"name":"json","slug":"json","permalink":"https://ahrilove.top/categories/json/"}],"tags":[{"name":"json.parse()","slug":"json-parse","permalink":"https://ahrilove.top/tags/json-parse/"},{"name":"json.stringify()","slug":"json-stringify","permalink":"https://ahrilove.top/tags/json-stringify/"}]},{"title":"数据库存储引擎与索引,视图","slug":"mysql(二)","date":"2019-11-11T16:00:00.000Z","updated":"2019-12-02T13:06:44.920Z","comments":true,"path":"2019/11/12/mysql(二)/","link":"","permalink":"https://ahrilove.top/2019/11/12/mysql(%E4%BA%8C)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引概述 索引作用 视图 视图的操作","text":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引概述 索引作用 视图 视图的操作 1.索引概述索引在创建表的时候可以同时创建，也可以随时增加新的索引创建新索引的语法为:create [unique|fulltext|spatial] index index_name [using index_type] on table_name( col_name [(length)] [asc|desc])删除索引： DROP INDEX index_name on table_name 2.索引作用合理的创建索引是提高查询速度最有效的方式之一。&nbsp;&nbsp;&nbsp;&nbsp;在没有建立索引的情况下，查询一条数据的过程是这样：MySQL是从第一条记录开始查表，在某一个地方查到了匹配的数据，停止？NO，继续查询剩下的数据，直到查完整张表。 &nbsp;&nbsp;&nbsp;&nbsp;在建立合适索引的情况下，查询一条数据的过程又是这样：MySQL先根据索引快速到达一个位置去搜索数据文件，然后查出数据，而不必查看整张表的数据。tips:1、索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。2、索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。3、通过创建唯一索引，可以保证某一列的值具有唯一性。 1234567891011/*添加唯一索引：*/ALTER TABLE studentsADD UNIQUE INDEX unique_name(name);/*只添加唯一约束而不添加唯一索引：*/ALTER TABLE studentsADD CONSTRAINT unique_name UNIQUE(name); 因此，为了提高查询速度，合理建立索引是非常有必要的。 类型 描述 普通索引 基本的索引类型，允许定义索引的列中插入重复值和空值 唯一索引 索引列值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 主键索引 特殊的唯一索引，不允许有空值 全文索引 类型为FULLTEXT,支持值的全文查找，允许在索引列中插入重复值和空值 组合索引 在表的多个字段组合上创建的索引 3.视图（5.0.1提供视图功能）&nbsp;&nbsp;&nbsp;&nbsp;视图是一种虚拟存在的表，它存储的是查询语句，显示出来的是查询的结果；更直白的说就是当我们需要从表中查询一些信息时需要编写相关SQL语句，将这些SQL语句存储为视图，那么我们调用这些视图的时候就相当于执行了SQL语句，从而可以得到想要的结果eg:创建视图并执行查询操作 create view view_name as select qty,price,qty*price as value from temp; 视图有什么作用 1.视图就像是一个封装了很多功能的函数，我们把一系列复杂的查询语句存储为一个视图，这样在需要频繁使用这些语句时不必反复编写，直接使用视图代替即可 12345678如果要频繁获取表user的name和表goods的name。就应该使用以下sql语句：select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;但有了视图就不一样了，创建视图other。示例create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;创建好视图后，就可以这样获取user的name和goods的name： select * from other; 2.对数据库进行重构但仍不会影响程序运行 12345678假如因为某种需求，需要将user表拆成表usera和表userb，该两张表的结构如下： 测试表:usera有id，name，age字段 测试表:userb有id，name，sex字段这时如果程序端一直使用的sql语句是：select * from user;那就会报错提示该表不存在，这时要么去更改程序的查询语句要么就创建视图。显然，创建视图更简单，成本更低。以下sql语句创建视图：create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;以上假设name都是唯一的。这时程序端端使用的sql语句：select * from user;就不会报错。这就实现了更改数据库结构，而不用更改脚本程序的功能。 4.视图的操作 4.1 创建或修改视图 create [ or replace ] [ algorithm = { undefined | merge | temptable } ] view view_name [ (column_list) ] as select_statement [ with [ cascaded | local ] check option ] 使用了OR REPLACE可以修改视图，或者直接就CREATE OR REPLACE 替换为ALTER 即变成修改语法； UNDEFINED：未定义指定算法；MERGE：更新视图表数据的同时会更新真实表的数据（默认）；TEMPTABLE：只能查询不能更新； CASCADED(默认)：必须满足所有针对该视图的所有视图的条件才可以更新；LOCAL：只需满足本视图的条件就可以更新； WITH CHECK OPTION：需要满足相关的检查条件才能进行更新12345--常量视图create or replace view pi as select 3.1415926 as pi; --select中包含子查询create or replace view city_view as select (select city from city where city_id=1); 4.2 查看当前数据库下所有视图 show full tables where table_type like ‘view’; 5.优化SQL语句一般步骤 5.1 通过show status 查看各语句的频率 6.数据库Leetcode1.求薪水第二高，不存在就返回null 123select ifnull((select distinct(Salary) from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary; 超过5名学生的课(having用法) 1234select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5 DATEDIFF是两个日期的天数差集 123select a.Id as newIdfrom Weather a left join Weather b on datediff(a.RecordDate,b.RecordDate)=1 where a.Temperature&gt;b.Temperature","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ahrilove.top/tags/mysql/"},{"name":"InnoDB","slug":"InnoDB","permalink":"https://ahrilove.top/tags/InnoDB/"},{"name":"MyISAM","slug":"MyISAM","permalink":"https://ahrilove.top/tags/MyISAM/"}]},{"title":"MySQL数据库(一)：DDL，DML，DCL","slug":"MySQL数据库","date":"2019-11-10T16:00:00.000Z","updated":"2019-12-12T01:47:30.499Z","comments":true,"path":"2019/11/11/MySQL数据库/","link":"","permalink":"https://ahrilove.top/2019/11/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式1.两个用户在同一个应用服务器上:select * from &#39;user_name&#39;&nbsp;.&nbsp;&#39;table_name&#39;;2.两个用户不在同一个应用服务器上。。。","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式1.两个用户在同一个应用服务器上:select * from &#39;user_name&#39;&nbsp;.&nbsp;&#39;table_name&#39;;2.两个用户不在同一个应用服务器上。。。 1.启动服务net start 服务器名（Windows）service start 服务器名（linux） 2.登录与修改密码 命令 含义 mysql -u root -p -h localhost 登录MySQL（p表示密码；u表示用户名；h表示主机地址） mysqladmin -u用户名 -p旧密码 password新密码 修改用户名密码 3.基本使用 命令 含义 show databases; 用于显示所有的数据库 use 数据库名; 使用目标数据库 select database()/version()/now()/user(); 显示当前连接的信息 show tables; 用于显示选中数据库下的所有的表 desc table_Name; 查看表结构 show create table table_name \\G; 查看到创建时的SQL语句及更多详细信息 \\G使记录按照字段竖向排列，易于阅读 创建数据库并指定编码格式:create database if not exists 数据库名 character set utf8;删除数据库：drop database [if exists] 数据库名; 4.DDL&amp;DMLDDL:数据定义语言仅对数据库，表，列，索引起作用（create、drop、alter）DML:数据操纵语言仅对table中的具体数据起作用（select、insert、delete、update） 5.DDL 1.创建表 创建表 create table 表名( ​ 列名 数据类型 列级约束, ​ 列名 数据类型 列级约束 ​ )【表类型】【表字符集】【表注释】 12345678910#创建学生表，并设置表类型、字符集CREATE TABLE `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &apos;主键、学号&apos;, `psd` VARCHAR(20) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;123456&apos; COMMENT &apos;密码&apos;, `name` VARCHAR(30) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;匿名&apos; COMMENT &apos;学生姓名&apos;, `sex` VARCHAR(2) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;男&apos; COMMENT &apos;性别&apos;, `birsday` DATETIME DEFAULT NULL, `email` VARCHAR(20) COLLATE utf8_estonian_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_estonian_ci 数据类型 约束条件： not null unique primary key 主键名 foreign key (Id_P) references Persons(Id_P) :一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY default 默认值 auto increment:在每次插入新记录时，自动地创建主键字段的值 5.1主键&nbsp;&nbsp;&nbsp;&nbsp;对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 &nbsp;&nbsp;&nbsp;&nbsp;由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。&nbsp;&nbsp;&nbsp;&nbsp;使用BIGINT，会占用更大的磁盘和内存空间，内存空间毕竟有限，无效的占用会导致更多的数据换入换出，额外增加了IO的压力，对性能是不利的。因此推荐自增主键使用int unsigned类型，但不建议使用bigint。&nbsp;&nbsp;&nbsp;&nbsp;所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键,而应该使用INT UNSINGED自增或者GUID类型。主键也不应该允许NULL。可以使用多个列作为联合主键，但联合主键并不常用。&nbsp;&nbsp;&nbsp;&nbsp;如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 12345create table user( id INT UNSIGNED NOT NULL AUTO_INCREMENT primary key , /*数据类型 非空 自增 主码约束*/ name varchar(200) /*主码，外码约束条件写法二：primary key(id) */ ) 2.删除表：drop table table_name 3.修改表 命令 含义 修改表中列的数据类型 alter table table_name modify 列名 column_definition 增加表字段 alter table table_name add [column] 列名 column_definition 删除表字段表字段 alter table table_name drop [column] 列名 表的字段改名 alter table table_name change [column] old_col_name new_col_name 表字段改名同时也可修改字段类型 alter table table_name change [column] old_col_name new_col_name column_definition 更改表名 alter table table_name rename [to] new_tablename 6.DML语句 命令 含义 插入数据 insert into table_name ( field1, field2,…) values (value1,value2,….); 一次性插入多条数据 insert into table_name ( field1, field2,…) values (value1,value2,..),(value1,value2,..)…; 更新记录 update table_name set field1=value1，field2=value2，… [ WHERE CONDITION ] 删除某一项记录 delete from table_name [WHERE CONDITION ] 排序和限制 select * from table_name [ WHERE CONDITION ] [ order by field1 [ DESC\\ASC ], field2 [ DESC\\ASC], ..] 表连接 select ename,deptname from emp1 left join dept on emp1.deptno=dept.deptno; 子查询 关键字主要有in、not in、=、!=、exists、not exists,between and等等 1.可以不用指定字段名称，但此时后面的values应该与表的字段顺序保持一致2.对于某些字段允许空值、非空但是有指定的默认值、自增长等，这些字段在insert时如果没有指定value，那么将会右系统自动配置 7.DCL语句 创建数据库用户，并声明权限 创建操作数据库的专用用户，格式：grant 权限 on 数据库名.数据表名 to 用户名@主机IP IDENTIFIED BY 密码 1234说明：权限：ALL PRIVILEGES(所有权限),select,insert,update,delete,create,alter,drop主机IP： &apos;%&apos; 匹配所有主机，localhost表名： * 表示所有表 刷新权限 flush privileges 这里向大家拓展一个知识点，那就是主机IP指的是该用户只能在对应的主机IP上进行登录。例如：假如user用户设置的主机IP为localhost，那么其他人就将无法从本地以外的地方使用user用户进行登录。 8.查询记录 8.1 distinct 查询不重复的记录 select distinct id from emp1; 加distinct关键字使得查出的结果中去掉了重复记录 8.2 条件查询 判断条件可以使用=、&gt;、&lt;、&gt;=、&lt;=、!=等等，同时多个条件还可以使用and、or等进行连接 8.3 聚合 1234567891011select [ field1, field2,...,fieldn] fun_name from tablename [ where condition ] [ group by field1, field2,..., fieldn [ with rollup ] ] [ having condition ]参数说明：fun_name 聚合函数，表示要做的聚合操作，常用的有sum（求和）、count(*)（计数）、max、min等。 GROUP BY 表示对后面的字段进行分类聚合（也常叫分组）； WITH ROLLUP 可选语法，在ORDER BY 语句内出现，表示是否对分类聚合后的结果进行再汇总； HAVING 表示对分类后的结果再进行条件过滤； 同样是条件过滤，having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤。因此，为了提高聚合效率，一般先用where过滤不相干的记录后，在进行聚合，最后再用having进行二次过滤 12select gender，count(gender) from tab_teacher group by gender having gender=\"woman\";-- 含义为：按性别分组，查询出女老师人数的总数:先执行group by，再聚合函数，最后having筛选 9.注意要点 9.1 避免使用通配符“*” 实际开发中，要避免使用通配符”*”（通配符代表所有字段），因为系统要先解析出所有的字段名，将其还原为真实的名字，然后再进行操作。如果记录数据库内容特别多，会影响效率。 9.2 查询表的总记录数(推荐使用主键的方式查询) 因为主键唯一，且不能为空,此时id总数则代表总记录数select count(id) from table_teacher; 9.3 别名的用法 select count(id) as new_number from table_teacher;或者使用别名来代替表的名字select t.name,t.age from tab_teacher t; 9.4 分页查询方式 查询老师记录的前三条（从0位置开始找出3条）： limit后面有两个参数：第一个参数是起始位置，第二个参数是偏移量select * from tab_teacher limit 0,3; oracle的sql语句中没有limit,limit是mysql中特有的,在oracle中可用rownum来表示,用于查询结果中的前N行数据。如要查询emp表中的前5行数据,可用如下语句: &nbsp;&nbsp;select * from emp where rownum","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"database","slug":"database","permalink":"https://ahrilove.top/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://ahrilove.top/tags/mysql/"},{"name":"DDL","slug":"DDL","permalink":"https://ahrilove.top/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"https://ahrilove.top/tags/DML/"}]},{"title":"jQuery学习","slug":"jquery","date":"2019-11-10T16:00:00.000Z","updated":"2019-11-18T05:44:35.410Z","comments":true,"path":"2019/11/11/jquery/","link":"","permalink":"https://ahrilove.top/2019/11/11/jquery/","excerpt":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题","text":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题 1. 选择器id选择器 $(“#div”) 类选择器 $(“.div”) 标签选择器 $(“div”) 并集选择器 $(“selector1,selector2,…,selectN”)：使用逗号连接，以数组形式返回所有的合并元素 后代选择器 $(“div p”):div标签下的p标签，包含子孙节点 过滤选择器 $(“div:eq(n)”) :eq(index)获取给定索引值的元素 从0开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:gt(index) 匹配所有大于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:lt(index) 匹配所有小于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:even 匹配所有索引值为偶数的元素，从 0 开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:odd 匹配所有索引值为奇数的元素，从 0 开始计数属性选择器 $(“div[attribute=”value”]”) :匹配给定的属性是某个特定值的元素 表单的选择器:$(‘input:radio/checkbox/text/password/…’),即: type值为radio、checkbox、password等的input元素 筛选选择器 : $(‘div’).eq(n) 获取第n个元素 数值从0开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.first()获取第一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.last()获取最后一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.parent() 选择父亲元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.siblings()选择兄弟元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.find() 查找目标元素值 PS:注意筛选选择器与过滤选择器的函数位置","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"https://ahrilove.top/tags/API/"},{"name":"Ajax","slug":"Ajax","permalink":"https://ahrilove.top/tags/Ajax/"},{"name":"CSS","slug":"CSS","permalink":"https://ahrilove.top/tags/CSS/"},{"name":"jQuery","slug":"jQuery","permalink":"https://ahrilove.top/tags/jQuery/"},{"name":"选择器","slug":"选择器","permalink":"https://ahrilove.top/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"Python全栈系列章节更新（一）：基本数据类型","slug":"python数据类型","date":"2019-11-10T16:00:00.000Z","updated":"2019-12-19T00:49:10.176Z","comments":true,"path":"2019/11/11/python数据类型/","link":"","permalink":"https://ahrilove.top/2019/11/11/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 字符串：len(),split(),join()…列表：append(),pop(),count()…元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 字符串：len(),split(),join()…列表：append(),pop(),count()…元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 1.字符串 zip()函数：将可迭代对象所包含的元素是由原列表元素组成的元组 a = [a,b,c] b = [1, 2, 3]c = [x for x in zip(a,b)]c = [(a, 1), (b, 2), (c, 3)]结果为元祖型列表 format():位置参数，参数索引从0开始，format里填写{}对应的参数值 msg = “my name is {}, and age is {}”.format(‘chd’,18)渲染结果：my name is chd, and age is 18 str.index()字符串索引: 索引值从0开始,不存在就会报错 s=’index’ s[0]=is.index(‘i’) = 0 : 查找目标字符串索引值 str.find(‘目标字符串’)查找目标字符串,不存在就返回数值-1(推荐使用find) “i am iron man”.find(“man”) =&gt; 1 移除指定字符串 str.strip() s = ‘ hello,world! ‘s.strip()s.lstrip()s.rstrip()s2 = &#39;hello,world!&#39;s2.strip(&#39;\\ &#39;) len(str)字符串长度 len(‘hello,world’) =&gt; 11 str.replace(a,b)替换：在字符串str中，用b来替换a ‘hello,world’.replace(‘o’,’a’) =&gt; ‘hella,warld’ str[a:b:c] 切片操作(左闭右开) [a:b:c]：a表示为索引起始位置（索引以0开始）；b表示为索引结束位置；c表示为跳跃间隔案例如下： 12345678910111213&gt;&gt;&gt; test=&quot;1234hello-world56789&quot;&gt;&gt;&gt; type(test)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; test[:]&apos;1234hello-world56789&apos;&gt;&gt;&gt; test[0:1]&apos;1&apos;&gt;&gt;&gt; test[0:2]&apos;12&apos;&gt;&gt;&gt; test[0:5:2]&apos;13h&apos;&gt;&gt;&gt; test[0:5]&apos;1234h&apos; string.capitalize() 把字符串的第一个字符大写 str.count(‘目标字符串’): 返回 str 在 string 里面出现的次数 “连接字符”.join(seq序列):返回 str 在 string 里面出现的次数 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 str.lower()/upper() 将字符串全部转换为小写/大写 “hello world”.lower()/upper() =&gt;”hello world” / “HELLO WORLD” str.split(指定字符串) 以指定字符串来分割目标字符串，以列表形式返回 1234url = \"http://www.baidu.com/python/image/123456.jpg\"#以“.” 进行分隔path =url.split(\".\")path1=['http://www', 'baidu', 'com/python/image/123456', 'jpg'] 2019-11-28 新增：当split的参数为空时，即string.split():表示以空格作为分割符，并将换行符也去掉 2.列表 列表截取（索引从0开始，且满足左闭右开原则）与拼接:从右至左取值，则索引默认从-1开始 L=[‘Google’, ‘Runoob’, ‘Taobao’]L[2]=’Taobao’ L[-1]=’Taobao’ 列表函数和方法 函数和方法 描述 len(list) 列表元素个数 list(seq) 将元组或字符串转换为列表 max/min(list) 返回列表元素最大/最小值 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) 将对象插入列表 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中某个值的第一个匹配项 list.reverse() 反向列表中元素 list.sort( key=None, reverse=False) 对原列表进行排序 2019-12-2 新增： 数组拆分：将一个含有m个数目的数组拆分成每n个一组，剩下的构成一个新数组 12345# 将obj数组分割成每100个一组numbers=[1,2,3,4,5,6,7,8,...,10000]number =[]for i in range(0, len(numbers), 100): number.append(numbers[i:i + 100]) 3.元组 3.1元组的创建 元组使用小括号，而列表使用方括号，只需要在括号中添加元素，并使用逗号隔开即可 1tup1 = ('a','b','c',336) 3.2 元组的访问使用下脚标索引来访问元组中的值，下标索引从0开始 tup1[0] =&gt; &#39;a&#39; ,tup[1] =&gt; &#39;b&#39; 3.3 元组的修改 元组中的元素是不允许修改或删除的，但我们开始对其进行拼接组合tuple(seq)：将列表转换为元组。 4.字典:可变模型，可存储任意类型对象 4.1字典的创建 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号&nbsp;&nbsp;,&nbsp;&nbsp;分割，整个字典包括在花括号 {} 1d = &#123;key1 : value1, key2 : value2 &#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258',9527:'badwoman',6394:998&#125; 4.2 字典的访问 访问方式：字典名[&quot;键名&quot;] 或者字典名.(&quot;键名&quot;,自定义数据)：当目标键名不存在时，使用自定义数据值作为默认值，注意此刻不会修改原字典 4.3 字典的更新 1234567dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; dict['Age'] = 8 # 更新dict['School'] = \"RUNOOB\" # 添加 print(\"dict['Age']: \", dict['Age'])print(\"dict['School']: \", dict['School']) 4.4 内置函数和方法 函数和方法 描述 cmp(dict1, dict2) 比较字典元素值：如果两个字典的元素相同返回0，如果字典dict1大于字典dict2返回1，如果字典dict1小于字典dict2返回-1 len() 计算字典元素个数，即键的总数 dict.items() 将字典的键值一一对应组合成一个元组，以列表的形式返回值 dict.pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 123456demo=&#123;'Name': 'Zara', 'Age': 8, 'Class': 'First', 'School': 'RUNOOB'&#125;demo.items() # dict_items([('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')])a = [x for x in demo.items()]print(a) # a=[('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')] python的直接赋值，浅拷贝和深拷贝 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 解析： b = a 赋值引用，a与b都指向同一个对象，即共有同一块内存地址 123456a = &#123;1: [1, 2, 3]&#125;b = a # b = &#123;1: [1, 2, 3]&#125;# 更新a的值a[1]=[1,2,3,4]print(b) # b = &#123;1: [1, 2, 3, 4]&#125;# 即直接赋值也属于浅拷贝，共用同样一块地址 b = a.copy():浅拷贝，a与b是一个独立的对象，但他们的子对象还是指向统一对象（是引用） 12345a = &#123;1: [1,2,3]&#125;b = a.copy()print(a,b) # (&#123;1: [1, 2, 3]&#125;, &#123;1: [1, 2, 3]&#125;)a[1].append(4) # 字典更新print(a, b) #(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;) b = copy.deepcopy(a) 深拷贝：深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的,是两块独立的地址。 1234567&gt;&gt;&gt; import copy&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;)&gt;&gt;&gt; a[1].append(5)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4, 5]&#125;, &#123;1: [1, 2, 3, 4]&#125;) map与reducde函数（python2与python3的区别）map()函数接收两个参数，一个是函数，一个是Iterable（可迭代对象），map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator（迭代器）返回(可以使用list转换为数组)，而python2返回的是一个数组 12345def f(x): return x * xr = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])list(r) # [1, 4, 9, 16, 25, 36, 49, 64, 81] 使用map返回结果是迭代器，将数据转换为列表reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ahrilove.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"元组","slug":"元组","permalink":"https://ahrilove.top/tags/%E5%85%83%E7%BB%84/"},{"name":"列表","slug":"列表","permalink":"https://ahrilove.top/tags/%E5%88%97%E8%A1%A8/"},{"name":"字典","slug":"字典","permalink":"https://ahrilove.top/tags/%E5%AD%97%E5%85%B8/"},{"name":"数值","slug":"数值","permalink":"https://ahrilove.top/tags/%E6%95%B0%E5%80%BC/"}]},{"title":"docker容器虚拟化技术","slug":"docker容器虚拟技术","date":"2019-11-09T16:00:00.000Z","updated":"2019-12-22T06:55:41.087Z","comments":true,"path":"2019/11/10/docker容器虚拟技术/","link":"","permalink":"https://ahrilove.top/2019/11/10/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/","excerpt":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题","text":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题 1.docker适用环境其实docker本身也没有太多在Windows下花功夫。目前，docker仅支持Linux与Windows企业版、专业版、教育版。ps：家庭版不支持docker,并且win10下可以安装docker-for-windows,这个安装包是专门适用于win10，安装简单，而对于win7/8则可以使用Docker Toolbox下载地址 2.Windows下无法对docker容器进行端口访问（端口映射的问题）1.问题详情&nbsp;&nbsp;&nbsp;在Windows10系统服务器中安装了docker和docker-compose&nbsp;&nbsp;&nbsp;并尝试在其中运行Nginx服务，映射也做好&nbsp;&nbsp;&nbsp;问题：在主机的浏览器中，打开localhost:port无法访问对应的Web服务。2.问题解析&nbsp;&nbsp;&nbsp;原因：docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows10。3.解决办法&nbsp;&nbsp;&nbsp;启动docker命令行窗口&nbsp;&nbsp;&nbsp;输入命令:docker-machine ip default&nbsp;&nbsp;&nbsp;Linux的ip地址，一般情况下这个地址是192.168.99.100&nbsp;&nbsp;&nbsp;然后在Windows的浏览器中，输入 http://IP:port 即可启用（http://192.168.99.100：8069） 3.docker与VMware不可兼容&nbsp;&nbsp;&nbsp;在Windows下安装docker，第一步就是要打开Hyper-V(打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V),开启win自带的虚拟管理技术。但是若想要使用VMware，则必须关闭Hyper-V，鱼和熊掌不可兼得呀！(′д｀ )…彡…彡 4.Windows：vmware与hyper-v不兼容,请移除hyper-v角色1、请移除hyper-v角色。（1）以管理员身份（win + x）运行命令提示符；（2）执行命令：bcdedit /set hypervisorlaunchtype off（3）重启系统，运行vm即可。2、如果想要恢复hyper启动：&nbsp;&nbsp;&nbsp;bcdedit / set hypervisorlaunchtype auto 5.docker run后接/bin/sh和接/bin/bash的区别是什么：比如我们要获取一个nginx镜像，同一镜像存在有不同的tags&nbsp;&nbsp;&nbsp;/bin/sh命令仅适用于tags带alpine标签的： nginx:1.17-alpine；&nbsp;&nbsp;&nbsp;/bin/bash命令仅适用于tags不带alpine标识的：nginx：laster，nginx:1.8… 6.docker运行MySQL服务 拉取镜像docker pull mysql:[tag] 创建并运行容器docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql：5.6 ps: -p 表示指定访问端口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e 设置环境变量，或者覆盖已存在的环境变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-d 表示以守护式方式来运行容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MYSQL_ROOT_PASSWORD=123456 声明MySQL的用户名为ROOT，密码为123456 查看容器是否启动docker ps 启动容器docker start container_id 进入容器内部,以命令行交互docker exec -it container_id /bin/bash 登录MySQLmysql -u root -p 然后在输入密码 成功表示已经成功登陆MySQL 7.最强万能公式:数据卷挂载式创建容器12345守护式：docker run -di [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine交互式：docker run -it [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine含义： a） 以-v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw 带rw(read,write)权限来将宿主机与容器进行数据卷挂载 b) docker run 以新容器名和端口号以及守护式或者交互式来创建容器 8.宿主机与docker容器权限纠纷问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它来了！问题又出现了！哭啦。数据卷挂载时，即使声明了rw权限，在宿主机中创建文件，数据共享后，容器内能够具有正常的rw权限；但在容器内新建了文件后，宿主机就只有只读权限，无法修改文件内容。 解决方案：宿主机的权限不够&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在（7）式中的万能公式中添加：docker run ··· --privileged=true ··· 9.docker配置nginx的配置文件命令：docker run --name=&quot;dnmp_nginx&quot; -p 80:80 -v /home/docker-nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/docker-nginx/log:/var/log/nginx -v /home/docker-nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -di nginx:\\[tags]&nbsp;&nbsp;&nbsp;&nbsp;第一个-v 表示将你本地的nginx.conf覆盖你要起启动的容器的nginx.conf文件，第二个表示将日志文件进行挂载，就是把nginx服务器的日志写到你docker宿主机的/home/docker-nginx/log/下面。第三个-v 表示的和第一个-v意思一样的&nbsp;&nbsp;&nbsp;&nbsp;我个人更喜欢守护式映射的方式，麻烦的是需要自己准备好nginx.conf 和default.conf文件，我是直接从容器里面复制的，然后根据自己的需要改的 我都想把它杀了，部署nginx太多坑了，不过参考了此博文，最终解决了问题，解决方法： 1.创建三个根目录根据情况创建：/docker/nginx/conf www logs docker run -d -p 80:80 --name=”nginx” --net host -v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/logs:/var/log/nginx nginx:1.17.5 2.不对配置文件进行数据挂载即 -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf 这个 3.进入容器 获取文件 docker exec -it nginx /bin/bash 4.cd /etc/nginx/ （这里主要获取配置文件路径的）,然后exit 5.数据拷贝 进入宿主机目录文件 cd /docker/nginx/conf/将已经运行成功的容器的配置文件拷贝到宿主机的配置文件目录：docker cp 容器ID:/etc/nginx/nginx.conf .（ps：“.”表示拷贝到当前目录） ps：文件copy成功后 把nginx容器先删除掉 6.创建最终的nginx容器 12345678docker run -di -p 80:80 --name nginx [--net host] :再思考一下有没有必要写，使用–net = host时,它告诉容器使用主机网络堆栈.因此无法将端口暴露给主机,因为它是主机(就网络堆栈而言).-v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf-v /docker/nginx/logs:/var/log/nginx nginx:1.17.5ps:成功后就代表部署成功 2019-11-29 新增：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里宿主机的nginx.conf其实是挂载了一个文件，docker是不推荐这样使用的，可以尝试在宿主机上创建目录为：/docker/nginx/conf/nginx.conf/nginx.conf(当前conf文件是一个具体的配置文件，不是一个目录)，这样上式就不会出现docker warning，结合此篇文章 。 PS：访问可能会403 因为/docker/nginx/www/ 里面没有index.html放进去就好了 7.权限赋予 挂载成功后，给宿主机上的www目录（或整个文件目录）增加权限，不然一直无法读写：&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod -R 777 目标目录 ：给目标目录赋予最大管理员权限&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod +/-rwx 文件名|目录 给文件或目录的赋予权限 10.docker配置MySQL，redis教程等，请点击此处链接命令:docker run -di -p 12345:3306 \\--name=&quot;mysql&quot; -v /lnmp/mysql/conf:/etc/mysql/conf.d -v /lnmp/mysql/logs:/logs -v /lnmp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456:rw mysql:5.6 命令说明：-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。--name mysql：运行服务名字-v /lnmp/mysql/conf:/etc/mysql/conf.d ：将主机/lnmp/mysql录下的conf/my.cnf 挂载到容器的 /etc/mysql/conf.d-v /lnmp/mysql/logs:/logs：将主机/lnmp/mysql目录下的 logs 目录挂载到容器的 /logs。-v /lnmp/mysql/data:/var/lib/mysql ：将主机/lnmp/mysql目录下的data目录挂载到容器的 /var/lib/mysql-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。-d mysql:5.6 : 后台程序运行mysql5.6 11.docker 容器管理工具：portainer使用 这个数据卷用于持久化Portainer数据： docker volume create portainer_data2. 创建相关portainer容器docker run -di -p 9000:9000 --name=”portainer”-v /var/run/docker.sock:/var/run/docker.sock-v portainer_data:/data portainer/portainer 12.外部Windows如何访问docker内的容器 1.基本架构：Windows，Dockers，Linux三者关系 2.相关操作 2.1 关闭Linux防火墙：systemctl stop firewalld.service 2.2 查看Linux，Docker的IP地址:ifconfig(区别于Windows的ipconfig命令) 2.3 Windows访问测试: 思想：docker作为一个容器虚拟技术，创建并启动相关的容器服务，并把端口映射到Linux系统中。比如MySQL：docker启动MySQL服务后，并映射了一个外部访问的某端口（比如还是3306），则此刻Linux就具有了3306这个一个端口=&gt;外界访问方式应该是：访问虚拟机Linux上与之相绑定docker容器映射出的端口。 2019-11-27 新增：Linux:在 windows 系统中访问 linux 中 nginx，默认不能访问的，因为防火墙问题,即我们可以有两种解决方法（1）关闭防火墙：参考上述相关操作（2）开放访问的端口号，比如80端口，操作如下： 查看开放的端口号 firewall-cmd --list-all 设置开放的端口号 firewall-cmd --add-service=http --permanentfirewall-cmd --add-port=80(或其它开放端口号)/tcp --permanent 重启防火墙 firewall-cmd --reload Ubuntu:Ubuntu与linux对于防火墙的操作存在很大的区别：注意区分1、查看端口开启状态（inactive表示已经关闭了防火墙）sudo ufw status 2、开启某个端口，比如我开启的是3306sudo ufw allow 3306 3、开启防火墙sudo ufw enable 4、关闭防火墙sudo ufw disable 5、重启防火墙sudo ufw reload 6、禁止外部某个端口比如80sudo ufw delete allow 80 7、查看端口ipnetstat -ltn————————————————","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"},{"name":"VMware","slug":"VMware","permalink":"https://ahrilove.top/tags/VMware/"},{"name":"images","slug":"images","permalink":"https://ahrilove.top/tags/images/"},{"name":"container","slug":"container","permalink":"https://ahrilove.top/tags/container/"},{"name":"Hyper-V","slug":"Hyper-V","permalink":"https://ahrilove.top/tags/Hyper-V/"},{"name":"Linux","slug":"Linux","permalink":"https://ahrilove.top/tags/Linux/"},{"name":"交互式与守护式创建","slug":"交互式与守护式创建","permalink":"https://ahrilove.top/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%B8%8E%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%88%9B%E5%BB%BA/"}]},{"title":"Vue","slug":"Vue","date":"2019-11-07T16:00:00.000Z","updated":"2019-12-17T02:34:25.882Z","comments":true,"path":"2019/11/08/Vue/","link":"","permalink":"https://ahrilove.top/2019/11/08/Vue/","excerpt":"&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,有很好的数据双向绑定性。","text":"&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,有很好的数据双向绑定性。 1.jQuery与Vue糅合使用 1.jquery基本使用：先导入相关jQuery库包，然后按人类正常思维，就声明入口函数,然后在入口函数中书写逻辑代码 123456&lt;script&gt; $(function()&#123; ... ... &#125;);&lt;/script&gt; 但是，奇怪他个猪猪皮，即使不用声明入口函数，直接书写逻辑程序，经过多次测试，TM居然还可以正常使用 2.jQuery+Vue(若想两者结合使用，则一定不能声明入口函数，否则Vue无法使用)当你想测试Vue时，就会出现vue实例未声明的报错 &nbsp;&nbsp;1 Uncaught ReferenceError: vm is not defined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at :1:1 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"rookie\"&gt; &lt;p&gt;hello fpx&lt;/p&gt; &lt;p&gt;hello IG&lt;/p&gt; &lt;p&gt;hello kk&lt;/p&gt; &lt;pre&gt;total:&#123;&#123;number&#125;&#125;&lt;/pre&gt; &lt;h6 :class=\"&#123;box:isactive&#125;\"&gt;this is new h6&amp;nbsp;&amp;nbsp;&lt;/h6&gt; &lt;h5 :class=\"[box1,box2,box3?'luko':'']\"&gt;this is new h6&amp;nbsp;&amp;nbsp;&lt;/h5&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input number\" v-model=\"msg\" @keyup.enter=\"fn\"&gt;按键盘enter键触发:&#123;&#123;msg&#125;&#125;&lt;br&gt; &lt;input type=\"text\" placeholder=\"please click enter\" v-model=\"message\" @keyup.13=\"greet(9527)\"&gt;按键盘enter键触发&#123;&#123;message&#125;&#125;&lt;br&gt; &lt;/div&gt; &lt;script&gt; console.log($('p').length); let vm = new Vue(&#123; el:'#app', data:&#123; number:$('p').length, isactive:true, box1:'moko', box2:'boka', box3:true, msg:'', message:'', &#125;, methods:&#123; fn()&#123; alert(this.msg) &#125;, greet(hi)&#123; alert(this.message+hi) &#125; &#125;, &#125;); $('h5').append('&lt;b&gt;this is new plus increment&lt;/b&gt;'); $('h6').append('&lt;br&gt; hello world'); &lt;/script&gt;&lt;/body&gt; 2.Vue的组件 1.组件创建方式分为全局组件与局部组件： &nbsp;&nbsp;&nbsp;全局组件：可以被多个APP进行调用,在APP实例外创建;定义一个名为 button-counter 的新组件:组件名称若使用驼峰原则，引用组件时需要全部小写，并且两个单词之间用“-”连接;若不使用驼峰原则时，直接使用原组件名 全局组件创建方式一： 12345678910Vue.component('buttonCounter', &#123; data: function () &#123; // 1.组件可以有自己的data数据，组件中的data必须是一个方法，且这个方法内部必须返回一个对象才行，而实例中的data可以为一个对象 return &#123; count: 0, info: 'hello world' &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;&#123;&#123;message&#125;&#125; clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;' // 2. 全局组件有template属性 &#125;) 全局组件创建方式二：调用公共模板对象 123456789101112&lt;script&gt; let project=&#123; template:&apos;&apos;, data:function()&#123; // 组件中的data必须是一个方法 return &#123; info:&apos;hello world&apos;, message:&apos;badwoman&apos; &#125;, methods:&#123;&#125;&#125; Vue.component(&apos;组件名&apos;,project); &#125;&lt;/script&gt; 全局组件创建方式三：调用公共模板对象–其实这也是全局组件的一种创建方式，将template绑定到自身data函数中，此刻的data不同于实例中的data，此刻为一个函数 123456789101112131415161718192021222324&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj = &#123; count: 0 &#125;; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component('counter', &#123; data: function () &#123; // return dataObj return &#123; count: 0 &#125; &#125;, template: '#tmpl', methods: &#123;&#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;) &lt;/script&gt; 3. props属性使用： 数组写法 props: [‘cmovies’, ‘cmessage’] 对象写法 12345678props: &#123; // propsName表示要传递的值 propsName: &#123; type: String, // 组件的值的类型 default: &apos;zzzzz&apos;, // 组件的默认值 required: true //在使用组件必传值 &#125;&#125; props对象写法样例如下：拓展：组件props选项的值可以为为数组类型,也可以是对象类型，props选项的对象类型可以用于对外部传递进来的参数进行数据验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script type=\"text/javascript\"&gt; Vue.component('my-component',&#123; props:&#123; // Number类型 propA: Number, // 多种类型校验: String 或 Number类型 propB: [String, Number], // 布尔类型,默认值true propC:&#123; type:Boolean, default: true &#125;, // String类型且必输 propD:&#123; type:String, required: true &#125;, // Array类型,默认返回一个数组对象 propE:&#123; type:Array, default: function () &#123; return [1,2,3] &#125; &#125;, // Object类型,默认返回一个对象 propF:&#123; type:Object, default: function () &#123; return &#123;a:1&#125; &#125; &#125;, // 自定义验证函数 propG:&#123; validator:function (value) &#123; return value &lt; 10; &#125; &#125;, &#125; &#125;); const vm = new Vue(&#123; el: '#app', data:&#123; parentInput:0 &#125; &#125;)&lt;/script&gt; 4.接受动态数据与静态数据有时候组件接收的参数是来自父组件的动态数据,需要使用v-bind动态绑定props值.下列案例此刻使用了v-blid绑定props值，即此刻绑定的message的值就是为表单中输入的值 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"parentInputText\" placeholder=\"请输入...\"&gt; &lt;my-component :message=\"parentInputText\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; Vue.component('my-component',&#123; props:['message'], template:'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;' &#125;); const vm = new Vue(&#123; el: '#app', data:&#123; parentInputText:'' &#125; &#125;)&lt;/script&gt; 在使用props对子组件传值时,如果不使用v-bind传递数字,布尔,数组,对象类型的数据，这时传递的数据都是字符串类型,由于未使用模板绑定语法,不会被编译，会被当做参数传递到模板中.下列案例此刻没有使用了v-blid绑定props值，即此刻绑定的message的值直接就是”parentInputText“ 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;my-component message=\"parentInputText\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; Vue.component('my-component',&#123; props:['message'], template:'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;' &#125;); const vm = new Vue(&#123; el: '#app', data:&#123; parentInputText:'' &#125; &#125;)&lt;/script&gt; 注意：重要的来了，必须理解┗|｀O′|┛ 嗷~~ 创建格式：Vue.component('组件名',{ /* ..组件的模板对象.. */ }) &nbsp;&nbsp;&nbsp;组件的第一个参数为组件名，而第二个参数是以对象的形式去描述一个组件。组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项 2019-12-9 新增： 5.vue实例中的method方法抽象说明假设在HTML中有这样一个语句：调用methods里面的方法时，假如有返回值时，直接在&lt;!–￼10–&gt;里面展示，注意区分@click=”methodName” 12345678910111213141516171819202122232425&lt;div class=\"box\"&gt;&#123;&#123;test(2)&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; &lt;!---这里是调用methods里面的test()方法：判断参数的数据类型 ---&gt; el:\"#app\", data:&#123;&#125;, methods:&#123; test(hi) &#123; arr = typeof(hi); switch (arr) &#123; case \"string\": return \"this type is string\"; case \"number\": console.log(\"good\"); if (hi&lt;=10 &amp;&amp; hi%2===0) &#123; return hi; &#125; else return(\"不满足条件\"); case \"object\": return(\"this type is object\"); &#125; &#125; &#125; &#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/tags/Vue/"},{"name":"Jquery","slug":"Jquery","permalink":"https://ahrilove.top/tags/Jquery/"},{"name":"component","slug":"component","permalink":"https://ahrilove.top/tags/component/"}]},{"title":"python文件读read()、readline()、readlines()对比","slug":"python的read_readlines_readline","date":"2019-11-06T16:00:00.000Z","updated":"2019-11-29T01:27:38.088Z","comments":true,"path":"2019/11/07/python的read_readlines_readline/","link":"","permalink":"https://ahrilove.top/2019/11/07/python%E7%9A%84read_readlines_readline/","excerpt":"&nbsp;&nbsp;&nbsp;read():读取整个文件，将文件内容放到一个字符串变量中&nbsp;&nbsp;&nbsp;readline():每次读取一整行，包括换行符，并将其作为字符串返回&nbsp;&nbsp;&nbsp;readline():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素）","text":"&nbsp;&nbsp;&nbsp;read():读取整个文件，将文件内容放到一个字符串变量中&nbsp;&nbsp;&nbsp;readline():每次读取一整行，包括换行符，并将其作为字符串返回&nbsp;&nbsp;&nbsp;readline():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素） 1.readline()示例：假设需求是读取一个多行的all_term.txt文件，并列出每一个单词all_term.txt文件： 1234new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothrnobyl social impact chernobyl disastdavid r marpl st martin piano 程序源代码： 123456789101112131415161718def main(): obj = [] with open('all_term.txt', 'r', encoding='utf-8',errors=\"ignore\") as f: while True: myStr = f.readline() # 表示一次读取一行 if not myStr: # 读到数据最后跳出，结束循环。数据的最后也就是读不到数据了，mystr为空的时候 break # 指定字符串来分割目标字符串，以列表形式返回 new_list = myStr.split() # 表示将拆分好的每一行重新拼接成一个完整的数组 obj += new_list print(obj)if __name__ == '__main__': main() readline()表示读取一整行，那如果一个文件有多行数据，使用readline()函数是不是一直重复读取第一行？其实不然，使用with open()打开文件后，第一个readline()读取第一行（也包括换行符），第二个读取第二行,…,第n个读取第n行数据，这是由系统机制判定的。下面我列举一个实例： 12345678910111213141516171819\"\"\"all_term.txt:new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothnew fallout chernobyl social impact chernobyl disastdavid r marpl st martin press cloth\"\"\"# -*- coding:utf-8 -*-with open('all_term.txt', 'r', encoding='utf-8', errors='ignore') as f: a = f.readline().replace(\"\\n\", \"\") b = f.readline().replace(\"\\n\", \"\")print(\"a:\", a)print(\"b:\", b)\"\"\"结果为：a: new fallout chernobyl social impact chernobyl disastb: david r marpl st martin press cloth\"\"\" 根据结果可以得出结论： 1.第一个readline()读取第一行（也包括换行符），第二个读取第二行，…… 2.上面是我们经常看到的按行遍历一个文件方法，你可能已经注意到我在代码中写的if not myStr:部分。当readline读取到为空的时候，意味着读到了文件的结束。这个时候，问题就在这里，很多人会想，是不是遇到一个空行，也会被认为是文件的结束呢？事实上，文件的空白行并不会返回一个空行。因为在每一行的末尾还有一个或者多个分隔符，因此“空白行”至少会有一个换行符或者系统使用的其他符号。所以，即使文件中真的包含一个“空白行”，读入的行也不是空的，这就意味着在真实遍历读取到文件结束之前，程序实际上是不会停止的","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"read() - readline() - readlines()","slug":"read-readline-readlines","permalink":"https://ahrilove.top/tags/read-readline-readlines/"}]},{"title":"Hexo主体设置知识点","slug":"Hexo主体设置知识点","date":"2019-10-26T13:28:53.000Z","updated":"2019-12-11T09:21:32.841Z","comments":true,"path":"2019/10/26/Hexo主体设置知识点/","link":"","permalink":"https://ahrilove.top/2019/10/26/Hexo%E4%B8%BB%E4%BD%93%E8%AE%BE%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法","text":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法 1.Hexo创建文章、标签、分类的Front-matter方法 Ⅰ&nbsp;&nbsp; Front-matter ⅡFront-matter 是md文件最上方以 — 分隔的区域，用于指定个别文件的变量 其实Front-matter就是在\\Hexo\\source_posts下的.md文件中书写文章标题，上传时间，分类名，标签名等等 字段 含义 值类型 默认值 layout 布局模版 String - title 标题 String - date 创建时间 Date 文件创建时间 description 页面描述、摘要 String - cover 是否显示封面 Bool true 2.Makedown标题页的写法 --- layout: 页面布局（配合主题文档使用） title: 文章名称 date: 文章日期 comments: 文章是否开启评论 photos: 文章封面图（仅部分主题支持） tags: - 文章标签一 - 文章标签二 categories: # 文章分类（文章分类等级） - 父分类 - 子分类 - 孙分类 description: 文章描述，即要在首页显示的摘要（仅部分主题支持） --- 这里是摘要 这里是正文 注意：description 和 方式显示摘要二选一即可，部分主题不支持description， 每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档 3.md文件的基本写法 3.1. ``` 代码段 ``` : 表示以原格式展示代码片段。比如 1234567891011121314$(function () &#123; ...... //鼠标进入的时候,其他的li标签透明度：0.5 $(&quot;.wrap li&quot;).hover(function() &#123; $(this).siblings().stop().fadeTo(400, 0.5); //.stop():停止所有在指定元素上正在运行的动画。 &#125;, function() &#123; // 鼠标离开，其他li 透明度改为 1 $(this).siblings().stop().fadeTo(400, 1); &#125;); console.log($(&apos;.attr a&apos;).prop(&apos;href&apos;)); console.log($(&apos;.attr a&apos;).prop(&apos;title&apos;)); console.log($(&apos;input:checkbox&apos;).attr(&apos;id&apos;)); console.log($(&apos;.office p:eq(0)&apos;).scrollTop());&#125;) 3.2. &lt;img src=”url” width=” “&gt; &nbsp;&nbsp;&nbsp;表示在md文件中展示图片，若不想破坏图片原格式，就只需要写width或者height其中一个，另一个会自适应变化 3.3. 文本修饰:粗体，斜体… &nbsp;&nbsp;&nbsp;粗体文本用两个*或_包含，斜体文本用一个_包含 3.4. 表格(注意其格式) 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 3.5. 颜色RGB和字体以及背景颜色 12345678910&lt;font face=\"Tahoma\"&gt;这是一串Tahoma字体&lt;/font&gt;&lt;br/&gt;&lt;font face=\"黑体\"&gt;这是一串黑体字&lt;/font&gt;&lt;br/&gt;&lt;font face=\"微软雅黑\"&gt;这是一串微软雅黑&lt;/font&gt;&lt;br/&gt;&lt;font face=\"STCAIYUN\"&gt;这是一串华文彩云&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ced1 size=7 face=\"黑体\"&gt;背景色+字体+字的size&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ffff size=72&gt;颜色设置&lt;/font&gt;&lt;br/&gt;&lt;font color=gray size=72&gt;灰色处理&lt;/font&gt;&lt;br/&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#bfe1f1&gt;背景色是：#bfe1f1&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 这是一串Tahoma字体这是一串黑体字这是一串微软雅黑这是一串华文彩云背景色+字体+字的size颜色设置灰色处理 3.6. 转义字符 &lt;br&gt; : 换行\\ : 转义字符，原生字符，不加修饰&amp;nbsp; : 空格 3.7 每一篇博文设置图片 只需要在文章前面配置 photos 关键字即可，若没有这种配置，可以选择在正文插入图片，然后使用 将图片显示在摘要里 3.8 图片可点击设置，单独出现 &lt;fancybox&gt;图片设置&lt;/fancybox&gt; 4.Hexo的搜索search功能设置问题描述： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的博客中点击search，输入相关关键字后，点击查询到的相关文章，会出现404错误 解决方法： 1.检查是否安装文档要求正确的安装了依赖包。2.检查根目录配置文件是否有search字段冲突（我的根目录配置文件中没有search字段）。3.检查我们的主题（我使用的是Material X主题）的配置文件是否开启search功能 1234567891011121314151617# 搜索配置search: enable: true service: hexo # google google_api_key: google_engine_id: # algolia algolia_app_id: algolia_api_key: algolia_index_name: # azure azure_service_name: azure_index_name: azure_query_key: # baidu baidu_api_id: 4.这是最容易忽略的，但往往也是问题出现的源头，请检查根目录配置文件中的链接是否正确，如： 1234url: https://fioralove.github.io# 这里似乎存在一个bug，推荐填写GitHub Page的访问地址，不要使用自己在阿里云以及其它的域名注册服务商所提供的地址# 比如我在阿里云所注册的https:AhriLove.top，填上依旧会出现404错误root: / 5.封面轮播图封面幻灯片轮播图片怎么引入本地的照片？？修改主题下_config.yml文件，里面有个banner改一下，多加几行即可 6.front-matter设置123456789101112131415161718192021222324252627282930313233front-matter是指两个\\---之间的内容\\---title: Javascript篇章四：快速入门// 小图标icons: [fas fa-fire accent]date: 2019-11-21toc: true #是否显示文章目录categories: #分类 - javascript// 是否显示封面 cover: truetags: #标签// 是否置顶文章top: true// 文章右边的音乐块music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID// 作者相关信息块author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.commeta: header: \\[title, author, date, categories, counter, top] footer: \\[updated, tags, share]---// 文章描述&lt;!-- more --&gt;","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"https://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"front-matter","slug":"front-matter","permalink":"https://ahrilove.top/tags/front-matter/"}]},{"title":"Hello Hexo","slug":"hello-world","date":"2019-10-24T16:00:00.000Z","updated":"2019-11-10T07:53:24.497Z","comments":true,"path":"2019/10/25/hello-world/","link":"","permalink":"https://ahrilove.top/2019/10/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"初次见面，请多关照","slug":"初次见面_请多关照","date":"2019-10-20T13:01:24.000Z","updated":"2019-12-08T10:45:37.404Z","comments":true,"path":"2019/10/20/初次见面_请多关照/","link":"","permalink":"https://ahrilove.top/2019/10/20/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2_%E8%AF%B7%E5%A4%9A%E5%85%B3%E7%85%A7/","excerpt":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示","text":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示 大家好–^^__^^–，我叫陈浩东 &nbsp;&nbsp;&nbsp;作为GP-12线,滚齿磨齿操作员，目前正学习清洗包装流程、磨齿、滚齿、齿轮生产工艺以及安全生产。&nbsp;&nbsp;&nbsp;对网站开发的有关知识几乎为零，这也是我搭建好自己的不完全博客之后写的第一篇博客，刚开始搭建博客的时候自己也是网上各种百度，由于自己属于小白那种，历经了千辛万苦才弄好，所以借这个机会会一直坚持下去分析自己的知识，一起走向成功的彼岸！","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"https://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"Github Page","slug":"Github-Page","permalink":"https://ahrilove.top/tags/Github-Page/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ahrilove.top/tags/Hexo/"}]}]}