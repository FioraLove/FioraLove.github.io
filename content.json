{"meta":{"title":"AhriLove","subtitle":null,"description":null,"author":"AhriLove","url":"https://ahrilove.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-06T07:08:15.056Z","updated":"2019-12-06T07:08:15.008Z","comments":true,"path":"404.html","permalink":"https://ahrilove.top/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-01-17T09:20:39.304Z","updated":"2020-01-17T09:20:39.304Z","comments":true,"path":"about/index.html","permalink":"https://ahrilove.top/about/index.html","excerpt":"","text":"君の名は .container { margin: 0 auto; } .content { max-width: 800px; margin: 0 auto; } .content img { max-width: 100%; } @media (max-width: 900px) { .content { max-width: 100%; margin: 20px; } } 我一路向北，离开有你的季节 慢慢的写，好好的活 起笔： 人们常说，心中有梦，不怕天涯路远，眼里有情，何惧秋风寒呢！一直向前拼命走着，也时刻在做着虚幻的梦，不肯醒来。当时光偷换了年华，光阴在疯长，一切却如同昨日云烟，转瞬即逝，刹那的一念起，缘起缘灭，转身的一瞬间，便是沧海桑田，那些青春年少的时光曾经飘荡在云端上的梦，与我隔着那样遥远的距离。 蓦然回首这半生走过的足迹，层层叠叠于时光的转角处，虽已模糊不清，却依旧感慨万千。角落里的花，悄然绽放，无需观众，也同样精彩。一直认为，一个真正内心富有的人，不需要太张扬的个性，看重浮华名利的背后，鲜花和掌声再多么热情，也和价值无关。 时间可以改变一切，比如年轮，容貌，却无法改变一个人思乡情结。离别故乡多年，漂泊在外的脚步疲惫不堪，乡愁也日益浓郁。时常独自站在深夜里，举目眺望深邃的夜空，遥望故乡的方向，一幕幕的往事总会浮现在眼前。故乡的一草一木，一屋一舍，亲人们的笑脸和嘱托，儿时的时光总能勾起深深的回忆。 随着年轮的增长，岁月的叠加，我被时光无情的隔在了这头。如今，童年的玩伴早已长大，昔日嬉戏玩耍的画面早已被光阴无情的掩埋，成了名副其实的沙漏。 记得上次回故乡的时候，路上遇到了邻里的大叔一下子愣住了。以前一口气能扛几十个麻袋粮食都面不改色的大叔，硬朗的身板，如今已经驼背了，走路蹒跚，满脸皱纹，鬓角斑白，面对面的时候我们似乎都愣在原地，一时间名字在嘴边却说不出来了。迟疑了片刻才缓过神来，热情的打起了招呼。大叔憨厚的笑声依旧爽朗，拉住我的手亲切的问候着，眼神里却带着些许的生疏和感动。 2019-6-5 : 今天我毕业啦 我们只是老师送走的其中一届，但是老师们却是我们的唯一一批 多希望有一天突然惊醒，发现自己在高三的一节课上睡着了，现在经历的一切都是一场梦，桌上满是你的口水。你告诉同桌，说做了个好长的梦。同桌骂你白痴，叫你好好听课。你看着窗外的球场，一切都那么熟悉，一切还充满希望... 大学似乎是中了单身魔咒，1号楼东 111寝室，简直不能再邪乎了，但也可以叫做龙潭，因为我们寝室目前已经出了两条龙，他们都在各自的领域取得了不小的成就，努力向他们靠拢。我的大学室友：胡某，张先生，家义123，周队，还有我自己陈某... 这是我们大一冬天的合照，好像是因为寝管阿姨叫每一个寝室都拍一张，发在寝室管理群里... 这就是我们最后离校最后几天，一起合照 2019-12-25 : 人的身体究竟有多脆弱？ &nbsp;&nbsp;&nbsp;&nbsp;之前公司的玻璃坏了，今天有人来维修，真是奇了猪猪皮，在印象中玻璃有怎么重？？？我看那两个二十多岁师傅在安装的时候很吃力，就去帮他们一起装，因为在四楼，所以说格外注意，生怕出一点点安全事故。 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在安装时候，手不小心卡在玻璃与墙棱角处，一点点擦伤贼痛，火辣辣的痛，皮肤神经这么敏感？？但是又不能叫他们挪开，不然玻璃会掉下去。我一直都在锻炼身体，腹肌，胸肌等等，现在跑个二公里，都不会怎么累，一点点的擦伤就很痛，这就让我人的身体究竟有多脆弱？一点点小小的风寒就会头昏脑胀。生物高等进化后的充分条件？相对于其它生物，开发了大脑，但身体健壮性却每况愈下。 【转载知乎一个小文章】 2020再给自己定一个小目标：依旧每天锻炼身体，肉体成圣，找回大学时六块腹肌的我。你看我整不整死小日本儿鬼子就完事了 2020-1-17 : 兄弟萌！诸葛大力~我爱了。我承认我下贱，我馋她 诸葛大力（成果饰演）,《爱情公寓5》里她是胡一菲的学生，超级学霸。胡一菲是这么介绍诸葛大力的：2000年发生过三件大事，‘千年虫’，‘悉尼奥运’和‘诸葛大力’的诞生，诸葛大力外号‘别人家的孩子’，从小甩开同龄人几百条街，她是集体照里的小不点，却是同学眼中的巨人，她到处实习，精通各种专业技能，上天入地，无所不能，她是老师的骄傲，学校的荣光。 成果饰演的爱情公寓里的诸葛大力，简直好看的离谱，可以说她把这个人物角色塑造的十分完美，简直是胡一菲+诺澜+婉瑜的综合体 一眼，提神醒脑 两眼，永不疲劳 三眼，长生不老 可攻可萌可文艺日系颜 如果你喜欢这个相册，那么你可能也喜欢: Hi-Si ？？？ 英雄联盟"},{"title":"所有分类","date":"2019-11-05T14:21:22.930Z","updated":"2019-10-25T13:05:49.103Z","comments":true,"path":"categories/index.html","permalink":"https://ahrilove.top/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-08T00:52:54.690Z","updated":"2020-01-08T00:52:54.690Z","comments":true,"path":"friends/index.html","permalink":"https://ahrilove.top/friends/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;欢迎大家留言分享自己发掘的优秀博文、微信文章、GitHub开源项目、二次元、摄影、运动、读书、影视…-留言请告诉我你的名称、主页、头像、标签或者简介哦～-如果想定制你的卡片颜色，也可以留言告诉我哦～（十六进制颜色码，如：#FF0000）"},{"title":"","date":"2019-12-06T12:22:18.383Z","updated":"2019-12-06T12:22:18.262Z","comments":true,"path":"game/index.html","permalink":"https://ahrilove.top/game/index.html","excerpt":"","text":"轻松一刻 body{ background-image:url(http://pic1.win4000.com/wallpaper/2019-09-20/5d84387f09a52.jpg); } 开始 简单 简单 入门 阿三 外星人 仙人"},{"title":"","date":"2019-12-06T05:56:16.124Z","updated":"2019-12-06T05:56:16.093Z","comments":true,"path":"mylist/index.html","permalink":"https://ahrilove.top/mylist/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;我从来不记在辞典上已经印有的东西。我的记忆力是运用来记忆书本上还没有的东西。 ——爱因斯坦&nbsp;&nbsp;在这主题页中我将分享自己收集的一些资料以及文档 优秀博客或文章 链接 RGB颜色对照表 https://www.114la.com/other/rgb.htm 比较柔和的配色表 https://www.geticsen.cn/Index/article/content/151.html Hexo的ico图标 http://www.wapadd.cn/icons/awesome/index.htm bilibili视频收藏 https://space.bilibili.com/215893581/favlist git详细教程 https://blog.csdn.net/u011535541/article/details/83379151 Django2.0详细资料文档 https://pan.baidu.com/s/1ppN8GSDdOdcd3ew0e7SxMQ 开发书籍电子版大全 https://pan.baidu.com/s/1HJtB9EieaMZPU0fSK2kgkQ docker详情mindmanage https://pan.baidu.com/s/1nUE4pfe2wThYVGMEYqADXw 网络用语大全~小鸡词典 https://jikipedia.com/ Vue-Devtools最简单的配置，有手就行 https://blog.csdn.net/weixin_38654336/article/details/80790698 Jetbrains全家桶注册码 http://www.medeming.com/ 阿里中间件团队博客 http://jm.taobao.org/ font-awesome ico小图标 https://fontawesome.com/icons?d=gallery&amp;m=free 亲测可用：navicat premium12 破解教程 https://blog.csdn.net/u013162035/article/details/89456708 小马视频码云仓库 https://gitee.com/komavideo/projects 服务端高并发分布式架构演进之路(天猫) https://segmentfault.com/a/1190000018626163 看完这篇还不了解Nginx，那我就哭了！ https://www.cnblogs.com/wcwnina/p/8728391.html#!comments Nginx笔记一 http://www.edrawsoft.cn/viewer/public/s/e194d338895116 Nginx安装配置笔记二（完整版） 链接：https://pan.baidu.com/s/1bTVdjwFl-kyd93C2GksZQQ 提取码：63x6 将table转变为Makedown,CSV,json,sql,yaml,html,excle https://tableconvert.com/"},{"title":"所有标签","date":"2019-11-05T14:21:22.945Z","updated":"2019-10-25T13:06:22.321Z","comments":true,"path":"tags/index.html","permalink":"https://ahrilove.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-06T14:22:21.947Z","updated":"2019-12-06T14:22:21.853Z","comments":true,"path":"cv/index.html","permalink":"https://ahrilove.top/cv/index.html","excerpt":"","text":"AhriLove'S BLOG | OFFER document.onkeydown = function () { if (window.event && window.event.keyCode == 123) { event.keyCode = 0; event.returnValue = false; return false; } }; 您的浏览器不支持audio标签，无法播放音乐！ 自称：陈某（师从盛建彬） 籍贯：中国 | 四川 | 绵阳 （俺木拆里斯） 生辰：1997（98年是真滴牛批，玩不过她，5555） 兴趣爱好：健身 | 编程 | 土味 | 钓鱼 技能 | Skill HTML/CSS/JS 35% PHP 10% 数据分析/爬虫 52% PYTHON 75% SQL 38% PS/剪辑 45% 简介 | Introduction ● 学历：高中文凭 ● 现况：脑瘫前端 | 学js逆向爬虫中 | 学习后端方向； ● 目标：不脑瘫前端 | 全栈 | 专升本，完成大学学业； ● 博客：只有能被明日的我们所铭记，今日才有意义（--源计划·艾希）； ● 兴趣：先打一拳，打的时候再把问题问遍（-- 源计划·蔚） ● 其他：虽然我学历低，但是在努力学习中！ 联系我 | Contact me Copyright © 2019 AhriLove'S BLOG. All rights reserved. if ('addEventListener' in window) { window.addEventListener('load', function () { document.body.className = document.body.className.replace(/\\bis-loading\\b/, ''); }); document.body.className += (navigator.userAgent.match(/(MSIE|rv:11\\.0)/) ? ' is-ie' : ''); } uniform mat4 uProjection; uniform mat4 uModelview; uniform vec3 uResolution; uniform vec3 uOffset; uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start attribute vec3 aPosition; attribute vec3 aEuler; attribute vec2 aMisc; //x:size, y:fade varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; void main(void) { // Projection is based on vertical angle vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0); gl_Position = uProjection * pos; gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5; pposition = pos.xyz; psize = aMisc.x; pdist = length(pos.xyz); palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z); vec3 elrsn = sin(aEuler); vec3 elrcs = cos(aEuler); mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, elrcs.x, elrsn.x, 0.0, -elrsn.x, elrcs.x ); mat3 roty = mat3( elrcs.y, 0.0, -elrsn.y, 0.0, 1.0, 0.0, elrsn.y, 0.0, elrcs.y ); mat3 rotz = mat3( elrcs.z, elrsn.z, 0.0, -elrsn.z, elrcs.z, 0.0, 0.0, 0.0, 1.0 ); mat3 rotmat = rotx * roty * rotz; normal = rotmat[2]; mat3 trrotm = mat3( rotmat[0][0], rotmat[1][0], rotmat[2][0], rotmat[0][1], rotmat[1][1], rotmat[2][1], rotmat[0][2], rotmat[1][2], rotmat[2][2] ); normX = trrotm[0]; normY = trrotm[1]; normZ = trrotm[2]; const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237); float tmpdfs = dot(lit, normal); if(tmpdfs < 0.0) { normal = -normal; tmpdfs = dot(lit, normal); } diffuse = 0.4 + tmpdfs; vec3 eyev = normalize(-pos.xyz); if(dot(eyev, normal) > 0.0) { vec3 hv = normalize(eyev + lit); specular = pow(max(dot(hv, normal), 0.0), 20.0); } else { specular = 0.0; } rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0); rstop = pow(rstop, 0.5); //-0.69315 = ln(0.5) distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y)); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec3 uDOF; //x:focus distance, y:focus radius, z:max radius uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start const vec3 fadeCol = vec3(0.08, 0.03, 0.06); varying vec3 pposition; varying float psize; varying float palpha; varying float pdist; //varying mat3 rotMat; varying vec3 normX; varying vec3 normY; varying vec3 normZ; varying vec3 normal; varying float diffuse; varying float specular; varying float rstop; varying float distancefade; float ellipse(vec2 p, vec2 o, vec2 r) { vec2 lp = (p - o) / r; return length(lp) - 1.0; } void main(void) { vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0; vec3 d = vec3(0.0, 0.0, -1.0); float nd = normZ.z; //dot(-normZ, d); if(abs(nd) < 0.0001) discard; float np = dot(normZ, p); vec3 tp = p + d * np / nd; vec2 coord = vec2(dot(normX, tp), dot(normY, tp)); //angle = 15 degree const float flwrsn = 0.258819045102521; const float flwrcs = 0.965925826289068; mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs); vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm; float r; if(flwrp.x < 0.0) { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5); } else { r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5); } if(r > rstop) discard; vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r); float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35)); col *= vec3(1.0, grady, grady); col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3)); col = col * diffuse + specular; col = mix(fadeCol, col, distancefade); float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0; alpha = smoothstep(0.0, 1.0, alpha) * palpha; gl_FragColor = vec4(col * 0.5, alpha); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform vec2 uTimes; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec3 col; float c; vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0); c = exp(-pow(length(tmpv) * 1.8, 2.0)); col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c); gl_FragColor = vec4(col * 0.5, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; uniform vec4 uBlurDir; //dir(x, y), stride(z, w) varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 col = texture2D(uSrc, texCoord); col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta); col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta); col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta); gl_FragColor = col / 5.0; } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_FragColor = texture2D(uSrc, texCoord); } uniform vec3 uResolution; attribute vec2 aPosition; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { gl_Position = vec4(aPosition, 0.0, 1.0); texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5); screenCoord = aPosition.xy * vec2(uResolution.z, 1.0); } #ifdef GL_ES //precision mediump float; precision highp float; #endif uniform sampler2D uSrc; uniform sampler2D uBloom; uniform vec2 uDelta; varying vec2 texCoord; varying vec2 screenCoord; void main(void) { vec4 srccol = texture2D(uSrc, texCoord) * 2.0; vec4 bloomcol = texture2D(uBloom, texCoord); vec4 col; col = srccol + bloomcol * (vec4(1.0) + srccol); col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5); col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2) gl_FragColor = vec4(col.rgb, 1.0); gl_FragColor.a = 1.0; }"},{"title":"逆水行舟用力撑，一篙松劲退千寻","date":"2019-12-16T07:41:46.457Z","updated":"2019-12-16T07:41:46.389Z","comments":true,"path":"sport/index.html","permalink":"https://ahrilove.top/sport/index.html","excerpt":"","text":"Daily PLAN1.每天两则HTML，jQuery，Vue，PHP，docker，服务器，ThinkPHP，读英语 2019-11-12 planning: 1.数据库基础2.python的字符串，字典，列表，元组，序列 2019-11-14 planning: 1.学习归纳json知识2.json_decode3.json_encode与thinkPHP 2019-12-2 planning: 1.pyhton的ftp库 2.python的time，datetime库 3.python的多线程，多进程 4.DBUtils管理数据库连接池 5.未完待续… 2019-12-9 planning: 1.温习一下php，vue2.完成PHP防止SQL注入3.温习python爬虫解析库4.开始学习js5.逐渐学习Java起来 2019-12-11 planning: 1.完成博客的轮播图片2.完成博客的简历3.继续js的学习和vue4.ps AhriLove博客首页5.数学 2019-12-16 summarize: 最近很迷茫，不知道在干什么，总结一下自己用到的知识，与此对比，查漏补缺：1.Pyhton2.html,css,javascript3.jQuery4.PHP,ThinkPHP5.Vue6.Bootstrap7.Echarts8.git，hexo9.SQl:mysql,oracle,Memcached,redis10.docker11.Ubuntu&amp;&amp;Linux"},{"title":"","date":"2020-02-04T06:48:45.683Z","updated":"2020-02-04T06:48:45.683Z","comments":true,"path":"feiyan2020/index.html","permalink":"https://ahrilove.top/feiyan2020/index.html","excerpt":"","text":"全国新型冠状病毒实时分布图 body { height: 88vh; margin: 0; padding: 0; overflow: hidden; } h2 { text-align:center; margin: 20px 0 0 0; color: #0822B5; } h3 { text-align:center; margin: 20px 0 0 0; color: #0822B5; } a { color: #178b50; text-decoration: none; } a:hover { color: #d81d1b; text-decoration: none; } iframe { overflow:hidden; margin: 20px 0 0 0; border: none; } AhriLove'S BLOG丨新冠肺炎实时疫情图（数据来源：腾讯新闻） 相关链接：武汉新型冠状病毒防疫信息收集平台 丨 2019-nCoV 疫情信息导航网站"}],"posts":[{"title":"Java（四）：Java核心类","slug":"Java核心类(四)","date":"2020-02-13T16:00:00.000Z","updated":"2020-02-15T09:23:24.122Z","comments":true,"path":"2020/02/14/Java核心类(四)/","link":"","permalink":"https://ahrilove.top/2020/02/14/Java%E6%A0%B8%E5%BF%83%E7%B1%BB(%E5%9B%9B)/","excerpt":"本章内容： 1.字符串与编码2.定义常量3.enum枚举类型4.常用工具类5.异常处理机制6.Java集合","text":"本章内容： 1.字符串与编码2.定义常量3.enum枚举类型4.常用工具类5.异常处理机制6.Java集合 1.字符串与编码String，【与js，python的字符串操作对比】 在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用”…”来表示一个字符串。 字符串比较：比较字符串的内容是否相同。必须使用equals()方法而不能用==str1.equals(str2):判断两个字符串的是否相同 字符索引查找字符串.indexOf(“目标字符”) 判断以什么开头字符串.startsWith(“目标字符串”):判断是否以目标字符串开头字符串.endWith(“目标字符串”):判断是否以目标目标字符串结尾 字符串的截取字符串.substring(起始索引，结束索引)：截取目标字符串，索引从0开始 去掉首尾空白字符字符串.trim()字符串.strip():也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除 替换字符串字符串.replace(a,b):用字符b替换字符a 拼接字符串拼接字符串使用静态方法String.join,它用指定的字符串连接字符串数组 12String arr = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;String s = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; 类型转换 要把任意基本类型或引用类型转换为字符串，可以使用静态方法String.valueOf() 1234String.valueOf(123); // &quot;123&quot;String.valueOf(45.67); // &quot;45.67&quot;String.valueOf(true); // &quot;true&quot;String.valueOf(new Object()); // 类似java.lang.Object@636be97c 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为int类型： 12int n1 = Integer.parseInt(&quot;123&quot;); // 123int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255 把字符串转换为boolean类型： 12boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // trueboolean b2 = Boolean.parseBoolean(&quot;FALSE&quot;); // false 是否包含子字符串字符串.contains(“目标字符串”)：返回结果true 或者 false 包装类型：基本类型===&gt; 对应的引用类型boolean ===&gt; java.lang.Booleanbyte ===&gt; java.lang.Byteshort ===&gt; java.lang.Shortint ===&gt; java.lang.Integerlong ===&gt; java.lang.Longfloat ===&gt; java.lang.Floatdouble ===&gt; java.lang.Doublechar ===&gt; java.lang.Character 2.定义常量Java 语言使用 final 关键字来定义一个常量（常量有三种类型：静态常量、成员常量和局部常量。），其语法如下所示：final dataType variableName = value 12345678910public class HelloWorld &#123; // 静态常量 public static final double PI = 3.14; // 声明成员常量 final int y = 10; public static void main(String[] args) &#123; // 声明局部常量 final double x = 3.3; &#125;&#125; 3.enum枚举类1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) &#123; System.out.println(\"Work at home!\"); &#125; else &#123; System.out.println(\"Work at office!\"); &#125; &#125;&#125;enum Weekday &#123; SUN, MON, TUE, WED, THU, FRI, SAT;&#125; 4.常用工具类MAth：进行数学计算Math.abs()求绝对值Math.max/min()Math.pow(a,b)计算a的次方Math.sqrt()计算开方Math.exp()计算e的次方Math.PI 数学常量PIMath.E 数学常量eMath.random() 生成随机[0,1)的数 Random：创建伪随机数1234567// 创建Random实例对象Random r = new Random();r.nextInt(); // 2071575453,每次都不一样r.nextInt(10); // 5,生成一个[0,10)之间的intr.nextLong(); // 8811649292570369305,每次都不一样r.nextFloat(); // 0.54335...生成一个[0,1)之间的floatr.nextDouble(); // 0.3716...生成一个[0,1)之间的double 5.异常处理机制在Java中，凡是可能抛出异常的语句，都可以用try ... catch捕获。把可能发生异常的语句放在try { … }中，然后使用catch捕获对应的Exception及其子类。 在使用try…catch捕获处理异常时需要注意：· 不要过度使用异常，不能使用异常处理机制来代替正常的流程控制语句· 异常捕获时，一定要先捕获小异常，再捕获大异常。否则小异常将无法被捕获· 避免出现庞大的try块· 避免使用catch(Exception e){}· 不要忽略异常 Exception类的常用的几种情况：IOException有：EOFException文件已结束异常；FileNotFoundException文件未找到异常。 RuntimeException有：IndexOutOfBoundsException索引越界异常；ArrayIndexOutOfBoundsException数组索引越界异常；ArithmeticException算数条件异常，譬如:整数除零等；NullPointerException空指针异常；NegativeArraySizeException数组长度为负异常；ArrayStoreException数组存储异常，当向数组中存放非数组声明类型对象时抛出；SecurityException违背安全原则异常；IllegalArgumentException非法参数异常；ClassCastException类型强制转换异常。ReflectiveOperationException有：ClassNotFoundException找不到类异常；NoSuchMethodException方法未找到异常；NoSuchFieldException找不到属性异常。 错误类Error：一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断。所以不应该试图使用catch块来捕捉Error和不能在throws子句中声明该方法可能抛出Error及其任何子类 多catch语句多catch语句:简单来说，多个catch语句只有一个能被执行 可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 finally语句无论是否有异常发生，程序语句最终都要执行 123456789101112131415public class HelloWorld&#123; public static void main(String[] args) &#123; try &#123; process1(); process2(); process3(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"Bad encoding\"); &#125; catch (IOException e) &#123; System.out.println(\"IO error\"); &#125; finally &#123; System.out.println(\"END\"); &#125;&#125;&#125; 6.集合Java的集合与数组都是为了处理一类数据，但Java数组也存在很大的缺陷： 数组初始化后大小不可变； 数组只能按索引顺序存取。 Java标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合： List：一种有序列表的集合，具体实现的类有ArrayList，LinkedList； Set：一种保证没有重复元素的集合； Map：一种通过键值（key-value）查找的映射表集合。 创建List： 12345List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 只能放入String类型List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); // 只能放入Integer类型List&lt;Character&gt; list2 = new ArrayList&lt;&gt;(); // 只能放入Character类型拓展：根据给定的元素快速创建ListList&lt;Integer&gt; list3 = List.of(1, 2, 5); List主要的接口方法： 123456在末尾添加一个元素：void add(E e)在指定索引添加一个元素：void add(int index, E e)删除指定索引的元素：int remove(int index)删除某个元素：int remove(Object e)获取指定索引的元素：E get(int index)获取链表大小（包含元素的个数）：int size() List的遍历：童鞋可能觉得使用Iterator访问List的代码比使用索引更复杂。但是，要记住，通过Iterator遍历List永远是最高效的方式。并且，由于Iterator遍历是如此常用，所以，Java的for each循环本身就可以帮我们使用Iterator遍历 12345678public class Main &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = List.of(\"apple\", \"pear\", \"banana\"); for (String s : list) &#123; System.out.println(s); &#125; &#125;&#125; 1.ArrayList对于ArrayList来说，有一个尖括号代表泛型（泛型：也就是装在集合中的所有元素，全部都是统一的什么类型。注意，泛型只能是引用数据类型，不能是基本类型） 2.equals方法经典案例给定一组整数，找出缺失的数字:这里推荐使用集合，因为不确定整数的数据多少，而Java中的数组个数无法改变 123456789101112131415161718192021222324252627282930313233import java.util.*;public class Main &#123; public static int findMissingNumber(int start, int end, List&lt;Integer&gt; list) &#123; // 对等差数列进行求和 Sn=na1+n(n-1)d/2或Sn=n(a1+an)/2 int total = ((end+start)*(end-start + 1))/2; int max = 0; // 对list集合进行求和 for(Integer p : list) max+= p; // 将两个集合之和做差，即可知晓缺失的是那个数 return total - max; &#125; public static void main(String[] args) &#123; // 构造从start到end的序列： final int start = 10; final int end = 20; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = start; i &lt;= end; i++) &#123; list.add(i); &#125; // 随机删除List中的一个元素: int removed = list.remove((int) (Math.random() * list.size())); int found = findMissingNumber(start, end, list); System.out.println(list.toString()); System.out.println(\"missing number: \" + found); System.out.println(removed == found ? \"测试成功\" : \"测试失败\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（三）：面向对象编程","slug":"Java面向对象编程(三)","date":"2020-02-09T16:00:00.000Z","updated":"2020-02-13T08:16:14.705Z","comments":true,"path":"2020/02/10/Java面向对象编程(三)/","link":"","permalink":"https://ahrilove.top/2020/02/10/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E4%B8%89)/","excerpt":"本章内容： 1.类（class）与实例（instance）2.方法3.this变量4.构造方法5.方法重载Overload6.继承7.多态8.抽象类9.接口10.package包11.作用域","text":"本章内容： 1.类（class）与实例（instance）2.方法3.this变量4.构造方法5.方法重载Overload6.继承7.多态8.抽象类9.接口10.package包11.作用域 1.类（class）与实例（instance）现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同。在Java中，我们来写一个完整的程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243// class的public前缀有且仅有一个public class OOP &#123; // 在主类中定义一个demo方法 public static int demo(int x)&#123; return x; &#125; // 定义程序入口方法：main方法 public static void main(String[] args) &#123; // 调用定义好的demo方法 System.out.println(demo(5)); // 创建一个ming实例变量 Person ming = new Person(); ming.setBirth(2008); ming.tel = \"15867119504\"; System.out.println(ming.getTel()); System.out.println(ming.getAge()); &#125;&#125;// 创建一个People类（类里包含属性和方法）class Person &#123; public String tel; private String name; private int birth; public void setBirth(int birth) &#123; this.birth = birth; &#125; public String getTel()&#123; return this.tel; &#125; // 这里说明一下：利用public型的getAge()方法调用private型的calcAge()方法 public int getAge() &#123; return calcAge(2019); // 调用private方法 &#125; // private方法: private int calcAge(int currentYear) &#123; return currentYear - this.birth; &#125;&#125; 小结： public是用来修饰字段的，它表示这个字段可以被外部访问。 private方法不允许外部调用,内部方法（即处于同一class中）是可以调用private方法 2.方法1234修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 3.this变量在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的字段。 如果没有命名冲突，可以省略this。 12345678910111213141516class Person &#123; private String name; public String getName() &#123; return name; // 相当于this.name &#125;&#125;但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this：class Person &#123; private String name; public void setName(String name) &#123; this.name = name; // 前面的this不可少，少了就变成局部变量name了 &#125;&#125; 4.构造方法123456789101112131415161718192021222324252627282930313233public class OOP &#123; public static void main(String[] args) &#123; // 在通过new操作符调用的时候，构造方法的参数数量、位置和类型一一对应 Person p = new Person(\"chd\",18,10086); System.out.println(p.getAge()); // 调用实例对象的属性 System.out.println(p.tel); System.out.println(p.getAge()); System.out.println(p.getName()); &#125;&#125;class Person &#123; // 这个不能省略，用以声明变量 private String name; private int age; public int tel; // 这就是Java的构造方法，类似于python的def __init__函数 public Person(String name, int age,int tel) &#123; this.name = name; this.age = age; this.tel = tel; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 拓：多构造方法可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： 1234567891011121314151617class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name) &#123; this.name = name; this.age = 12; &#125; public Person() &#123; &#125;&#125; 如果调用new Person(&quot;Xiao Ming&quot;, 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(&quot;Xiao Ming&quot;);，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person() 5.方法重载这种方法名相同，但各自的参数不同（即参数数目不同，参数数据类型不同），称为方法重载（Overload）。注意：方法重载的返回值类型通常都是相同的。 1234567891011121314151617class Hello &#123; public void hello() &#123; System.out.println(\"Hello, world!\"); &#125; public void hello(String name) &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; public void hello(String name, int age) &#123; if (age &lt; 18) &#123; System.out.println(\"Hi, \" + name + \"!\"); &#125; else &#123; System.out.println(\"Hello, \" + name + \"!\"); &#125; &#125;&#125; 6.继承继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。继承的特点： Java是单继承语言：一个类的直接父类只能有唯一一个 Java语言可以多级继承：父类也可以继承父类的父类 一个父类可以拥有多个子类：兄弟子类 123456789101112131415161718class Person &#123; private String name; private int age; public String getName() &#123;...&#125; public void setName(String name) &#123;...&#125; public int getAge() &#123;...&#125; public void setAge(int age) &#123;...&#125;&#125;class Student extends Person &#123; // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() &#123; … &#125; public void setScore(int score) &#123; … &#125;&#125; supersuper关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName实际上，这里使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段 12345class Student extends Person &#123; public String hello() &#123; return \"Hello, \" + super.name; &#125;&#125; 在继承时，如果父类存在构造函数，在这个时候，就必须使用super,其正确写法应为(牢记)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class OOP &#123; public static void main(String[] args) &#123; Person p = new Person(\"chd\",18,10086); // 实例s为Person的子类Student类的实例 Student s = new Student(\"gz\",18,10010,100); System.out.println(s.getAge()); System.out.println(p.getAge()); System.out.println(p.tel); System.out.println(p.getAge()); System.out.println(p.getName()); System.out.println(s.grand); &#125;&#125;class Person &#123; protected String name; protected int age; public int tel; public Person(String name, int age,int tel) &#123; this.name = name; this.age = age; this.tel = tel; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125;class Student extends Person&#123; protected int grand; public Student(String name, int age, int tel,int grand) &#123; super(name, age, tel); // 自动调用父类的构造方法Person(name, age, tel) this.grand = grand; // 这是新构建的字段 &#125; @Override // Override重写，方法名，参数，返回值类型完全相同 public int getAge()&#123; return this.grand; &#125;&#125; 继承小结： Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类 子类无法访问父类的private字段或者private方法，为了让子类可以访问父类的字段，我们需要把private改为protected 子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的 7.多态在继承关系中，子类如果与父类的方法名完全相同（方法名相同，参数相同，返回值相同），被称为重写（Override，这里要区别于Overload是方法名相同，但各自的参数不同）举一个简单案例： 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person p = new Student(); p.run(); // 应该打印Person.run还是Student.run? &#125;&#125;class Person &#123; // class中的方法不要写static public void run() &#123; System.out.println(\"Person.run\"); &#125;&#125;// Student类继承Person类class Student extends Person &#123; @Override // 这是重写符号 // 将子类的run方法进行重写，增加新的功能 public void run() &#123; System.out.println(\"Student.run\"); &#125;&#125; 调用super关键字在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如： 1234567891011121314class Person &#123; protected String name; public String hello() &#123; return \"Hello, \" + name; &#125;&#125;class Student extends Person &#123; @Override public String hello() &#123; // 调用父类的hello()方法: return super.hello() + \"!\"; &#125;&#125; final继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： 12345678910111213class Person &#123; protected String name; public final String hello() &#123; return \"Hello, \" + name; &#125;&#125;class Student extends Person &#123; // compile error: 不允许覆写 @Override public String hello() &#123; &#125;&#125; 8.抽象类由于多态的存在，每个子类都可以覆写父类的方法，例如： 12345678910111213class Person &#123; public void run() &#123; … &#125;&#125;class Student extends Person &#123; @Override public void run() &#123; … &#125;&#125;class Teacher extends Person &#123; @Override public void run() &#123; … &#125;&#125; 定义：抽象类：抽象方法所在的类，必须是抽象类才行，在class前写上abstract即可抽象方法：就是在方法强加上abstract关键字，然后去掉大括号，直接分号结束 使用方法： 不能直接创建new抽象类对象 必须用一个子类来继承抽象父类 子类必须覆盖重写抽象父类当中的所有抽象方法 创建子类实例对象进行使用如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。1234567891011121314151617181920212223242526272829public class OOP&#123; public static void main(String[] args) &#123; /* *这里值得值得注意：用abstract修饰的类就是抽象类。我们无法实例化一个抽象类 */ Person p = new Student(); // 第四点：创建子类实例对象 p.age = 18; p.run(); &#125;&#125;// 抽象类不仅要在类名前加abstract，也要在抽象方法名前加abstract// Person类用abstract修饰的，表示为抽象类，我们无法实例化抽象类abstract class Person&#123; protected int age; public abstract void run();&#125;// Student类继承Person类，并将父类的run方法进行重写class Student extends Person&#123; @Override public void run()&#123; System.out.println(super.age); // super指代父类 System.out.println(this.age); &#125;&#125; 小结： 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范； 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法； 抽象类无法被实例化（即className 变量名 = new className()） 9.接口含义如果一个抽象类没有字段或者说没有属性，所有方法全部都是抽象方法【抽象方法：修饰符 abstract 返回值类型 方法名()】，就可以把该抽象类改写为接口：interface 123456// 抽象类abstract class Person &#123; public abstract void run(); public abstract String getName(); public abstract String getName();&#125; 在Java中，可以使用interface可以声明一个接口： 1234interface Person&#123; void run(); String getName();&#125; 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样） 实现方式当一个具体的class去实现一个interface时，需要使用implements关键字 1234567891011121314151617class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + \" run\"); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; 类实现多接口在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface 123class Student implements Person, Hello &#123; // 实现了两个interface ...&#125; 接口继承一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： 12345678interface Hello &#123; void hello();&#125;interface Person extends Hello &#123; void run(); String getName();&#125; 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 10.package包12345678910程序目录结构：package_sample└─ src ├─ hong │ └─ Person.java │ ming │ └─ Person.java └─ mr └─ jun └─ Arrays.java 使用import导入相关包 方式一：import 包名.某一类名 方式二：import 包名.* 11.作用域priavte 本类可见 public 所有类可见 protected 作用于继承关系，定义为protected的字段和方法可以被子类访问，以及子类的子类 default 本包可见（即默认的形式）（本包中的子类非子类均可访问，不同包中的类及子类均不能访问） 小结 Java内建的访问权限包括public、protected、private和package权限； Java在方法内部定义的变量是局部变量，局部变量的作用域从变量声明开始，到一个块结束； final修饰符不是访问权限，它可以修饰class、field和method； 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 12.未完待续…","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（二）：流程控制","slug":"Java流程控制(二)","date":"2020-02-08T16:00:00.000Z","updated":"2020-02-10T08:28:13.737Z","comments":true,"path":"2020/02/09/Java流程控制(二)/","link":"","permalink":"https://ahrilove.top/2020/02/09/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6(%E4%BA%8C)/","excerpt":"本章内容： 1.Java输入输出2.if判断3.switch语句4.while循环5.do-while循环6.for循环7.break与continue8.Java多维数组","text":"本章内容： 1.Java输入输出2.if判断3.switch语句4.while循环5.do-while循环6.for循环7.break与continue8.Java多维数组 1.输入输出在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用System.out.print()格式化输出：如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式： 1234567public class Main&#123; public static void main(String[] args)&#123; double d = 3.1415927; System.out.printf(\"%.2f\",d); System.out.printf(\"%.4f\",d); &#125;&#125; 占位符 说明 %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 输入： 直接看案例 123456789101112import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(\"Input your name: \"); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(\"Input your age: \"); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(\"Hi, %s, you are %d\\n\", name, age); // 格式化输出 &#125;&#125; 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。 然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。 有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()；要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 2.if判断if语句的基本语法是： 123456789if (条件) &#123; // 条件一满足时执行&#125;else if(条件) &#123; // 条件二满足时执行&#125;else&#123; // 条件不满足时执行&#125; 拓：浮点数相等判断。浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱 1234567891011public class Main &#123; public static void main(String[] args) &#123; double x = 1 - 9.0 / 10; // 利用Math的绝对值之差 if (Math.abs(x - 0.1) &lt; 0.00001) &#123; System.out.println(\"x is 0.1\"); &#125; else &#123; System.out.println(\"x is NOT 0.1\"); &#125; &#125;&#125; 3.switch语句1234567891011121314switch (option) &#123; case 3: ... break; case 2: ... break; case 1: ... break; default: ... break;&#125; 4.while循环while循环在每次循环开始前，首先判断条件是否成立。如果计算结果为true，就把循环体内的语句执行一遍，如果计算结果为false，那就直接跳到while循环的末尾，继续往下执行。 1234567891011public class Main &#123; public static void main(String[] args) &#123; int sum = 0; // 累加的和，初始化为0 int n = 1; while (n &lt;= 100) &#123; // 循环条件是n &lt;= 100 sum = sum + n; // 把n累加到sum中 n ++; // n自身加1 &#125; System.out.println(sum); // 5050 &#125;&#125; while循环是先判断循环条件，再循环，因此，有可能一次循环都不做。 5.do…while循环在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是： 123do &#123; 执行循环语句&#125; while (条件表达式); 可见，do while循环会至少循环一次。 6.for循环12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; int sum = 0; for (int i=0; i&lt;ns.length; i++) &#123; System.out.println(\"i = \" + i + \", ns[i] = \" + ns[i]); sum = sum + ns[i]; &#125; System.out.println(\"sum = \" + sum); &#125;&#125;/*i = 0, ns[i] = 1i = 1, ns[i] = 4i = 2, ns[i] = 9i = 3, ns[i] = 16i = 4, ns[i] = 25sum = 55*/ 7.break与continuebreak：会跳出整个循环，也就是整个循环都不会执行了continue：提前结束本次循环，直接继续执行下次循环 8.二维数组12345678910public class Main &#123; public static void main(String[] args) &#123; int[][] ns = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125; &#125;; System.out.println(ns.length); // 3 &#125;&#125; 因为ns包含3个数组，因此，ns.length为3.访问二维数组的某个元素需要使用array[row][col]，例如： 1System.out.println(ns[1][2]); // 7","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Java（一）：程序基础","slug":"Java程序基础(一)","date":"2020-02-06T16:00:00.000Z","updated":"2020-02-07T04:14:18.141Z","comments":true,"path":"2020/02/07/Java程序基础(一)/","link":"","permalink":"https://ahrilove.top/2020/02/07/Java%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80(%E4%B8%80)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 1.Java基础结构2.Java命名规范与注释3.变量，常量与数据类型4.字符与字符串类型5.数组类型","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 1.Java基础结构2.Java命名规范与注释3.变量，常量与数据类型4.字符与字符串类型5.数组类型 1.Java基础结构123456// 类名与Java文件名相同public class Hello &#123; public static void main(String[] args) &#123; // 方法名是main，main方法表示为入口文件 // 方法代码... &#125; // 方法定义结束&#125; PS：我们注意到public除了可以修饰class外，也可以修饰方法。而关键字static是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。 2.命名规范命名规则：包含数字，字母，下划线与$符号（不能以数字开头；不能为关键字）命名规范：类名（大驼峰原则），方法名与变量名（小驼峰原则） 3.注释单行注释：\\\\多行注释：\\* content *\\从Java 13开始，字符串可以用&quot;&quot;&quot;...&quot;&quot;&quot;表示多行字符串（Text Blocks） 4.变量与数据类型在Java中，变量必须先定义后使用，定义时，也可以赋值一个初始值，在Java中，变量分为两种：基本类型的变量和引用类型的变量。基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型： 整数类型：byte，short，int，long 浮点数类型：float，double 字符类型：char 布尔类型：boolean注意char类型使用单引号&#39;，且仅有一个字符，要和双引号&quot;的字符串类型区分开。 5.常量(通常大写)定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error! 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。 注意： 变量可重新赋值，等号是赋值语句，不是数学意义的等号。 常量在初始化后不可重新赋值，使用常量便于理解程序意图。 5.字符与字符串类型字符类型：字符char是基本数据类型，一个char保存一个Unicode字符 12char c1 = &apos;A&apos;;char c2 = &apos;中&apos;; 要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可： 12int n1 = &apos;A&apos;; // 字母“A”的Unicodde编码是65int n2 = &apos;中&apos;; // 汉字“中”的Unicode编码是20013 字符串类型：和char类型不同，字符串类型String是引用类型，常常使用双引号包裹起来 1234String s = &quot;&quot;; // 空字符串，包含0个字符String s1 = &quot;A&quot;; // 包含一个字符String s2 = &quot;ABC&quot;; // 包含3个字符String s3 = &quot;中文 ABC&quot;; // 包含6个字符，其中有一个空格 6.数组类型语法：定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。 1234567public class Main &#123; public static void main(String[] args) &#123; // 数组的创建方式 int[] grades = new int[5]; System.out.println(ns.length); // 5 &#125;&#125; Java的数组有几个特点： 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。 可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;。 可以用数组变量.length获取数组大小 python的列表List与python的数组的区别：List（列表） 是 Python 中使用最频繁的数据类型。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 Java数值初始化： 12int[] ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;int[] ns = &#123; 68, 79, 91, 85, 62 &#125; // 这是简写 小结： 数组是同一数据类型的集合，数组一旦创建后，大小就不可变； 可以通过索引访问数组元素，但索引超出范围将报错； 数组元素可以是值类型（如int）或引用类型（如String），但数组本身是引用类型；","categories":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://ahrilove.top/tags/Java/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"2020 新年快乐  \\﻿ (•◡•) /","slug":"HappyNewYear","date":"2020-01-23T16:00:00.000Z","updated":"2020-02-01T06:50:48.400Z","comments":true,"path":"2020/01/24/HappyNewYear/","link":"","permalink":"https://ahrilove.top/2020/01/24/HappyNewYear/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"你很秀！但下一秒，我跟你一样秀","slug":"成神装逼进化之路","date":"2020-01-22T16:00:00.000Z","updated":"2020-02-15T14:56:12.416Z","comments":true,"path":"2020/01/23/成神装逼进化之路/","link":"","permalink":"https://ahrilove.top/2020/01/23/%E6%88%90%E7%A5%9E%E8%A3%85%E9%80%BC%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/","excerpt":"【天不造人上之人,亦不造人下之人】谢邀，人在美国，刚下飞机。利益相关，圈子太小，匿了(总结装逼的知识百科)。","text":"【天不造人上之人,亦不造人下之人】谢邀，人在美国，刚下飞机。利益相关，圈子太小，匿了(总结装逼的知识百科)。 要想修身,齐家,治国,平天下,无形之中装逼，除了超凡的智商压制，还离不开知识的积累铺垫。 1. 大相径庭：比喻相差很远，大不相同近义词： 迥然不同、泾渭分明、截然不同、天差地别反义词： 一模一样、如出一辙、大同小异、相差无几 2. 量子纠缠态官方解释：【在量子力学里，当几个粒子在彼此相互作用后，由于各个粒子所拥有的特性已综合成为整体性质，无法单独描述各个粒子的性质，只能描述整体系统的性质，则称这现象为量子缠结或量子纠缠（quantum entanglement）。量子纠缠是一种纯粹发生于量子系统的现象；在经典力学里，找不到类似的现象。】我一直不能理解量子纠缠理论的解释，为什么两个相距甚远的两个粒子发生量子纠缠现象，就会瞬间互相改变对方的状态？今天早晨，我有了新的理解！因为我觉得爱情可以用量子纠缠来解释，两个完全不相关的人，在某一点发生相遇，发生纠缠，产生了爱情，即使这两个人一个在火星，一个在地球，只要一个人心情发生变化，也会影响到另外一个人的心情，比如一个人像另一个人提出分手，即使距离很远，两个人的恋爱状态都在瞬间发生改变了！爱情的不确定性用量子物理学解释的很清楚，太诡异啦！ 3. 从量子纠缠态解释记忆记忆是个神奇的东西，虚虚实实，如薛定谔的猫，也就像处在不同态同时叠加的量子，确定了他的位置，就摸不到他的温度。 集体记忆更是个神奇的东西，大家一起构建，共同维护，却不一定就是真实的时间轨迹。物理学里面世界尺度小到原子级别以后，就会出现量子态，而相干的量子态之间，一定会纠缠。正如有关联的的两个人，记忆缠在一起，只能同时出现或消失，而无法分开。 最神奇的事情是，量子态被测量时，会坍缩。本来都有一定几率发生的叠加态，会坍缩到其中一个确定的态，而纠缠的量子之间，因为相干，而无法相互独立，故而测量会使得纠缠的所有量子态集体坍缩，如同集体记忆的共同丢失，变得诡异异常。 当一个群体的记忆发生变化时，一切都仿佛演化到了新的世界线，在那里，现状里看不清过去，过去的推演不到现在。如同被测量的量子态，并不在遵循因果律，因而也完全无法时间反演，要做的，只有重新建立原来的叠加态，然后二次测量。 假设我是一个眼睁睁地看着另一个量子态在测量中坍缩的（光或者原子）量子，我记得他坍缩前的样子，记得测量前发生的所有事情，我还和他是一个好朋友。目睹了这一切之后，脑子可能要炸了吧。 4. 诸葛大力对张伟的告白情书特斯拉穿过平面，编织成一个又一个韦伯 。 安倍冲过欧姆，寻找着法拉，充电到一个伏特，电键已断，我以库仑之名涌出，化为焦耳，为了你，烟消云散。我们知道，磁生电的其中一个方法为让闭合电路中的导体在磁场中做切割磁感线的运动。那么这个“平面”的理解即是其定义式：Φ=BS，即当平面与磁场方向不垂直时：Φ=BS⊥=BScosθ（θ为两个平面的二面角,即垂直于磁感线的平面），所以晚上老抢我被子的大力所说“平面”应该就指的是上文中物理意义上的抽象的平面。所以“特斯拉穿过平面，编织成一个又一个韦伯 ”整句的意思就是以电磁感应做一个开始，以电流作为主要人物贯穿整封情书。 5. 蚂蚁花呗，京东白条背后的真实利率惊人在网购支付时，经济不宽裕时我们常常选择分期付款，看似每个月支付的很少，其实背后的利率究竟有多吓人？？其计算方式究竟是怎样的？？我用两张图片来展示如何详细计算不同的平台对利息的叫法是不同的，比如阿里的手续费，京东的服务费等等，就是换了个壳子的叫法而已这是京东上面价值3899.00的iPhone8，可以看到其费率是1.00%（3899.001.00% = 38.99）即每期的利息相当于38.99元， 这里需要注意的是：不管你每月还了多少，每月利息不是按剩余未还本金计算，而是按照总共本金计算每月利息，总结起来都是这样的套路。假如我们选择`201.4124期`这一选项，我们来具体算算这些数字的得来吧 每月固定的利息为1.00%，其利息 = 本金 * 利率 （3899.00*1.00% = 38.99） 每月固定的偿还本金为：总金额/分期时限 （3899/24 = 162.46） 相加大约为38.99+162.46 = 201.45 （201.45 * 24 = 4834.8） 分期付款时，你的商品（手机）价格是一直贬值的，而你一直支付的该商品的原来价值，所以说资本家又会将这价值差拿来在钱生钱 比如上图这张图片，虽然没有明确标注出费率是多少，我们也可以计算出来，依旧选择24期分期，由图可知，其24期的手续费为14.36元： 商品价格 * 费率 = 每期固定利息 （14.36 / 2299 = 0.625%费率） 每月固定偿还的本金：总金额/分期时限 （2299/24 = 95.79） （95.79 + 14.36 = 110.15元） 可知在分期付款方面，白条的费率更高，更吓人呀！！ 至于真实的年化率怎么计算，直接在微信小程序IRR内部收益率计算器上输入计算得知 6. 英语佳句Diamonds and gold last for ever，and so will our love:宝石与金子能够永存，我们的爱也是！！ 7. 如何做一个优质的自媒体？做B站UP赚钱吗？对于B站，我是十分喜欢的，上面有很多的优质的视频资源，我认为它是“多元宇宙最好的APP”，旨在对标YouTube 【做B站up主赚钱吗? - 魔法纽扣的回答 - 知乎】我这里对于视频流量特别说明一哈：千万不要刷流量x3，也不要加互助群，因为平均有效观看时长被你弄得很低很低。系统算法会认为你的视频质量极低首先它很贵…比如说1万的播放量，B站近百元，爱奇艺16元，腾讯2元，优酷8元，乐视0.8元，秒拍、美拍1元。为什么贵这么多，因为B站一个IP一天算一个播放量，应该算是播放量最真实的一个视频网站了，所以我说B站潜力很大，像微博僵尸粉和机器人遍地走之后想变回来都不可能。这么贵的刷，会不会回本呢？ 永远不会，你刷一千播放量，是的，视频很快破千，然后你会发现它几乎就不动了。你在互助群和十几个小伙伴点来点去，然后视频就再也没什么赞了。为什么？因为平均有效观看时长被你弄得很低很低。系统算法会认为你的视频质量极低，一千个人都是点开来一秒钟就走，这个视频可能会被判定为标题党。no作no die 8.微商&amp;&amp;传销微商与传销本质都是割韭菜，找接盘侠。不同之处是微商有真实的商品，传销完完全全是虚空的，没有实际商品价值，纯粹收人头费，入会费！ 9.2019武汉新型冠状肺炎&amp;瑞德西韦2019年的武汉肺炎可谓闹的是沸沸扬扬，给全中国人民带来很大的不便和经济损失。美国的吉利德公司（HIV，流感，丙肝等）研发出了一款瑞德西韦药物，中国与吉利德公司于2月5号紧急签订协议，通常一款药物从研发到上市差不多要10年之久，流程十分复杂： 一期：安全性的试验 二期，三期：药物疗效对照试验。实验对象分为两组，实验组注射韦德西韦，对照组注射安慰剂。实验主要分为三个阶段：一盲（实验对象不知道自己注射的是那种试剂），双盲（实验对象，医生不知道试剂类别），三盲（实验对象，医生，实验结果统计专家都不知道） 上市阶段 拓展：对于某些疾病尚未有有效药物时，美国的“同情原则”==“中国的死马当活马医”，2月5号第一位病人注射了瑞德西韦，到4月底实验结束才能确定这种特效药究竟有没有作用","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"无名","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章七：js函数与构造函数","slug":"Javascript篇章七","date":"2020-01-21T16:00:00.000Z","updated":"2020-02-10T03:28:11.579Z","comments":true,"path":"2020/01/22/Javascript篇章七/","link":"","permalink":"https://ahrilove.top/2020/01/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%83/","excerpt":"函数: 就是可被重复调用执行的代码块。一般来说，一个函数是可以通过外部代码调用的一个“子程序”（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。 1.函数的创建方式2.关于变量作用域的说明3.js的构造函数4.python，js与java关于类和对象的理解","text":"函数: 就是可被重复调用执行的代码块。一般来说，一个函数是可以通过外部代码调用的一个“子程序”（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。 1.函数的创建方式2.关于变量作用域的说明3.js的构造函数4.python，js与java关于类和对象的理解 1.函数的创建方式方式一：函数声明/函数语句（推荐） 123function 函数名(参数1, 参数2, ... , 参数3) &#123; // 需要执行的代码块 &#125; 方式二：函数表达式 (function expression) 1var myFunction = function name([param1, param2, ... paramN)&#123;statements&#125; ps:在使用函数表达式时，注意以下几点 name:函数名，可以省略。当省略函数名的时候，该函数就成为了匿名函数。 param:传递给函数的参数的名称，一个函数最多可以有255个参数. statements:组成函数体的声明语句。 2.关于变量作用域的说明在JavaScript中，用var申明的变量实际上是有作用域的（局部变量：在函数中通过var声明的变量；全局变量：在函数外通过var声明的变量）变量按照作用域划分有局部变量和全局变量。对以下几点做出说明： 1.如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量 2.如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响 3.由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行:举例12345678'use strict';function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; 3.js的构造函数1,函数名首字母大写(不强制,味蕾和普通函数的区别)2,通过this来给对象添加属性和方法 123456789101112131415161718function Student(name,age,grender) &#123; // 添加属性 this.name = name; this.age = age; this.grender = grender; // 添加方法 this.sayHi = function()&#123; return name+\":\"+age+\":\"+grender &#125;&#125;// 使用构造函数来创建对象var student1 = new Student(\"chd\",18,\"man\");var student2 = new Student(\"lmm\",19,\"woman\");// 调用对象的属性和方法console.log(student1.name); // 调用属性：\"chd\"console.log(student1.sayHi()); // 调用方法：\"chd:18:man\" instanceof判断是否是实例对象，返回true或者false python，js与java关于类和对象的理解 Python的类和对象 123456789101112131415class 类名(object/父类): def __init__(self,参数1,参数2): self.对象的属性1 = 参数1 self.对象的属性2 = 参数2 def 方法名(self):pass def 方法名2(self):pass对象名 = 类名(实参1,实参2) #对象就是实例，代表一个具体的东西 #类名() : 类名+括号就是实例化一个类，相当于调用了__init__方法 #括号里传参数，参数不需要传self，其他与init中的形参一一对应 #结果返回一个对象对象名.对象的属性1 #查看对象的属性，直接用 对象名.属性名 即可对象名.方法名() #调用类中的方法，直接用 对象名.方法名() 即可 js的class类与对象 constructor 是一种用于创建和初始化class创建的对象的特殊方法(与js的构造函数用法相差无几)。 123456789101112131415class Polygon &#123; constructor(age) &#123; this.name = \"Polygon\"; this.age = age; this.demo = function()&#123; return this.name+\":\"+this.age &#125; &#125;&#125;const poly1 = new Polygon(18); console.log(poly1); // [object Object] console.log(poly1.demo()); // \"Polygon:18\" java的类与对象 123456789101112131415161718192021222324252627282930313233public class OOP &#123; public static void main(String[] args) &#123; // 在通过new操作符调用的时候，构造方法的参数数量、位置和类型一一对应 Person p = new Person(\"chd\",18,10086); System.out.println(p.getAge()); // 调用实例对象的属性 System.out.println(p.tel); System.out.println(p.getAge()); System.out.println(p.getName()); &#125;&#125;class Person &#123; // 这个不能省略，用以声明变量 private String name; private int age; public int tel; // 这就是Java的构造方法，类似于python的def __init__函数 public Person(String name, int age,int tel) &#123; this.name = name; this.age = age; this.tel = tel; &#125; public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125;&#125; 更新中。。。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ahrilove.top/tags/js/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"python的requirement.txt文件","slug":"Python全栈系列章节更新（十三）","date":"2020-01-21T16:00:00.000Z","updated":"2020-01-22T06:29:48.438Z","comments":true,"path":"2020/01/22/Python全栈系列章节更新（十三）/","link":"","permalink":"https://ahrilove.top/2020/01/22/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如 PHP 中使用 Composer 维护依赖一样，Python 也需要维护项目相关的依赖包。通常我们会在项目的根目录下放置一个 requirement.txt 文件，用于记录所有依赖包和它的确切版本号。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如 PHP 中使用 Composer 维护依赖一样，Python 也需要维护项目相关的依赖包。通常我们会在项目的根目录下放置一个 requirement.txt 文件，用于记录所有依赖包和它的确切版本号。 1.Python的依赖requirement.txt 的内容长这样： 12345678910111213alembic==1.0.10appnope==0.1.0astroid==2.2.5attrs==19.1.0backcall==0.1.0bcrypt==3.1.6bleach==3.1.0cffi==1.12.3Click==7.0decorator==4.4.0defusedxml==0.6.0entrypoints==0.3... 2.如何使用：那么 requirement.txt 究竟如何使用呢？当我们拿到一个项目时，首先要在项目运行环境安装 requirement.txt 所包含的依赖： script1pip install -r requirement.txt 当我们要把环境中的依赖写入 requirement.txt 中时，可以借助 freeze 命令： script1pip freeze &gt;requirements.txt 3.环境混用怎么办？在导出依赖到 requirement.txt 文件时会有一种尴尬的情况。你的本地环境不仅包含项目 A 所需要的依赖，也包含着项目 B 所需要的依赖。此时我们要如何做到只把项目 A 的依赖导出呢？ pipreqs 可以通过扫描项目目录，帮助我们仅生成当前项目的依赖清单。 通过以下命令安装： script1pip install pipreqs 运行： script1pipreqs ./","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"requirement.txt","slug":"requirement-txt","permalink":"https://ahrilove.top/tags/requirement-txt/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"html关于图片自适应大小的说明","slug":"html关于图片自适应大小的说明","date":"2020-01-19T16:00:00.000Z","updated":"2020-01-20T03:54:17.110Z","comments":true,"path":"2020/01/20/html关于图片自适应大小的说明/","link":"","permalink":"https://ahrilove.top/2020/01/20/html%E5%85%B3%E4%BA%8E%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AF%B4%E6%98%8E/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在div盒子中想要展示一张图片，我们可以使用style样式来设置width或者height中的某一项，即style=&quot;width:100px&quot;，这时另一项就会自适应变化,按比例变化。学习犹如逆水行舟，不进则退。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在div盒子中想要展示一张图片，我们可以使用style样式来设置width或者height中的某一项，即style=&quot;width:100px&quot;，这时另一项就会自适应变化,按比例变化。学习犹如逆水行舟，不进则退。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设置网页的整个背景图片时，我们可以在css中的使用background-size：100%来铺满整个页面，也可以设置为其它的百分比数值来局部铺HTML页面。 123456body&#123; background-image: url(\"../public/images/5927f2c7269aa.jpg\"); background-attachment: fixed; background-size: 100%;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在div盒子中想要展示一张图片，我们可以使用style样式来设置width或者height中的某一项，即style=&quot;width:100px&quot;，这时另一项就会自适应变化,按比例变化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我来举一个例子说明，也可以总结出一个公式，以后若固定了width或height中的某一项，另一项也就会求出来： 12&lt;a href=\"#\"&gt;&lt;img src=\"../public/images/5d5e5c7d1e1b8.jpg\" style=\"width: 100px\" /&gt;&lt;/a&gt;&lt;!--引入的图片的原分辨率为1920*1080--&gt; style=&quot;width: 100px&quot;：将引入的图片的宽度固定为100px；此时height就会自适应变化。由上图可知，图片已经自适应变化了，height:56.25px，这个数字是怎么得出来的？width:1920---&gt;100heidth:1080 ---&gt;56.25 &nbsp;&nbsp;&nbsp;因为：1080/(1920/100)=56.25px","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://ahrilove.top/tags/html/"},{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"sql查询大全补充","slug":"sql系列更新（四）","date":"2020-01-16T16:00:00.000Z","updated":"2020-01-17T06:01:25.492Z","comments":true,"path":"2020/01/17/sql系列更新（四）/","link":"","permalink":"https://ahrilove.top/2020/01/17/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"数据库是每一个IT工程师必备的技能树，而select往往是使用频率最大的，总结并补充之前有关于select查询的补充 本文要点：1.sql的执行顺序2.select+case…when…then语句3.select top语句4.where条件查询","text":"数据库是每一个IT工程师必备的技能树，而select往往是使用频率最大的，总结并补充之前有关于select查询的补充 本文要点：1.sql的执行顺序2.select+case…when…then语句3.select top语句4.where条件查询 1.sql的执行顺序下面展示一张sql的执行图：这里我们可以理解为：先执行from语句，获取表----&gt;然后在使用where过滤掉不相关的记录----&gt;再执行聚合函数或者group by分组----&gt;紧接着执行having进行二次过滤----&gt;最后执行sql的select语句 2.Select+case…when…then语句case…when…then语句，相当于编程语言中if判断 例1:根据IsUser字段查询学生是否在线12345select a.StudentID, (case a.IsUse when '0' then '未在线' when '1' then '在线' else '未上传' end) as 在线情况from StudentBindPaperTypeEntity as a 3.select top语句TOP 子句用于规定要返回的记录的数目。对于拥有数千条记录的大型表来说，TOP 子句是非常有用的。注释：并非所有的数据库系统都支持 TOP 子句(top仅适用于sql server)。 12345-- 例1.取出表中第几行数据（如第一行）select top 1 * from TABLE_NAME --例2.取出表中百分之多少数据select top 50 percent * from TABLE_NAME oracle语法:rownum 123SELECT column_name(s)FROM table_nameWHERE ROWNUM &lt;= number mysql语法：limit 123SELECT column_name(s)FROM table_nameLIMIT number 4.where条件查询","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"数据分析章节（三）：pandas","slug":"数据分析章节（三）","date":"2020-01-15T16:00:00.000Z","updated":"2020-01-16T05:58:57.995Z","comments":true,"path":"2020/01/16/数据分析章节（三）/","link":"","permalink":"https://ahrilove.top/2020/01/16/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pandas是Python的一个大数据处理模块。Pandas使用一个二维的数据结构DataFrame来表示表格式的数据，相比较于Numpy，Pandas可以存储混合的数据结构，同时使用NaN来表示缺失的数据，而不用像Numpy一样要手工处理缺失的数据，并且Pandas使用轴标签来表示行和列。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pandas是Python的一个大数据处理模块。Pandas使用一个二维的数据结构DataFrame来表示表格式的数据，相比较于Numpy，Pandas可以存储混合的数据结构，同时使用NaN来表示缺失的数据，而不用像Numpy一样要手工处理缺失的数据，并且Pandas使用轴标签来表示行和列。 pandas与numpy在数据处理前期阶段起着重要作用，两者相辅相成，异曲同工 1.Series一维数据Series是一种类似于一维数组的对象，由一组数据和一组与之相关的数据标签（索引）组成Series的字符串表现形式为：索引在左边，值在右边。如果没有为数据指定索引，于是会自动创建一个0到N-1(N为数据的长度)的整数型索引。可以通过Series的values和index属性获取其数组表现形式和索引对象： 123456789import numpy as npimport pandas as pda = pd.Series([1,2,3])\"\"\" a:左边为索引，右边为值0 11 22 3\"\"\" 1.1 传递带有日期时间索引和标签dates = pd.date_range(&#39;20190110&#39;,periods=6):period表示时间期间 1234&gt;&gt;&gt; datesDatetimeIndex([&apos;2020-01-10&apos;, &apos;2020-01-11&apos;, &apos;2020-01-12&apos;, &apos;2020-01-13&apos;, &apos;2020-01-14&apos;, &apos;2020-01-15&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;) 1.2 pandas的index指定索引目录123456789a1 = pd.Series([2, 3, 4, 5], index=['a', 'b', 'c', 'd'])\"\"\"&gt;&gt;&gt; a1a 2b 3c 4d 5dtype: int64\"\"\" 2.Series支持numpy的array特性 从ndarray创建Series 12345678910111213import pandas as pdimport numpy as np# np.array创建一维数组a2 = pd.Series(np.array([1,2,3,4]))# np.arrange(start,end,jiange)创建一维数组a3 = pd.Series(np.arange(1,9,2))\"\"\"a2:0 11 22 33 4dtype: int32\"\"\" 与标量的运算两个series运算,即索引值相对应的值相加减:a2 + a3 Series的索引:下角标从零开始(类似于数组的索引切片)b[0] :单个字符的索引b[[1,2,3]] :数组组合的索引所对应的具体值 切片操作(满足左闭右开，起始索引为0的原则)b[1:4] 通用函数（最大值，绝对值等） 12345678import pandas as pdimport numpy as npdata = 10c1 = pd.Series(np.linspace(-1,1,data))print(c1)print(c1.min())print(c1.max()) 3.从字典创建series 3.1 从字典创建series12345678910sr = pd.Series(&#123;'name': 'chd', 'age': 18, 'gender': 'man', 'capacity': 10,'is_love_girl':True&#125;)\"\"\"&gt;&gt;&gt; srname chdage 18gender mancapacity 10is_love_girl Truedtype: object\"\"\" 3.2.in运算：&#39;a&#39; in sr:只能判断键名是否在’pandas.core.series.Series’类中，不能判断values值 123print('name' in sr) # trueprint('age' in sr) # trueprint('love is unlimited' in sr) # false 3.3.遍历运算:只遍历打印值，不会打印键名123&gt;&gt;&gt; x = [i for i in sr]&gt;&gt;&gt; x[&apos;chd&apos;, 18, &apos;man&apos;, 10, True] 3.4.获取索引以及对应值12print(sr.index) # 获取索引print(sr.values) # 获取对应的值 3.5 整数索引问题：12str = pd.Series(np.arange(4.))print(str) 3.6 浅拷贝，a，b都指向内存地址，若其中一个修改值，则另一个也必会修改值12str2 = str[1:].copy()print(str2) series数据对齐，pandas在进行两个Series对象运算时，会按索引自动对齐然后运算若两series对象的index长度不一样，则会当做数据缺失值NaN处理 4.Series对象运算123sr1 = pd.Series([12, 23, 34, 34], index=['c', 'a', 'b', 'd'])sr2 = pd.Series([11, 20, 10], index=['a', 'b', 'c'])print(sr1 + sr2) 4.1 Series灵活算术方法123print(sr1.add(sr2,fill_value = 0))print(sr1.sub(sr2,fill_value = 0))print(sr1.div(sr2,fill_value = 0)) 4.2 缺失值处理方式： 缺失值处理方式一：过滤缺失数据str.dropna()：直接删除缺值的键值 123d = pd.Series(np.array([1, 3, 4., None, 8, None, 99]))print(d.dropna())print(d.isnull()) # 判断每一键值对是否缺失数据 缺失值处理方式二：填充缺失数据：str.fillna(填充值) print(d.fillna(1)) 缺失值处理方式三：不处理 提出NaN后求得平均值 print(d.mean()) 5.DataFrame二维数组对象DataFrame是一个表格式的数据结构，含有一组有序的列（即：好几列）。DataFrame可以被看做是由Series组成的字典，并且共用一个索引。 5.1 创建方式1：通过一个字典来创建123456789a = pd.DataFrame(&#123;'name': ['chd', 'zyq', 'fqt'], 'age': [18, 12, 15]&#125;)print(a)\"\"\"&gt;&gt;&gt;a 结果为 name age0 chd 181 zyq 122 fqt 15\"\"\" 5.2 index指定行索引12345&gt;&gt;&gt;pd.DataFrame(&#123;&apos;name&apos;: [&apos;chd&apos;, &apos;zyq&apos;, &apos;fqt&apos;], &apos;age&apos;: [18, 12, 15]&#125;,index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) name agea chd 18b zyq 12c fqt 15 5.3 创建方式二：用Series来组成字典123456&gt;&gt;&gt;pd.DataFrame(&#123;&apos;one&apos;:pd.Series([1,2,3],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]),&apos;two&apos;:pd.Series([5,6,7,8],index=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;])&#125;) one twoa 1.0 5b 2.0 6c 3.0 7d NaN 8 5.4 其它1234567891011121314151617181920212223242526272829303132333435363738# CSV文件的读写# CSV文件的写入print(a2.to_csv('demo.csv'))# CSV文件的读取print(pd.read_csv('demo.csv'))# json数据的读取和存储df = pd.read_json('demo2.json')# 读取时可能乱序，需要对索引进行重新排序df = df.sort_index()print(df)# 存储为json数据df.to_json('out.json')# Excel数据的读取df_excel = pd.read_excel('inputs.xlsx')# Excel的存储:需要用到openpyxl库# sheet_name：设置工作表名，indexA=None不存储行索引df_excel.to_excel('biao_name.xlsx',sheet_name='biao_name',index = None)# DataFrame常用属性# var.index获取行索引print(a2.index)# var.columns:获取列索引print(a2.columns)# values 获取取值数组（一般是二维数组）print(a2.values)# T:装置print(a2.T)# descriibe():获取统计数据print(a2.describe())","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://ahrilove.top/tags/pandas/"}]},{"title":"Javascript篇章六：js的数值保留指定有效位数","slug":"Javascript篇章六","date":"2020-01-14T16:00:00.000Z","updated":"2020-01-15T07:33:04.107Z","comments":true,"path":"2020/01/15/Javascript篇章六/","link":"","permalink":"https://ahrilove.top/2020/01/15/Javascript%E7%AF%87%E7%AB%A0%E5%85%AD/","excerpt":"在做数据分析处理时，往往会遇到float或double这类的数据，我们往往应要求会保留指定的小数点后位数","text":"在做数据分析处理时，往往会遇到float或double这类的数据，我们往往应要求会保留指定的小数点后位数 1.四舍五入相关 toFixed(number):保留指定小数位数，将数值类型转换为字符串类型 12345// 1.四舍五入var num =2.446242342; num = num.toFixed(2); console.log(num); //2.45console.log(typeof num); // string Math.floor()，不四舍五入，向下取整,不改变数据类型 1234// 2.不四舍五入 向下取整num = Math.floor(num * 100) / 100;console.log(num); //2.44console.log(typeof num); // number 字符串匹配注意，先将数据转换为字符串，最后再转为数值类型 1234// 3.不四舍五入 字符串匹配再转换num = Number(num.toString().match(/^\\d+(?:\\.\\d&#123;0,2&#125;)?/));console.log(num); //2.44console.log(typeof num); // number 四舍五入保留2位小数（若第二位小数为0，则保留一位小数） 12345678910111213//4.四舍五入保留2位小数（若第二位小数为0，则保留一位小数） function keepTwoDecimal(num) &#123; var result = parseFloat(num); if (isNaN(result)) &#123; alert('传递参数错误，请检查！'); return false; &#125; result = Math.round(num * 100) / 100; return result; &#125; keepTwoDecimal(num); console.log(num); //2.44 console.log(typeof num); //number 四舍五入保留2位小数（不够位数，则用0替补）注意，数据类型变为字符串类型 123456789101112131415161718192021222324252627282930//5.四舍五入保留2位小数（不够位数，则用0替补） function keepTwoDecimalFull(num) &#123; var result = parseFloat(num); if (isNaN(result)) &#123; alert('传递参数错误，请检查！'); return false; &#125; result = Math.round(num * 100) / 100; var s_x = result.toString(); //将数字转换为字符串 var pos_decimal = s_x.indexOf('.'); //小数点的索引值 // 当整数时，pos_decimal=-1 自动补0 if (pos_decimal &lt; 0) &#123; pos_decimal = s_x.length; s_x += '.'; &#125; // 当数字的长度&lt; 小数点索引+2时，补0 while (s_x.length &lt;= pos_decimal + 2) &#123; s_x += '0'; &#125; return s_x; &#125; console.log(keepTwoDecimalFull(120.5)); //120.50 console.log(typeof keepTwoDecimalFull(120.5)); //string console.log(keepTwoDecimalFull(2.446242342)); //2.45 console.log(typeof keepTwoDecimalFull(2.446242342)); //string 2.浮点数保留两位小数 将浮点数四舍五入，取小数点后2位(数据类型不变) 123456789101112//浮点数保留两位小数 //1.功能：将浮点数四舍五入，取小数点后2位 function toDecimal(x) &#123; var f = parseFloat(x); if (isNaN(f)) &#123; return; &#125; f = Math.round(x*100)/100; return f; &#125; console.log(toDecimal(3.1465926)); // 3.15 console.log(typeof toDecimal(3.1415926)); //number 强制保留2位小数，如：2，会在2后面补上00.即2.00注意，数据类型变为字符串类型 1234567891011121314151617181920//2.强制保留2位小数，如：2，会在2后面补上00.即2.00 function toDecimal2(x) &#123; var f = parseFloat(x); if (isNaN(f)) &#123; return false; &#125; var f = Math.round(x*100)/100; var s = f.toString(); var rs = s.indexOf('.'); if (rs &lt; 0) &#123; rs = s.length; s += '.'; &#125; while (s.length &lt;= rs + 2) &#123; s += '0'; &#125; return s; &#125; console.log(toDecimal2(3.1)); // 3.10console.log(typeof toDecimal2(3.1415926)); //string 保留两位小数 浮点数四舍五入 位数不够 不补0注意，数据类型不变 123456// 3.保留两位小数 浮点数四舍五入 位数不够 不补0function fomatFloat(src,pos)&#123; return Math.round(src*Math.pow(10, pos))/Math.pow(10, pos); &#125; console.log(fomatFloat(3.12645,2)); // 3.13console.log(typeof fomatFloat(3.1415926)); //number","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ahrilove.top/tags/js/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"union和union all（联合查询）","slug":"sql系列更新（三）","date":"2020-01-13T16:00:00.000Z","updated":"2020-01-15T09:12:07.891Z","comments":true,"path":"2020/01/14/sql系列更新（三）/","link":"","permalink":"https://ahrilove.top/2020/01/14/sql%E7%B3%BB%E5%88%97%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。","text":"如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。 1.基础概念union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； Union All：对两个结果集进行并集操作，包括重复行，不进行排序； Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序； Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。 注意的是：UNION 、UNION ALL内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 2.使用方法基本语法： union：123select employee_id,job_id from employees union select employee_id,job_id from job_history union all：123select employee_id,job_id from employees union allselect employee_id,job_id from job_history 3.FAQ 1.union 和 union all都可以将多个结果集合并，而不仅仅是两个，你可以将多个结果集串起来。 2.使用union和union all必须保证各个select 集合的结果有相同个数的列，并且每个列的类型是一样的。但列名则不一定需要相同，oracle会将第一个结果的列名作为结果集的列名。例如下面是一个例子： 123select empno,ename from emp union select deptno,dname from dept 3.没有必要在每一个select结果集中使用order by子句来进行排序，我们可以在最后使用一条order by来对整个结果进行排序。例如： 1234select empno,ename from emp union select deptno,dname from dept order by ename;","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"},{"name":"union","slug":"union","permalink":"https://ahrilove.top/tags/union/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"GNE v0.1 正式发布： 4 行代码开发新闻网站通用爬虫","slug":"Python全栈系列章节更新（十二）","date":"2020-01-11T16:00:00.000Z","updated":"2020-01-12T08:01:06.080Z","comments":true,"path":"2020/01/12/Python全栈系列章节更新（十二）/","link":"","permalink":"https://ahrilove.top/2020/01/12/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/","excerpt":"GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。","text":"GNE（GeneralNewsExtractor）是一个通用新闻网站正文抽取模块，输入一篇新闻网页的 HTML， 输出正文内容、标题、作者、发布时间、正文中的图片地址和正文所在的标签源代码。GNE在提取今日头条、网易新闻、游民星空、 观察者网、凤凰网、腾讯新闻、ReadHub、新浪新闻等数百个中文新闻网站上效果非常出色，几乎能够达到100%的准确率。 1.简单使用方式GNE的输入是经过js渲染后的HTML代码，所以GNE往往需要配合selenium或Pyppeteer 使用。安装GNE：pip install gne使用简单案例： 12345from gne import GeneralNewsExtractorextractor = GeneralNewsExtractor()html = '网站源代码'result = extractor.extract(html)print(result) GNE配合selenium实现的一个小demo 12345678910import timefrom gne import GeneralNewsExtractorfrom selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.toutiao.com/a6766986211736158727/')time.sleep(3)extractor = GeneralNewsExtractor()result = extractor.extract(browser.page_source)print(result) 2.功能特性2.1 获取正文源代码在extract()方法只传入网页源代码，不添加任何额外参数时，GNE 返回如下字段： title：新闻标题 publish_time：新闻发布时间 author：新闻作者 content：新闻正文 images: 正文中的图片（相对路径或者绝对路径） 可能有些朋友希望获取新闻正文所在标签的源代码，此时可以给extract()方法传入with_body_html参数，设置为 True： 12extractor = GeneralNewsExtractor()extractor.extract(html, with_body_html=True) 返回数据中将会增加一个字段body_html，它的值就是正文对应的 HTML 源代码。 运行效果如下图所示： 2.2 总是返回图片的绝对路径默认情况下，如果新闻中的图片使用的是相对路径，那么 GNE 返回的images字段对应的值也是图片相对路径的列表。 如果你想始终让 GNE 返回绝对路径，那么你可以给extract()方法增加host参数，这个参数的值是图片的域名，例如： 12extractor = GeneralNewsExtractor()extractor.extract(html, host='https://AhriLove.top') 这样，如果新闻中的图片是/images/pic.png，那么 GNE 返回时会自动把它变为https://AhriLove.top/images/pic.png。 2.3 指定新闻标题所在的 XPathGNE 预定义了一组 XPath 和正则表达式用于提取新闻的标题。但某些特殊的新闻网站可能无法提取标题，此时，你可以给extract()方法指定title_xpath参数，用于提取新闻标题： 12extractor = GeneralNewsExtractor()extractor.extract(html, title_xpath='//title/text()') 2.4 提前移除噪声标签某些新闻下面可能会存在长篇大论的评论，这些评论看起来比新闻正文“更像”正文，为了防止他们干扰新闻的提取，可以通过给extract()方法传入noise_node_list参数，提前把这些噪声节点移除。noise_node_list的值是一个列表，里面是一个或多个 XPath： 12extractor = GeneralNewsExtractor()extractor.extract(html, noise_node_list=['//div[@class=\"comment-list\"]', '//*[@style=\"display:none\"]']) 2.5使用配置文件API 中的参数 title_xpath、 host、 noise_node_list、 with_body_html除了直接写到 extract() 方法中外，还可以通过一个配置文件来设置。请在项目的根目录创建一个文件 .gne，配置文件可以用 YAML 格式，也可以使用 JSON 格式。 YAML格式配置文件1234567title: xpath: //title/text()host: https://www.xxx.comnoise_node_list: - //div[@class=\\\"comment-list\\\"] - //*[@style=\\\"display:none\\\"]with_body_html: true json格式配置文件（习惯性用json）123456789&#123; \"title\": &#123; \"xpath\": \"//title/text()\" &#125;, \"host\": \"https://www.xxx.com\", \"noise_node_list\": [\"//div[@class=\\\"comment-list\\\"]\", \"//*[@style=\\\"display:none\\\"]\"], \"with_body_html\": true&#125; 3.FAQGeneralNewsExtractor(以下简称GNE)是爬虫吗？GNE不是爬虫，它的项目名称General News Extractor表示通用新闻抽取器。它的输入是HTML，输出是一个包含新闻标题，新闻正文，作者，发布时间的字典。你需要自行设法获取目标网页的HTML。 GNE 现在不会，将来也不会提供请求网页的功能。 GNE支持翻页吗？GNE不支持翻页。因为GNE不会提供网页请求的功能，所以你需要自行获取每一页的HTML，并分别传递给GNE。 GNE支持哪些版本的Python？不小于Python 3.6.0 我用requests/Scrapy获取的HTML传入GNE，为什么不能提取正文？GNE是基于HTML来提取正文的，所以传入的HTML一定要是经过JavaScript渲染以后的HTML。而requests和Scrapy获取的只是JavaScript渲染之前的源代码，所以无法正确提取。 另外，有一些网页，例如今日头条，它的新闻正文实际上是以JSON格式直接写在网页源代码的，当页面在浏览器上面打开的时候，JavaScript把源代码里面的正文解析为HTML。这种情况下，你在Chrome上面就看不到Ajax请求。 所以建议你使用Puppeteer/Pyppeteer/Selenium之类的工具获取经过渲染的HTML再传入GNE。 GNE 支持非新闻类网站吗（例如博客、论坛……）不支持。 4.关于 GNEGNE 官方文档：https://generalnewsextractor.readthedocs.io/ GNE 的项目源代码在：https://github.com/kingname/GeneralNewsExtractor。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"re","slug":"re","permalink":"https://ahrilove.top/tags/re/"},{"name":"GNE","slug":"GNE","permalink":"https://ahrilove.top/tags/GNE/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（十一）：某openLaw网站","slug":"Python全栈系列章节更新（十一）","date":"2020-01-10T16:00:00.000Z","updated":"2020-01-11T06:25:48.869Z","comments":true,"path":"2020/01/11/Python全栈系列章节更新（十一）/","link":"","permalink":"https://ahrilove.top/2020/01/11/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/","excerpt":"目标网站：某openLaw裁判文书反爬机制：js逆向爬虫，密码加密相关技术：js逆向爬虫技术难度：★★★☆☆☆爬取目标：模拟登录官网，抓取相关裁判文书源代码：https://github.com/FioraLove/Python/tree/master/js%E9%80%86%E5%90%91%E7%88%AC%E8%99%AB/openLaw%E7%BD%91%E7%AB%99说明：先get请求，正则获取csrf，在post携带账号密码来模拟登录","text":"目标网站：某openLaw裁判文书反爬机制：js逆向爬虫，密码加密相关技术：js逆向爬虫技术难度：★★★☆☆☆爬取目标：模拟登录官网，抓取相关裁判文书源代码：https://github.com/FioraLove/Python/tree/master/js%E9%80%86%E5%90%91%E7%88%AC%E8%99%AB/openLaw%E7%BD%91%E7%AB%99说明：先get请求，正则获取csrf，在post携带账号密码来模拟登录 1.解析思路： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照常规步骤进行抓包：输入错误的账号密码，找到post/get请求地址---&gt;看请求表单数据是否加密---&gt;全局搜索加密关键字---&gt;找到与之相关联的js加密函数，扣出js代码这里我们可以看到，有四个参数，其中_csrf是未知的，password是经过加密的，其余两个字段是很简单的。 2. _csrf关键字我们先全局搜索一下，可以找到_csrf其实就在网页中，是在网页中生成的，所以我们就需要抓取“login.jsp?$=deny”这个数据包,这里是get请求 1234567891011121314151617import re,requests# 先请求一次网页，获取页面中的csrfdef get_csrf(): try: csrfUrl = \"http://openlaw.cn/login.jsp?$=deny\" session = requests.session() response = session.get(csrfUrl, headers=headers, timeout=5) if (response.status_code == 200): # 编译正则表达式，带上re.S pattern = re.compile('name=\"_csrf\" value=\"(.*?)\"/&gt;', re.S) # findall是将返回结果以元组型列表 result = re.findall(pattern, response.text) return result except Exception as e: print(e) 拓展：我第一次写的时候就出现了如下的错误提示，其实是re.S在使用compile编译时没有编译到,以后要注意这点 在爬取网页数据时， 12p=re.compile('&lt;div class=\"card-title\"&gt;(.*?)&lt;/div&gt;')data=re.findall(p,html.text,re.S) 出现错误：ValueError: Cannot process flags argument with a compiled pattern原因：如果re.findall() 中有flags项，如re.S(正则中‘.’代表在每行中的任意字符，每一行遇到换行符‘\\n’结束，re.S作用是将‘\\n’当成是普通字符，这样就把整个html文档看成了一个字符串。正确写法： 12p=re.compile('&lt;div class=\"card-title\"&gt;(.*?)&lt;/div&gt;',re.S)data=re.findall(p,html.text) 3.password加密依旧全局搜索这个关键字，找到password这个关键字，发现这个generateEncryptPassword(生成加密密码)很可疑，最终输出加密密码的函数其实是keyEncrypt函数 123456789101112131415161718192021222324252627282930313233343536373839404142var $publicKey = '-----BEGIN PUBLIC KEY-----\\n\\MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0zI8aibR9ZN57QObFxvI\\n\\wiRTmELItVVBLMrLd71ZqakR6oWUKkcAGgmxad2TCy3UeRe4A0Dduw97oXlbl5rK\\n\\RGISzpLO8iMSYtsim5aXZX9SB5x3S9ees4CZ6MYD/4XQOTrU0r1TMT6wXlhVvwNb\\n\\fMNYHm3vkY0rhfxBCVPFJoHjAGDFWNCAhf4KfalfvWsGL32p8N/exG2S4yXVHuV6\\n\\cHDyFJAItKVmyuTmB62pnPs5KvNv6oPmtmhMxxsvBOyh7uLwB5TonxtZpWZ3A1wf\\n\\43ByuU7F3qGnFqL0GeG/JuK+ZR40LARyevHy9OZ5pMa0Nwqb8PwfK810Bc8PxD8N\\n\\EwIDAQAB\\n\\-----END PUBLIC KEY-----\\n\\';var encryptPassChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz*&amp;-%/!?*+=()\";var rsaEncrypt = new JSEncrypt();rsaEncrypt.setPublicKey($publicKey);var keyEncrypt = function(data) &#123; var passPhrase = generateEncryptPassword(32); var iv = CryptoJS.lib.WordArray.random(128 / 8).toString(CryptoJS.enc.Hex); var salt = CryptoJS.lib.WordArray.random(128 / 8).toString(CryptoJS.enc.Hex); var key = CryptoJS.PBKDF2(passPhrase, CryptoJS.enc.Hex.parse(salt), &#123; keySize: 128 / 32, iterations: 1000 &#125;); var aesEncrypted = CryptoJS.AES.encrypt(data, key, &#123; iv: CryptoJS.enc.Hex.parse(iv) &#125;); var aesKey = passPhrase + \":::\" + salt + \":::\" + aesEncrypted.iv; var encryptedMessage = aesEncrypted.ciphertext.toString(CryptoJS.enc.Base64); var encryptedKey = rsaEncrypt.encrypt(aesKey); var encrypted = encryptedKey + \":::\" + encryptedMessage; return encrypted;&#125;;var generateEncryptPassword = function(length) &#123; var randomstring = ''; for (var i = 0; i &lt; length; i++) &#123; var rnum = Math.floor(Math.random() * encryptPassChars.length); randomstring += encryptPassChars.substring(rnum, rnum + 1); &#125; return randomstring;&#125;; 4.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import reimport requestsimport execjs# 请求登录urlurl = \"http://openlaw.cn/login\"# 构造请求头headers = &#123; \"Origin\": \"http://openlaw.cn\", \"Referer\": \"http://openlaw.cn/login.jsp\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36\"&#125;# 先请求一次网页，获取页面中的csrfdef get_csrf(): try: csrfUrl = \"http://openlaw.cn/login.jsp?$=deny\" session = requests.session() response = session.get(csrfUrl, headers=headers, timeout=5) if (response.status_code == 200): pattern = re.compile('name=\"_csrf\" value=\"(.*?)\"/&gt;', re.S) result = re.findall(pattern, response.text) return result except Exception as e: print(e)def get_pwd(): with open('main.js', 'r', encoding='utf-8') as f: js_code = f.read() # 编译js函数 ctx = execjs.compile(js_code) # 执行js中的getPassword函数，参数为password result = ctx.call('getPassword', 'a123456') return result# 第二次post请求模拟登录openLaw网站def login(): data = &#123; \"_csrf\": (get_csrf())[0], \"username\": \"badwoman\", \"password\": get_pwd(), \"_spring_security_remember_me\": \"true\" &#125; try: # 模拟登录openLaw response = requests.post(url=url, headers=headers, data=data, timeout=5) if (response.status_code == 200): return response.text return None except Exception as e: print(e)if __name__ == '__main__': login()","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"re","slug":"re","permalink":"https://ahrilove.top/tags/re/"},{"name":"js逆向","slug":"js逆向","permalink":"https://ahrilove.top/tags/js%E9%80%86%E5%90%91/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（十）：headers处理小脚本","slug":"Python全栈系列章节更新（十）","date":"2020-01-06T16:00:00.000Z","updated":"2020-01-07T03:17:48.974Z","comments":true,"path":"2020/01/07/Python全栈系列章节更新（十）/","link":"","permalink":"https://ahrilove.top/2020/01/07/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%8D%81%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在写python爬虫脚本时，常常需要处理请求头headers，将其转换为字典格式，如果一个个的加单双引号，往往很费劲，所以我们可以借用正则表达式，直接将其替换掉。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在写python爬虫脚本时，常常需要处理请求头headers，将其转换为字典格式，如果一个个的加单双引号，往往很费劲，所以我们可以借用正则表达式，直接将其替换掉。 1.python字典与js的对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，我懵了，最近有点迷糊，刚刚说起字典（值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。），这就可以联想到js的对象写法 12# 字典dicts = &#123;'Alice': '2341', 9527: '9102', (2,3): '3258'&#125; js的对象提供多个内建对象，比如 Object、String、Date、Array,Number,Function 等等 1234567let obj = &#123; name : \"xiaoming\", age : 18, show : function (girlfriend) &#123; console.log(this.name + \"的女朋友是\" + girlfriend); &#125;&#125;; headers字符串处理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从chrome里面的截取到的headers往往是需要我们二次处理的，而我一般喜欢加双引号，构造成json格式，一劳永逸。源代码： 123456789101112import reheaders_str = \"\"\"sec-fetch-mode: navigatesec-fetch-site: same-originsec-fetch-user: ?1upgrade-insecure-requests: 1user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36\"\"\"pattern = re.compile(\"^(.*?): (.*)$\")for line in headers_str.splitlines(): print(re.sub(pattern, \"\\\"\\\\1\\\": \\\"\\\\2\\\",\", line)) 这里的headers_str存放我们的目标headers字符串，运行结果为： 12345&quot;sec-fetch-mode&quot;: &quot;navigate&quot;,&quot;sec-fetch-site&quot;: &quot;same-origin&quot;,&quot;sec-fetch-user&quot;: &quot;?1&quot;,&quot;upgrade-insecure-requests&quot;: &quot;1&quot;,&quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36&quot;","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"re","slug":"re","permalink":"https://ahrilove.top/tags/re/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"数据分析章节（二）：matplotlib","slug":"数据分析章节（二）","date":"2020-01-01T16:00:00.000Z","updated":"2020-01-02T08:34:13.126Z","comments":true,"path":"2020/01/02/数据分析章节（二）/","link":"","permalink":"https://ahrilove.top/2020/01/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。！ 本文要点：struct模块科学运算基本三大库Matplotlib图形","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。！ 本文要点：struct模块科学运算基本三大库Matplotlib图形 1.import struct库1.1 struct模块: 在Python中，『一切皆对象』，基本数据类型也不列外C语言的数组int a[3] = {1, 2, 4};存储的是真正的值Python的列表list = [1, 2, 4]，存储的是元素的指针 1.2 pack(),unpack()函数: struct模块最重要的两个函数就是pack()、unpack()方法：打包函数：pack(fmt, v1, v2, v3, …)；解包函数：unpack(fmt, buffer)，其中，fmt是格式字符（format的谐音），struct模块支持的格式化字符如下表 2.matplotlib库&nbsp;&nbsp;&nbsp;&nbsp;在python的matplotlib库中分别可用bar、barh、plot函数来构建它们，再使用xticks与yticks（设置坐标轴刻度）、xlabel与ylabel（设置坐标轴标签）、title（标题）、legend（图例）、xlim与ylim（设置坐标轴数据范围）、grid（设置网格线）等命令来装饰图形 2.1导入库文件&nbsp;&nbsp;&nbsp;&nbsp;from matplotlib import pyplot as plt&nbsp;&nbsp;&nbsp;&nbsp;import numpy as np 2.2 简单figure图像生成案例：123456789101112131415161718192021# 使用import导入模块matplotlib.pyplot，并简写成plt 使用import导入模块numpy，并简写成npfrom matplotlib import pyplot as pltimport numpy as npimport matplotlib# 使用np.linspace定义x：范围是(-1,1);个数是50x = np.linspace(-1, 1, 50)# 函数y=x^3y = x ** 3y1 = x ** 2# 使用plt.figure定义一个图像窗口.num代表图像窗口编号，figsize表示窗口大小plt.figure(num=3, figsize=(8, 5), )# 使用plt.plot画(x ,y1)曲线，曲线的颜色属性(color)为红色;# 曲线的宽度(linewidth)为1.0；曲线的类型(linestyle)为虚线. 使用plt.show显示图像plt.plot(x, y1, color='red', linewidth='1.0', linestyle='--')# 使用plt.plot画(x ,y1)曲线.plt.plot(x, y)# 展示绘制图像plt.show() 2.3坐标轴以及line： 设置坐标轴不同的名字、刻度以及范围： 1234567891011121314151617# 使用plt.xlim设置x坐标轴范围：(-2, 2)plt.xlim((-2,2))# 使用plt.ylim设置x坐标轴范围：(-2, 2)plt.ylim((-2,2))# 定义x轴名称plt.xlabel('x轴')# 定义y轴名称plt.ylabel('y轴')new_ticks = np.linspace(-2, 2, 5)print(new_ticks)# 使用plt.xticks设置x轴刻度：范围是(-2,2);个数是8.plt.xticks(new_ticks)# 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]# 对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]plt.yticks([-2, -1.8, -1, 1.22, 2],[r'$really\\ bad$', r'$bad$', r'$normal$', r'$good$', r'$really\\ good$']) 坐标轴移至中心： 12345678910111213\"\"\"plt.gca获取当前坐标轴信息. 使用.spines设置边框；使用.set_color设置边框颜色\"\"\"# 坐标轴中移：ax = plt.gca()# 隐藏上边和右边ax.spines['top'].set_color('none')ax.spines['right'].set_color('none')# 移动另外两个轴ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data', 0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0)) 图例legend 123456# set line sylesl1, = plt.plot(x, y1, label='linear line')l2, = plt.plot(x, y2, color='red', linewidth=1.0, linestyle='--', label='square line')# legend将要显示的信息来自于上面代码中的 label(表示图例的名称). 所以我们只需要简单写下一下代码, plt 就能自动的为我们添加图例.# 图例展示plt.legend(loc='upper right') # loc属性表示图例放置位置：upper，right，bottom，left annotate标注 123456789101112# 标注具体某点x0 = 0.5y0 = x0**2plt.plot([x0, x0,], [0, y0,], 'k--', linewidth=2.5)# set dot stylesplt.scatter([x0, ], [y0, ], s=50, color='b')# 注释annotate，对(x0,y0)这个点进行标注plt.annotate(r'$x**2=%s$' % x0, xy=(x0, y0), xycoords='data', xytext=(+10, -10), # xytext=(+10, -10) 和 textcoords='offset points' 对于标注位置的描述 和 xy 偏差值 textcoords='offset points', fontsize=10, arrowprops=dict(arrowstyle='-&gt;', connectionstyle=\"arc3,rad=.2\")) matplotlib的颜色及线条控制（linestyle，color） linestyle: 12345&apos;-&apos; solid line style&apos;--&apos; dashed line style&apos;-.&apos; dash-dot line style&apos;:&apos; dotted line styl color:【参考此篇文章】 多图分区展示 语法格式：subplot(a,b,c)表示a行，b列，第c个图像区域 12345678910111213141516171819202122232425262728from matplotlib import pyplot as pltimport numpy as np# 规则图形：# 创建一个图形窗口plt.figure()# subplot(m,n,x):代表创建m*n个小图，x代表第i个图plt.subplot(2, 2, 1)# 绘制折线图x = [1, 2, 3, 4, 5, 6]y = [3, 5, 7, 8, 1, 2]plt.plot(x, y)# plt.subplot(2,2,2)表示将整个图像窗口分为2行2列, 当前位置为2plt.subplot(2, 2, 2)data = np.arange(1, 4, .25)plt.scatter(data, data)# plt.subplot(2,2,3)表示将整个图像窗口分为2行2列,当前位置为3plt.subplot(223)plt.plot([0, 1], [0, 3])# plt.subplot(2,2,4)表示将整个图像窗口分为2行2列,当前位置为4plt.subplot(2, 2, 4)plt.plot([0, 1], [3, 3])plt.show() plt.text()给图形添加数据标签 123456789101112131415161718import matplotlib.pyplot as pltimport numpy as np#创建带数字标签的直方图numbers = list(range(1,11))#np.array()将列表转换为存储单一数据类型的多维数组x = np.array(numbers)y = np.array([a**2 for a in numbers])plt.bar(x,y,width=0.5,align='center',color='c')plt.title('Square Numbers',fontsize=24)plt.xlabel('Value',fontsize=14)plt.ylabel('Square of Value',fontsize=14)plt.tick_params(axis='both',labelsize=14)plt.axis([0,11,0,110])for a,b in zip(x,y): # 用%.2f保留两位小数，横向居中对齐ha='center'，纵向底部（顶部）对齐va='bottom' plt.text(a,b+0.1,'%.2f'%b,ha = 'center',va = 'bottom',fontsize=7)plt.savefig('images\\squares.png')plt.show() &nbsp;&nbsp;&nbsp;&nbsp;首先，前边设置的x、y值其实就代表了不同柱子在图形中的位置（坐标），通过for循环找到每一个x、y值的相应坐标——a、b，再使用plt.text在对应位置添文字说明来生成相应的数字标签，而for循环也保证了每一个柱子都有标签。其中，a+0.5, b+0.05(表示位置高度)表示在每一柱子对应x值、y值上方0.05处标注文字说明，&#39;%.2f’ % b,代表标注的文字，即每个柱子对应的y值，其中0表示不显示小数后面的数值，1就表示显示小数后面一位，以此类推； ha=’center’, va= ‘bottom’代表horizontalalignment（水平对齐）、verticalalignment（垂直对齐）的方式，fontsize则是文字大小。条形图、折线图也是如此设置，饼图则在pie命令中有数据标签的对应参数。对于累积柱状图、双轴柱状图则需要用两个for循环，同时通过a与b的不同加减来设置数据标签位置。 3.图形未完待续： -3.1 散点图 -3.2 柱形图","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://ahrilove.top/tags/numpy/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://ahrilove.top/tags/matplotlib/"}]},{"title":"Python全栈系列章节更新（九）：极验滑动二维码","slug":"Python全栈系列章节更新（九）","date":"2019-12-29T16:00:00.000Z","updated":"2019-12-30T03:04:07.281Z","comments":true,"path":"2019/12/30/Python全栈系列章节更新（九）/","link":"","permalink":"https://ahrilove.top/2019/12/30/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B9%9D%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：极验官网 哔哩哔哩反爬机制：极验滑动3.0版本相关技术：selenium技术难度：★★☆☆☆☆爬取目标：模拟登录官网，破解滑动二维码源代码：本页面说明：找到相关节点DOM，其他网站则可复用此源代码","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：极验官网 哔哩哔哩反爬机制：极验滑动3.0版本相关技术：selenium技术难度：★★☆☆☆☆爬取目标：模拟登录官网，破解滑动二维码源代码：本页面说明：找到相关节点DOM，其他网站则可复用此源代码 1.识别思路目标网站：哔哩哔哩动画&nbsp;&nbsp;&nbsp;但是对于应用了极验验证码的网站，识别并不是没有办法的。如果我们直接模拟表单提交的话，加密参数的构造是个问题，参数构造有问题服务端就会校验失败，所以在这里我们采用直接模拟浏览器动作的方式来完成验证，在 Python 中我们就可以使用 Selenium 来通过完全模拟人的行为的方式来完成验证，此验证成本相对于直接去识别加密算法容易不少。 模拟登录，找到入口url 模拟点击验证按钮 识别滑动缺口的位置 模拟拖动滑块&nbsp;&nbsp;&nbsp;&nbsp;可以看到缺口的四周边缘有明显的断裂边缘，而且边缘和边缘周围有明显的区别，我们可以实现一个边缘检测算法来找出缺口的位置。对于极验来说，我们可以利用和原图对比检测的方式来识别缺口的位置，因为在没有滑动滑块之前，缺口其实是没有呈现的.&nbsp;&nbsp;&nbsp;&nbsp;所以我们可以同时获取两张图片，设定一个对比阈值，然后遍历两张图片找出相同位置像素 RGB 差距超过此阈值的像素点位置，那么此位置就是缺口的位置。&nbsp;&nbsp;&nbsp;&nbsp;第四步操作看似简单，但是其中的坑比较多，极验验证码增加了机器轨迹识别，匀速移动、随机速度移动等方法都是不行的，只有完全模拟人的移动轨迹才可以通过验证，而人的移动轨迹一般是先加速后减速的，这又涉及到物理学中加速度的相关问题，我们需要模拟这个过程才能成功。2.初始化&nbsp;&nbsp;&nbsp;&nbsp;首先这次我们选定的链接为：https://account.geetest.com/login，也就是极验的管理后台登录页面，在这里我们首先初始化一些配置，如 Selenium 对象的初始化及一些参数的配置：123456789101112# 极验账号EMAIL = 'test@test.com'# 极验密码PASSWORD = '123456' class CrackGeetest(): def __init__(self): self.url = 'https://account.geetest.com/login' self.browser = webdriver.Chrome() self.wait = WebDriverWait(self.browser, 20) self.email = EMAIL self.password = PASSWORD 3.模拟点击随后我们需要实现第一步的操作，也就是模拟点击初始的验证按钮，弹出滑动二维码，所以我们定义一个方法来获取这个按钮，利用显式等待的方法来实现： 12345678def get_geetest_button(self): \"\"\" 获取初始验证按钮（点击就会弹出验证码滑块，这一步按实际情况出发， 有些验证码滑块是直接存在，不用再点击一次来触发生成滑块） :return: 按钮对象 \"\"\" button = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_radar_tip'))) return button 这里返回一个网页节点对象，直接调用click()方法即可模拟点击 12button = self.get_geetest_button()button.click() 到这里就完成了第一步，点击一下就会弹出极验滑动二维码界面 4.识别缺口&nbsp;&nbsp;&nbsp;&nbsp;接下来我们需要识别缺口的位置，首先我们需要将前后的两张比对图片获取下来，然后比对二者的不一致的地方即为缺口。首先我们需要获取不带缺口的图片，利用 Selenium 选取图片元素，然后得到其所在位置和宽高，随后获取整个网页的截图，再从截图中裁切出来即可，代码实现如下： 1234567891011121314151617181920212223def get_position(self): \"\"\" 获取验证码位置 :return: 验证码位置元组 \"\"\" img = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'geetest_canvas_img'))) time.sleep(2) location = img.location size = img.size top, bottom, left, right = location['y'], location['y'] + size['height'], location['x'], location['x'] + size[ 'width'] return (top, bottom, left, right) def get_geetest_image(self, name='captcha.png'): \"\"\" 获取验证码图片 :return: 图片对象 \"\"\" top, bottom, left, right = self.get_position() print('验证码位置', top, bottom, left, right) screenshot = self.get_screenshot() captcha = screenshot.crop((left, top, right, bottom)) return captcha &nbsp;&nbsp;&nbsp;&nbsp;在这里 get_position() 函数首先获取了图片对象，然后获取了它的位置和宽高，随后返回了其左上角和右下角的坐标。而 get_geetest_image() 方法则是获取了网页截图，然后调用了 crop() 方法将图片再裁切出来，返回的是 Image 对象。&nbsp;&nbsp;&nbsp;&nbsp;随后我们需要获取第二张图片，也就是带缺口的图片，要使得图片出现缺口，我们只需要点击一下下方的滑块即可，触发这个动作之后，图片中的缺口就会显现，实现如下： 1234567def get_slider(self): \"\"\" 获取滑块 :return: 滑块对象 \"\"\" slider = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_slider_button'))) return slider 利用 get_slider() 方法获取滑块对象，接下来调用其 click() 方法即可触发点击，缺口图片即可呈现： 123# 点击呼出缺口slider = self.get_slider()slider.click() &nbsp;&nbsp;&nbsp;&nbsp;随后还是调用 get_geetest_image() 方法将第二张图片获取下来即可。 &nbsp;&nbsp;&nbsp;&nbsp;到现在我们就已经得到了两张图片对象了，分别赋值给变量 image1 和 image2，接下来对比图片获取缺口即可。要对比图片的不同之处，我们在这里遍历图片的每个坐标点，获取两张图片对应像素点的 RGB 数据，然后判断二者的 RGB 数据差异，如果差距超过在一定范围内，那就代表两个像素相同，继续比对下一个像素点，如果差距超过一定范围，则判断像素点不同，当前位置即为缺口位置，代码实现如下： 123456789101112131415161718192021222324252627282930313233def is_pixel_equal(self, image1, image2, x, y): \"\"\" 判断两个像素是否相同 :param image1: 图片1 :param image2: 图片2 :param x: 位置x :param y: 位置y :return: 像素是否相同 \"\"\" # 取两个图片的像素点 pixel1 = image1.load()[x, y] pixel2 = image2.load()[x, y] threshold = 60 if abs(pixel1[0] - pixel2[0]) &lt; threshold and abs(pixel1[1] - pixel2[1]) &lt; threshold and abs( pixel1[2] - pixel2[2]) &lt; threshold: return True else: return False def get_gap(self, image1, image2): \"\"\" 获取缺口偏移量 :param image1: 不带缺口图片 :param image2: 带缺口图片 :return: \"\"\" left = 60 for i in range(left, image1.size[0]): for j in range(image1.size[1]): if not self.is_pixel_equal(image1, image2, i, j): left = i return left return left &nbsp;&nbsp;&nbsp;&nbsp;get_gap() 方法即为获取缺口位置的方法，此方法的参数为两张图片，一张为带缺口图片，另一张为不带缺口图片，在这里遍历两张图片的每个像素，然后利用 is_pixel_equal() 方法判断两张图片同一位置的像素是否相同，比对的时候比较了两张图 RGB 的绝对值是否均小于定义的阈值 threshold，如果均在阈值之内，则像素点相同，继续遍历，否则遇到不相同的像素点就是缺口的位置。 5.模拟拖动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def get_track(self, distance): \"\"\" 根据偏移量获取移动轨迹 :param distance: 偏移量 :return: 移动轨迹 \"\"\" # 移动轨迹 track = [] # 当前位移 current = 0 # 减速阈值 mid = distance * 4 / 5 # 计算间隔 t = 0.2 # 初速度 v = 0 while current &lt; distance: if current &lt; mid: # 加速度为正2 a = 2 else: # 加速度为负3 a = -3 # 初速度v0 v0 = v # 当前速度v = v0 + at v = v0 + a * t # 移动距离x = v0t + 1/2 * a * t^2 move = v0 * t + 1 / 2 * a * t * t # 当前位移 current += move # 加入轨迹 track.append(round(move)) return track def move_to_gap(self, slider, tracks): \"\"\" 拖动滑块到缺口处 :param slider: 滑块 :param tracks: 轨迹 :return: \"\"\" ActionChains(self.browser).click_and_hold(slider).perform() for x in tracks: ActionChains(self.browser).move_by_offset(xoffset=x, yoffset=0).perform() time.sleep(0.5) ActionChains(self.browser).release().perform() 在这里传入的参数为滑块对象和运动轨迹，首先调用ActionChains 的 click_and_hold() 方法按住拖动底部滑块，随后遍历运动轨迹获取每小段位移距离，调用 move_by_offset() 方法移动此位移，最后移动完成之后调用 release() 方法松开鼠标即可。 6.完整源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218import timefrom io import BytesIOfrom PIL import Imagefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECEMAIL = 'example@example.com'PASSWORD = ''BORDER = 6INIT_LEFT = 60class CrackGeetest(): def __init__(self): self.url = 'https://account.geetest.com/login' self.browser = webdriver.Chrome() self.wait = WebDriverWait(self.browser, 20) self.email = EMAIL self.password = PASSWORD def __del__(self): self.browser.close() def get_geetest_button(self): \"\"\" 获取初始验证按钮 :return: \"\"\" button = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_radar_tip'))) return button def get_position(self): \"\"\" 获取验证码位置 :return: 验证码位置元组 \"\"\" img = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'geetest_canvas_img'))) time.sleep(2) location = img.location size = img.size top, bottom, left, right = location['y'], location['y'] + size['height'], location['x'], location['x'] + size[ 'width'] return (top, bottom, left, right) def get_screenshot(self): \"\"\" 获取网页截图 :return: 截图对象 \"\"\" screenshot = self.browser.get_screenshot_as_png() screenshot = Image.open(BytesIO(screenshot)) return screenshot def get_slider(self): \"\"\" 获取滑块 :return: 滑块对象 \"\"\" slider = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'geetest_slider_button'))) return slider def get_geetest_image(self, name='captcha.png'): \"\"\" 获取验证码图片 :return: 图片对象 \"\"\" top, bottom, left, right = self.get_position() print('验证码位置', top, bottom, left, right) screenshot = self.get_screenshot() captcha = screenshot.crop((left, top, right, bottom)) captcha.save(name) return captcha def open(self): \"\"\" 打开网页输入用户名密码 :return: None \"\"\" self.browser.get(self.url) email = self.wait.until(EC.presence_of_element_located((By.ID, 'email'))) password = self.wait.until(EC.presence_of_element_located((By.ID, 'password'))) email.send_keys(self.email) password.send_keys(self.password) def get_gap(self, image1, image2): \"\"\" 获取缺口偏移量 :param image1: 不带缺口图片 :param image2: 带缺口图片 :return: \"\"\" left = 60 for i in range(left, image1.size[0]): for j in range(image1.size[1]): if not self.is_pixel_equal(image1, image2, i, j): left = i return left return left def is_pixel_equal(self, image1, image2, x, y): \"\"\" 判断两个像素是否相同 :param image1: 图片1 :param image2: 图片2 :param x: 位置x :param y: 位置y :return: 像素是否相同 \"\"\" # 取两个图片的像素点 pixel1 = image1.load()[x, y] pixel2 = image2.load()[x, y] threshold = 60 if abs(pixel1[0] - pixel2[0]) &lt; threshold and abs(pixel1[1] - pixel2[1]) &lt; threshold and abs( pixel1[2] - pixel2[2]) &lt; threshold: return True else: return False def get_track(self, distance): \"\"\" 根据偏移量获取移动轨迹 :param distance: 偏移量 :return: 移动轨迹 \"\"\" # 移动轨迹 track = [] # 当前位移 current = 0 # 减速阈值 mid = distance * 4 / 5 # 计算间隔 t = 0.2 # 初速度 v = 0 while current &lt; distance: if current &lt; mid: # 加速度为正2 a = 2 else: # 加速度为负3 a = -3 # 初速度v0 v0 = v # 当前速度v = v0 + at v = v0 + a * t # 移动距离x = v0t + 1/2 * a * t^2 move = v0 * t + 1 / 2 * a * t * t # 当前位移 current += move # 加入轨迹 track.append(round(move)) return track def move_to_gap(self, slider, track): \"\"\" 拖动滑块到缺口处 :param slider: 滑块 :param track: 轨迹 :return: \"\"\" ActionChains(self.browser).click_and_hold(slider).perform() for x in track: ActionChains(self.browser).move_by_offset(xoffset=x, yoffset=0).perform() time.sleep(0.5) ActionChains(self.browser).release().perform() def login(self): \"\"\" 登录 :return: None \"\"\" submit = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, 'login-btn'))) submit.click() time.sleep(10) print('登录成功') def crack(self): # 输入用户名密码 self.open() # 点击验证按钮 button = self.get_geetest_button() button.click() # 获取验证码图片 image1 = self.get_geetest_image('captcha1.png') # 点按呼出缺口 slider = self.get_slider() slider.click() # 获取带缺口的验证码图片 image2 = self.get_geetest_image('captcha2.png') # 获取缺口位置 gap = self.get_gap(image1, image2) print('缺口位置', gap) # 减去缺口位移 gap -= BORDER # 获取移动轨迹 track = self.get_track(gap) print('滑动轨迹', track) # 拖动滑块 self.move_to_gap(slider, track) success = self.wait.until( EC.text_to_be_present_in_element((By.CLASS_NAME, 'geetest_success_radar_tip_content'), '验证成功')) print(success) # 失败后重试 if not success: self.crack() else: self.login()if __name__ == '__main__': crack = CrackGeetest() crack.crack()","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"极验滑动","slug":"极验滑动","permalink":"https://ahrilove.top/tags/%E6%9E%81%E9%AA%8C%E6%BB%91%E5%8A%A8/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章一：TypeScript基本知识","slug":"TypeScript篇章（一）","date":"2019-12-22T16:00:00.000Z","updated":"2019-12-24T10:11:26.343Z","comments":true,"path":"2019/12/23/TypeScript篇章（一）/","link":"","permalink":"https://ahrilove.top/2019/12/23/TypeScript%E7%AF%87%E7%AB%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS作为一门动态弱类型语言,对变量类型非常宽容,使得语言具有极大”灵活性”,同时这也是JS的一种”缺陷”.如果在一年前,可能TypeScript还不是刚需,但按目前的趋势看,不管是对于JS语言本身还是开发者类型思维的塑造,TypeScript已经是开发者的必备技能,ES6,TypeScript等也都是面试中经常会被问到的点. 本文要点：1.TS变量及数据类型2.TS变量声明…","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS作为一门动态弱类型语言,对变量类型非常宽容,使得语言具有极大”灵活性”,同时这也是JS的一种”缺陷”.如果在一年前,可能TypeScript还不是刚需,但按目前的趋势看,不管是对于JS语言本身还是开发者类型思维的塑造,TypeScript已经是开发者的必备技能,ES6,TypeScript等也都是面试中经常会被问到的点. 本文要点：1.TS变量及数据类型2.TS变量声明… 1.TS的数据类型6种基本数据类型：boolean，number，string，symbol，undefined，null，void，any，never，元组，枚举，高级类型 3种引用类型：array，function，object 2.变量声明 1.简单数据类型定义 语法:变量修饰符 变量名/函数:数据类型 = value 123456// Boolean类型let flag:boolean = true;// number数值类型let age:number = 18;// string字符串类型let username:string = \"chd\"; 2.数组类型 数组定义方法:let array1:Array&lt;number|string|object…&gt;;let array2:number[];let array3:any[]; 1234567// arr:number[]要加一个[]表示一维数组，数组创建方式一：基本数组定义var arr1:number[] = [1,2,3];var arr2:string[] = [\"chd\",\"sgx\",\"lmm\"];// 数组创建方式二：数组泛型定义var arr3:Array&lt;number|string|object&gt; =[\"蒙\",18,&#123;school:\"Tinghua\",height:1.75&#125;];// 数组创建方式三：anylet arr4:any[] = ['Xcat Liu', 25, &#123; website: 'http://xcatliu.com', port:3306&#125;]; 3.元组类型 元组是一种限制数组的元素类型和个数的数组,此时,如果改变数组的元素类型或添加元素数量,编辑器都会报错: 1let tuple: [number, string,object] = [0, '1', &#123; website: 'http://xcatliu.com', port:3306&#125;] 元组越界问题:虽然元组限制了数组元素的类型和数量,过多的元素声明会报错,但TS允许向元组中使用数组的push方法插入新元素(但不允许访问) 4.函数 12345function fun(a:number,b:string) &#123; console.log(\"数值型a:\",a); console.log(\"字符串型b:\",b);&#125;let a = fun(18,\"hello world\"); 5.对象 在JS中，可以任意修改对象属性，但在TS中不允许 12let obj: object = &#123;x: 'a', y: 'b'&#125;;obj.x = 3 // Property 'x' does not exist on type 'object'. 6.symbol 具有唯一的值，可以显式声明，也可以创建 1234let symbol1:Symbol = Symbol(); // 显示声明let symbol2 = Symbol() ; // 直接创建// 验证:是否是同一个对象console.log(symbol1 === symbol2) // fasle","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://ahrilove.top/categories/TypeScript/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Vue(三)：组件与webpack","slug":"Vue(三)","date":"2019-12-21T16:00:00.000Z","updated":"2019-12-29T06:47:50.142Z","comments":true,"path":"2019/12/22/Vue(三)/","link":"","permalink":"https://ahrilove.top/2019/12/22/Vue(%E4%B8%89)/","excerpt":"本文要点：1.父子组件之间的访问方式2.前端模块化3.webpack","text":"本文要点：1.父子组件之间的访问方式2.前端模块化3.webpack 1.父子组件之间的访问方式Vue基础知识&nbsp;&nbsp;&nbsp;&nbsp;之前我们已经了解到组件的创建方式（三种全局组件创建方式和两种局部组建方式），props属性使用以及接受动态数据和静态数据。那我们今天就要学习一下关于： 有时候我们需要父组件访问子组件，子组件直接访问父组件，或者是子组件访问跟组件 父组件访问子组件：使用$children或$refs(reference引用之意) $refs =&gt; 对象类型，默认为空的对象，必须要加ref=”xxxx” ：在组件中使用ref（即，即表示给组件添加唯一的id属性）相当于给标签添加一个id，使得开发者可以知道我们操作的是那个DOM，用来获取DOM元素和组建引用 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;div id=\"app\"&gt; &lt;cpn ref=\"aaa\"&gt;&lt;/cpn&gt; &lt;button @click=\"btnClick('hello woman')\" value=\"click\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/template&gt; &lt;script&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; message:'hello man' &#125;, methods:&#123; btnClick(hi)&#123; console.log(hi); /* *调用子组件的name返回值 * 经测试：this必须添加，否则会出现$refs未定义的报错 * $refs.aaa.name中的aaa相当于id属性，也必须需要，否则会弹出name未定义的错误undefined * */ console.log(this.$refs.aaa.name); console.log(this.$refs.aaa.num) &#125; &#125;, components:&#123; 'cpn':&#123; template:'#cpn' , data()&#123; return &#123; name:\"我是子组件的name\", num:18 &#125; &#125;, methods: &#123; showMessage()&#123; console.log(\"showMessage\") &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 子组件访问父组件：使用$parent（不常用） 2.前端模块化方式 2.1 CommonJS的模块化实现,需要nodeJS的支持 【参考之前的文章】 2.2 ES6的模块化实现(可以直接在浏览器上直接运行) 如何实现模块化，在html中需要使用type=’module’属性。 1234&lt;!--index.html--&gt;&lt;h3&gt;hello world&lt;/h3&gt;&lt;script src=\"./aaa.js\" type=\"module\"&gt;&lt;/script&gt;&lt;script src=\"./bbb.js\" type=\"module\"&gt;&lt;/script&gt; 此时表示aaa.js等是一个单独的模块，此模块是有作用域的。如果要使用aaa.js内的变量，需要在aaa.js中先导出变量，再在需要使用的地方导入变量。 2.1 导出方式:这里推荐使用统一导出 123456789101112// aaa.js// 这里推荐使用统一导出：var age = 22;function sum(num1, num2) &#123; return num1 + num2;&#125;var flag = true;if (flag) &#123; console.log(sum(10, 20))&#125;//2.最后统一导出,导出sum函数，flag，age等属性值export &#123;flag,sum,age&#125; 2.2 导入方式:使用import {name,flag,sum} from &#39;./aaa.js&#39;导入多个变量 12345678910// bbb.js导入aaa.js中的sum函数，flag，name等属性值import &#123;name,flag,sum&#125; from './aaa.js';console.log(name);if(flag)&#123; console.log(\"小明是天才\");&#125;console.log(sum(20,30)); 2.3 默认导入 export default:有且只有一个export default导出： 123export default &#123; flag,sum,age&#125; 导入：注意：使用默认导出会将所有需要导出的变量打包成一个对象，此时导出一个对象，此时我在bbb.js中导入变量时候命名为aaa，如果要调用变量需要使用aaa.变量。 12345678910//默认导入 export defaultimport aaa from './aaa.js';console.log(aaa.sum(10,110));//使用import * as aaa from './aaa.js'统一全部导入// 5.统一全部导入import * as aaa from './aaa.js';console.log(aaa.flag);console.log(aaa.name); 3.webpack3.1 webpack的安装 webpack依赖node环境。 node环境依赖众多包，所以需要npm，npm（node packages manager）node包管理工具 nvm是node管理工具可以自由切换node环境版本 3.2 webpack起步【参考GitHub关于webpack的详细说明，这里不做重复累述】 以及【哔哩哔哩视频】 未完待续。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/tags/Vue/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Frame与iFrame标签","slug":"frame与iframe","date":"2019-12-19T16:00:00.000Z","updated":"2020-02-14T13:47:28.957Z","comments":true,"path":"2019/12/20/frame与iframe/","link":"","permalink":"https://ahrilove.top/2019/12/20/frame%E4%B8%8Eiframe/","excerpt":"本文要点：1.Frame 和 IFrame 对象2.frame 和 iframe 的区别3.frame4.iframe","text":"本文要点：1.Frame 和 IFrame 对象2.frame 和 iframe 的区别3.frame4.iframe 1. Frame 和 IFrame 对象其实就是在HTML页面中镶入了一个框架，并且框架可拆分为多个内容区。Frame 对象代表一个 HTML 框架。&lt;frame&gt;标签定义了在框架中一个特定的窗口（框架）。在 HTML 文档中 &lt;frame&gt; 每出现一次，就会创建一个 Frame对象。 IFrame 对象代表一个 HTML 的内联框架。&lt;iframe&gt; 标签定义了包含另外一个文档的内联框架。在 HTML 文档中 &lt;iframe&gt; 每出现一次，一个 IFrame 对象就会被创建。 2.frame 和 iframe 的区别 1、frame 不能脱离 frameset 单独使用，iframe 可以； 2、frame 不能放到body中，否则将无法显示； 3、iframe 也可以嵌套在frameset ，但是必须放到body中，不嵌套在frameset 中的iframe 可以随意使用； 4、frame 的高度只能通过 frameset 控制，iframe 是自己本身控制，不能通过 frameset 设置； 5、iframe 可以放到表格中； 3.frame1234567891011121314151617181920&lt;!-- noresize: 规定无法调整框架的大小 frameborder: 规定是否显示框架周围的边框 0为无边框 1为有 marginheight: 定义框架的上方和下方的边距 marginwidth: 定义框架的左侧和右侧的边距 noresize: 规定无法调整框架的大小 scrolling: 规定是否在框架中显示滚动条 yes no auto src: 规定在框架中显示的文档的 URL。 --&gt; &lt;!-- cols: 定义框架集中列的数目和尺寸 rows: 定义框架集中行的数目和尺寸 --&gt;&lt;html&gt;&lt;frameset cols=\"25%,50%,25%\"&gt; &lt;frame src=\"frame_a.htm\" /&gt; &lt;frame src=\"frame_b.htm\" /&gt; &lt;frame src=\"frame_c.htm\" /&gt;&lt;/frameset&gt;&lt;/html&gt; 4.iframe126邮箱登陆框就涉及到iframe 12345678&lt;html&gt; &lt;body&gt; ... &lt;iframe id=\"x-URS-iframe\" ...&gt; &lt;html&gt; &lt;body&gt; ... &lt;input name=\"email\" &gt; 【iframe标签详解参考文章】注：iframe是迫不得已才使用的，因为使用iframe会带来较多的问题，而有的浏览器可以设置将iframe当作广告屏蔽。","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://ahrilove.top/tags/html/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（八）：js逆向爬虫的奇技淫巧","slug":"Python全栈系列章节更新(八)","date":"2019-12-18T16:00:00.000Z","updated":"2019-12-20T06:13:19.597Z","comments":true,"path":"2019/12/19/Python全栈系列章节更新(八)/","link":"","permalink":"https://ahrilove.top/2019/12/19/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0(%E5%85%AB)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：微信公众平台反爬机制：用户名不变，密码加密相关技术：selenium，requests，execjs技术难度：★★☆☆☆☆爬取目标：模拟登陆公共号，获取页面的所有信息源代码：本页面（selenium代码还在测试更新当中）说明：第一次玩js逆向爬虫，如有不足，多多指教","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的反爬措施越来越复杂，一些常见的反爬措施有Headers and referer反爬机制、语音动作识别、各种变态二维码（12306）、字符js加密、Ajax动态加载、模拟登录和cookie限制。。。 目标网站：微信公众平台反爬机制：用户名不变，密码加密相关技术：selenium，requests，execjs技术难度：★★☆☆☆☆爬取目标：模拟登陆公共号，获取页面的所有信息源代码：本页面（selenium代码还在测试更新当中）说明：第一次玩js逆向爬虫，如有不足，多多指教 1.分析js，找到目标接口函数F12打开 开发者工具, 按照一般逻辑步骤，先输入一个错误账号密码，找到真正的入口接口函数,案例如下：继续向下翻动，我们可以看到请求参数表单数据的pwd密码是明显经过加密的 2.破解在Search功能栏下搜索pwd 很快可以定位到以下代码 12345678910_loginPost: function(e, i) &#123; n.post(&#123; url: i.url, data: &#123; username: i.account, pwd: o(i.pwd.substr(0, 16)), // 关键代码 imgcode: i.verify, f: \"json\", userlang: i.currentLang, redire 我们在pwd: o(i.pwd.substr(0, 16))行处下断点。然后步入进去. 1234567t.exports = function(n, r, t) &#123; return r ? t ? c(r, n) : function(n, r) &#123; return e(c(n, r)) &#125;(r, n) : t ? o(n) : function(n) &#123; return e(o(n)) // ***** &#125;(n)&#125; 继续步入一次，代码最后会走到我标****的地方。这就是我们需要的关键函数,扣代码吧。 扣下代码。然后自己编写一个Js function 123function JsKiller(pwd)&#123; return e(o(pwd));&#125; js逆向加密源代码：pwd.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091function d(n, r) &#123; var t = (65535 &amp; n) + (65535 &amp; r); return (n &gt;&gt; 16) + (r &gt;&gt; 16) + (t &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; t&#125;function f(n, r, t, e, u, o) &#123; return d(function (n, r) &#123; return n &lt;&lt; r | n &gt;&gt;&gt; 32 - r &#125;(d(d(r, n), d(e, o)), u), t)&#125;function g(n, r, t, e, u, o, c) &#123; return f(r &amp; t | ~r &amp; e, n, r, u, o, c)&#125;function l(n, r, t, e, u, o, c) &#123; return f(r &amp; e | t &amp; ~e, n, r, u, o, c)&#125;function v(n, r, t, e, u, o, c) &#123; return f(r ^ t ^ e, n, r, u, o, c)&#125;function s(n, r, t, e, u, o, c) &#123; return f(t ^ (r | ~e), n, r, u, o, c)&#125;function i(n, r) &#123; n[r &gt;&gt; 5] |= 128 &lt;&lt; r % 32; n[14 + (r + 64 &gt;&gt;&gt; 9 &lt;&lt; 4)] = r; var t, e, u, o, c, f = 1732584193, i = -271733879, a = -1732584194, h = 271733878; for (t = 0; t &lt; n.length; t += 16) i = s(i = s(i = s(i = s(i = v(i = v(i = v(i = v(i = l(i = l(i = l(i = l(i = g(i = g(i = g(i = g(u = i, a = g(o = a, h = g(c = h, f = g(e = f, i, a, h, n[t], 7, -680876936), i, a, n[t + 1], 12, -389564586), f, i, n[t + 2], 17, 606105819), h, f, n[t + 3], 22, -1044525330), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 4], 7, -176418897), i, a, n[t + 5], 12, 1200080426), f, i, n[t + 6], 17, -1473231341), h, f, n[t + 7], 22, -45705983), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 8], 7, 1770035416), i, a, n[t + 9], 12, -1958414417), f, i, n[t + 10], 17, -42063), h, f, n[t + 11], 22, -1990404162), a = g(a, h = g(h, f = g(f, i, a, h, n[t + 12], 7, 1804603682), i, a, n[t + 13], 12, -40341101), f, i, n[t + 14], 17, -1502002290), h, f, n[t + 15], 22, 1236535329), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 1], 5, -165796510), i, a, n[t + 6], 9, -1069501632), f, i, n[t + 11], 14, 643717713), h, f, n[t], 20, -373897302), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 5], 5, -701558691), i, a, n[t + 10], 9, 38016083), f, i, n[t + 15], 14, -660478335), h, f, n[t + 4], 20, -405537848), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 9], 5, 568446438), i, a, n[t + 14], 9, -1019803690), f, i, n[t + 3], 14, -187363961), h, f, n[t + 8], 20, 1163531501), a = l(a, h = l(h, f = l(f, i, a, h, n[t + 13], 5, -1444681467), i, a, n[t + 2], 9, -51403784), f, i, n[t + 7], 14, 1735328473), h, f, n[t + 12], 20, -1926607734), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 5], 4, -378558), i, a, n[t + 8], 11, -2022574463), f, i, n[t + 11], 16, 1839030562), h, f, n[t + 14], 23, -35309556), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 1], 4, -1530992060), i, a, n[t + 4], 11, 1272893353), f, i, n[t + 7], 16, -155497632), h, f, n[t + 10], 23, -1094730640), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 13], 4, 681279174), i, a, n[t], 11, -358537222), f, i, n[t + 3], 16, -722521979), h, f, n[t + 6], 23, 76029189), a = v(a, h = v(h, f = v(f, i, a, h, n[t + 9], 4, -640364487), i, a, n[t + 12], 11, -421815835), f, i, n[t + 15], 16, 530742520), h, f, n[t + 2], 23, -995338651), a = s(a, h = s(h, f = s(f, i, a, h, n[t], 6, -198630844), i, a, n[t + 7], 10, 1126891415), f, i, n[t + 14], 15, -1416354905), h, f, n[t + 5], 21, -57434055), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 12], 6, 1700485571), i, a, n[t + 3], 10, -1894986606), f, i, n[t + 10], 15, -1051523), h, f, n[t + 1], 21, -2054922799), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 8], 6, 1873313359), i, a, n[t + 15], 10, -30611744), f, i, n[t + 6], 15, -1560198380), h, f, n[t + 13], 21, 1309151649), a = s(a, h = s(h, f = s(f, i, a, h, n[t + 4], 6, -145523070), i, a, n[t + 11], 10, -1120210379), f, i, n[t + 2], 15, 718787259), h, f, n[t + 9], 21, -343485551), f = d(f, e); i = d(i, u); a = d(a, o); h = d(h, c); return [f, i, a, h]&#125;function a(n) &#123; var r, t = \"\"; for (r = 0; r &lt; 32 * n.length; r += 8) t += String.fromCharCode(n[r &gt;&gt; 5] &gt;&gt;&gt; r % 32 &amp; 255); return t&#125;function h(n) &#123; var r, t = []; for (t[(n.length &gt;&gt; 2) - 1] = void 0, r = 0; r &lt; t.length; r += 1) t[r] = 0; for (r = 0; r &lt; 8 * n.length; r += 8) t[r &gt;&gt; 5] |= (255 &amp; n.charCodeAt(r / 8)) &lt;&lt; r % 32; return t&#125;function e(n) &#123; var r, t, e = \"0123456789abcdef\", u = \"\"; for (t = 0; t &lt; n.length; t += 1) r = n.charCodeAt(t); u += e.charAt(r &gt;&gt;&gt; 4 &amp; 15) + e.charAt(15 &amp; r); return u&#125;function u(n) &#123; return unescape(encodeURIComponent(n))&#125;function o(n) &#123; return function (n) &#123; return a(i(h(n), 8 * n.length)) &#125;(u(n))&#125;function c(n, r) &#123; return function (n, r) &#123; var t, e, u = h(n), o = [], c = []; for (o[15] = c[15] = void 0, 16 &lt; u.length &amp;&amp; (u = i(u, 8 * n.length)), t = 0; t &lt; 16; t += 1) o[t] = 909522486 ^ u[t]; c[t] = 1549556828 ^ u[t]; return e = i(o.concat(h(r)), 512 + 8 * r.length); a(i(c.concat(e), 640)) &#125;(u(n), u(r))&#125;function JsKiller(pwd) &#123; return e(o(pwd))&#125; 3.执行破解出的js123456789101112import execjsdef parseJS(pwd): # 读取pwd.js文件内容 with open(\"pwd.js\", 'r') as f: js_code = f.read() # 编译js函数 ctx = execjs.compile(js_code) # 执行js中的JsKiller函数，参数为pwd result = ctx.call('JsKiller', pwd) return result 比如我们来执行一下这个python代码，测试一下结果：令pwd=”Github” ctx.call(‘JsKiller’, pwd) ==&gt; &quot;e1adbcbb92c622d0b3e619f9d0730abf”,即将GitHub加密成32位。 4.模拟登陆 这里直接列出来模拟登录的源代码，这里需要注意一定要加referer 12345678910111213141516171819202122232425262728293031323334353637383940414243import execjsimport requestsurl = \"https://mp.weixin.qq.com/cgi-bin/bizlogin?action=startlogin\" # 这就是真正的入口urldef get_content(username, pwd): headers = &#123; \"referer\": \"https://mp.weixin.qq.com/\", # 必须要写 \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36\" &#125; data = &#123; \"username\": username, \"pwd\": pwd, \"f\": \"json\", \"imgcode\": \"\", \"userlang\": \"zh_CN\", \"lang\": \"zh_CN\", \"ajax\": 1 &#125; try: response = requests.post(url=url, headers=headers, data=data, timeout=10) if (response.status_code == 200): return response.text return None except Exception as e: print(e)def parseJS(pwd): with open(\"pwd.js\", 'r') as f: js_code = f.read() ctx = execjs.compile(js_code) result = ctx.call('JsKiller', pwd) return resultif __name__ == '__main__': username = \"980710425@qq.com\" pwd = \"XXXXXXXX\" pwd = parseJS(pwd) print(get_content(username, pwd)) 5.结果分析得到返回结果：这里返回了一个json格式数据，并且我们可以得知，这里其实是重定向到了这个新的URL地址 12345&#123;\"base_resp\":&#123; \"err_msg\":\"ok\", \"ret\":0&#125;, \"redirect_url\":\"/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account=980710425%40qq.com\"&#125; https://mp.weixin.qq.com/cgi-bin/bizlogin?action=validate&amp;lang=zh_CN&amp;account=980710425%40qq.com这个链接其实是需要微信扫码登陆认证的链接，我也不知道怎么去绕过这个扫码认证，如果有大神巨佬知道，请带带我。我的笨办法是通过selenium自动化测试，还是不可避免要扫码，然后扫码登陆，获取目标数据 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"逆向爬虫","slug":"逆向爬虫","permalink":"https://ahrilove.top/tags/%E9%80%86%E5%90%91%E7%88%AC%E8%99%AB/"}],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章五：常见函数和属性","slug":"Javascript篇章五","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-25T03:43:02.140Z","comments":true,"path":"2019/12/18/Javascript篇章五/","link":"","permalink":"https://ahrilove.top/2019/12/18/Javascript%E7%AF%87%E7%AB%A0%E4%BA%94/","excerpt":"1.isFinite()函数2.jQuery中的$.inArray()3.Math(算术对象)4.数据类型判断5.arguments参数属性","text":"1.isFinite()函数2.jQuery中的$.inArray()3.Math(算术对象)4.数据类型判断5.arguments参数属性 1.isFinite()函数isFinite() 函数用于检查其参数是否是无穷大。（如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。） 123456document.write(isFinite(123)+ \"&lt;br&gt;\"); //truedocument.write(isFinite(-1.23)+ \"&lt;br&gt;\"); // truedocument.write(isFinite(5-2)+ \"&lt;br&gt;\"); // truedocument.write(isFinite(0)+ \"&lt;br&gt;\"); // truedocument.write(isFinite(\"Hello\")+ \"&lt;br&gt;\"); // falsedocument.write(isFinite(\"2005/12/12\")+ \"&lt;br&gt;\"); // false 2.jQuery中的$.inArray（）$.inArray( value, array)判断参数值是否存在数组中，并返回索引值（默认从0开始）如果不存在就返回-1 12345678910&lt;script&gt;$(function () &#123; var arr = [ 4, \"Pete\", 8, \"John\" ]; var $spans = $( \"span\" ); $spans.eq( 0 ).text( jQuery.inArray( \"John\", arr ) ); $spans.eq( 1 ).text( jQuery.inArray( 4, arr ) ); $spans.eq( 2 ).text( jQuery.inArray( \"Karl\", arr ) ); $spans.eq( 3 ).text( jQuery.inArray( \"Pete\", arr, 2 ) );&#125;)&lt;/script&gt; 3.Math(算术对象)Math对象，提供科学数学计算，也同样具有属性与方法，案例如下： 12345678&lt;script&gt; let mypi = Math.PI; let myabs = Math.abs(-15.88963); console.log(mypi); console.log(myabs); document.getElementById(\"kajima\").innerHTML=mypi; document.getElementById(\"bady\").innerHTML=myabs;&lt;/script&gt; Math对象属性 Math 对象方法 4.数据类型判断PS:typeof无法判断数组，null和对象，因为他会把这些都判断为Object，其余都可以正常判断。最完美的检测数组类型的方法： 12345function isArrayFn (o) &#123;return Object.prototype.toString.call(o) === '[object Array]';&#125;var arr = [1,2,3,1];alert(isArrayFn(arr));// true 其实这个函数可以改进一下，使得同样能够判断其它数据类型：数组，null，function，String，object等等 123function isArrayFn (o) &#123;return Object.prototype.toString.call(o);&#125; 实例 测试结果 [1,2,3,1] [object Array] {a:”chenhaodong”,age:18} [object Object] function a(){return null} [object Function] “hello world” [object String] null [object Null] 5.arguments参数属性arguments.length 属性返回函数调用过程接收到的参数个数arguments[0]:获取传入的第一个参数值arguments[1]:获取传入的第二个参数值","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[],"author":{"name":"AhriLove","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Vue(二)：生命周期函数","slug":"Vue(二)","date":"2019-12-16T16:00:00.000Z","updated":"2019-12-18T02:45:32.587Z","comments":true,"path":"2019/12/17/Vue(二)/","link":"","permalink":"https://ahrilove.top/2019/12/17/Vue(%E4%BA%8C)/","excerpt":"本文要点：1.生命周期函数2.Watch方法3.计算属性computed","text":"本文要点：1.生命周期函数2.Watch方法3.计算属性computed 1.生命周期函数（与el，data，methods，computed等等同级） 创建阶段 1234567891.beforeCreate():表示实例完全被创建时，会执行它 /ps：在beforCreate生命周期函数执行时，data和methods中的数据均未被初始化2.created():在created中，data与methods都已经被实例化了，3.beforeMount(): 表示模板已经在内存中编译好了，只是未渲染到真正要展示的页面上4.mounted():是实例创建期间最后一个生命周期函数，当执行完mounted就表示，实例已经完全创建好了， 此时，如果没有其它操作的话，这个实例就静静地躺在内存中 组件运行阶段： 12341.beforeUpdate(): 表示我们的界面还没有更新，但数据肯定被更新了 结论：运行beforeUpdate，页面上显示的数据还没有被更新，但数据已经更新了，页面与数据更新不同步2.updated():页面都data数据已经保持同步了，都是最新的 销毁过程 1231.beforeDestroy：Vue示例已经从运行阶段，进入到销毁阶段，实例身上的所有data，methods以及过滤器，指令都处于可用状态，未执行真正的销毁动作2.destroyed：组件已经完全销毁了，一切data，方法，指令，过滤器均不可使用 2.Watch属性Watch，可以监听data属性域中的数据变化，主要有handler方法，immediate属性，deep属性handler方法就是你watch中需要具体执行的方法；immediate为true时则立即触发回调函数；如果为false，则和上面的例子一样，不会立即执行回调deep顾名思义就是深入监听，也就是在对象中层层遍历，并在监听对象上的每一个属性上都添加监听，固然也会损耗性能 123456789watch: &#123; orgBarChartData: &#123; // 监听的目标属性 handler(newVal,oldVal)&#123; this.renderOrgBarChart(); //重设图表，这两个都是动作体 this.orgBarChart.resize(); //重新设置图表高宽 &#125;, deep: true // deep:true &#125;,&#125; 3.methods与computed的区别： computed 和 methods虽然都可以实现对数据的计算,但两者有一定的区别: methods:使用methods方法可以接受外部传参,使用更加灵活；computed:计算属性，computed的亮点在于:它能够依赖缓存，当计算属性所依赖的数据发生改变时，才会重新触发计算属性方法执行。所以对于较复杂或消耗效率的计算,一定要采用计算属性。计算属性computed里面也可以写函数，并且调用函数时使用的mustache语法不用加括号，案例如下： 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;!--这里的mustache语法调用函数时没有声明括号---&gt; &lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;script &gt; const vm = new Vue(&#123; el: '#app', data:&#123; firstName:\"浩东\", lastName:\"陈\" &#125;, computed:&#123; fullname () &#123; return this.lastName+this.firstName; &#125; &#125;, methods:&#123;&#125; &#125;)&lt;/script&gt; 使用methods的方法,每次页面刷新都会触发方法的执行，使用计算属性,只要依赖的数据没有变化,就会直接从缓存中读取结果,不需要重新计算,这种做法可以提升效率更可以带来更好的用户体验","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/tags/Vue/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"ThinkPHP项目（三）：常见函数和属性","slug":"ThinkPHP(三)","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-19T08:36:45.243Z","comments":true,"path":"2019/12/16/ThinkPHP(三)/","link":"","permalink":"https://ahrilove.top/2019/12/16/ThinkPHP(%E4%B8%89)/","excerpt":"还是紧接前面的知识展开，本章节列举出遇到的一些项目相关函数与属性 1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单","text":"还是紧接前面的知识展开，本章节列举出遇到的一些项目相关函数与属性 1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单 1. is_array(search_value,array,type)in_array() 函数搜索数组中是否存在指定的值。type是可选的，如果设置该参数为true，则又要检查搜索的数据与数组的值的类型是否相同 12345678&lt;?php $people = array(\"Bill\", \"Steve\", \"Mark\", \"David\"); if (in_array(\"Mark\", $people))&#123; echo \"匹配已找到\";&#125; else&#123; echo \"匹配未找到\";&#125;?&gt;","categories":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://ahrilove.top/categories/ThinkPHP/"}],"tags":[{"name":"thinkPHP","slug":"thinkPHP","permalink":"https://ahrilove.top/tags/thinkPHP/"}],"author":{"name":"憨批龟","avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png"}},{"title":"数据分析章节（一）：初始数学之美","slug":"数据分析章节（一）","date":"2019-12-14T16:00:00.000Z","updated":"2019-12-15T11:26:58.502Z","comments":true,"path":"2019/12/15/数据分析章节（一）/","link":"","permalink":"https://ahrilove.top/2019/12/15/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AB%A0%E8%8A%82%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学是一门美丽的学科，是美丽的，也充满悲剧的！ 本文要点：直角坐标系与极坐标方程科学运算基本三大库Matplotlib，Numpy，Pandas一个浪漫又悲情的爱情故事——笛卡尔心形线执子之魂，与子共生——玫瑰线给我一个支点——阿基米德螺线","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数学是一门美丽的学科，是美丽的，也充满悲剧的！ 本文要点：直角坐标系与极坐标方程科学运算基本三大库Matplotlib，Numpy，Pandas一个浪漫又悲情的爱情故事——笛卡尔心形线执子之魂，与子共生——玫瑰线给我一个支点——阿基米德螺线 1.直角坐标与极坐标方程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较直角坐标系方程y=x，它表示平面上的一条线，而极坐标方程ρ=θ表示螺线。用极坐标系描述的曲线方程称作极坐标方程，通常用来表示ρ为自变量θ的函数(ρ,θ)=0。 两坐标系之间的转换 极坐标系中的两个坐标r和θ可以由下面的公式转换为直角坐标系下的坐标值。x = rcos（θ），y = rsin（θ），由上述二公式，可得到从直角坐标系中x和y两坐标如何计算出极坐标下的坐标：角度θ = arctan(y/x)总结如下： 2.科学运算三大基本库基本知识点参考我的GitHub补充一点：PYTHON使用MATPLOTLIB绘图时出现的中文乱码问题,设置代码如下 1234from matplotlib import pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 3.一个浪漫又悲情的爱情故事——笛卡尔心形线【转载】1650年，斯德哥尔摩的街头，52岁的笛卡尔邂逅了18岁的瑞典公主克里斯汀。 那时，落魄、一文不名的笛卡尔过着乞讨的生活，全部的财产只有身上穿的破破烂烂的衣服和随身所带的几本数学书籍。生性清高的笛卡尔从来不开口请求路人施舍，他只是默默地低头在纸上写写画画，潜心于他的数学世界。 一个宁静的午后，笛卡尔照例坐在街头，沐浴在阳光中研究数学问题。他如此沉溺于数学世界，身边过往的人群，喧闹的车马队伍。都无法对他造成干扰。 突然，有人来到他旁边，拍了拍他的肩膀，“你在干什么呢？”扭过头，笛卡尔看到一张年轻秀丽的睑庞，一双清澈的眼睛如湛蓝的湖水，楚楚动人，长长的睫毛一眨一眨的，期待着他的回应。她就是瑞典的小公主，国王最宠爱的女儿克里斯汀。 她蹲下身，拿过笛卡尔的数学书和草稿纸，和他交谈起来。言谈中，他发现，这个小女孩思维敏捷，对数学有着浓厚的兴趣。 和女孩道别后，笛卡尔渐渐忘却了这件事，依旧每天坐在街头写写画画。 几天后，他意外地接到通知，国王聘请他做小公主的数学老师。满心疑惑的笛卡尔跟随前来通知的侍卫一起来到皇宫，在会客厅等候的时候，他听到了从远处传来的银铃般的笑声。转过身，他看到了前儿天在街头偶遇的女孩子。慌忙中，他赶紧低头行礼。 从此，他当上了公主的数学老师。 公主的数学在笛卡尔的悉心指导下突飞猛进，他们之间也开始变得亲密起来。笛卡尔向她介绍了他研究的新领域——直角坐标系。通过它，代数与几何可以结合起来，也就是日后笛卡尔创立的解析几何学的雏形。 在笛卡尔的带领下，克里斯汀走进了奇妙的坐标世界，她对曲线着了迷。每天的形影不离也使他们彼此产生了爱慕之心。 在瑞典这个浪漫的国度里，一段纯粹、美好的爱情悄然萌发。 然而，没过多久，他们的恋情传到了国王的耳朵里。国王大怒，下令马上将笛卡尔处死。在克里斯汀的苦苦哀求下，国王将他放逐回国，公主被软禁在宫中。 当时，欧洲大陆正在流行黑死病。身体孱弱的笛卡尔回到法国后不久，便染上重病。在生命进入倒计时的那段日子，他日夜思念的还是街头偶遇的那张温暖的笑脸。他每天坚持给她写信，盼望着她的回音。然而，这些信都被国王拦截下来，公主一直没有收到他的任何消息。 在笛卡尔给克里斯汀寄出第十三封信后，他永远地离开了这个世界。此时，被软禁在宫中的小公主依然徘徊在皇宫的走廊里，思念着远方的情人。 这最后一封信上没有写一句话，只有一个方程：r=a(1-sinθ)。 国王看不懂，以为这个方程里隐藏着两个人不可告人的秘密，便把全城的数学家召集到皇宫，但是没有人能解开这个函数式。他不忍看着心爱的女儿每天闷闷不乐，便把这封信给了她。 拿到信的克里斯汀欣喜若狂，她立即明白了恋人的意图，找来纸和笔，着手把方程图形画了出来，一颗心形图案出现在眼前，克里斯汀不禁流下感动的泪水，这条曲线就是著名的“心形线”。 国王去世后，克里斯汀继承王位，登基后，她便立刻派人去法国寻找心上人的下落，收到的却是笛卡尔去世的消息，留下了一个永远的遗憾…… 这封享誉世界的另类情书，至今，还保存在欧洲笛卡尔的纪念馆里。———————————————— 4.三大曲线图像展示 极坐标方程： 心形线：r=a(1-cosθ) (a&gt;0)玫瑰线：r=asin(3θ) (a&gt;0)阿基米德螺线：r=aθ(a&gt;0,θ&gt;=0) 成品展示 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import numpy as npfrom matplotlib import pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号def draw(): plt.title(\"数学其实很美\") pi = np.pi a = 1 # 生成0到2pi的数据集 datas = np.linspace(0, 2 * pi, 100) # 绘制极坐标r = a(1-cosθ)(a&gt;0)的心形图 x = a * (1 - np.cos(datas)) * (np.cos(datas)) y = a * (1 - np.cos(datas)) * (np.sin(datas)) plt.plot(x, y, label='心形线', color='red', linewidth='1.0') # 绘制极坐标r = a(1-cosθ)(a&gt;0)的心形图 x1 = a * (np.sin(3 * datas)) * (np.cos(datas)) y1 = a * (np.sin(3 * datas)) * (np.sin(datas)) plt.plot(x1, y1, label='玫瑰线', color='blue', linewidth='2.0', linestyle=\"--\") # 绘制极坐标r = a(1-cosθ)(a&gt;0)的阿基米德螺线图 x2 = a * datas * (np.cos(datas)) y2 = a * datas * (np.sin(datas)) plt.plot(x2, y2, label='阿基米德螺线', color='black', linewidth='1.0', linestyle=\"-.\") # # 使用plt.xlim设置x坐标轴范围： # plt.ylim((-10, 10)) # # 使用plt.ylim设置x坐标轴范围： # plt.ylim((-10, 10)) # 定义x轴名称 plt.xlabel('x轴') # 定义y轴名称 plt.ylabel('y轴') new_ticks = np.arange(-5, 10, 1) # 使用plt.xticks设置x轴刻度：范围是(-2,2);个数是8. plt.xticks(new_ticks) \"\"\" plt.gca获取当前坐标轴信息. 使用.spines设置边框；使用.set_color设置边框颜色 \"\"\" # 坐标轴中移 ax = plt.gca() # 隐藏上边和右边 ax.spines['top'].set_color('none') ax.spines['right'].set_color('none') # 移动另外两个轴 ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data', 0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data', 0)) plt.legend() plt.savefig(\"math.png\") plt.show()if __name__ == '__main__': draw()","categories":[{"name":"Data analysis","slug":"Data-analysis","permalink":"https://ahrilove.top/categories/Data-analysis/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ahrilove.top/tags/python/"},{"name":"numpy","slug":"numpy","permalink":"https://ahrilove.top/tags/numpy/"}]},{"title":"docker安装使用redis","slug":"docker的redis","date":"2019-12-11T16:00:00.000Z","updated":"2019-12-12T05:14:04.397Z","comments":true,"path":"2019/12/12/docker的redis/","link":"","permalink":"https://ahrilove.top/2019/12/12/docker%E7%9A%84redis/","excerpt":"docker系列章节更新（三），这一章节主要学习docker安装redis以及非关系型数据库redis学习 docker安装redis redis学习笔记","text":"docker系列章节更新（三），这一章节主要学习docker安装redis以及非关系型数据库redis学习 docker安装redis redis学习笔记 1.docker安装redis 拉取镜像 docker search redisdocker pull redis:[version] 创建容器 docker run -di -p 6379:6379 -p指定端口,-d以守护式形式-v /zzyyuse/myredis/data:/data-v /zzyyuse/myredis/conf/redis.conf:/usr/local/etc/redis/redis.confredis-server /usr/local/etc/redis/redis.confredis:3.2 指定redis版本--appendonly yes 新建redis.conf文件 在宿主机/zzyyuse/myredis/conf/redis.conf目录下新建redis.conf文件（文件内容） 进入容器并以命令行交互 docker exec -it container_id redis-cli(区分其它容器的/bin/bash或者/bin/sh) 退出命令 SHUTDOWN 2.redis的基础知识【转载】羊松林博客的redis讲解就很详细了，不重复造轮子，先抄他一手再说","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://ahrilove.top/tags/redis/"}]},{"title":"ALL MY LIFE","slug":"2020","date":"2019-12-10T16:00:00.000Z","updated":"2019-12-19T09:33:54.894Z","comments":true,"path":"2019/12/11/2020/","link":"","permalink":"https://ahrilove.top/2019/12/11/2020/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做她的战士，跟她一起经历&nbsp;&nbsp;&nbsp;失败！！","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做她的战士，跟她一起经历&nbsp;&nbsp;&nbsp;失败！！ 自我介绍&nbsp;&nbsp;&nbsp;兄弟萌，您们好，我叫陈浩东，浩东陈的陈，你也可以叫我陈某。97年的四川绵阳人，于2019年6月5日毕业于中国计量大学信息与计算科学专业。虽然口头上一直在说~不会再爱了( ﹁ ﹁ ) ~→，但是我还是忘不了那个badwoman,试问，如果不是真心喜欢，谁愿意当舔狗呢？☹ ☹ ☹ 她不是漂不漂亮的问题，她真的就是那种，很少见，很冷艳的漂亮…&nbsp;&nbsp;&nbsp;你们有可能会说：你那叫喜欢吗？你那是馋她的身子，你下贱 &nbsp;&nbsp;&nbsp;作为一个正能量，儒雅随和的知识分子，兴趣爱好当然必不可少。喜欢羽毛球、乒乓球、登山、游泳（仅能浮起来☹ ☹）、钓鱼以及英雄联盟，当然作为一个资深的土味鉴定师,文艺复兴模仿者,能够快速洞察每一个土味视频背后的正能量思想，有内味了。 2020年职业技术规划： XXXXXXXXX(终极目标，可以决定是否可以改变未来轨迹的) Python进阶，web框架以及爬虫框架~js逆向解密爬虫 Python爬取抓包app数据 Vue基础知识与微信小程序MVVM（两者大同小异） java ThinkPHP以及PHP学习 HTML+CSS+JavaScript Jquery进阶以及bootstrap Docker容器虚拟技术 Linux的Ubuntu要经常多用 数据库进阶以及存储过程 数据分析与深度学习 完成一个简单的健康指数的微信小程序 完成一个GitHub开源项目，暂时有一点想法 每日作息安排：1.早上7:25-7:50起床2.中午早点休息，下午一点上班3.五点下班：会寝室吃饭并休息到6:00-6:30,继续学习4.晚上10:40到11:00开始收拾收拾准备下班5.回到寝室，做10-15分钟的Keep，锻炼胸肌腹肌6.周六周日特殊安排：早上9-10点起床，其余正常安排 7.周而复始，学会坚持，每天多学一点，未来会好很多，兄弟萌，不甘碌碌无为，那就，冲，杀！！ 推荐学习方法： 渗透科学学习法 晚上睡觉前，把文献放在脑袋和枕头之间，知识会从浓度较高的的书本向浓度较低的脑袋渗透。书本越多，外界知识浓度越高，夜间复习的效果越好！ 奋斗目标 1.翻新/二手iPhone 16年买的iPhone6s 32G，现在内存不到5个G。可以买但没必要☹ ☹ ☹，还不卡，让手机再奋斗个两三年吧，先存钱买房吧 2.翻新/二手Macbook Pro 16年5月买的联想小新700，有点重，不方便携带，但换个内存条也超神。可以买，但没必要☹ ☹ ☹，让电脑再奋斗个三四年吧，存钱买房 3.Audi 直接想就完事了，买不起，也没必要☹ ☹ ☹ 4.买房 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红颜一春树,流年一掷梭，一瞬为白骨","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（七）：爬虫解析库","slug":"Python全栈系列章节更新（七）","date":"2019-12-09T16:00:00.000Z","updated":"2020-02-01T10:09:15.826Z","comments":true,"path":"2019/12/10/Python全栈系列章节更新（七）/","link":"","permalink":"https://ahrilove.top/2019/12/10/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%83%EF%BC%89/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列举几个常用的python爬虫解析库 正则表达式XpathBeautifulSouppyqueryScrapy的selector的用法Selenium自动测试库学习","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列举几个常用的python爬虫解析库 正则表达式XpathBeautifulSouppyqueryScrapy的selector的用法Selenium自动测试库学习 1.正则表达式123456789101112131415161718192021&apos;.&apos; 默认匹配除\\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行&apos;^&apos; 匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r&quot;^a&quot;,&quot;\\nabc\\neee&quot;,flags=re.MULTILINE)&apos;$&apos; 匹配字符结尾， 若指定flags MULTILINE ,re.search(&apos;foo.$&apos;,&apos;foo1\\nfoo2\\n&apos;,re.MULTILINE).group() 会匹配到foo1&apos;*&apos; 匹配*号前的字符0次或多次， re.search(&apos;a*&apos;,&apos;aaaabac&apos;) 结果&apos;aaaa&apos;&apos;+&apos; 匹配前一个字符1次或多次，re.findall(&quot;ab+&quot;,&quot;ab+cd+abb+bba&quot;) 结果[&apos;ab&apos;, &apos;abb&apos;]&apos;?&apos; 匹配前一个字符1次或0次 ,re.search(&apos;b?&apos;,&apos;alex&apos;).group() 匹配b 0次&apos;&#123;m&#125;&apos; 匹配前一个字符m次 ,re.search(&apos;b&#123;3&#125;&apos;,&apos;alexbbbs&apos;).group() 匹配到&apos;bbb&apos;&apos;&#123;n,m&#125;&apos; 匹配前一个字符n到m次，re.findall(&quot;ab&#123;1,3&#125;&quot;,&quot;abb abc abbcbbb&quot;) 结果&apos;abb&apos;, &apos;ab&apos;, &apos;abb&apos;]&apos;|&apos; 匹配|左或|右的字符，re.search(&quot;abc|ABC&quot;,&quot;ABCBabcCD&quot;).group() 结果&apos;ABC&apos;&apos;(...)&apos; 分组匹配， re.search(&quot;(abc)&#123;2&#125;a(123|45)&quot;, &quot;abcabca456c&quot;).group() 结果为&apos;abcabca45&apos;&apos;[...]&apos; 用来表示一组字符，单独列出，比如匹配[amk]匹配a,m或k &apos;\\A&apos; 只从字符开头匹配，re.search(&quot;\\Aabc&quot;,&quot;alexabc&quot;) 是匹配不到的，相当于re.match(&apos;abc&apos;,&quot;alexabc&quot;) 或^&apos;\\Z&apos; 匹配字符结尾，同$&apos;\\d&apos; 匹配数字0-9&apos;\\D&apos; 匹配非数字&apos;\\w&apos; 匹配[A-Za-z0-9],还包括下划线‘_’&apos;\\W&apos; 匹配非[A-Za-z0-9]&apos;s&apos; 匹配空白字符、\\t、\\n、\\r , re.search(&quot;\\s+&quot;,&quot;ab\\tc1\\n3&quot;).group() 结果 &apos;\\t&apos;&apos;(.*?)&apos; 贪婪匹配，用来获取目标字符&apos;.*?&apos; 非贪婪匹配，用来替换任意非目标字符 常用方法： re.match() re.match()方法会从字符串的起始位置开始匹配正则表达式，如果匹配，就返回匹配成功的结果，一旦开头不匹配，直接返回None，整个匹配失败 re.search() re.search()：扫描整个字符串，然后返回第一个成功匹配的结果 re.findall() re.findall()：把所有匹配到的字符放到以列表中的元素返回，返回的列表中的每一个元素都是元组类型 re.sub() re.sub(‘a’,’b’,content) ,即在content中，用b替换a的内容 re.compile() re.compile(正则表达式,修饰符re.S等)方法将正则表达式字符串编译成正则表达式对象，以便在后面的匹配中复用 修饰符 修饰符 描述 re.I 使匹配对大小写不敏感 re.M 多行匹配 re.S 使.匹配包括换行在内的所有字符 2.xpath1.导入相关库包from lxml import etree2.初始化html = etree.HTML(response.text)3.常用规则 表达式 描述 nodename 选取此节点的所有子节点 / 从根节点选取 // 从匹配选择的当前节点选择文档的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 路径表达式 描述 bookstore 选取 bookstore 元素的所有子节点 /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。索引默认从1开始 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 3.pyquery 导入相关库包 from pyquery import PyQuery as pq 初始化工作 doc = pq(html)字符串初始化doc = pq(url)URL初始化doc = pq(filename=””)文件初始化print(doc(‘li’)) css选择器 表达式 说明 id选择器 使用# class选择器 使用. 标签选择器 直接使用标签，什么都不加 * 选择所有元素 p 选择所有p标签 div,p 选择所有的div和p标签（并集） div p 选择div下的所有p标签（子集） pyquery获取信息(跟jQuery用法一样) 1.获取属性值：变量名.attr(属性名) 或者 变量名.attr.属性名2.获取文本内容：变量名.text()3.获取html： 变量名.html()4.找寻某一特定标签：变量名.find(标签名).eq(n) n从0开始，表示find某标签，并选择第n个目标值 4.Selenium库学习动态渲染页面不仅仅涉及到Ajax技术，绝大多数的网页是通过Javascript计算生成新页面的，比如说百度Echarts，淘宝，中国青年网。。。 4.1基本库导入 123456789101112from selenium import webdrivefrom selenium.webdrive.common.by import By# 若想要模拟键盘，就需要导入keys()类from selenium.webdrive.common.keys import Keys# 等待条件类from selenium.webdrive.support import expected_conditions as EC# 等待条件from selenium.webdrive.support.wait import WebDriverWait# 监听鼠标事件,声明动作链from selenium.webdrive import ActionChains# 导入下拉选择框Select类from selenium.webdriver.support.select import Select 4.2 声明浏览器对象 browser = webdriver.Chrome()/Firefox()/PhantomJS() 等等 4.3 访问目标页面 browser.page_source:打印网页源代码 123456# 访问目标网址browser.get(\"https://www.taobao.com\")# 打印页面源代码print(browser.page_source)# 关闭浏览器browser.close() 4.4 获取单个节点的方法 语法：find_element(By.xx,”XXX”)或者是find_elements(By.xx,”XXX”)一般常用的是(By.ID,id_name),(By.XPath,xpath_path),(By.CSS_SELECTOR,css_selector_path) 4.5 节点交互 Selenium可以驱动浏览器执行一些列操作，可以模仿一些列简单的人的动作：nodeName.send_keys(“content”)：输入目标节点框文字nodeName.clear()：清空目标节点框文字nodeName.click()：点击目标节点 控制浏览器的操作方法 说明 click() 点击目标节点 set_window_size() 设置浏览器的大小 back() 控制浏览器后退 forward() 控制浏览器前进 refresh() 刷新当前页面 clear() 清除文本 send_keys (value) 模拟按键输入 close() 关闭浏览器 quit() 关闭所有窗口 submit() 用于提交表单 get_attribute(name) 获取元素属性值 is_displayed() 设置该元素是否用户可见 size 返回元素的尺寸 location 返回元素在浏览器中的位置，以字典的形式返回 text 获取元素的文本 2019-12-30：新增关于location和size方法的说明先看示例源代码： 12345# 显示等待图片节点加载出来img = self.wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'geetest_canvas_img')))time.sleep(2)location = img.locationsize = img.size 这里用了显示等待获取到了我要识别的滑动验证码图片对象，接下来调用该对象的location属性和size属性。location属性可以返回该图片对象(既这张图片)在浏览器中的位置(坐标轴是以屏幕左上角为原点，x轴向右递增，y轴像下递增)，以字典的形式返回 12345678910&#123;&quot;x&quot;:30, &quot;y&quot;:30 &#125;# 这里我们假设图片的位置是（30,30)size属性同样返回一个字典，size属性是图片对象的高度，宽度。&#123;&quot;height&quot;:30,&quot;width&quot;:30&#125; 4.6 鼠标事件 在WebDriver中，将这些关于鼠标操作的方法封装在 ActionChains 类提供。 鼠标监听方法 说明 ActionChains(driver) 构造ActionChains对象 move_to_element(above) 执行鼠标悬停操作 context_click() 右击 double_click() 双击 drag_and_drop() 拖动 move_to_element(above) 执行鼠标悬停操作 context_click() 用于模拟鼠标右键操作， 在调用时需要指定元素定位 perform() 执行所有 ActionChains 中存储的行为，可以理解成是对整个操作的提交动作 ———————————————— 4.7 多表单切换，点击详情 &nbsp;&nbsp;&nbsp;&nbsp;在Web应用中经常会遇到frame/iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。 鼠标监听方法 说明 switch_to.frame() 将当前定位的主体切换为frame/iframe表单的内嵌页面中 switch_to.default_content() 跳回最外层的页面 1234567891011121314from selenium import webdriverdriver = webdriver.Chrome()driver.get(&quot;http://www.126.com&quot;)# 切换到id为x-URS-iframe的iframe表单driver.switch_to.frame(&apos;x-URS-iframe&apos;)driver.find_element_by_name(&quot;email&quot;).clear()driver.find_element_by_name(&quot;email&quot;).send_keys(&quot;username&quot;)driver.find_element_by_name(&quot;password&quot;).clear()driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;password&quot;)driver.find_element_by_id(&quot;dologin&quot;).click()driver.switch_to.default_content()driver.quit() switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。 先通过xpth定位到iframexf = driver.find_element_by_xpath(‘//*[@id=”x-URS-iframe”]’) 再将定位对象传给switch_to.frame()方法driver.switch_to.frame(xf) driver.switch_to.parent_frame() 4.8 设置元素等待 元素等待分为显示等待（推荐：显式等待使WebdDriver等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException））与隐式等待selenium.webdriver.support.ui 和selenium.webdriver.support.wait都是用来做显式等待的，但两者没有任何一丢丢的区别，将ui换成了wait，这样更直接易懂。 1234567891011121314151617181920from selenium import webdriverimport timefrom selenium.webdriver.common.by import By# 导入时间等待库文件from selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Chrome()driver.get(\"http://www.baidu.com\")# 最长超时时间为10s，检测间隔为0.5swait = WebDriverWait(driver,10,0.5)element = wait.until( # 等待节点出现的含义 EC.presence_of_element_located((By.ID, \"kw\")) )# 输入文本 element.send_keys('selenium')time.sleep(10)# 浏览器退出driver.quit() 2020-1-11 新增： 4.9 下拉框选择操作 导入选择下拉框Select类，使用该类处理下拉框操作方法：select_by_value(“选择值”)：相当于我们使用鼠标选择下拉框的值 1234567891011121314151617181920from selenium import webdriverfrom selenium.webdriver.support.select import Selectfrom time import sleepdriver = webdriver.Chrome()driver.get('http://www.baidu.com')#1.鼠标悬停至“设置”链接driver.find_element_by_link_text('设置').click()sleep(1)#2.打开搜索设置driver.find_element_by_link_text(\"搜索设置\").click()sleep(2)#3.搜索结果显示条数sel = driver.find_element_by_xpath(\"//select[@id='nr']\")Select(sel).select_by_value('50') # 显示50条sleep(3)driver.quit() 4.10 警告框处理 在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用 switch_to.alert 方法定位到 alert/confirm/prompt，然后使用text/accept/dismiss/ send_keys等方法进行操作。 鼠标监听方法 说明 text 返回 alert/confirm/prompt 中的文字信息 accept() 接受现有警告框 dismiss() 解散现有警告框 send_keys(keysToSend) 发送文本至警告框。keysToSend：将文本发送至警告框 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"解析库","slug":"解析库","permalink":"https://ahrilove.top/tags/%E8%A7%A3%E6%9E%90%E5%BA%93/"}]},{"title":"兄弟萌！枯啦，要恰不了饭了","slug":"恰饭危机","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-08T10:49:29.305Z","comments":true,"path":"2019/12/08/恰饭危机/","link":"","permalink":"https://ahrilove.top/2019/12/08/%E6%81%B0%E9%A5%AD%E5%8D%B1%E6%9C%BA/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，怎么办？我要枯啦，要恰不了饭了，要吃红牌出场了","text":"&nbsp;&nbsp;&nbsp;&nbsp;兄弟萌，怎么办？我要枯啦，要恰不了饭了，要吃红牌出场了 最近一直没有什么活干，每天就是混吃等死，建彬哥说也没有什么我能做的项目，呀！糟了呀，以前一直打趣说“你有你的好果子吃”，现在才明白过来，原来是我才没有好果子吃。而且就目前的市场和我最近咸鱼，我也感觉我要直接吃红牌了，看不到生活的希望（55555。。。）算了吧！！走一步算一步，做好心理准备，每天使劲多学一些，也不至于打包回家的时候那么狼狈，现在回想起来，15年做决定的时候是不是选对了？是当时脑瘫了？","categories":[{"name":"随笔","slug":"随笔","permalink":"https://ahrilove.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"探究密码加salt原理以及PHP防止SQL注入","slug":"浅谈密码加盐原理","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-08T14:01:25.487Z","comments":true,"path":"2019/12/08/浅谈密码加盐原理/","link":"","permalink":"https://ahrilove.top/2019/12/08/%E6%B5%85%E8%B0%88%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%8E%9F%E7%90%86/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，一些小网站，小公司对于用户的账号密码很大概率是对其进行散列处理。我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如某MD5密码破解网站），得到某用户的密码。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，一些小网站，小公司对于用户的账号密码很大概率是对其进行散列处理。我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如某MD5密码破解网站），得到某用户的密码。 1.加salt原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，以确定密码是否正确。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的“佐料”被称作“Salt值”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。 2.加密示例（以PHP为例，python同理调用hashlib库）12345678&lt;?phpfunction hash($a) &#123; $salt=”Random_KUGBJVY”; //定义一个salt值，程序员规定下来的随机字符串 $b=$a.$salt; //把密码和salt连接, $b=md5($b); //执行MD5散列 return $b; //返回散列 &#125;?&gt; 这里的加salt处理方式有很多种，程序员按要求自定义，比如： 12345$salt=”Random_KUGBJVY”;$b=$a.$salt;$b1=$salt.$a.$salt;$b2=$salt.md5($a.$salt);... 调用方式：$new_password=hash($_POST[password]); //这里接受表单提交值，并进行加密 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户注册时：用户输入【账号】和【密码】（以及其他用户信息）；系统为用户生成【Salt值】；系统将【Salt值】和【用户密码】连接到一起；对连接后的值进行散列，得到【Hash值】；将【Hash值1】和【Salt值】分别放到数据库中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户登录时：用户输入【账号】和【密码】；系统通过用户名找到与之对应的【Hash值】和【Salt值】；系统将【Salt值】和【用户输入的密码】连接到一起；对连接后的值进行散列，得到【Hash值2】（注意是即时运算出来的值）；比较【Hash值1】和【Hash值2】是否相等，相等则表示密码正确，否则表示密码错误。有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值 3.php基本语法知识,参考FioraLove的GitHub 1.为什么要使用PDO：增加数据库连接扩展，是程序连接数据库的方法之一 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PDO是PHP5新加入的一个重大功能，我们的数据库服务器为MySQL，所有的程序代码的数据库操作全是一mysql(）或者mysqli()函数来操作，当我们的数据库 需要更换时比如换成，SQL、SERVER、PostgreSQL、MS 等，我们不可能去修改所有的程序代码！所以就要用到PDO，PDO很好的帮我们解决了这个问题，使用PDO操作非常方便，只需要修改数据源格式，和加载相应的驱动文件到PHP.ini即可； 2.PDO连接数据库`PDO(php data object)连接MySQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 方式一：借由mysqli &lt;?php $servername = 'localhost'; $username = 'username'; $password = 'password'; $db_name = 'NMSL'; // 创建连接 $conn = mysqli($servername, $username, $password,$db_name); // 检测连接 if (!$conn) &#123; die(\"Connection failed: \" . mysqli_error()); &#125; echo \"连接成功\"; ?&gt; 方式二：PDO $DSN = 'mysql:host=localhost;dbname=demo;charset=utf-8'; $pdo = new PDO($DSN,'username','password'); // 表示已连接了数据库 ``` &gt;3.设置PDO在处理数据的过程中采用什么方式去处理 ```html setAttribute()方法是设置部分属性，主要属性有：PDO::ATTR_CASE、PDO::ATTR_ERRMODE等，我们设置的是PDO::ATTR_CASE(使用关联索引获取数据) PDO::ATTR_CASE：强制列名为指定的大小写。他的$value可为： PDO::CASE_LOWER：强制列名小写。 PDO::CASE_NATURAL：保留数据库驱动返回的列名。 PDO::CASE_UPPER：强制列名大写。 PDO::ATTR_ERRMODE：错误报告。他的$value可为： PDO::ERRMODE_SILENT： 仅设置错误代码。 PDO::ERRMODE_WARNING: 引发 E_WARNING 错误 PDO::ERRMODE_EXCEPTION: 抛出 exceptions 异常。 PDO::ATTR_ORACLE_NULLS （在所有驱动中都可用，不仅限于Oracle）： 转换 NULL 和空字符串。他的$value可为： PDO::NULL_NATURAL: 不转换。 PDO::NULL_EMPTY_STRING： 将空字符串转换成 NULL 。 PDO::NULL_TO_STRING: 将 NULL 转换成空字符串。``` &gt; 4.数据库操作：exec(不返回数据集，即insert，update，delete)与query(仅执行带结果返回的，即select)方法```html &lt;?php /* 连接数据库*/ $DSN = 'mysql:host=localhost;dbname=demo;charset=utf-8'; $pdo = new PDO($DSN,'username','password'); /* 删除 FRUIT 数据表中满足条件的所有行~exec方法 */ $count = $pdo-&gt;exec(\"DELETE FROM fruit WHERE colour = 'red'\"); /* 返回被删除的行数 */ print(\"Deleted $count rows.\\n\"); ?&gt; 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"salt","slug":"salt","permalink":"https://ahrilove.top/tags/salt/"},{"name":"PHP","slug":"PHP","permalink":"https://ahrilove.top/tags/PHP/"}]},{"title":"HTML+CSS易忘点","slug":"html与css","date":"2019-12-05T16:00:00.000Z","updated":"2020-01-20T03:50:41.466Z","comments":true,"path":"2019/12/06/html与css/","link":"","permalink":"https://ahrilove.top/2019/12/06/html%E4%B8%8Ecss/","excerpt":"HTML是网页内容的载体,CSS样式是表现,JavaScript是用来实现网页上的特效效果与交互。总结自己遇到的一些知识点，查漏补缺，学习犹如逆水行舟，不进则退。","text":"HTML是网页内容的载体,CSS样式是表现,JavaScript是用来实现网页上的特效效果与交互。总结自己遇到的一些知识点，查漏补缺，学习犹如逆水行舟，不进则退。 1.HTML的音视频播放1.1 HTML视频Video播放最好的 HTML 解决方法：以下实例中使用了 4 种不同的视频格式。HTML 5 &lt;video&gt; 元素会尝试播放以 mp4、ogg 或 webm 格式中的一种来播放视频。如果均失败，则回退到 &lt;embed&gt; 元素。 HTML5 + &lt;object&gt; +&lt;embed&gt;mp3文件路径为相对路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!--创建固定宽高的播放器标签--&gt;&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; &lt;source src=\"movie.webm\" type=\"video/webm\"&gt; &lt;object data=\"movie.mp4\" width=\"320\" height=\"240\"&gt; &lt;embed src=\"movie.swf\" width=\"320\" height=\"240\"&gt; &lt;/object&gt;&lt;/video&gt;``` 拓展：js与DOM操作设置视频播放器的功能（视频暂停，缩小，放大）```html &lt;div style=\"text-align:center\"&gt; &lt;button onclick=\"playPause()\"&gt;播放/暂停&lt;/button&gt; &lt;button onclick=\"makeBig()\"&gt;放大&lt;/button&gt; &lt;button onclick=\"makeSmall()\"&gt;缩小&lt;/button&gt; &lt;button onclick=\"makeNormal()\"&gt;普通&lt;/button&gt; &lt;br&gt; &lt;video id=\"video1\" width=\"420\"&gt; &lt;source src=\"mov_bbb.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"mov_bbb.ogg\" type=\"video/ogg\"&gt; 您的浏览器不支持 HTML5 video 标签。 &lt;/video&gt; &lt;/div&gt; &lt;script&gt; var myVideo=document.getElementById(\"video1\"); function playPause() &#123; if (myVideo.paused) myVideo.play(); else myVideo.pause(); &#125; function makeBig() &#123; myVideo.width=560; &#125; function makeSmall() &#123; myVideo.width=320; &#125; function makeNormal() &#123; myVideo.width=420; &#125; &lt;/script&gt; 1.2 audio音频文件的播放设置src:MP3文件为相对路径 12345&lt;audio controls style=\"height:100px; width=100px\"&gt; &lt;source src=\"../static_audio/yiluxiangbei.mp3\" type=\"audio/mpeg\"&gt; &lt;source src=\"../static_audio/yiluxiangbei.ogg\" type=\"audio/ogg\"&gt; &lt;embed height=\"50\" width=\"100\" src=\"../static_audio/yiluxiangbei.mp3\"&gt;&lt;/audio&gt; &lt;audio&gt;标签的属性值有： autoplay：如果设置该属性，音频将自动播放，值为：autoplay； controls：如果设置该属性，则显示音频控件（播放/暂停按钮），值：controls； loop：如果设置该属性，则音频重复播放，值为：loop； muted：如果设置该属性，则音频输出为静音，值：muted； preload：规定当网页加载时，音频是否默认被加载以及如何被加载。值：auto/metadata/none； src：规定音频文件的地址； 2.CSS的易混易错点 -1.css样式的overflow-x：对边框中的溢出的内容进行隐藏 123div&#123; overflow-x:hidden;&#125; -2. -webkit-text-size-adjust:none :禁用Webkit内核浏览器的文字大小调整功能 123456故-webkit-text-size-adjust的用法如下：1、当样式表里font-size&lt;12px时，中文版chrome浏览器里字体显示仍为12px，这时可以用 html&#123;-webkit-text-size-adjust:none;&#125;2、-webkit-text-size-adjust放在body上会导致页面缩放失效3、body会继承定义在html的样式4、用-webkit-text-size-adjust不要定义成可继承的或全局的———————————————— -3. display用于设置元素的外部或者内部显示类型 外部定义了在流式布局中如何展示，内部显示类型定义了元素内子元素的布局方式。 -4. CSS中, padding: 0px 0px 0px 0px; 四个0px分别代表什么? padding: 0px 0px 0px 0px; 按顺序分别表示上填充、右填充、下填充、左填充为0px。对应着：padding-top:0px;padding-right:0px;padding-bottom:0px;padding-left:0px; -5. css:background背景样式 12345678910111213141516background-color：背景颜色background-image：背景图片 -- body&#123; background-image:url(&apos;相对路径URL&apos;); &#125;background-repeat：背景样式是否重复 --background-repeat:repeat-x;水平方向重复 --background-repeat:repeat-y;垂直方向重复background-attachment：设置背景图像是否固定或者随着页面的其余部分滚动 --：scroll 默认值，背景随着滚动而滚动 --：fixed 固定图像，不随页面滚动而滚动background-position：right top left bottom (可多个组合)background-size: 规定背景图像的尺寸(100%表示全局展示图片) 拓：背景图片自适应窗口大小案例 123456789101112&lt;!--背景图片自适应窗口大小--&gt;&lt;head&gt;&lt;style&gt; body&#123; background-image: url(./public/images/5bbd6378a1fdc.jpg); background-repeat: no-repeat; background-attachment: fixed; background-size: 100%; position: relative; // 可以选择不写 &#125;&lt;/style&gt;&lt;/head&gt; -6 CSS：text-align：文本对齐方式 12345text-align： left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 inherit 规定应该从父元素继承 text-align 属性的值。 -7 设置字体大小： 方式一：1em的默认大小是16px方式二：px（像素）方式三：百分比 -8 overflow: 显示滚动条 visible 默认值。超出部分呈现在元素框外面 hidden 裁剪超出部分 scroll 一直显示滚动条，超出部分滚动可见 auto 当超出元素框后，显示滚动条，超出部分滚动可见 inherit 从父元素继承overflow属性做一个简单的小demo： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-image: url(\"../public/images/5927f2c7269aa.jpg\"); background-attachment: fixed; background-size: 100%; &#125; div.ex1 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: scroll; &#125; div.ex2 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: hidden; &#125; div.ex3 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: auto; &#125; div.ex4 &#123; background-color: lightblue; width: 110px; height: 110px; overflow: visible; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;overflow 属性&lt;/h1&gt;&lt;p&gt;如果元素中的内容超出了给定的宽度和高度属性，overflow 属性可以确定是否显示滚动条等行为。&lt;/p&gt;&lt;h2&gt;overflow: scroll:&lt;/h2&gt;&lt;div class=\"ex1\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;h2&gt;overflow: hidden:&lt;/h2&gt;&lt;div class=\"ex2\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;h2&gt;overflow: auto:&lt;/h2&gt;&lt;div class=\"ex3\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;h2&gt;overflow: visible (默认):&lt;/h2&gt;&lt;div class=\"ex4\"&gt;永州之野产异蛇：黑质而白章，触草木尽死；以啮人，无御之者。然得而腊之以为饵，可以已大风、挛踠、瘘疠，去死肌，杀三虫。其始太医以王命聚之，岁赋其二。募有能捕之者，当其租入。永之人争奔走焉。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Demo展示：这里实现了背景图片的应用，以及css的overflow属性 -9.&lt;img&gt;标签 -和h系列标签/p标签还有hr标签不一样，img标签不会独占一行，如果我们手动指定了img标签显示的图片的宽度和高度，有可能会导致图片变形，那么如果又想指定宽度和高度，&lt;img src=”当前电脑图片的路径” width=”200px” height=”200px” /&gt; 又不想让图片发生变形，我们可以只指定宽度或者高度其中的一个值即可 -只要指定了宽度，系统会自动根据宽度计算出高度，只要指定了高度，系统会自动根据高度计算出宽度，并且都是等比拉伸的，也就是说不会变形：&lt;img src=”当前电脑图片的路径” width=”200px” /&gt;&lt;img src=”当前电脑图片的路径” height=”200px” /&gt; 10.postion属性 postion:relative是相对定位:是相对于前面的容器定位的。这个时候不能用top left在定位,应该用margin。它可以随窗口大小变化。但大小仍然不会变。要是你设置成width:100%;height:100%;这样就会随着窗口变大变小postion:absolute是绝对定位:是相对于浏览器的定位，释放自己的位置，以网页坐标原点做一个新的坐标，它不会随着窗口大小变化，只是固定在一个特定的坐标轴上比如：position：absolute；left:20px;top:80px; 这个容器始终位于距离浏览器左20px,距离浏览器上80px的这个位置。 11.CSS spirit css精灵 CSS Image Sprites. ❮ Previous Next ❯: An image sprite is a collection of images put into a single image. A web page with many images can take a long time to load and generates multiple server requests. Using image sprites will reduce the number of server requests and save bandwidth 12345/*Code sample:*/ .box&#123; width: 46px; height: 44px; background: url(img_navsprites.gif) -x -y(这两个参数分别表示：向左，向上平移，均用负数表示); &#125; 12.HTML如何给网页添加ico图标: 在head标签中添加：href表示ico文件的相对路径&lt;link rel=”Bookmark” type=”image/x-icon” href=”b/img/icon/favicon.ico” /&gt;&lt;link rel=”icon” type=”image/x-icon” href=”b/img/icon/favicon.ico” /&gt;&lt;link rel=”shortcut icon” type=”image/x-icon” href=”b/img/icon/favicon.ico” /&gt;(推荐) shortcut icon，特指浏览器中地址栏左侧显示的图标，一般大小为16x16，后缀名为.icon；icon，指的是图标，格式可为PNG\\GIF\\JPEG，尺寸一般为16x16、24x24、36x36等。把这个图标放到网站的根目录下就可以了，页面加载时浏览器会自动检索这个图标然后把它加到标题上（当然也可以放在一个页面可以请求到的目录下）。Bookmark，当网站收藏到收藏夹中时，显示在前面的图标。———————————————— 13.readme文件的伪徽章样式,参考代码 14.表单form标签 &lt;input&gt;标签 定义通用的表单元素,其type类型为： type=”text” 定义单行文本输入框 type=”password” 定义密码输入框 type=”radio” 定义单选框 type=”checkbox” 定义复选框 type=”file” 定义上传文件 form表单需要加上属性enctype=”multipart/form-data” type=”submit” 定义提交按钮 type=”reset” 定义重置按钮 type=”button” 定义一个普通按钮 相关属性介绍： value属性 定义表单元素的值,此值是数据提交时键的值 name属性 定义表单元素的名称，此名称是提交数据时的键名 checked: radio 和 checkbox 默认被选中 readonly: 只读. text 和 password disabled: 对所用input都好使.举一个案例：123456789101112131415161718192021222324252627282930313233343536&lt;body&gt;&lt;!--action 定义表单数据提交地址--&gt;&lt;form action=\"http://127.0.0.1:8000/post_info\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;!--单行文本框--&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入账号\"&gt;&lt;br&gt;&lt;br&gt; &lt;!--密码框--&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\"&gt;&lt;br&gt;&lt;br&gt; &lt;!--单选框--&gt; 性别：&lt;label&gt;&lt;input type=\"radio\" name=\"sex\" value=\"1\"&gt;男&lt;/label&gt; &lt;label&gt;&lt;input type=\"radio\" name=\"sex\" value=\"2\"&gt;女&lt;/label&gt; &lt;!--多选框--&gt; &lt;br&gt;&lt;br&gt; 最喜欢的游戏： &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"LOL\"&gt;英雄联盟&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"shoot\"&gt;喷射战士&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"zelder\"&gt;塞尔达传说&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"fav\" value=\"mario\"&gt;马里奥&lt;/label&gt; &lt;!--上传图片--&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"file\" name=\"pic\"&gt; &lt;!--多行文本框--&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=\"text\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;!--下拉列表--&gt; &lt;br&gt;&lt;br&gt; &lt;select name=\"city\"&gt; &lt;option value=\"gz\"&gt;广州&lt;/option&gt; &lt;option value=\"sz\"&gt;深圳&lt;/option&gt; &lt;option value=\"zh\"&gt;中山&lt;/option&gt; &lt;/select&gt; &lt;!--提交表单--&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;!--重置表单--&gt; &lt;input type=\"reset\" value=\"重置\"&gt;&lt;/form&gt;&lt;/body&gt; tips：1.HTML下的表单标签中的&lt;input&gt;便签的value属性：定义表单元素的值,此值是数据提交时键的值2.单选框radio与多选框checkbox的name，type属性必须要全部一样，value值可以不一样，因为value值定义表单元素的值,此值是数据提交时键的值","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://ahrilove.top/tags/html/"},{"name":"css","slug":"css","permalink":"https://ahrilove.top/tags/css/"}],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Python全栈系列章节更新（六）：装饰器","slug":"Python全栈系列章节更新（六）装饰器","date":"2019-12-04T16:00:00.000Z","updated":"2019-12-05T01:01:36.547Z","comments":true,"path":"2019/12/05/Python全栈系列章节更新（六）装饰器/","link":"","permalink":"https://ahrilove.top/2019/12/05/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AD%EF%BC%89%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让爬虫像人一样打卡工作，工作还得有快有慢，wtf，想了半天，写个装饰器算了，也顺便复习下装饰器，也能基本能满足需求：其实也可以使用1.轻量级的Python定时任务调度框架（APSchedule库）2.Linux的定时任务3.文件数多，还要做监控和扩展之类的话，用 Flask 写一个服务，将 Apscheduler 和 Scrapyd 继承到服务中，这样就是一个完整的爬虫项目部署和调度管理平台了","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让爬虫像人一样打卡工作，工作还得有快有慢，wtf，想了半天，写个装饰器算了，也顺便复习下装饰器，也能基本能满足需求：其实也可以使用1.轻量级的Python定时任务调度框架（APSchedule库）2.Linux的定时任务3.文件数多，还要做监控和扩展之类的话，用 Flask 写一个服务，将 Apscheduler 和 Scrapyd 继承到服务中，这样就是一个完整的爬虫项目部署和调度管理平台了 装饰器原理：不修改已实现的功能代码块，不改变原函数调用方式，只对现有功能进行扩展 装饰器案例举一个简单的装饰器 12345678910111213141516171819def test(func): # 装饰器接受一个函数作为参数，并返回一个函数 def wrapper(*args, **kwargs): # (*args, **kwargs)表示带参数的装饰器 print('call %s(): ' % func.__name__) # 魔法函数，返回函数名 func(*args, **kwargs) return wrapper@test # 运用@语法把装饰器放置在函数定义处def now(a,b): print(\"%s:%s\"%(a,b))if __name__ == '__main__': now(\"hello\",\"world\") \"\"\" :return call now(): hello:world \"\"\" 爬虫波动性工作装饰器函数1234567891011121314151617181920212223242526272829303132333435import time,datetime,randomdef jobstatus(func): \"\"\" 爬虫的工作状态装饰器 周一至周五 09:00-18:00 小时数是偶数 每分钟请求30次左右 小时数是奇数 每分钟请求10次左右 其余时间等待 \"\"\" def inner(*args, **kwargs): while 1: week_now = datetime.datetime.now().weekday() hour_now = datetime.datetime.now().hour # 14 # 判断当前星期是否为工作日 if week_now in list(range(1,6)): # 判断当前时间是否为工作时间 if 9 &lt;= hour_now &lt;= 18: if hour_now % 2 == 0: time.sleep(random.choice([1,2])) return func(*args, **kwargs) else: time.sleep(random.choice([3,4])) return func(*args, **kwargs) else: # time.sleep(3600*16) # 休眠24小时 else: time.sleep(86400) return inner","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"https://ahrilove.top/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"定时任务","slug":"定时任务","permalink":"https://ahrilove.top/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"Echarts","slug":"echarts","date":"2019-12-04T16:00:00.000Z","updated":"2020-01-04T03:44:27.751Z","comments":true,"path":"2019/12/05/echarts/","link":"","permalink":"https://ahrilove.top/2019/12/05/echarts/","excerpt":"简而言之，百度Echarts真的是数据展示的神器，官方给出的实例就能够满足实际基本要求 1.echarts创建实例2.","text":"简而言之，百度Echarts真的是数据展示的神器，官方给出的实例就能够满足实际基本要求 1.echarts创建实例2. 1.引入ECharts通过标签方式直接引入构建好的 echarts 文件 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 2.为 ECharts 准备一个具备高宽的 DOM 容器1234&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;&lt;/body&gt; 3. echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图完整案例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=\"main\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.异步加载123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/body&gt; &lt;div id=\"pie\" style=\"width: 600px;height:400px;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt;var myChart1 = echarts.init(document.getElementById('pie'));myChart1.showLoading();setInterval(function()&#123; myChart1.hideLoading(); &lt;!---这里面进行数据绑定与实例化图表 --&gt; myChart1.setOption(&#123; series : [ &#123; name: '访问来源', type: 'pie', radius: '55%', data:[ &#123;value:235, name:'视频广告'&#125;, &#123;value:274, name:'联盟广告'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:335, name:'直接访问'&#125;, &#123;value:400, name:'搜索引擎'&#125; ] &#125; ] &#125;);&#125;,1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5.移动端自适应1.为Echarts准备一个具有宽高(有一个即可)的DOM，推荐使用bootstrap的栅栏系统来设置布局2.大部分的组件和系列的left/right/top/bottom/width/height的定位方式 绝对值，用number形式书写（已经固定写死了浏览器的像素） 百分比，表示占DOM容器的宽高的百分之多少，用string形式书写 位置描述，即center（水平居中），middle（垂直居中） 6.echarts小知识点 legend默认不显示某些图例(selected属性) selected属性将目标图例设置为false 12345678legend: &#123; show: &apos;&apos;, icon:&quot;circle&quot;, //更改图列的默认样式 （ &apos;circle&apos;, &apos;rect&apos;, &apos;roundRect&apos;, &apos;triangle&apos;, &apos;diamond&apos;, &apos;pin&apos;, &apos;arrow&apos;）（全部的图例类型改变） selected:&#123; &quot;上期增长率&quot;:false //图例为‘上期增长率’的一项默认置灰 &quot;同比增长率&quot;:false //图例为‘同比增长率’的一项默认置灰 &#125;&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://ahrilove.top/tags/echarts/"}]},{"title":"Python全栈系列章节更新（五）：并发编程~多线程","slug":"Python全栈系列章节更新（五）","date":"2019-12-03T16:00:00.000Z","updated":"2019-12-23T02:25:40.545Z","comments":true,"path":"2019/12/04/Python全栈系列章节更新（五）/","link":"","permalink":"https://ahrilove.top/2019/12/04/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"线程顾名思义，就是一条流水线工作的过程（流水线的工作需要电源，电源就相当于cpu），而一条流水线必须属于一个车间，一个车间的工作过程是一个进程，车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一条流水线。所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.线程与进程的区别2.为何会选择多线程3.创建多线程的方式4.线程对象的属性和方法5.守护线程6.线程池与进程池7.多线程，到底该设置多少个线程？","text":"线程顾名思义，就是一条流水线工作的过程（流水线的工作需要电源，电源就相当于cpu），而一条流水线必须属于一个车间，一个车间的工作过程是一个进程，车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一条流水线。所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.线程与进程的区别2.为何会选择多线程3.创建多线程的方式4.线程对象的属性和方法5.守护线程6.线程池与进程池7.多线程，到底该设置多少个线程？ 1.线程与进程的区别1、每启动一个进程，进程内都至少有一个线程。 2、进程本身只是一个资源调度集合，并不能真正执行，进程内开的线程才是真正的运行单位。 3、一个进程内可以启动多个线程，同一进程内线程间共享资源。 4、启动线程的开销远远小于开进程。 5、线程可以相当程度控制相同进程下的线程，进程只能控制其子进程。 6、对主线程的更改（取消、优先级更改等）可能会进程的其他线程的行为；对父进程的修改则不会影响子进程。 7、进程之间是竞争关系，线程之间是协作关系 2.为何会选择多线程？ 同一个进程内的多个线程共享该进程内的地址资源 线程比进程更轻量级，线程比进程更容易创建可撤销 3.创建线程的方式12345678910111213141516171819import time, randomfrom threading import Threaddef piao(name): print('%s piaoing' % name) time.sleep(random.randrange(1, 5)) print('%s piao end' % name)if __name__ == '__main__': t1 = Thread(target=piao, args=('egon', )) t1.start() # 主线程向操作系统发信号，又开了一个线程 print(\"主线程\") # 执行角度看是主线程，从资源角度看是主进程# 这个程序总体是一个进程、两个线程\"\"\"egon piaoing主线程egon piao end\"\"\" 4.线程对象的属性和方法 4.1 Thread实例对象的方法 isAlive():返回线程是否活动的getName():返回线程名setName():设置线程名 5.守护线程守护线程守护主线程，等到主线程死了才会被销毁。在有其他线程的情况下，主线程代码运行完后，等其他非守护线程结束，守护线程才会死掉。 无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行。运行完毕的真正含义： 1、对主进程来说，运行完毕指的是主进程代码运行完毕。 2、对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才能运行完毕。 6.进程池和线程池进程池和线程池的接口一模一样，用法也一样。池就是要对数目加以限制，保证机器一个可承受的范围，以一个健康的状态保证它的运行基本方法：1、submit(fn, args, *kwargs)异步提交任务 2、map(func, *iterables, timeout=None, chunksize=1)取代for循环submit的操作 3、shutdown(wait=True)相当于进程池的pool.close()+pool.join()操作wait=True，等待池内所有任务执行完毕回收完资源后才继续wait=False，立即返回，并不会等待池内的任务执行完毕但不管wait参数为何值，整个程序都会等到所有任务执行完毕submit和map必须在shutdown之前 4、result(timeout=None)取得结果 5、add_done_callback(fn)回调函数 进程池 1234567891011121314151617181920212223242526from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutorimport os, time, randomdef task(name): print(\"name: %s pid: %s run\" % (name, os.getpid())) time.sleep(random.randint(1,3))if __name__ == '__main__': pool = ProcessPoolExecutor(4) # 指定进程池大小，最大进程数，如果不指定默认是CPU核数 for i in range(10): \"\"\"从始至终四个进程解决这10个任务，谁没事了接新任务\"\"\" pool.submit(task, 'egon%s' %i) # 提交任务的方式————异步调用：提交完任务，不用在原地等任务执行拿到结果。 print(\"主进程\")\"\"\"name: egon0 pid: 12445 runname: egon1 pid: 12444 runname: egon2 pid: 12446 runname: egon3 pid: 12447 run主进程name: egon4 pid: 12445 runname: egon5 pid: 12444 runname: egon6 pid: 12446 run\"\"\" shutdown()方法的使用 12345678910111213141516171819202122232425from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutorimport os, time, randomdef task(name): print(\"name: %s pid: %s run\" % (name, os.getpid())) time.sleep(random.randint(1,3))if __name__ == '__main__': pool = ProcessPoolExecutor(4) # 指定进程池大小，最大进程数，如果不指定默认是CPU核数 for i in range(10): \"\"\"从始至终四个进程解决这10个任务，谁没事了接新任务\"\"\" pool.submit(task, 'egon%s' %i) # 提交任务的方式————异步调用：提交完任务，不用在原地等任务执行拿到结果。 pool.shutdown() # 把提交任务入口关闭，默认参数wait=True；同时还进行了pool.join()操作，等任务提交结束，再结束主进程 print(\"主进程\")\"\"\"name: egon0 pid: 12502 runname: egon1 pid: 12503 run....name: egon9 pid: 12505 run主进程\"\"\" 7.多线程，到底该设置多少个线程？那我们如何分配线程？我们提供一个公式： 最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 备注：这个公式也是前辈们分享的，当然之前看了淘宝前台系统优化实践的文章，和上面的公式很类似，不过在CPU数目那边，他们更细化了，上面的公式只是参考。不过不管什么公式，最终还是在生产环境中运行后，再优化调整。 我们继续上面的任务，我们的服务器CPU核数为4核，一个任务线程cpu耗时为20ms，线程等待（网络IO、磁盘IO）耗时80ms，那最佳线程数目：( 80 + 20 )/20 * 4 = 20。也就是设置20个线程数最佳。 从这个公式上面我们就得出，线程的等待时间越大，线程数就要设置越大，这个正好符合我们上面的分析，可提升CPU利用率。那从另一个角度上面说，线程数设置多大，是根据我们自身的业务的，需要自己去压力测试，设置一个合理的数值。 基础常规标准 我们可以尝试去猜想，因为很多业务集中到一个线程池中，不像上面的案例比较简单，事实上业务太多，怎么设置呢？这个就是要去压力测试去调整。不过我们的前辈已经帮我们总结了一个基础的值（最终还是要看运行情况自行调整） 1、CPU密集型：操作内存处理的业务，一般线程数设置为：CPU核数 + 1 或者 CPU核数*2。核数为4的话，一般设置 5 或 8 2、IO密集型：文件操作，网络操作，数据库操作，一般线程设置为：cpu核数 / (1-0.9)，核数为4的话，一般设置 40","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://ahrilove.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Python全栈系列章节更新（四）：并发编程~多进程","slug":"并发编程（多进程）","date":"2019-12-03T16:00:00.000Z","updated":"2019-12-04T12:51:06.647Z","comments":true,"path":"2019/12/04/并发编程（多进程）/","link":"","permalink":"https://ahrilove.top/2019/12/04/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89/","excerpt":"","text":"1.进程与程序程序仅仅是一堆代码，进程指的是程序的运行过程注意：同一个程序执行两次，也是两个进程进程：正在进行的一个过程，是一个任务，或者说是一个资源调度的集合。 2.并发与并行无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真实干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务。 一、并发：伪并行，即看起来多个进程像在同时运行。单个cpu+多道技术可实现并发。 二、并行：多个进程同时运行，只有具备多个cpu才能实现。 3.多进程的创建：Process类注意：在windows中Process()必须放到# if __name__ == &#39;__main__&#39;:下进程创建格式：target表示函数名，args=(参数一,参数二,…,)，参数最后一定要保留一个逗号p = Process(target=task, args=(‘子进程1’,)) 123456789101112131415from multiprocessing import Processimport timedef task(name): print(\"%s is running\" % name) time.sleep(3) print(\"%s is done\" % name) if __name__ == '__main__': # 创建进程 p = Process(target=task, args=('子进程1',)) # 得到对象 # 启动进程 p.start() print(\"这是主进程\") 3.1 Process类的方法和属性介绍 方法 详解 p.start()： 启动进程，并调用该子进程中的p.run() p.run(): 进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 p.terminate(): 强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 p.is_alive(): 如果p仍然运行，返回True p.join([timeout]): 主线程等待p线程终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间 Process属性 详解 p.daemon： 默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置 p.name: 进程的名称 p.pid： 进程的pid p.exitcode: 进程在运行时为None、如果为–N，表示被信号N结束(了解即可) p.authkey: 进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串 3.2 进程之间的内存空间是隔离的3.3 Process对象的join方法 join方法：优先运行子进程，主进程卡在原地，子进程结束后，运行主进程后面的代码。案例如下： 1234567891011121314151617181920from multiprocessing import Processimport time, osdef task(): print('%s is running, parent id is &lt;%s&gt;' % (os.getpid(), os.getppid())) # 进程和父进程查看方式 time.sleep(3) print(\"%s is done, parent id is &lt;%s&gt;\" % (os.getpid(), os.getppid()))if __name__ == '__main__': p = Process(target=task, ) p.start() p.join() # 优先运行子进程，主进程卡在原地 print('主进程', os.getpid(), 'pycharm ID', os.getppid()) print(p.pid) # 子进程运行完，变为僵尸进程，主进程仍能够查到子进程的pid，当主进程结束后，所有僵尸子进程将被丢掉。\"\"\"is running, parent id is &lt;827&gt;is done, parent id is &lt;827&gt;主进程 827 pycharm ID 504\"\"\" 使用join方法实现并发执行 12345678910111213141516171819202122232425262728from multiprocessing import Processimport timedef task(name ,n): print('%s is running' % name) time.sleep(n)if __name__ == '__main__': start = time.time() p1 = Process(target=task, args=(\"子进程1\",5,)) p2 = Process(target=task, args=(\"子进程2\",3,)) p3 = Process(target=task, args=(\"子进程3\",2,)) p1.start() p2.start() p3.start() # 再添加join函数前，主程序的执行输出次序是完全随机的，需要加join()保证主程序等到在子进程之后执行完成 p1.join() p2.join() p3.join() # 以上并非串行执行，实际是并发执行，只是约束了主程序要等在子程序后结束 # print('主进程', os.getpid(), 'pycharm ID', os.getppid()) print(\"主进程\", (time.time()-start))\"\"\"子进程1 is running子进程2 is running子进程3 is running主进程 5.010260343551636 # 主程序只等了5秒，说明确实是并发执行\"\"\" 使用join方法实现多进程串行执行 123456789101112131415161718from multiprocessing import Processdef task(name ,n): passif __name__ == '__main__': p1 = Process(target=task, args=(\"子进程1\",5)) p2 = Process(target=task, args=(\"子进程2\",3)) p3 = Process(target=task, args=(\"子进程3\",2)) # 串行执行 p1.start() p1.join() p2.start() p2.join() p3.start() p3.join() print(\"我是主进程\") 4.守护进程主进程创建守护进程： 一：守护进程会在主进程代码执行结束后就终止，主进程代码运行结束，守护进程立即死亡 二：守护进程内无法再开启子进程,否则抛出异常 12345if __name__ == &apos;__main__&apos;: p = Process(target=task, args=(&apos;子进程&apos;, )) p.daemon=True # 守护进程一定要在进程开启前,即p.start()开启前设置 p.start() print(&quot;我是主进程&quot;) 4.互斥锁进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,而共享带来的是竞争，竞争带来的结果就是错乱互斥锁的原理：就是把并发改成穿行，降低了效率，但保证了数据安全不错乱 1234567891011def task(): # 获得锁 lock.acquire() ... # 释放锁 lock.release()if __name__ == &apos;__main__&apos;: lock = Lock() # 只实例化一次，并传给子进程，要保证所有进程用同一把锁 for i in range(3): p = Process(target=task, args=(&apos;进程%s&apos; % i, lock,)) # 传递给子进程的锁 p.start() 5.队列进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的 队列的创建 Queue（maxsize）：创建队列中允许的最大项数 队列的主要方法 q.put(value)方法用以插入数据到队列中。q.get(value)方法可以从队列读取并且删除一个元素。q.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。q.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样q.close():关闭队列PS:使用q.get()从空队列中再取值时与使用q.put()在队列为满时继续插入数据，都会出现程序卡在原地的结果 队列的使用 123456789101112131415161718from multiprocessing import Queue# 队列中应该放消息，不应该放大文件大数据# 队列可以不设置长度，但是队列是受制于内存大小的，不可能无限存放q = Queue(3) # 指定队列大小q.put('hello')q.put(&#123;'a': 1&#125;)q.put([3,3,3,])print(q.full()) # 查看队列是否满了 # True# q.put(123) # 队列满了再往里面放时，被锁住，只能在原地卡着。print(q.get()) # helloprint(q.get()) # &#123;'a':1&#125;print(q.get()) # [3,3,3]print(q.empty()) # 判断队列是否全部清空 # True# print(q.get()) # 由于已经空了，程序也卡在原处","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"多进程","slug":"多进程","permalink":"https://ahrilove.top/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"}]},{"title":"sql语句关于时间的讨论","slug":"ThinkPHP(二)","date":"2019-12-03T16:00:00.000Z","updated":"2019-12-05T08:31:06.477Z","comments":true,"path":"2019/12/04/ThinkPHP(二)/","link":"","permalink":"https://ahrilove.top/2019/12/04/ThinkPHP(%E4%BA%8C)/","excerpt":"进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.oracle时间和日期的处理2.mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写","text":"进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源调度集合），而线程才是cpu上的执行单位 1.oracle时间和日期的处理2.mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写 1.oracle时间和日期的处理，详情请点击此处 1.字符串转换为日期时分秒格式：to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’) select to_date(‘20180831154546’, ‘yyyy-mm-dd hh24:mi:ss’) from dual;结果为：2018-08-31 15:45:46 2.获取系统时间 SELECT SYSDATE FROM dual; – 系统时间:2019-12-04 21:40:15 SELECT SYSTIMESTAMP FROM dual; – 当前系统时间戳:2019-12-04 21:40:41.328000 +08:00 3.时间类型与字符串相互转换 字符串转换为时间类型：to_date(字符串, ‘yyyy-mm-dd hh24:mi:ss’); 1234567891011121314151617181920212223-- 字符串转时间类型SELECT to_date('2018-08-23 00:00:00','yyyy-mm-dd hh24:mi:ss') FROM dual;-- 时间类型转字符串select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;select to_char(sysdate,'yyyy-mm-dd') from dual;``` &gt; 4.日期的加减如果时间要进行加减，和现在的时间或者某个目标时间进行比较。to_date(字符串, 'yyyy-mm-dd hh24:mi:ss')+1后面为1的时候就是加1天，2的时候就是加两天，如果加一个小时，就是为1/24，如果加一分钟，就是为1/24/60,...```sql-- 案例：select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1 from dual;-- 加一天 2019-02-19 23:59:00select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1/24 from dual;-- 加一个小时 2019-02-19 00:59:00select to_date('2019-02-18 23:59:00','yyyy-mm-dd hh24-mi-ss')+1/24/60 from dual;-- 加一分钟 2019-02-19 00:00:00 2.MySQL的时间与日期的处理 mysql 查询今天，昨天，本月，今年，本季度，上一年等的sql语句编写 – 今天SELECT 【想要的字段】 FROM 【表名】 WHERETO_DAYS(【时间字段名】) =TO_DAYS(now()); – 昨天SELECT 【想要的字段】 FROM 【表名】 WHERE TO_DAYS( NOW( ) ) - TO_DAYS(【时间字段名】) = 1; – 近七天SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;=DATE(【时间字段名】); – 本周内SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now()); – 上一周SELECT 【想要的字段】 FROM 【表名】 WHERE YEARWEEK(DATE_FORMAT(【时间字段名】,’%Y-%m-%d’)) = YEARWEEK(now())-1; – 30天内 注意这个不是本月是从当天起向前推30天SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;=DATE(【时间字段名】); – 本月SELECT 【想要的字段】 FROM 【表名】 WHERE DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) = DATE_FORMAT( CURDATE( ) , ‘%Y%m’ ); – 上一个月SELECT 【想要的字段】 FROM 【表名】 WHERE PERIOD_DIFF( DATE_FORMAT( now( ) , ‘%Y%m’ ) , DATE_FORMAT( 【时间字段名】, ‘%Y%m’ ) ) =1; – 本季度SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(now()); – 上一季度SELECT 【想要的字段】 FROM 【表名】 WHERE QUARTER(【时间字段名】)=QUARTER(DATE_SUB(now(),interval 1 QUARTER)); – 本年度SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(NOW()); – 上一年度SELECT 【想要的字段】 FROM 【表名】 WHERE YEAR(【时间字段名】)=YEAR(date_sub(now(),interval 1 YEAR)); - 未完待续。。。","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://ahrilove.top/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"https://ahrilove.top/tags/MySQL/"}]},{"title":"Python全栈系列章节更新（三）：数据库分批次处理和数据库通用连接函数","slug":"Python全栈系列章节更新（三）","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-13T11:24:53.449Z","comments":true,"path":"2019/12/03/Python全栈系列章节更新（三）/","link":"","permalink":"https://ahrilove.top/2019/12/03/Python%E5%85%A8%E6%A0%88%E7%B3%BB%E5%88%97%E7%AB%A0%E8%8A%82%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"数据库分批次处理:execute,executemany数据库通用连接函数数据库插入百万级数据优化","text":"数据库分批次处理:execute,executemany数据库通用连接函数数据库插入百万级数据优化 1.数据库通用连接函数（连接模块视实际数据库决定，大同小异）将其封装成一个新的python文件，以便可以重复调用，命名为SqlConnectManage.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True def executemany(self, sql,*args): print(\"-----插入数据-----\") try: self.cursor.executemany(sql,*args) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 2.数据分批次处理数据库分批次处理可以使用两种方法：execute()与executemany()方法 2.1 executemany()在使用executemany方法时，需要注意的几个问题： 1.在写sql语句时，不管字段为什么类型，占位符统一使用%s,且不能加上引号。例如 1sql=\"insert into tablename (id,name) values (%s,%s)\" 2.添加的数据的格式必须为元组型列表或元组型元组(并不是无限添加):list[tuple(),tuple(),tuple()]或者tuple(tuple(),tuple(),tuple())例如 123values=[(1,\"zhangsan\"),(2,\"lisi\")]#或者values=((1,\"zhangsan\"),(2,\"lisi\")) 3.最后通过executemany插入 12cursor.executemany(sql,values)connect.commit() 2.2 execute()execute()语法一次只能执行一个sql语句，分批次处理的原理是：循环执行批量语句，然后在commit，如下 12345for i in range(10): sql = \"insert into users(id,grand) values(i,i+10)\" cursor.execute(sql)# 批量执行数据后，然后提交 connect.commit() 3.数据库插入百万级数据优化,参考此文章：Python3 多线程(连接池)操作MySQL插入数据最近做一个项目，需要插入和读取很多数据，所以就需要对数据库大量插入操作进行优化，还是以python为基石，不过在开始动工前，需要明确以下几点：1.考虑是一条线程完整地执行数据库的连接、创建游标、然后插入数据、commit数据、断开连接这一系列操作，还是使用多线程执行获取数据的操作，然后单线程来插入整理好的数据？2.考虑是每执行一次insert，update或者delete，就执行一次commit，还是批量处理数据后，才执行一次commit3.数据执行语句execute()与executemany()的选择 对我而言，我的设计是调用数据库的通用数据池连接文件SqlConnectManage.py，将数据库的连接和关闭函数作为全局使用，放在程序的首尾（就相当于不会重复连接数据库，减少IO开销）然后创建多线程+队列的方式获取数据，以单线程形式来插入数据，批量处理数据后，才commit提交。案例如下： 123456789101112131415161718192021222324252627282930313233343536373839from SqlConnectManage import sqlserverManager# 创建全局连接和游标(这里暂时不用DBUtils库)DB_CONN = pymssql.connect(SERVER , USER , PASSWORD, DATABASE)DB_CURSOR = DB_CONN.cursor()# ...# ...# ... if __name__ == \"__main__\": # 开始时间戳 s_time = time.time() # 设定最大队列数和线程数 q = Queue(maxsize=10) threads = [] starttime, endtime = get_date() # print(starttime,endtime) # 经测试，获取查询时间段成功 # 获取所有用户组列表 userid_all_list = get_user_list() # print(userid_all_list) # 经测试，获取所有用户组成功 # 循环每一个用户组列表并开启多线程采集企业微信考勤数据 while userid_all_list: user_list = userid_all_list.pop() t = Thread(target=gatherData, args=(starttime, endtime, user_list, )) q.put(t) if (q.full() == True or len(userid_all_list) == 0): while q.empty() == False: t = q.get() threads.append(t) t.start() for t in threads: t.join() # 单线程插入数据 insert_sql() 4.python 一个.py文件如何调用另一个.py文件中的类和函数类和文件名相同","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"数据库分批次处理","slug":"数据库分批次处理","permalink":"https://ahrilove.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E6%89%B9%E6%AC%A1%E5%A4%84%E7%90%86/"},{"name":"数据库通用连接函数","slug":"数据库通用连接函数","permalink":"https://ahrilove.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0/"}]},{"title":"关于数据库返回值的讨论","slug":"关于数据库返回值的讨论","date":"2019-12-01T16:00:00.000Z","updated":"2019-12-02T13:55:39.070Z","comments":true,"path":"2019/12/02/关于数据库返回值的讨论/","link":"","permalink":"https://ahrilove.top/2019/12/02/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E8%AE%A8%E8%AE%BA/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;每到深夜，打开音乐，带上耳机，周围很安静，只有到这个时候我才感觉到自己是一个学者，而此刻头脑中只有两件事罢了：1.记下今天所用到的知识 2.安安静静听歌最近做一个python获取考勤数据的小脚本，一直没有怎么用到数据库，今天就来探讨一下获取数据库的返回值 关于数据库返回值的讨论python文件打开方式详解fetchall(),fetchone()","text":"&nbsp;&nbsp;&nbsp;&nbsp;每到深夜，打开音乐，带上耳机，周围很安静，只有到这个时候我才感觉到自己是一个学者，而此刻头脑中只有两件事罢了：1.记下今天所用到的知识 2.安安静静听歌最近做一个python获取考勤数据的小脚本，一直没有怎么用到数据库，今天就来探讨一下获取数据库的返回值 关于数据库返回值的讨论python文件打开方式详解fetchall(),fetchone() 1.关于数据库返回值的讨论1.1.构造简单sql语句假设存在这样一个简单的数据库,获取每一行的数据，并保存为txt格式 构造sql语句 select * from dbo.userlist where user_serial&lt;100010 1.2.python连接数据库（SQL server）1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-import pymssql# 获取考勤系统数据def demo(): server = \"\" user = \"\" password = \"\" database = \"\" conn = pymssql.connect( server=server, user=user, password=password, database=database ) # 创建游标 cursor = conn.cursor() # 构造查询sql语句 sql =\"select * from dbo.kt_dev where user_serial&lt;100010\" cursor.execute(sql) numbers = cursor.fetchall() print(numbers[0]) # 元组(100002, '0010014', '00101') print(type(numbers[0])) # tuple元组类型 # 元组访问方式与拼接 print(str(str(numbers[1][0]))+\":\"+str(numbers[1][1])) # 100002:0010002 print(type(numbers)) # list 列表 print('总列表：',numbers) cursor.execute(sql) loan_count = 0 # 获取所有的查询数据(1.区别于fetchone() 2.fetchall/fetchone()的返回值均为元组型列表，即[(第一行数据),(第二行数据),...()]) with open(\"test_demo.txt\",'a+',encoding='utf-8') as f: for number in numbers: f.write(str(number[0])+\" \"+str(number[1]) + \" \"+str(number[2]+\"\\n\")) # 元组数据number=(\"考勤卡号”，\"刷卡时间\") loan_count += 1 # 断开连接 cursor.close() conn.close() print(\"写入完成,共写入%d条数据！\" % loan_count)if __name__ == '__main__': demo() 数据库查询后返回的所有数据 12# 总列表： [(100002, '0010014', '00101'), (100002, '0010002', '00101'),..., (100006, '0010014', '00101')] 由上式案列可知：1.fetchall():表示返回查询到的所有数据；fetchone():表示返回查询到的第一行数据2.python查询返回的所有数据类型为元组型列表，即[(),(),...()]3.元组的访问方式为：元组名[&quot;index&quot;] 2.python文件打开方式详解 打开方式 详解 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"fetchall()","slug":"fetchall","permalink":"https://ahrilove.top/tags/fetchall/"},{"name":"fetchone()","slug":"fetchone","permalink":"https://ahrilove.top/tags/fetchone/"}]},{"title":"Python全栈系列章节更新（二）：常见库模块","slug":"python(二)常见库函数","date":"2019-11-28T16:00:00.000Z","updated":"2020-02-07T06:28:43.549Z","comments":true,"path":"2019/11/29/python(二)常见库函数/","link":"","permalink":"https://ahrilove.top/2019/11/29/python(%E4%BA%8C)%E5%B8%B8%E8%A7%81%E5%BA%93%E5%87%BD%E6%95%B0/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.DBUtils管理数据库连接池3.ftplib模块4.os模块5.datetime模块6.tqdm模块7.控制台输出带颜色文字的方法8.random模块","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.DBUtils管理数据库连接池3.ftplib模块4.os模块5.datetime模块6.tqdm模块7.控制台输出带颜色文字的方法8.random模块 1.time模块Unix时间戳转与时间的转换 将时间戳转换成时间，首先需要将时间戳转换成localtime，再转换成时间的具体格式： 利用localtime()函数将时间戳转化成localtime的格式利用strftime()函数重新格式化时间 123456789101112131415161718192021222324# -*- coding:utf-8 -*-import time# 将时间戳转化为目标时间格式def timestamp_datatime(value): format = '%Y-%m-%d %H:%M' # format = '%Y-%m-%d %H:%M:%S' # value 为时间戳值,如:1460073600.0 value = time.localtime(value) dt = time.strftime(format, value) return dt# 将目标时间格式转化为时间戳def datetime_timestamp(dt): newTime = time.strptime(dt, '%Y-%m-%d %H:%M') s = time.mktime(newTime) return sif __name__ == '__main__': s = timestamp_datatime(1460073600.0) print(s) # 2016-04-08 08:00 d = datetime_timestamp('2019-06-05 08:00') print(d) # 1559692800.0 按指定的格式获取当前时间利用time()获取当前时间，再利用localtime()函数转换为localtime，最后利用strftime()函数重新格式化时间。 1234567891011#coding:UTF-8import time#获取当前时间time_now = int(time.time())#转换成localtimetime_local = time.localtime(time_now)#转换成新的时间格式(2016-05-09 18:59:20),时间连接符号可改变dt = time.strftime(\"%Y-%m-%d %H:%M:%S\",time_local)print(dt) 2.DBUtils管理数据库连接池当使用多线程，多进程将海量数据存入数据库时，每次执行一个sql的时候都单独建立一个mysql连接，执行完就close掉，很明显这样的问题在于，频繁连接，断开mysql，这样是相当消耗系统资源的，而且增加了mysql连接失败的几率，所以万一哪个线程没有连接成功 这个线程也over了。 2.1 连接池原理1.在程序创建连接的时候，可以从一个空闲的连接中获取，不需要重新初始化连接，提升获取连接的速度2.关闭连接的时候，把连接放回连接池，而不是真正的关闭，所以可以减少频繁地打开和关闭连接 安装DBUtils库 pip install DBUtils 参数解释 参数 详解 creator, # 使用链接数据库的模块(必须：pymssql，pymysql，cx_oralce,…) mincached=0, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=0, # 链接池中最多闲置的链接，0和None不限制 maxshared=0, # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用 maxconnections=0, # 连接池允许的最大连接数，0和None表示不限制连接数 blocking=False, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=None, # 开始会话前执行的命令列表。如：[“set datestyle to …”, “set time zone …”] reset=True, failures=None, ping=1, # ping MySQL服务端，检查是否服务可用 数据库设置(数据库连接模块不一样，其参数名也不同) 如creator=pymysql：host=&#39;localhost&#39;, port=3306,db=&#39;mydata&#39;,user=&quot;root&quot;,passwd=&quot;123456&quot;,charset=&#39;utf8&#39; 数据库通用连接函数（连接模块视实际数据库决定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 2.2 多线程（连接池）操作MySQL插入数据 启动线程任务 每调用一次插入函数就从连接池中取出一个链接操作,完成后关闭链接;executemany 批量操作,减少 commit 次数,提升效率; 3.ftplib操作ftp实现上传和下载的ftplib模块是系统默认安装的，实现文件的上传与下载 3.1 ftp登陆连接1234567891011121314151617181920212223242526from ftplib import FTP #加载ftp模块ftp=FTP() #设置变量ftp.set_debuglevel(2) #打开调试级别2，显示详细信息ftp.connect(\"IP\",\"port\") #连接的ftp sever和端口ftp.login(\"user\",\"password\") #连接的用户名，密码print(ftp.getwelcome()) #打印出欢迎信息bufsize=1024 #设置的缓冲区大小filename=\"filename.txt\" #需要下载的文件file_handle=open(filename,\"wb\").write #以写模式在本地打开文件ftp.retrbinaly(\"RETR filename.txt\",file_handle,bufsize) #接收服务器上文件并写入本地文件ftp.set_debuglevel(0) #关闭调试模式ftp.quit() #退出ftp # ftp相关命令操作ftp.cwd(pathname) #设置FTP当前操作的路径ftp.dir() #显示目录下所有目录信息ftp.nlst() #获取目录下的文件ftp.mkd(pathname) #新建远程目录ftp.pwd() #返回当前所在位置ftp.rmd(dirname) #删除远程目录ftp.delete(filename) #删除远程文件ftp.rename(fromname, toname)#将fromname修改名称为toname。ftp.storbinary(\"STOR filename.txt\",file_content,bufsize) #上传目标文件ftp.retrbinary(\"RETR filename.txt\",file_content,bufsize) #下载FTP文件 3.2 ftp上传或下载文件/目录4.os模块记下常用的os模块的操作指令 命令 含义 os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径,相当于shell的pwd os.chdir(“dirname”) 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: (‘.’) os.pardir 获取当前目录的父目录字符串名：(‘..’) os.makedirs(‘dirname1/dirname2’) 可生成多层递归目录 os.removedirs(‘dirname1’) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(‘dirname’) 生成单级目录；相当于shell中mkdir dirname os.rmdir(‘dirname’) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(‘dirname’) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(“oldname”,”newname”) 重命名文件/目录 os.stat(‘path/filename’) 获取文件/目录信息 os.name 输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’ os.system(“执行的命令”) 运行shell命令，直接显示,相当于直接在cmd命令中执行 os.environ 获取系统环境变量 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path/file) 如果路径或文件存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.join(path1,path2,…,pathn) 将多个路径组合后返回 简要样例说明： 123456789101112131415161718192021222324252627&gt;&gt;&gt; os.path.split(&quot;/Users/hqs/PycharmProjects/startMyPython3.0&quot;) (&apos;/Users/hqs/PycharmProjects&apos;, &apos;startMyPython3.0&apos;)&gt;&gt;&gt; os.path.dirname(&apos;/Users/hqs/PycharmProjects/startMyPython3.0&apos;)&apos;/Users/hqs/PycharmProjects&apos;&gt;&gt;&gt;os.system(&quot;ping 127.0.0.1&quot;)正在 Ping 127.0.0.1 具有 32 字节的数据:来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64127.0.0.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms &gt;&gt;&gt;os.path.abspath(__file__) 当前文件的绝对路径&gt;&gt;&gt;os.path.dirname(os.path.abspath(__file__))当前文件的上一层目录的绝对路径os.path.dirname(os.path.dirname(os.path.abspath(__file__)))当前文件的上上层目录的绝对路径 5 datetime模块1.datetime.date：表示日期的类2.datetime.datetime：表示日期时间的类3.datetime.time：表示时间的类4.datetime.timedelta：表示时间间隔，即两个时间点的间隔5.datetime.tzinfo：时区的相关信息 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt;datetime.datetime.now()当前系统时间：datetime.datetime(2019, 12, 3, 20, 31, 10, 740869)&gt;&gt;&gt;datetime.datetime.now().year/month/day分别为：2019，12，3&gt;&gt;&gt;datetime.datetime.now().weekday()1 表示在第几周&gt;&gt;&gt;time1 = datetime.datetime(2016, 10, 20)&gt;&gt;&gt;time2 = datetime.datetime(2015, 11, 2) &quot;&quot;&quot;计算天数差值&quot;&quot;&quot;print(time1-time2).days &quot;&quot;&quot;计算两个日期之间相隔的秒数&quot;&quot;&quot;print (time1-time2).total_seconds()# 获取当前时间,并转化为字符串型&gt;&gt;&gt;time_new = str(datetime.datetime.now().date()) # &apos;2019-12-4&apos;# 以当天的09：00为开始时间（时间戳格式）&gt;&gt;&gt;time_on = time.mktime(time.strptime(time_new+ &apos; 09:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))# 以当天的18：00为结束时间（时间戳格式）&gt;&gt;&gt;time_off = time.mktime(time.strptime(time_new+ &apos; 18:00&apos;, &apos;%Y-%m-%d %H:%M&apos;))# 当前星期几&gt;&gt;&gt;week_now = datetime.datetime.now().weekday()# 当前时间&gt;&gt;&gt;time_now = datetime.datetime.now() # datetime.datetime(2019, 12, 4, 14, 57, 48, 988520)# 当前第几小时（24小时制）&gt;&gt;&gt;hour_now = datetime.datetime.now().hour # 14 5.tqdm模块（最优雅的进度条）from tqdm import tqdm使用方法： 123456from tqdm import tqdmimport timeif __name__ == '__main__': for i in tqdm(range(1000)): time.sleep(0.5) 6.控制台输出带颜色文字的方法设置颜色开始 ：\\033[显示方式;前景色;背景色m 文本内容 \\033[0m（此处为结束语） 12345print('\\033[1;31m我以我血荐轩辕\\033[0m')print('\\033[4;35m我以我血荐轩辕\\033[0m')print('\\033[5;37;40m我以我血荐轩辕\\033[0m')print('\\033[0;32m我以我血荐轩辕\\033[0m')print('\\033[1;32m我以我血荐轩辕\\033[0m') 7.random模块 函数 说明 randint(a, b) 生成一个[a, b]之间的整数 randrange(m, n[, k]) 生成一个[m, n)之间以k为步长的随机整数 getrandbits(k) 生成一个k比特长的随机整数 uniform(a, b) 生成一个[a, b]之间的随机小数 choice(seq) 从序列seq中随机选择一个元素 shuffle(seq) 将序列seq中元素随机排列，返回打乱后的序列 random() 生成一个[0.0, 1.0)之间的随机小数 12345678910111213141516import randomrandom.random()0.5random.randint(10, 100)64random.randrange(10, 100, 10)80random.getrandbits(16)37885random.uniform(10, 100)13.096321648808136random.choice([1,2,3,4,5,6,7,8,9])8 s=[1,2,3,4,5,6,7,8,9];random.shuffle(s);print(s)[3, 5, 8, 9, 6, 1, 2, 7, 4] 未完待续。。。","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"time","slug":"time","permalink":"https://ahrilove.top/tags/time/"},{"name":"datetime","slug":"datetime","permalink":"https://ahrilove.top/tags/datetime/"},{"name":"DBUtils","slug":"DBUtils","permalink":"https://ahrilove.top/tags/DBUtils/"}]},{"title":"技术小白教你如何定位照片拍摄位置","slug":"照片的GPS信息定位","date":"2019-11-27T16:00:00.000Z","updated":"2019-12-05T09:04:11.808Z","comments":true,"path":"2019/11/28/照片的GPS信息定位/","link":"","permalink":"https://ahrilove.top/2019/11/28/%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动）","text":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动） 1.获取GPS信息&nbsp;&nbsp;&nbsp;&nbsp;将照片复制至电脑。点击照片，右键--“右键菜单”--“属性”--“详细信息”，下拉至“GPS”，将会看到经纬度信息。如下图所示： 2.经纬度计算方法&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到经纬度信息，是以度分秒的格式展示的（度分秒之间以“；”间隔），为了方便定位，我们需要将度分秒转换为度的格式。计算方法：经纬度同理（本例为32；49；49.942932000005413）经度：度+（分+秒/60）/60，即32+(49+49.9429/60)/60=32.8305; 3.测试在奥维地图上将计算后的经纬度（以英文格式书写）代入其中，就可以获得地理位置信息。","categories":[],"tags":[{"name":"定位照片拍摄位置","slug":"定位照片拍摄位置","permalink":"https://ahrilove.top/tags/%E5%AE%9A%E4%BD%8D%E7%85%A7%E7%89%87%E6%8B%8D%E6%91%84%E4%BD%8D%E7%BD%AE/"}]},{"title":"Nginx（二）：Nginx的命令和配置文件","slug":"Nginx(二)","date":"2019-11-26T16:00:00.000Z","updated":"2019-12-05T14:28:10.699Z","comments":true,"path":"2019/11/27/Nginx(二)/","link":"","permalink":"https://ahrilove.top/2019/11/27/Nginx(%E4%BA%8C)/","excerpt":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1","text":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1 1.理清概念docker创建Nginx容器很简单：共享数据卷，外部访问端口映射window下运行nginx，只需简单式一直点击“NEXT”安装，然后添加到环境变量即可在Linux下启动nginx相对比较麻烦，如果你采用其它两种方式，可以跳过本节，本节主要是介绍Linux下的运行命令无论哪种方式启动Nginx，其核心的配置文件以及接下来的几个配置实例都是通用的 2.Linux下Nginx的常用命令先关闭防火墙或者是开放目标端口 进入nginx目录中 cd /usr/local/nginx/sbin (前面路径有可能不同，主要是nginx内的nginx/sbin路径) 1、查看nginx版本号 ./nginx -v 2、启动nginx ./nginx 3、停止nginx ./nginx -s stop 4、重新加载nginx ./nginx -s reload 3.ginx的基本配置文件nginx.conf3.1、nginx 配置文件位置cd /usr/local/nginx/conf/nginx.conf 3.2、配置文件中的内容 包含三部分内容（1）全局块：配置服务器整体运行的配置指令 比如 worker_processes 1;处理并发数的配置 （2）events 块：影响 Nginx 服务器与用户的网络连接 比如 worker_connections 1024; 支持的最大连接数为 1024 （3）http 块 还包含两部分： http 全局块 server 块 3.3 默认的nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; 404.md # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 4.Nginx 配置实例-反向代理实例 14.1、实现效果（1）打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到 liunx 系统 tomcat 主页 面中 4.2、准备工作（1）在 liunx 系统安装 tomcat，使用默认端口 8080 * tomcat 安装文件放到 liunx 系统中，解压 * 进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器 （2）对外开放访问的端口firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload （3）查看已经开放的端口号firewall-cmd –list-all （4）在 windows 系统中通过浏览器访问 tomcat 服务器(linux_IP + tomcat_Port) 4.3、访问过程分析 映射IP 假设域名www.123.com映射的IP为Linux上的nginx的ip地址（比如我的是192.168.17.129:80）,nginx也相当于一个分发器，将请求发送至tomcat服务器 123访问过程分析windows端 ----------&gt;Nginx（linux_IP：80）------&gt;tomcat(127.0.0.1:8080)（假设访问www.123.com） 在 nginx 进行请求转发的配置（反向代理配置） 123456789server&#123; listen 80; # 监听端口 server_name www.123.com; # 配置域名 location /&#123; proxy_pass http://127.0.0.1:8080; # 跳转到127.0.0.1：8080路径 index index.html index.htm index.jsp; &#125;&#125; 如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 www.123.com后，成功后直接跳转到tomcat主页","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nginx.conf","slug":"nginx-conf","permalink":"https://ahrilove.top/tags/nginx-conf/"},{"name":"nginx","slug":"nginx","permalink":"https://ahrilove.top/tags/nginx/"}]},{"title":"Nginx（一）：基本概念","slug":"Nginx","date":"2019-11-24T16:00:00.000Z","updated":"2019-11-28T00:31:56.883Z","comments":true,"path":"2019/11/25/Nginx/","link":"","permalink":"https://ahrilove.top/2019/11/25/Nginx/","excerpt":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程","text":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程 1.正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。如图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结来说：正向代理，”它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正向代理的用途：（1）访问原来无法访问的资源，如Google（2） 可以做缓存，加速访问资源（3）对客户端访问授权，上网进行认证（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 2.反向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：http://tengine.taobao.org/。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理的作用：（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网（2）负载均衡，通过反向代理服务器来优化网站的负载 3.项目场景以及两者区别通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：两者区别：图解： 在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息； 在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息； 实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了 4.负载均衡我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？ 这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。 请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。 所以，将服务器接收到的请求按照规则分发的过程，称为负载均衡。 负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。Nginx支持的负载均衡调度算法方式如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。 5.动静分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 6.nginx安装windows下安装与部署NginxLinux下安装与部署Nginx以后都推荐再docker下安装各式各样的环境Ubuntu+docker下安装与部署Nginx","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"https://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ahrilove.top/tags/nginx/"},{"name":"apache","slug":"apache","permalink":"https://ahrilove.top/tags/apache/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://ahrilove.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"Javascript篇章四：快速入门","slug":"Javascript篇章四","date":"2019-11-22T16:00:00.000Z","updated":"2019-12-24T11:24:22.554Z","comments":true,"path":"2019/11/23/Javascript篇章四/","link":"","permalink":"https://ahrilove.top/2019/11/23/Javascript%E7%AF%87%E7%AB%A0%E5%9B%9B/","excerpt":"1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单6.前端模块化","text":"1.条件判断以及prompt() 方法2.循环3.Map与Reduce4.全局作用域与浏览器对象5.高阶函数与操作表单6.前端模块化 1.条件判断以及prompt() 方法多条件判断：if…else if…else if…elseprompt(text,defaultText)方法用于显示可提示用户进行输入的对话框（即输入数据）,参数一表示提示文本，参数二表示默认值var name=prompt(“Please enter your name”,”ritian zhao”) 2.循环 for(i=1;i&lt;=1000;i++){} 2.for (item in items){} (不推荐) 3.while(){} 3. return终止函数1.return后面的语句不执行2.JavaScript里的return只能返回一个数值（区别于python可以返回多个） 4.Map与Set运用Map是一组键值对的结构，具有很快的查找速度举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 Map的方法（初始化Map需要一个二维数组，或者直接初始化一个空Map） 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67,获取值m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，map函数会把后面的值会把前面的值冲掉 Set() Set和Map类似，也是一组key的集合，但不存储value。 由于key不能重复，所以，在Set中，没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); //一个Array含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 全局作用域1.不在任何函数内定义的变量就具有全局作用域，实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。window.属性/window.方法2.ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量3.ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域 浏览器对象：window,navigator,screen,Location，document window对象不仅充当全局作用域，而且表示浏览器的窗口 window.innerWidth和window.innerHeight:可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高 windows.outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高 navigator对象表示浏览器信息 navigator.appName：浏览器名称；navigator.appVersion：浏览器版本；navigator.language：浏览器设置的语言；navigator.platform：操作系统类型；navigator.userAgent：浏览器设定的User-Agent字符串 screen表示屏幕信息 screen.width：屏幕宽度，以像素为单位；screen.height：屏幕高度，以像素为单位；screen.colorDepth：返回颜色位数，如8、16、24。 Location对象表示当前页面的URL信息 location.protocol; // ‘http’location.host; // ‘www.example.com&#39;location.port; // ‘8080’location.pathname; // ‘/path/index.html’location.search; // ‘?a=1&amp;b=2’location.hash; // ‘TOP’location.href 获取完整urlwindow.location.href=&quot;新的跳转url”：跳转到指定的页面location.assign()：加载一个新页面，可以调用location.reload()：如果要重新加载当前页面 document对象表示当前页面 高阶函数 map/reduce函数，与python的map，reduce作用相同 1234var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]// 对于reduce函数：函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) instanceof关键字 这个关键字的用法是：A instanceof B ，返回值为boolean类型。用来判断A是否是B的实例对象或者B子类的实例对象。如果是则返回true,否则返回false 1234567//Man是Person的子类p = new Person() ; //m = new Man() ; a = new Animal() ;m instanceof Man //返回truem instanceof Animal//返回falsem instanceof Person//返回true 操作表单文本框，对应的&lt;input type=”text”&gt;，用于输入文本； 口令框，对应的&lt;input type=”password”&gt;，用于输入口令； 单选框，对应的&lt;input type=”radio”&gt;，用于选择一项； 复选框，对应的&lt;input type=”checkbox”&gt;，用于选择多项； 下拉框，对应的&lt;select&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=”hidden”&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 获取值 如果我们获得了一个&lt;input&gt;节点的引用，就可以直接调用value获得对应的用户输入值，使用样例：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量名.value可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： 12345678// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"monday\" value=\"1\"&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=\"radio\" name=\"weekday\" id=\"tuesday\" value=\"2\"&gt; Tuesday&lt;/label&gt;var mon = document.getElementById('monday');var tue = document.getElementById('tuesday');mon.value; // '1'tue.value; // '2'mon.checked; // true或者falsetue.checked; // true或者false 面向对象编程 构造函数 构造函数与普通函数的区别就是调用方式不同：普通函数是直接调用，而构造函数需要使用new关键字来调用PS:构造函数的函数名一般默认首字母大写；构造函数里可以使用this;参考：本质与python的构造函数相同 12345678910function Person(name,age) &#123; this.name=name; this.age = age; this.sayHi = function() &#123; alert(this.name) &#125;&#125;// 创建一个对象pervar per = new Person();console.log(per); indexOf()方法strings.indexOf(“目标字符串”):可返回某个指定的字符串值在字符串中首次出现的位置 123456789var str=\"Hello world!\";document.write(str.indexOf(\"Hello\") + \"&lt;br /&gt;\");document.write(str.indexOf(\"World\") + \"&lt;br /&gt;\");document.write(str.indexOf(\"world\"));/** 0*-1*6 */ indexOf() 方法对大小写敏感！:如果要检索的字符串值没有出现，则该方法返回 -1,而且索引值默认起始值为0 Timing事件setTimeout(function,milliseconds):等待指定的毫秒数后执行函数setInterval(function,milliseconds):等同于setTimeout()，但在每个给定的时间间隔内重复执行该函数 1234567var myVar = setInterval(myTimer, 3000); function myTimer() &#123; var d = new Date(); console.log(d.getFullYear())&#125;// setInterval在每隔3秒就打印一次当前的月份 clearTimeout(变量名) 方法停止执行 setTimeout() 中规定的函数。 1234&lt;!--使用setTimeout等待执行函数，clearTimeout停止执行函数---&gt;&lt;button onclick=\"myVar = setTimeout(myFunction, 3000)\"&gt;试一试&lt;/button&gt;&lt;button onclick=\"clearTimeout(myVar)\"&gt;停止执行&lt;/button&gt; 5.前端模块化(node.js) 1.模块暴露 我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块 123456789'use strict';var s = 'Hello';function greet(name) &#123; console.log(s + ', ' + name + '!');&#125;module.exports = greet; module.exports把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了 2.模块引入 12345678'use strict';// 引入hello模块:var greet = require('./hello');var s = 'Michael';greet(s); // Hello, Michael! 3.多模块暴露 我们不妨深入♂一下：将某个模块暴露出来，并访问该模块内的多个函数 12345678910111213141516171819// hello.js'use strict';var s = \"hello python\";function conn(name)&#123; console.log(s+','+name+'!'); return(s+\",\"+name+\"!\") &#125;function printer(n)&#123; let ab = []; if(n&gt;=1)&#123; for(var i = 0;i&lt;n;i++)&#123; ab.push(i)&#125; console.log(ab) &#125;else&#123; console.log(\"输入错误\") &#125;&#125;// 将模块暴露出来，以便于其它模块调用，采用对象的形式module.exports =&#123;conn:conn,printer:printer&#125;; 然后我们来访问hello模块，来玩♂一♀玩(注意模块里的函数调用方式) 123456// 主模块mian.js'use strict';var greet = require('./hello');var s = \"chd\";greet.conn(s);greet.printer(10)","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[],"author":{"name":"Badwoman","avatar":"https://cdn.jsdelivr.net/gh/FioraLove/Images/D:/data/imagesNaruto.jpg"}},{"title":"Javascript篇章三：js数字，数组与日期","slug":"Javascript篇章三","date":"2019-11-21T16:00:00.000Z","updated":"2020-01-15T02:39:45.997Z","comments":true,"path":"2019/11/22/Javascript篇章三/","link":"","permalink":"https://ahrilove.top/2019/11/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%89/","excerpt":"关关雎鸠，在河之洲。窈窕淑女，君子好逑 本文要点：1.数值方法2.数组以及数组属性和方法3.日期4.js数据类型转换大全5.js的休眠函数6.js正则表达式（RegExp）","text":"关关雎鸠，在河之洲。窈窕淑女，君子好逑 本文要点：1.数值方法2.数组以及数组属性和方法3.日期4.js数据类型转换大全5.js的休眠函数6.js正则表达式（RegExp） 1.数值方法 number.toString():将数值型转化为字符串型 123var n = 15; console.log(typeof(n)); // 为字数值类型numbera = n.toString(); // a为字符串类型 toFixed(number) 将数值保留为指定的小数位数，并再转化为String类型 123456var x = 9.656;x.toFixed(0); // 返回 10x.toFixed(2); // 返回 9.66x.toFixed(4); // 返回 9.6560x.toFixed(6); // 返回 9.656000console.log(typeof(x.toFixed(2))) // 返回\"String\" 把变量转换为数值 这三种 JavaScript 方法可用于将变量转换为数字： Number() 方法 parseFloat(string) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，则对其进行解析直到完整取出第一个数值，并返回首个数值，如果首字符不是数字则直接返回NaN parseInt(string，radix) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，将字符串取出首个完整数值，并转化为指定radix进制，如果首字符不是数字，就直接返回NaN 123456789101112parseInt(\"10.008\"); // 返回 10parseInt(\"10.33\"); // 返回 10parseInt(\"10 20 30\"); // 返回 10parseInt(\"10 years\"); // 返回 10parseInt(\"years 10\"); // 返回 NaNparseInt(\"30\",8); // 返回24，将30转化为8进制parseFloat(\"10\"); // 返回 10parseFloat(\"10.33\"); // 返回 10.33parseFloat(\"10 20 30\"); // 返回 10parseFloat(\"10 years\"); // 返回 10parseFloat(\"years 10\"); // 返回 NaN 2.数组 数组是一种特殊的变量，它能够一次存放一个以上的值。 var cars=[“Saab”,”Volov”,”BMW”]; 访问数组元素：通过索引（从0开始，下标号）来引用某个数组元素 var name=car[0] 访问数组值var car[0] = “Benz” 修改数组值，即新数组为[“Benz”,”Volov”,”BMW”] 数组属性和方法 length:返回数组元素的数目 遍历数组元素：最安全是使用for循环 123456var fruits;fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];for (i = 0; i &lt; fruits.length; i++) &#123; console.log(fruits[i]);&#125; 向数组添加新元素的最佳方法是使用 push() 方法，并返回新数组的元素个数 12let fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.push(\"Lemon\"); // 向 fruits 添加一个新元素 (Lemon),并返回数组元素个数 join() 方法也可将所有数组元素结合为一个字符串 格式：数组名.join(“指定拼接符”) 123var fruits = [\"Banana\", \"Orange\",\"Apple\", \"Mango\"];console.log(fruits.join(\" * \"));// Banana * Orange * Apple * Mango pop()从数组中删除最后一个元素,并返回该值（shift()从数组中删除第一个元素,并返回该值）var fruits = [“Banana”, “Orange”, “Apple”, “Mango”];var x = fruits.pop(); // x 的值是 “Mango” 123拓：push()+pop():可以构成栈方法，先进后出push()+shift()：可以构成队列方法，先进先出 sort()方法以字母顺序对数组进行排序 reverse()反转数组中的元素 123var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.sort(); // 对 fruits 中的元素进行排序fruitS.reverse(); // 对数组元素进行反转 JavaScript的数组可以包含任意数据类型创建方式一(推荐使用)：[1, 2, 3.14, ‘Hello’, null, true];创建方式二：通过Array()函数实现b = new Array(1, 2, 3); js的栈与队列栈：先进后出，利用push+pop队列：先进先出，利用push+shift 3.日期使用方法：var d = new Date(); 获取系统时间d.getDate()/d.getFullYear()… 方法 描述 getDate() 以数值返回天数（1-31） getDay() 以数值获取周几（0-6） getFullYear() 获取四位的年（yyyy） getHours() 获取小时（0-23） getMilliseconds() 获取毫秒（0-999） getMinutes() 获取分（0-59） getMonth() 获取月（0-11） getSeconds() 获取秒（0-59） getTime() 获取时间戳（从 1970 年 1 月 1 日至今） 4.js数据类型转换大全【转载】js数据类型转换 5.js的休眠函数获取的时间戳是秒级还是毫秒级：js里面获取到的是毫秒级（十三位），而像python，php的时间戳是秒级的（十位数字） 1234function sleep(n) &#123; //n表示的毫秒数 var start = new Date().getTime(); while (true) if (new Date().getTime() - start &gt; n) break;&#125; 6.js的正则表达式【转载】js正则表达式（RegExp） 未完待续…","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"对象","slug":"对象","permalink":"https://ahrilove.top/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"属性与方法","slug":"属性与方法","permalink":"https://ahrilove.top/tags/%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"}]},{"title":"Javascript篇章二：js计算精度丢失","slug":"Javascript篇章二","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-26T08:57:12.309Z","comments":true,"path":"2019/11/21/Javascript篇章二/","link":"","permalink":"https://ahrilove.top/2019/11/21/Javascript%E7%AF%87%E7%AB%A0%E4%BA%8C/","excerpt":"若教眼底无离恨，不信人间有白头 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript中没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失。 本文要点：1.js精确度丢失缘由2.精确度丢失解决方案","text":"若教眼底无离恨，不信人间有白头 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript中没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失。 本文要点：1.js精确度丢失缘由2.精确度丢失解决方案 js精确度丢失出现缘由 1.我们先看几个四舍五入的实例 12alert(Number(0.009).toFixed(2)); alert(Number(162.295).toFixed(2)); 按正常结果，应该分别弹出0.01和162.30。但实际测试结果却是在不同浏览器中得到的是不同的结果：在ie6、7、8下得到0.00和162.30，第一个数截取不正确；在firefox中得到0.01和162.29，第二个数截取不正确；在opera下得到0.01和162.29，第二个数截取不正确 2.再看有关于四则运算的实例 12345alert(1/3);//弹出: 0.3333333333333333 alert(0.1 + 0.2);//弹出: 0.30000000000000004 alert(-0.09 - 0.01);//弹出: -0.09999999999999999 alert(0.012345 * 0.000001);//弹出: 1.2344999999999999e-8 alert(0.000001 / 0.0001);//弹出: 0.009999999999999998 按正常结果，除第一行外(因为其本身就不能除尽)，其他都应该要得到精确的结果，从弹出的结果我们却发现不是我们想要的正确结果。是因为没有转换成Number类型吗？我们转换成Number后再计算看看： 12345alert(Number(1)/Number(3));//弹出: 0.3333333333333333 alert(Number(0.1) + Number(0.2));//弹出: 0.30000000000000004 alert(Number(-0.09) - Number(0.01));//弹出: -0.09999999999999999 alert(Number(0.012345) * Number(0.000001));//弹出: 1.2344999999999999e-8 alert(Number(0.000001) / Number(0.0001));//弹出: 0.009999999999999998 还是一样的结果，看来javascript默认把数字识别为number类型。为了验证这一点，我们用typeof弹出类型看看： 123alert(typeof(1));//弹出: number alert(typeof(1/3));//弹出: number alert(typeof(-0.09999999));//弹出: number 3.计算机原理 回忆一下大学时学过的计算机原理，计算机执行的是二进制算术，当十进制数不能准确转换为二进制数时，这种精度误差就在所难免。从上述的推演过程我们知道，这种误差是难免的，c#的decimal和Java的BigDecimal之所以没有出现精度差异，只是因为在其内部作了相应处理，把这种精度差异给屏蔽掉了，而javascript是一种弱类型的脚本语言，本身并没有对计算精度做相应的处理，这就需要我们另外想办法处理了 解决JS计算精确度丢失&nbsp;&nbsp;&nbsp;&nbsp;创建calc.js文件，其调用方法参考&nbsp;&nbsp;thinkphp项目调用Vue扩展函数方式 参考文章 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137Vue.prototype.calc = &#123; /** * 千分位格式化函数 * @param &#123;*&#125; number 要格式化的数字 * @param &#123;*&#125; decimals 保留几位小数 * @param &#123;*&#125; dec_point 小数点符号 * @param &#123;*&#125; thousands_sep 千分位符号 */ number_format(number, decimals, dec_point, thousands_sep) &#123; if(parseFloat(number) == 0) return \" - \"; number = (number + '').replace(/[^0-9+-Ee.]/g, ''); var n = !isFinite(+number) ? 0 : +number, decimals = (typeof decimals === 'undefined') ? 2 : decimals, prec = !isFinite(+decimals) ? 0 : Math.abs(decimals), sep = (typeof thousands_sep === 'undefined') ? ',' : thousands_sep, dec = (typeof dec_point === 'undefined') ? '.' : dec_point, s = '', toFixedFix = function (n, prec) &#123; var k = Math.pow(10, prec); return '' + Math.ceil(n * k) / k; &#125;; s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.'); var re = /(-?\\d+)(\\d&#123;3&#125;)/; while (re.test(s[0])) &#123; s[0] = s[0].replace(re, \"$1\" + sep + \"$2\"); &#125; if ((s[1] || '').length &lt; prec) &#123; s[1] = s[1] || ''; s[1] += new Array(prec - s[1].length + 1).join('0'); &#125; return s.join(dec); &#125;, /** * 加法函数，用来得到精确的加法结果 * 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 * 调用：accAdd(arg1,arg2) * 返回值：arg1加上arg2的精确结果 **/ accAdd: function(arg1, arg2) &#123; var r1, r2, m, c; try &#123; r1 = arg1.toString().split(\".\")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(\".\")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; c = Math.abs(r1 - r2); m = Math.pow(10, Math.max(r1, r2)); if (c &gt; 0) &#123; var cm = Math.pow(10, c); if (r1 &gt; r2) &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")); arg2 = Number(arg2.toString().replace(\".\", \"\")) * cm; &#125; else &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")) * cm; arg2 = Number(arg2.toString().replace(\".\", \"\")); &#125; &#125; else &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")); arg2 = Number(arg2.toString().replace(\".\", \"\")); &#125; return (arg1 + arg2) / m; &#125;, /** * 减法函数，用来得到精确的减法结果 * 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。 * 调用：accSub(arg1,arg2) * 返回值：arg1加上arg2的精确结果 **/ accSub: function(arg1, arg2) &#123; var r1, r2, m, n; try &#123; r1 = arg1.toString().split(\".\")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(\".\")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度 n = (r1 &gt;= r2) ? r1 : r2; return parseFloat(((arg1 * m - arg2 * m) / m).toFixed(n)); &#125;, //乘法函数，用来得到精确的乘法结果 //说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 //调用：accMul(arg1,arg2) //返回值：arg1乘以arg2的精确结果 accMul: function(arg1,arg2) &#123; var m = 0, s1 = arg1.toString(), s2 = arg2.toString(); try &#123; m += s1.split(\".\")[1].length &#125; catch (e) &#123;&#125; try &#123; m += s2.split(\".\")[1].length &#125; catch (e) &#123;&#125; return Number(s1.replace(\".\", \"\")) * Number(s2.replace(\".\", \"\")) / Math.pow(10, m); &#125;, //除法函数，用来得到精确的除法结果 //说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 //调用：accDiv(arg1,arg2) //返回值：arg1除以arg2的精确结果 accDiv: function(arg1, arg2) &#123; var t1 = 0, t2 = 0, r1, r2; try &#123; t1 = arg1.toString().split(\".\")[1].length &#125; catch (e) &#123;&#125; try &#123; t2 = arg2.toString().split(\".\")[1].length &#125; catch (e) &#123;&#125; with(Math) &#123; r1 = Number(arg1.toString().replace(\".\", \"\")); r2 = Number(arg2.toString().replace(\".\", \"\")); return (r1 / r2) * pow(10, t2 - t1); &#125; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js精确度丢失","slug":"js精确度丢失","permalink":"https://ahrilove.top/tags/js%E7%B2%BE%E7%A1%AE%E5%BA%A6%E4%B8%A2%E5%A4%B1/"}]},{"title":"Javascript篇章一：JavaScript基本知识","slug":"Javascript篇章一","date":"2019-11-19T16:00:00.000Z","updated":"2020-02-11T12:48:08.542Z","comments":true,"path":"2019/11/20/Javascript篇章一/","link":"","permalink":"https://ahrilove.top/2019/11/20/Javascript%E7%AF%87%E7%AB%A0%E4%B8%80/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的，一个前端项目必离不开HTML+CSS+JavaScript。 本文要点：1.变量及数据类型2.对象3.javascript小知识点","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的，一个前端项目必离不开HTML+CSS+JavaScript。 本文要点：1.变量及数据类型2.对象3.javascript小知识点 1. 变量及数据类型：JavaScript变量是数据值的容器变量修饰符：var,let,const2020-01-22 修改：js的变量作用域（1）局部变量：在函数中通过var声明的变量。 全局变量：在函数外通过var声明的变量。 没有声明就使用的变量，默认为全局变量，不论这个变量在哪被使用。 （2）var 可以先使用再定义。如下 12345x = 5; // 变量 x 设置为 5elem = document.getElementById(\"demo\"); // 查找元素 elem.innerHTML = x; // 在元素中显示 xvar x; // 声明 x (3) let和const let 声明的变量只在 let 命令所在的代码块内有效。 const 声明一个只读的常量，一旦声明，常量的值就不能改变。 JavaScript数据类型分为：数值、字符串值、数组、对象等等 1234let length = 7; // 数字let lastName = \"Gates\"; // 字符串let cars = [\"Porsche\", \"Volvo\", \"BMW\"]; // 数组let x = &#123;firstName:\"Bill\", lastName:\"Gates\"&#125;; // 对象 2.对象对象的值以名称:值对的方式来书写（名称和值由冒号分隔） 123456789var person = &#123; //这里的person称为对象 firstName:\"Bill\", // 这是属性 lastName:\"Gates\", age:62, eyeColor:\"blue\", fullName : function() &#123; // 这就是方法 return this.firstName + \" \" + this.lastName; &#125;&#125;; JavaScript中的this关键词 12345在函数定义中，this 引用该函数的“拥有者”。在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。换言之，this.firstName 的意思是 this 对象的 firstName 属性。 对象的访问方式： 对象名.属性名 或者对象名[“属性名”] 案例：数据集构造12345678910111213141516let dimensions = []; //维度let source = []; //数据集let series = []; //图系列dimensions.push(\"groupcus_name\");dimensions.push(\"剩余发出商品\");for(let i=0;i&lt;response.Rows.length;i++)&#123; let obj = &#123;&#125;; obj[\"groupcus_name\"] = response.Rows[i].groupcus_name; // 对象的调用方式obj[\"key_name\"]或obj.key_name obj[\"剩余发出商品\"] = response.Rows[i].surplusp; source.push(obj); // 记住push只适用于数组的元素添加，并返回数组元素个数&#125; 3.javascript小知识点 函数语法 function function_name(param1,param2,…){code}PS:不使用 () 访问函数将返回函数声明而不是函数结果 3.1 js字符串长度 易混点：JavaScript字符串长度：str.lengthphp的字符串长度：count(string)Java的字符串的长度：str.length()python的字符串长度：len(string)jQuery中的length：表示query对象中元素个数 $(“div”).siblings().length=&gt;表示div标签的兄弟节点元素个数 3.2 使用\\ 转义字符 \\n表示换行 3.3 比较运算符与逻辑运算符 &quot;==&quot;:表示值相等&quot;===&quot;:表示值相等基础上，数据类型也相同&amp;&amp; :表示与运算|| :表示或运算! : 表示非运算 3.4字符串的截取 str.slice(start，end)方法：提取字符串的某个部分并在新字符串中返回被提取的部分(起始索引值为0，且满足左闭右开)。该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。 substring()方法：类似于 slice()，不同之处在于 substring() 无法接受负的索引 substr(start,length)：第二个参数规定被提取部分的长度，如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。 str.replace(a,b) 在字符串str中用b替换a 12345678910let name = \"this girl that i fall in love with her sister is about 18 years old\";typeof(name); // 判断数据类型：\"string\"name.length; // 判断字符长度：67name.slice(0,4); // 满足左闭右开，索引值默认从0开始：\"this\"name.slice(-3,-1); // 从右至左，索引值默认为-1开始：\"ol\"name.substring(-8,2); // 不接受负索引值：\"th\"name.substring(-8,-2); // \"\"name.substr(2,5); // \"is gi\"name.replace(\"sister\",\"young sister\"); // 替换：\"this girl that i fall in love with her young sister ...\" 3.5 转换为大小写 str.toUpperCase()str.toLowerCase() 3.6 str.trim() str.trim() 方法仅能删除字符串两端的空白符 12let name = \" i love you\";name.trim(\"you\") // 返回结果\"i love you\"去除了首位的空格 3.7 str.split()：切割字符串，返回数组的形式 这里有一个小知识点，当split()里面什么都不加时，会把整个字符串当作一个数组；当写法为split(“”)时，表示将原字符串的每一个字符进行切割；当写法为split(“指定字符串”)时，将原字符串按照指定字符串进行切割举例说明： 12345678let quote = \"i love you because of you\";console.log(quote.split()); // [\"i love you because of you\"]console.log(quote.split(\"\")); /*[\"i\", \" \", \"l\", \"o\", \"v\", \"e\", \" \", \"y\", \"o\", \"u\", \" \", \"b\", \"e\", \"c\", \"a\", \"u\", \"s\", \"e\", \" \", \"o\", \"f\", \" \", \"y\", \"o\", \"u\"]*/console.log(quote.split(\"you\")); //[\"i love \", \" because of \", \"\"] 未完待续…","categories":[{"name":"javascript","slug":"javascript","permalink":"https://ahrilove.top/categories/javascript/"}],"tags":[{"name":"clone","slug":"clone","permalink":"https://ahrilove.top/tags/clone/"},{"name":"push","slug":"push","permalink":"https://ahrilove.top/tags/push/"}]},{"title":"Memcached","slug":"Memcache","date":"2019-11-19T16:00:00.000Z","updated":"2019-12-03T00:19:21.382Z","comments":true,"path":"2019/11/20/Memcache/","link":"","permalink":"https://ahrilove.top/2019/11/20/Memcache/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached……","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached…… 1.安装memcached&nbsp;&nbsp;&nbsp;Memcached是通过在内存里维护一个统一的巨大的hash表，memcached能存储各种各样的数据，包括图像、视频(但是极不推荐来保存二进制文件)、文件、以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。参考docker创建memecached容器windows下ThinkPHP3.2.3使用memcache缓存 2.创建memcached镜像docker run -di –name=”memcached” -m 256m -p 11211:11211 memcached:[tag] 123456-d是启动一个守护进程；-m是分配给Memcache使用的内存数量，单位是MB；-u是运行Memcache的用户；-l是监听的服务器IP地址，可以有多个地址；-p是设置Memcache监听的端口，，最好是1024以上的端口；-c是最大运行的并发连接数，默认是1024； 3.测试并进入docker容器 测试是否启动成功 netstat -luntp|grep 11211或者docker ps 安装telnet yum install -y telnet 或 sudo apt-get install telnet 通过telnet方式连接memcached telnet 127.0.0.1 11211 或者使用 telnet ubuntu_ip docker_memcached_port 设置值，age是key，0是标志位，900是生命周期，8代表所占字节数，回车之后的10是value set age 0 900 810 获取值 get age 退出 exitquit 4.telnet操作memcached：1.添加数据 set语法：12345678 set key flas(是否压缩,默认为0，不压缩) timeout value_length value示例： set username 0 60 7 zhiliao``` + add语法： add key flas(0) timeout value_lengthvalue示例：add username 0 60 7xiaotuoset和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。 2.获取数据：get key_name 3.删除数据：delete key_name 4.删除memcached所有数据：flush_all 5. memcached安全性memcached的操作不需要任何用户名和密码，只需要知道memcached服务器的ip地址和端口号即可。因此memcached使用的时候尤其要注意他的安全性。这里提供两种安全的解决方案。分别来进行讲解： &nbsp;&nbsp;&nbsp;&nbsp;1.使用-l参数设置为只有本地可以连接：这种方式，就只能通过本机才能连接，别的机器都不能访问，可以达到最好的安全性。&nbsp;&nbsp;&nbsp;&nbsp;2.使用防火墙，关闭11211端口，外面也不能访问 未完待续…","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"Memcached","slug":"Memcached","permalink":"https://ahrilove.top/tags/Memcached/"}]},{"title":"docker开发环境系列部署","slug":"docker开发环境部署","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-19T01:31:11.425Z","comments":true,"path":"2019/11/19/docker开发环境部署/","link":"","permalink":"https://ahrilove.top/2019/11/19/docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","excerpt":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡","text":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡 1.python3+Django+MySQL部署Django项目集群1.1 宿主机上创建工程目录site，并进入该目录1234567项目目录结构：site |__achievements |__db |__Dockerfile |__doocker-compose.yml |__requirements.txt 1.2 参考两篇优秀博文离未罔两|Docker—-搭建python3+django+mysql开发环境冰凉的枷锁lax|Docker搭建Python+Django+mysql开发环境 2. Docker实现Nginx和Tomcat负载均衡暗夜猎手-大魔王|使用docker搭建高并发网站架构实践2–Docker实现Nginx和Tomcat负载均衡 菲宇|Docker下Nginx+Tomcat实现负载均衡","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"},{"name":"python+Django+MySQL","slug":"python-Django-MySQL","permalink":"https://ahrilove.top/tags/python-Django-MySQL/"}]},{"title":"Python模拟登录淘宝(Ⅰ)","slug":"requests库模拟登录淘宝(Ⅰ)","date":"2019-11-18T05:45:34.494Z","updated":"2019-11-18T05:45:34.496Z","comments":true,"path":"2019/11/18/requests库模拟登录淘宝(Ⅰ)/","link":"","permalink":"https://ahrilove.top/2019/11/18/requests%E5%BA%93%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E6%B7%98%E5%AE%9D(%E2%85%A0)/","excerpt":"讲模拟登录淘宝之前，我们来回顾一下之前用requests库模拟登录GitHub和新浪微博的过程:这一类模拟登录是比较简单的登录，只需要在请求登录时将用户名和密码上传验证通过就成功了，也就是说一步到位！而淘宝登录就比较复杂，为什么说复杂呢？因为淘宝登录涉及参数多且请求不止一次！","text":"讲模拟登录淘宝之前，我们来回顾一下之前用requests库模拟登录GitHub和新浪微博的过程:这一类模拟登录是比较简单的登录，只需要在请求登录时将用户名和密码上传验证通过就成功了，也就是说一步到位！而淘宝登录就比较复杂，为什么说复杂呢？因为淘宝登录涉及参数多且请求不止一次！ 参考文章~裸睡的猪 淘宝系列欲更新文章内容： 第一篇：Python模拟登录淘宝，详细讲解如何使用requests库登录淘宝pc端。 第二篇：淘宝自动登录2.0，新增Cookies序列化，教大家如何将cookies保存起来。 第三篇：Python爬取淘宝商品避孕套，教大家如何爬取淘宝pc端商品信息。 第四篇：Python分析2000款避孕套，教大家如何做数据分析得出结论。 ———————————————— 1.淘宝登录流程","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"Requests","slug":"Requests","permalink":"https://ahrilove.top/tags/Requests/"},{"name":"POST请求","slug":"POST请求","permalink":"https://ahrilove.top/tags/POST%E8%AF%B7%E6%B1%82/"},{"name":"token","slug":"token","permalink":"https://ahrilove.top/tags/token/"}]},{"title":"Git命令总结","slug":"git命令大全","date":"2019-11-17T16:00:00.000Z","updated":"2019-12-16T12:59:31.428Z","comments":true,"path":"2019/11/18/git命令大全/","link":"","permalink":"https://ahrilove.top/2019/11/18/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"总结一下自己常用的git命令","text":"总结一下自己常用的git命令 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash” git config –global user.name “Your Name”git config –global user.email “email@example.com“ cd F: (打开F盘)mkdir (创建子目录)pwd (显示当前目录) git init (把这个目录变成Git可以管理的仓库) git add git commit -m “说明” git status (仓库当前的状态) git diff (查看不同) git log [–pretty=oneline {缩略版,可选}] (查看历史记录) git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id) git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本) git diff HEAD – (查看工作区和版本库里面最新版本的区别) git checkout – (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除) git reset HEAD (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本) git rm (用于删除一个文件) ssh-keygen -t rsa -C “youremail@example.com“ (创建SSH Key) git remote add origin git@github.com:Bruce333/other.git (关联github远程库) git push -u origin master/git push origin master(推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改) git clone git@github.com:Bruce333/other.git (克隆一个本地库) git checkout -b dev(创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支]) git branch (列出所有分支，当前分支前面会标一个*号) git checkout master (切换到master分支) git merge dev (合并指定分支到当前分支) git branch -d dev (删除dev分支) git log –graph (查看分支合并图) git merge –no-ff -m “merge with no-ff” dev(通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去) git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作) git stash list (查看工作现场) / git stash apply stash@{0} () git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除]) git branch -D (强行删除一个没有被合并过的分支) git remote (查看远程库的信息) / git remote -v (显示更详细的信息) git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致) 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 git pull(把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name) git tag &lt;commit id 可无&gt;(打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签) git show (查看标签信息) git tag (查看所有标签) git tag -a -m “blablabla…” (指定标签信息) git tag -s -m “blablabla…” (用PGP签名标签) git tag -d (删除标签) git push origin (推送某个标签到远程) git push origin –tags (一次性推送全部尚未推送到远程的本地标签) git tag -d (删除一个本地标签) git push origin :refs/tags/ (删除一个远程标签) git config –global color.ui true (让Git适当地显示不同的颜色) 忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 git config –global alias.st status(告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中) 2019-12-16 新增：当自己的账户有私人的GitHub和企业的gitlab时，不经意间就会将不同的用户名，邮箱搞混，幸得建彬哥真传，终于搞懂了。1.在自己的项目文件下直接”git bash here”2.查看当前项目所属的用户名与邮箱 git remote show origin查看当前仓库基本信息git remote -v 查看当前项目远程地址git branch -a 查看远程项目所有分支，红颜色分支代表当前所在分支git config user.name 查看当前项目的用户名git config user.email 查看当前项目的邮箱 3.设置用户名和邮件git config [–global] user.name “用户名”git config [–global] user.email “邮箱”git config命令的-- global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://ahrilove.top/tags/git/"},{"name":"git pull/push","slug":"git-pull-push","permalink":"https://ahrilove.top/tags/git-pull-push/"}]},{"title":"ThinkPHP","slug":"ThinkPHP","date":"2019-11-14T16:00:00.000Z","updated":"2019-12-08T12:58:13.469Z","comments":true,"path":"2019/11/15/ThinkPHP/","link":"","permalink":"https://ahrilove.top/2019/11/15/ThinkPHP/","excerpt":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push(),clone()ThinkPHP的变量输出memcached缓存机制ThinkPHP通用项目结构","text":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push(),clone()ThinkPHP的变量输出memcached缓存机制ThinkPHP通用项目结构 ThinkPHP3.2 笔记 1.js的clone()与push函数的一些生活纠纷 push()函数：向数组的末尾添加一个或多个元素，并返回新的长度。返回值是把指定的值添加到数组后的新长度语法：arrayObject.push(newelement1,newelement2,….) push() 方法可把它的参数顺序添加到 arrayObject（数组对象）的尾部。它直接修改 arrayObject，而不是创建一个新的数组，而是在原数组基础上修改。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能，该方法会改变数组的长度。 案例1：push() 1234567var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\"; console.log(arr);//输出原素组 ['chd','sjb','sgx']console.log(arr.push(\"badwoman\")); // 输出 4 PS:来了，push添加元素之后没有直接输出添加元素之后的数组，只显示了数组的个数（长度） 12345678// 展示push后的新数组var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\";arr.push('badwoman');console.log(arr);//输出结果为：['chd','sjb','sgx','badwoman'] js的clone()函数 js对象之间的赋值，如果直接用”=”会发现来两个对象还是同一个对象，改变其中一个另外的一个也会做出对应的改变。为了解决这个问题，可以利用java里面的clone的原理。假设有这样一个场景：当存在一个公共数组(对象型)时，一个需要加{“name”:”chd”,”age”:18}另一个需要在数组尾加上{“name”:”sgx”,”age”:108} 12345let commonCondition=[&#123;\"id\":15&#125;];let a=&#123;\"name\":\"chd\",\"age\":18&#125;;let b=&#123;\"name\":\"sgx\",\"age\":108&#125;;// 当我们利用a = commonCondition.push(a)时，此时原来的commonCondition也会跟着改变// 赋值b = commonCondition.push(b)。此时，b中也会包含a的数据，此刻js的clone函数就出现了 js的clone()函数源代码: 1234567891011121314151617181920212223function clone(Obj)&#123; var o; if (typeof obj == \"object\") &#123; if (obj === null) &#123; o = null; &#125; else &#123; if (obj instanceof Array) &#123; o = []; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; o.push(this.clone(obj[i])); // 有可能不要this &#125; &#125; else &#123; o = &#123;&#125;; for (var j in obj) &#123; o[j] = this.clone(obj[j]); // 有可能不要this &#125; &#125; &#125; &#125; else &#123; o = obj; &#125; return o; &#125; 即此刻，我们才有如下最正确的式子 1234let new_a = clone(commonCondition);a = new_a.push(a);let new_b = clone(commonCondition);b = new_b.push(b); 2. thinkphp项目调用Vue扩展函数方式2.1 导入vue扩展包.js文件 1&lt;script src=\"./cf.js\"&gt;&lt;/script&gt; 2.2 声明方法：新建一个与项目名同名的js文件，新增如下内容 123456789101112Vue.prototype.项目名 = &#123; // 这里表示扩展函数 函数名一:function(obj)&#123; ... &#125;, 函数名二:function(obj)&#123; ... &#125;, ...&#125; 2.3 调用方法：Vue实例化名. 项目名.函数名()Vue实力化名即：let app = new Vue({})中的app,经过测试后，调用方法为 项目名.函数名（） 3.thinkPHP的变量输出知识&lt;{:函数名/变量名}&gt; 中的冒号&quot;:&quot;表示引用调用函数，获取变量值 &lt;{:U(query)}&gt;:URL生成http://serverName/projectName/当前模块/当前控制器/声明的方法 123默认的模板标签为：在config.php文件下更改设置&apos;TMPL_L_DELIM&apos;=&gt;&apos;&lt;&#123;&apos;,&apos;TMPL_R_DELIM&apos;=&gt;&apos;&#125;&gt;&apos;, &lt;{:I(‘name’,’chd’)}&gt;中的I方法获取自定义参数值，不存在时，自定义默认值 I(‘get.name’); // 相当于 $_GET[‘name’]支持默认值： 2019-12-8 新增：查看thinkphp3.2手册存在变量输出方式二：在模板（即HTML文件）中输出变量的方式很简单，只需要我们在控制器给模板变量赋值： 1234567$name = \"ThinkPHP\";/*@param $this-&gt;assign() 绑定，分配数据@param （'name',$name）参数一：表示要在模板中引用的变量名，在不加$符号时，也要使用引号括起来*/$this-&gt;assign('name',$name); $this-&gt;display(); // 将分配的数据在HTML页面展示 然后再模板中使用（注意模板标签的{和$之间不能有任何的空格，否则标签无效,普通标签默认开始标记是{，结束标记是 }。也可以通过设置TMPL_L_DELIM和TMPL_R_DELIM进行更） 12345hello,&lt;&#123;$name&#125;&gt;&lt;!-- 在模板编译后结果为：--&gt;Hello,&lt;?php echo($name);?&gt;&lt;!--这样就在HTML页面显示为：--&gt;hello,ThinkPHP 4. ThinkPHP的memcached缓存机制 4.1 下载安装memcached，并启动其服务 参考docker创建memecached容器 windows下ThinkPHP3.2.3使用memcache缓存 4.2thinkphp3.2中其实已经加入了memcached缓存机制，只需要在Conf/config.php配置数据缓存类型即可使用Memcache: 1234567&lt;? php return array( 'DATA_CACHE_TYPE' =&gt; 'Memcache', // 数据缓存类型 'MEMCACHE_HOST' =&gt; 'tcp://127.0.0.1:11211', 'DATA_CACHE_TIME' =&gt; '3600' )?&gt; 5.ThinkPHP项目模块结构，参考此文章1234567891011121314151617project项目名: |---Application:应用模块 |Admin后台模块 |Home前台模块 |---Controller控制器 |---IndexController.class.php |---Model模型 |---IndexModel.class.php |---View视图 |---index.html |Common公共配置模块（不能直接访问） |Runtime缓存模块 |---Public静态资源文件 |---ThinkPHP框架 |---index.php：入口文件 |---favicon.ico：网站图标 |---.htaccess:Apache配置文件（重写URL，修改访问权限） 未完待续。。。","categories":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://ahrilove.top/categories/ThinkPHP/"}],"tags":[{"name":"$.post()","slug":"post","permalink":"https://ahrilove.top/tags/post/"},{"name":"thinkPHP","slug":"thinkPHP","permalink":"https://ahrilove.top/tags/thinkPHP/"},{"name":"API","slug":"API","permalink":"https://ahrilove.top/tags/API/"},{"name":"Ajax","slug":"Ajax","permalink":"https://ahrilove.top/tags/Ajax/"},{"name":"CSS","slug":"CSS","permalink":"https://ahrilove.top/tags/CSS/"}]},{"title":"JSON通常用于与服务端交换数据,在向服务器发送数据时一般是字符串","slug":"json","date":"2019-11-13T16:00:00.000Z","updated":"2019-12-23T01:15:50.740Z","comments":true,"path":"2019/11/14/json/","link":"","permalink":"https://ahrilove.top/2019/11/14/json/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组PS:json键值对一定要用双引号包裹起来","text":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组PS:json键值对一定要用双引号包裹起来 1.Python的json规则python程序中的json有一点点区别于JavaScript中的json，它是通过对象和数组的组合来表示数据 1.1 对象型数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它在JavaScript是使用花括号{}包裹起来的内容，数据结构为{key1:value1,key2:value2…}的键值对结构，key为对象的属性，value为对应的值。键名可以使用整数和字符串来表示，所以，一个json对象跨用写作如下格式(对象型数组) 123456789[&#123; \"name\": \"chd\", \"age\": 18, \"sex\": \"man\" &#125;,&#123; \"name\": \"Monica\", \"gender\": \"woman\", \"birthday\": \"1997-1-25\"&#125;] 调用方式:通过中括号加0索引，可以得到第一个字典元素，然后调用其键名即可得到相应的键值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式一：中括号加键名data[index][“键名”] =&gt; data[0][‘name’]，结果为‘chd’&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式二：get()方法传入键名，如果键名不存在，不会报错，会返回none（python中推荐使用）data[index].get(‘键名’) =&gt; data[1].get(“birthday”),结果为”1997-1-25” 1.2 键值对形式（类似于字典） 1234567891011121314&#123; \"code\": 1, \"msg\": \"success\", \"data\": &#123; \"name\": \"pig\", \"age\": \"18\", \"sex\": \"man\", \"hometown\": &#123; \"province\": \"江西省\", \"city\": \"抚州市\", \"county\": \"崇仁县\" &#125; &#125;&#125; 1.3 需要注意到点 JSON的键名和字符串都必须使用双引号引起来，而Python中单引号也可以表示为字符串，所以这是个比较容易犯的错误！Python类型与JSON相互转换的时候到底是用load//dump还是用loads\\dumps？他们之间有什么区别？什么时候该加s什么时候不该加s？这个我们可以通过查看源码找到答案：不加s的方法入参多了一个fp表示filepath，最后多了一个写入文件的操作。所以我们在记忆的时候可以这样记忆：加s表示转成字符串(str)，不加s表示转成文件。 2.javascript中的json1234567var stu = &#123;&quot;student&quot;: //stu 对象包含student的key,值为一个数组 [ //数组的每一个值为一个具体的学生对象 &#123;&quot;name&quot;: &quot;Tom&quot;,&quot;Grade&quot;:1, &quot;age&quot;:11, &quot;gender&quot;: &quot;M&quot;&#125;, //学生对象的键为名字,值为对应属性 &#123;&quot;name&quot;: &quot;Jerry&quot;, &quot;Grade&quot;:1, &quot;age&quot;:10, &quot;gender&quot;: &quot;M&quot;&#125; //每个属性对应的是一个key,value对 ], &quot;classroom&quot;: &#123;&quot;class1&quot;: &quot;room1&quot;, &quot;class2&quot;: &quot;room2&quot;&#125; //对象的值,嵌套对象 &#125;; json.parse()：是从一个字符串中解析出 json 对象 123456789//定义一个字符串var data='&#123;\"name\":\"goatling\"&#125;';//解析对象​​var a = JSON.parse(data);typeof(a) // 对象类型/*结果是：*Object* &#123;name:\"goatling\"&#125;*/ json.stringify() 是从一个对象中解析出字符串 123456789let data=&#123;name:'goatling'&#125;;let a = JSON.stringify(data);typeof(a) // 对象类型/** 结果是：* '&#123;\"name\":\"goatling\"&#125;'* 字符串类型* */","categories":[{"name":"json","slug":"json","permalink":"https://ahrilove.top/categories/json/"}],"tags":[{"name":"json.parse()","slug":"json-parse","permalink":"https://ahrilove.top/tags/json-parse/"},{"name":"json.stringify()","slug":"json-stringify","permalink":"https://ahrilove.top/tags/json-stringify/"}]},{"title":"数据库存储引擎与索引,视图","slug":"mysql(二)","date":"2019-11-11T16:00:00.000Z","updated":"2019-12-02T13:06:44.920Z","comments":true,"path":"2019/11/12/mysql(二)/","link":"","permalink":"https://ahrilove.top/2019/11/12/mysql(%E4%BA%8C)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引概述 索引作用 视图 视图的操作","text":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引概述 索引作用 视图 视图的操作 1.索引概述索引在创建表的时候可以同时创建，也可以随时增加新的索引创建新索引的语法为:create [unique|fulltext|spatial] index index_name [using index_type] on table_name( col_name [(length)] [asc|desc])删除索引： DROP INDEX index_name on table_name 2.索引作用合理的创建索引是提高查询速度最有效的方式之一。&nbsp;&nbsp;&nbsp;&nbsp;在没有建立索引的情况下，查询一条数据的过程是这样：MySQL是从第一条记录开始查表，在某一个地方查到了匹配的数据，停止？NO，继续查询剩下的数据，直到查完整张表。 &nbsp;&nbsp;&nbsp;&nbsp;在建立合适索引的情况下，查询一条数据的过程又是这样：MySQL先根据索引快速到达一个位置去搜索数据文件，然后查出数据，而不必查看整张表的数据。tips:1、索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。2、索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。3、通过创建唯一索引，可以保证某一列的值具有唯一性。 1234567891011/*添加唯一索引：*/ALTER TABLE studentsADD UNIQUE INDEX unique_name(name);/*只添加唯一约束而不添加唯一索引：*/ALTER TABLE studentsADD CONSTRAINT unique_name UNIQUE(name); 因此，为了提高查询速度，合理建立索引是非常有必要的。 类型 描述 普通索引 基本的索引类型，允许定义索引的列中插入重复值和空值 唯一索引 索引列值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 主键索引 特殊的唯一索引，不允许有空值 全文索引 类型为FULLTEXT,支持值的全文查找，允许在索引列中插入重复值和空值 组合索引 在表的多个字段组合上创建的索引 3.视图（5.0.1提供视图功能）&nbsp;&nbsp;&nbsp;&nbsp;视图是一种虚拟存在的表，它存储的是查询语句，显示出来的是查询的结果；更直白的说就是当我们需要从表中查询一些信息时需要编写相关SQL语句，将这些SQL语句存储为视图，那么我们调用这些视图的时候就相当于执行了SQL语句，从而可以得到想要的结果eg:创建视图并执行查询操作 create view view_name as select qty,price,qty*price as value from temp; 视图有什么作用 1.视图就像是一个封装了很多功能的函数，我们把一系列复杂的查询语句存储为一个视图，这样在需要频繁使用这些语句时不必反复编写，直接使用视图代替即可 12345678如果要频繁获取表user的name和表goods的name。就应该使用以下sql语句：select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;但有了视图就不一样了，创建视图other。示例create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;创建好视图后，就可以这样获取user的name和goods的name： select * from other; 2.对数据库进行重构但仍不会影响程序运行 12345678假如因为某种需求，需要将user表拆成表usera和表userb，该两张表的结构如下： 测试表:usera有id，name，age字段 测试表:userb有id，name，sex字段这时如果程序端一直使用的sql语句是：select * from user;那就会报错提示该表不存在，这时要么去更改程序的查询语句要么就创建视图。显然，创建视图更简单，成本更低。以下sql语句创建视图：create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;以上假设name都是唯一的。这时程序端端使用的sql语句：select * from user;就不会报错。这就实现了更改数据库结构，而不用更改脚本程序的功能。 4.视图的操作 4.1 创建或修改视图 create [ or replace ] [ algorithm = { undefined | merge | temptable } ] view view_name [ (column_list) ] as select_statement [ with [ cascaded | local ] check option ] 使用了OR REPLACE可以修改视图，或者直接就CREATE OR REPLACE 替换为ALTER 即变成修改语法； UNDEFINED：未定义指定算法；MERGE：更新视图表数据的同时会更新真实表的数据（默认）；TEMPTABLE：只能查询不能更新； CASCADED(默认)：必须满足所有针对该视图的所有视图的条件才可以更新；LOCAL：只需满足本视图的条件就可以更新； WITH CHECK OPTION：需要满足相关的检查条件才能进行更新12345--常量视图create or replace view pi as select 3.1415926 as pi; --select中包含子查询create or replace view city_view as select (select city from city where city_id=1); 4.2 查看当前数据库下所有视图 show full tables where table_type like ‘view’; 5.优化SQL语句一般步骤 5.1 通过show status 查看各语句的频率 6.数据库Leetcode1.求薪水第二高，不存在就返回null 123select ifnull((select distinct(Salary) from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary; 超过5名学生的课(having用法) 1234select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5 DATEDIFF是两个日期的天数差集 123select a.Id as newIdfrom Weather a left join Weather b on datediff(a.RecordDate,b.RecordDate)=1 where a.Temperature&gt;b.Temperature","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://ahrilove.top/tags/mysql/"},{"name":"InnoDB","slug":"InnoDB","permalink":"https://ahrilove.top/tags/InnoDB/"},{"name":"MyISAM","slug":"MyISAM","permalink":"https://ahrilove.top/tags/MyISAM/"}]},{"title":"MySQL数据库(一)：DDL，DML，DCL","slug":"MySQL数据库","date":"2019-11-10T16:00:00.000Z","updated":"2019-12-12T01:47:30.499Z","comments":true,"path":"2019/11/11/MySQL数据库/","link":"","permalink":"https://ahrilove.top/2019/11/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式1.两个用户在同一个应用服务器上:select * from &#39;user_name&#39;&nbsp;.&nbsp;&#39;table_name&#39;;2.两个用户不在同一个应用服务器上。。。","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式1.两个用户在同一个应用服务器上:select * from &#39;user_name&#39;&nbsp;.&nbsp;&#39;table_name&#39;;2.两个用户不在同一个应用服务器上。。。 1.启动服务net start 服务器名（Windows）service start 服务器名（linux） 2.登录与修改密码 命令 含义 mysql -u root -p -h localhost 登录MySQL（p表示密码；u表示用户名；h表示主机地址） mysqladmin -u用户名 -p旧密码 password新密码 修改用户名密码 3.基本使用 命令 含义 show databases; 用于显示所有的数据库 use 数据库名; 使用目标数据库 select database()/version()/now()/user(); 显示当前连接的信息 show tables; 用于显示选中数据库下的所有的表 desc table_Name; 查看表结构 show create table table_name \\G; 查看到创建时的SQL语句及更多详细信息 \\G使记录按照字段竖向排列，易于阅读 创建数据库并指定编码格式:create database if not exists 数据库名 character set utf8;删除数据库：drop database [if exists] 数据库名; 4.DDL&amp;DMLDDL:数据定义语言仅对数据库，表，列，索引起作用（create、drop、alter）DML:数据操纵语言仅对table中的具体数据起作用（select、insert、delete、update） 5.DDL 1.创建表 创建表 create table 表名( ​ 列名 数据类型 列级约束, ​ 列名 数据类型 列级约束 ​ )【表类型】【表字符集】【表注释】 12345678910#创建学生表，并设置表类型、字符集CREATE TABLE `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &apos;主键、学号&apos;, `psd` VARCHAR(20) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;123456&apos; COMMENT &apos;密码&apos;, `name` VARCHAR(30) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;匿名&apos; COMMENT &apos;学生姓名&apos;, `sex` VARCHAR(2) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;男&apos; COMMENT &apos;性别&apos;, `birsday` DATETIME DEFAULT NULL, `email` VARCHAR(20) COLLATE utf8_estonian_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_estonian_ci 数据类型 约束条件： not null unique primary key 主键名 foreign key (Id_P) references Persons(Id_P) :一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY default 默认值 auto increment:在每次插入新记录时，自动地创建主键字段的值 5.1主键&nbsp;&nbsp;&nbsp;&nbsp;对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 &nbsp;&nbsp;&nbsp;&nbsp;由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。&nbsp;&nbsp;&nbsp;&nbsp;使用BIGINT，会占用更大的磁盘和内存空间，内存空间毕竟有限，无效的占用会导致更多的数据换入换出，额外增加了IO的压力，对性能是不利的。因此推荐自增主键使用int unsigned类型，但不建议使用bigint。&nbsp;&nbsp;&nbsp;&nbsp;所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键,而应该使用INT UNSINGED自增或者GUID类型。主键也不应该允许NULL。可以使用多个列作为联合主键，但联合主键并不常用。&nbsp;&nbsp;&nbsp;&nbsp;如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 12345create table user( id INT UNSIGNED NOT NULL AUTO_INCREMENT primary key , /*数据类型 非空 自增 主码约束*/ name varchar(200) /*主码，外码约束条件写法二：primary key(id) */ ) 2.删除表：drop table table_name 3.修改表 命令 含义 修改表中列的数据类型 alter table table_name modify 列名 column_definition 增加表字段 alter table table_name add [column] 列名 column_definition 删除表字段表字段 alter table table_name drop [column] 列名 表的字段改名 alter table table_name change [column] old_col_name new_col_name 表字段改名同时也可修改字段类型 alter table table_name change [column] old_col_name new_col_name column_definition 更改表名 alter table table_name rename [to] new_tablename 6.DML语句 命令 含义 插入数据 insert into table_name ( field1, field2,…) values (value1,value2,….); 一次性插入多条数据 insert into table_name ( field1, field2,…) values (value1,value2,..),(value1,value2,..)…; 更新记录 update table_name set field1=value1，field2=value2，… [ WHERE CONDITION ] 删除某一项记录 delete from table_name [WHERE CONDITION ] 排序和限制 select * from table_name [ WHERE CONDITION ] [ order by field1 [ DESC\\ASC ], field2 [ DESC\\ASC], ..] 表连接 select ename,deptname from emp1 left join dept on emp1.deptno=dept.deptno; 子查询 关键字主要有in、not in、=、!=、exists、not exists,between and等等 1.可以不用指定字段名称，但此时后面的values应该与表的字段顺序保持一致2.对于某些字段允许空值、非空但是有指定的默认值、自增长等，这些字段在insert时如果没有指定value，那么将会右系统自动配置 7.DCL语句 创建数据库用户，并声明权限 创建操作数据库的专用用户，格式：grant 权限 on 数据库名.数据表名 to 用户名@主机IP IDENTIFIED BY 密码 1234说明：权限：ALL PRIVILEGES(所有权限),select,insert,update,delete,create,alter,drop主机IP： &apos;%&apos; 匹配所有主机，localhost表名： * 表示所有表 刷新权限 flush privileges 这里向大家拓展一个知识点，那就是主机IP指的是该用户只能在对应的主机IP上进行登录。例如：假如user用户设置的主机IP为localhost，那么其他人就将无法从本地以外的地方使用user用户进行登录。 8.查询记录 8.1 distinct 查询不重复的记录 select distinct id from emp1; 加distinct关键字使得查出的结果中去掉了重复记录 8.2 条件查询 判断条件可以使用=、&gt;、&lt;、&gt;=、&lt;=、!=等等，同时多个条件还可以使用and、or等进行连接 8.3 聚合 1234567891011select [ field1, field2,...,fieldn] fun_name from tablename [ where condition ] [ group by field1, field2,..., fieldn [ with rollup ] ] [ having condition ]参数说明：fun_name 聚合函数，表示要做的聚合操作，常用的有sum（求和）、count(*)（计数）、max、min等。 GROUP BY 表示对后面的字段进行分类聚合（也常叫分组）； WITH ROLLUP 可选语法，在ORDER BY 语句内出现，表示是否对分类聚合后的结果进行再汇总； HAVING 表示对分类后的结果再进行条件过滤； 同样是条件过滤，having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤。因此，为了提高聚合效率，一般先用where过滤不相干的记录后，在进行聚合，最后再用having进行二次过滤 12select gender，count(gender) from tab_teacher group by gender having gender=\"woman\";-- 含义为：按性别分组，查询出女老师人数的总数:先执行group by，再聚合函数，最后having筛选 9.注意要点 9.1 避免使用通配符“*” 实际开发中，要避免使用通配符”*”（通配符代表所有字段），因为系统要先解析出所有的字段名，将其还原为真实的名字，然后再进行操作。如果记录数据库内容特别多，会影响效率。 9.2 查询表的总记录数(推荐使用主键的方式查询) 因为主键唯一，且不能为空,此时id总数则代表总记录数select count(id) from table_teacher; 9.3 别名的用法 select count(id) as new_number from table_teacher;或者使用别名来代替表的名字select t.name,t.age from tab_teacher t; 9.4 分页查询方式 查询老师记录的前三条（从0位置开始找出3条）： limit后面有两个参数：第一个参数是起始位置，第二个参数是偏移量select * from tab_teacher limit 0,3; oracle的sql语句中没有limit,limit是mysql中特有的,在oracle中可用rownum来表示,用于查询结果中的前N行数据。如要查询emp表中的前5行数据,可用如下语句: &nbsp;&nbsp;select * from emp where rownum","categories":[{"name":"Database","slug":"Database","permalink":"https://ahrilove.top/categories/Database/"}],"tags":[{"name":"database","slug":"database","permalink":"https://ahrilove.top/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"https://ahrilove.top/tags/mysql/"},{"name":"DDL","slug":"DDL","permalink":"https://ahrilove.top/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"https://ahrilove.top/tags/DML/"}]},{"title":"jQuery学习","slug":"jquery","date":"2019-11-10T16:00:00.000Z","updated":"2020-01-20T04:13:21.115Z","comments":true,"path":"2019/11/11/jquery/","link":"","permalink":"https://ahrilove.top/2019/11/11/jquery/","excerpt":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题 本文要点：1.选择器2.bootstrap的进度条功能添加…","text":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题 本文要点：1.选择器2.bootstrap的进度条功能添加… 1. 选择器id选择器 $(“#div”) 类选择器 $(“.div”) 标签选择器 $(“div”) 并集选择器 $(“selector1,selector2,…,selectN”)：使用逗号连接，以数组形式返回所有的合并元素 后代选择器 $(“div p”):div标签下的p标签，包含子孙节点 过滤选择器 $(“div:eq(n)”) :eq(index)获取给定索引值的元素 从0开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:gt(index) 匹配所有大于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:lt(index) 匹配所有小于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:even 匹配所有索引值为偶数的元素，从 0 开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:odd 匹配所有索引值为奇数的元素，从 0 开始计数属性选择器 $(“div[attribute=”value”]”) :匹配给定的属性是某个特定值的元素 表单的选择器:$(‘input:radio/checkbox/text/password/…’),即: type值为radio、checkbox、password等的input元素 筛选选择器 : $(‘div’).eq(n) 获取第n个元素 数值从0开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.first()获取第一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.last()获取最后一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.parent() 选择父亲元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.siblings()选择兄弟元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.find() 查找目标元素值 PS:注意筛选选择器与过滤选择器的函数位置 2.bootstrap的进度条添加新功能bootstrap带动画效果的进度条的源代码为： 123456&lt;!--这里的class=\"one\"是我自己添加到，方便找出一个div标签--&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-striped active one\" role=\"progressbar\" aria-valuenow=\"45\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 45%\"&gt; &lt;span class=\"sr-only\"&gt;45% Complete&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 为了使进度条能够“运动”起来，这里有几种方法： 方法一：采用jQuery 123456789101112131415161718192021222324$(function()&#123; $('.one').click(function()&#123; // 休眠函数，类似于python的time.sleep() function sleep(n) &#123; //n表示的毫秒数 var start = new Date().getTime(); while (true) if (new Date().getTime() - start &gt; n) break; &#125; // 获取当前的进度条长度，并转换为正整数 let len = parseInt($(this).attr(\"aria-valuenow\")); while(len&lt;=100)&#123; // 进度条的长度其实就是style属性的width长度 $(this).css('width',String(len)+\"%\"); len ++; &#125; &#125;)&#125;)``` &gt;方法二：setInterval(function,milliseconds)，给定的时间间隔内重复执行该函数 ```javascriptsetInterval(function () &#123; $(this).css('width',String(len)+\"%\"); len ++;&#125;, 1000) 3.jQuery的事件常见的DOM事件: 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload hover 1.click鼠标点击事件:选择目标元素 123$(&quot;p&quot;).click(function()&#123; // 动作触发后执行的代码!!&#125;); 2.dblclick(),当双击元素时，会发生 dblclick 事件。 12345dblclick() 方法触发 dblclick 事件，或规定当发生 dblclick 事件时运行的函数： 实例$(&quot;p&quot;).dblclick(function()&#123; $(this).hide();&#125;); 3.mouseenter():当鼠标指针穿过元素时，会发生 mouseenter 事件 123$(&quot;#p1&quot;).mouseenter(function()&#123; alert(&apos;您的鼠标移到了 id=&quot;p1&quot; 的元素上!&apos;);&#125;); 4.mouseleave():当鼠标指针离开元素时，会发生 mouseleave 事件。 12345mouseleave() 方法触发 mouseleave 事件，或规定当发生 mouseleave 事件时运行的函数：实例$(&quot;#p1&quot;).mouseleave(function()&#123; alert(&quot;再见，您的鼠标离开了该段落。&quot;);&#125;); 5.mousedown():当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 12345mousedown() 方法触发 mousedown 事件，或规定当发生 mousedown 事件时运行的函数：实例$(&quot;#p1&quot;).mousedown(function()&#123; alert(&quot;鼠标在该段落上按下！&quot;);&#125;); 6.hover()方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave) 1234567$(&apos;p&apos;).hover(function()&#123; alert(&apos;你的鼠标在段落上&apos;);&#125;,function()&#123; alert(&apos;你的鼠标已经离开了段落&apos;);&#125;) 4.jQuery的Ajax:jQuery get() 和 post()4.1 jQuery $.get()方法，通过 HTTP GET 请求从服务器上请求数据。 12345678910语法：$.get(URL,callback);必需的 URL 参数规定您希望请求的 URL。可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据：$(&quot;button&quot;).click(function()&#123; $.get(&quot;demo_test.php&quot;,function(data,status)&#123; alert(&quot;数据: &quot; + data + &quot;\\n状态: &quot; + status); &#125;);&#125;); 4.2 jQuery $.post() 方法,通过 HTTP POST 请求向服务器提交数据。 1234567891011121314151617181920212223语法:$.post(URL,data,callback,data_type);url (String) : 发送请求的URL地址.data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示。callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法)。type (String) : (可选)官方的说明是：Type of data to be sent。其实应该为客户端请求的类型(JSON,XML,等等) 下面的例子使用 $.post() 连同请求一起发送数据： $(&quot;button&quot;).click(function()&#123; $.post(&quot;/try/ajax/demo_test_post.php&quot;, &#123; &quot;name&quot;:&quot;菜鸟教程&quot;, &quot;age&quot;:18, &quot;url&quot;:&quot;http://www.runoob.com&quot; &#125;, function(data,status)&#123; alert(&quot;数据: \\n&quot; + data + &quot;\\n状态: &quot; + status); &#125;); &#125;,&quot;json&quot;);","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"https://ahrilove.top/tags/API/"},{"name":"Ajax","slug":"Ajax","permalink":"https://ahrilove.top/tags/Ajax/"},{"name":"CSS","slug":"CSS","permalink":"https://ahrilove.top/tags/CSS/"},{"name":"jQuery","slug":"jQuery","permalink":"https://ahrilove.top/tags/jQuery/"},{"name":"选择器","slug":"选择器","permalink":"https://ahrilove.top/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"Python全栈系列章节更新（一）：基本数据类型","slug":"python数据类型","date":"2019-11-10T16:00:00.000Z","updated":"2020-02-01T09:55:47.533Z","comments":true,"path":"2019/11/11/python数据类型/","link":"","permalink":"https://ahrilove.top/2019/11/11/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 字符串：len(),split(),join()…列表：append(),pop(),count()…元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 字符串：len(),split(),join()…列表：append(),pop(),count()…元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 1.字符串 zip()函数：将可迭代对象所包含的元素是由原列表元素组成的元组 a = [“a”,”b”,”c”] b = [1, 2, 3]c = [x for x in zip(a,b)]c = [(“a”, 1), (“b”, 2), (“c”, 3)]结果为元祖型列表 format():位置参数，参数索引从0开始，format里填写{}对应的参数值 msg = “my name is {}, and age is {}”.format(‘chd’,18)渲染结果：my name is chd, and age is 18 str.index()字符串索引: 索引值从0开始,不存在就会报错 s=’index’ s[0]=is.index(‘i’) = 0 : 查找目标字符串索引值 str.find(‘目标字符串’)查找目标字符串,不存在就返回数值-1(推荐使用find) “i am iron man”.find(“man”) =&gt; 1 移除指定字符串 str.strip() s = ‘ hello,world! ‘s.strip()s.lstrip()s.rstrip()s2 = &#39;hello,world!&#39;s2.strip(&#39;\\ &#39;) len(str)字符串长度 len(‘hello,world’) =&gt; 11 str.replace(a,b)替换：在字符串str中，用b来替换a ‘hello,world’.replace(‘o’,’a’) =&gt; ‘hella,warld’ str[a:b:c] 切片操作(左闭右开) [a:b:c]：a表示为索引起始位置（索引以0开始）；b表示为索引结束位置；c表示为跳跃间隔案例如下： 12345678910111213&gt;&gt;&gt; test=&quot;1234hello-world56789&quot;&gt;&gt;&gt; type(test)&lt;class &apos;str&apos;&gt;&gt;&gt;&gt; test[:]&apos;1234hello-world56789&apos;&gt;&gt;&gt; test[0:1]&apos;1&apos;&gt;&gt;&gt; test[0:2]&apos;12&apos;&gt;&gt;&gt; test[0:5:2]&apos;13h&apos;&gt;&gt;&gt; test[0:5]&apos;1234h&apos; string.capitalize() 把字符串的第一个字符大写 str.count(‘目标字符串’): 返回 str 在 string 里面出现的次数 “连接字符”.join(seq序列):返回 str 在 string 里面出现的次数 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 str.lower()/upper() 将字符串全部转换为小写/大写 “hello world”.lower()/upper() =&gt;”hello world” / “HELLO WORLD” str.split(指定字符串) 以指定字符串来分割目标字符串，以列表形式返回 1234url = \"http://www.baidu.com/python/image/123456.jpg\"#以“.” 进行分隔path =url.split(\".\")path1=['http://www', 'baidu', 'com/python/image/123456', 'jpg'] 2019-11-28 新增：当split的参数为空时，即string.split():表示以空格作为分割符，并将换行符也去掉 2.列表 列表截取（索引从0开始，且满足左闭右开原则）与拼接:从右至左取值，则索引默认从-1开始 L=[‘Google’, ‘Runoob’, ‘Taobao’]L[2]=’Taobao’ L[-1]=’Taobao’ 列表函数和方法 函数和方法 描述 len(list) 列表元素个数 list(seq) 将元组或字符串转换为列表 max/min(list) 返回列表元素最大/最小值 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) 将对象插入列表 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中某个值的第一个匹配项 list.reverse() 反向列表中元素 list.sort( key=None, reverse=False) 对原列表进行排序 2019-12-2 新增： 数组拆分：将一个含有m个数目的数组拆分成每n个一组，剩下的构成一个新数组 12345# 将obj数组分割成每100个一组numbers=[1,2,3,4,5,6,7,8,...,10000]number =[]for i in range(0, len(numbers), 100): number.append(numbers[i:i + 100]) 3.元组 3.1元组的创建 元组使用小括号，而列表使用方括号，只需要在括号中添加元素，并使用逗号隔开即可 1tup1 = ('a','b','c',336) 3.2 元组的访问使用下脚标索引来访问元组中的值，下标索引从0开始 tup1[0] =&gt; &#39;a&#39; ,tup[1] =&gt; &#39;b&#39; 3.3 元组的修改 元组中的元素是不允许修改或删除的，但我们开始对其进行拼接组合tuple(seq)：将列表转换为元组。 4.字典:可变模型，可存储任意类型对象 4.1字典的创建 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号&nbsp;&nbsp;,&nbsp;&nbsp;分割，整个字典包括在花括号 {} 1d = &#123;key1 : value1, key2 : value2 &#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258',9527:'badwoman',6394:998&#125; 4.2 字典的访问 访问方式：字典名[&quot;键名&quot;] 或者字典名.(&quot;键名&quot;,自定义数据)：当目标键名不存在时，使用自定义数据值作为默认值，注意此刻不会修改原字典 4.3 字典的更新 1234567dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; dict['Age'] = 8 # 更新dict['School'] = \"RUNOOB\" # 添加 print(\"dict['Age']: \", dict['Age'])print(\"dict['School']: \", dict['School']) 4.4 内置函数和方法 函数和方法 描述 cmp(dict1, dict2) 比较字典元素值：如果两个字典的元素相同返回0，如果字典dict1大于字典dict2返回1，如果字典dict1小于字典dict2返回-1 len() 计算字典元素个数，即键的总数 dict.items() 将字典的键值一一对应组合成一个元组，以列表的形式返回值 dict.pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 123456demo=&#123;'Name': 'Zara', 'Age': 8, 'Class': 'First', 'School': 'RUNOOB'&#125;demo.items() # dict_items([('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')])a = [x for x in demo.items()]print(a) # a=[('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')] python的直接赋值，浅拷贝和深拷贝 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 解析： b = a 赋值引用，a与b都指向同一个对象，即共有同一块内存地址 123456a = &#123;1: [1, 2, 3]&#125;b = a # b = &#123;1: [1, 2, 3]&#125;# 更新a的值a[1]=[1,2,3,4]print(b) # b = &#123;1: [1, 2, 3, 4]&#125;# 即直接赋值也属于浅拷贝，共用同样一块地址 b = a.copy():浅拷贝，a与b是一个独立的对象，但他们的子对象还是指向统一对象（是引用） 12345a = &#123;1: [1,2,3]&#125;b = a.copy()print(a,b) # (&#123;1: [1, 2, 3]&#125;, &#123;1: [1, 2, 3]&#125;)a[1].append(4) # 字典更新print(a, b) #(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;) b = copy.deepcopy(a) 深拷贝：深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的,是两块独立的地址。 1234567&gt;&gt;&gt; import copy&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;)&gt;&gt;&gt; a[1].append(5)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4, 5]&#125;, &#123;1: [1, 2, 3, 4]&#125;) map与reducde函数（python2与python3的区别）map()函数接收两个参数，一个是函数，一个是Iterable（可迭代对象），map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator（迭代器）返回(可以使用list转换为数组)，而python2返回的是一个数组 12345def f(x): return x * xr = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])list(r) # [1, 4, 9, 16, 25, 36, 49, 64, 81] 使用map返回结果是迭代器，将数据转换为列表reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ahrilove.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"元组","slug":"元组","permalink":"https://ahrilove.top/tags/%E5%85%83%E7%BB%84/"},{"name":"列表","slug":"列表","permalink":"https://ahrilove.top/tags/%E5%88%97%E8%A1%A8/"},{"name":"字典","slug":"字典","permalink":"https://ahrilove.top/tags/%E5%AD%97%E5%85%B8/"},{"name":"数值","slug":"数值","permalink":"https://ahrilove.top/tags/%E6%95%B0%E5%80%BC/"}]},{"title":"docker容器虚拟化技术","slug":"docker容器虚拟技术","date":"2019-11-09T16:00:00.000Z","updated":"2020-01-02T09:17:34.762Z","comments":true,"path":"2019/11/10/docker容器虚拟技术/","link":"","permalink":"https://ahrilove.top/2019/11/10/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/","excerpt":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题","text":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题 1.docker适用环境其实docker本身也没有太多在Windows下花功夫。目前，docker仅支持Linux与Windows企业版、专业版、教育版。ps：家庭版不支持docker,并且win10下可以安装docker-for-windows,这个安装包是专门适用于win10，安装简单，而对于win7/8则可以使用Docker Toolbox下载地址 2.Windows下无法对docker容器进行端口访问（端口映射的问题）1.问题详情&nbsp;&nbsp;&nbsp;在Windows10系统服务器中安装了docker和docker-compose&nbsp;&nbsp;&nbsp;并尝试在其中运行Nginx服务，映射也做好&nbsp;&nbsp;&nbsp;问题：在主机的浏览器中，打开localhost:port无法访问对应的Web服务。2.问题解析&nbsp;&nbsp;&nbsp;原因：docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows10。3.解决办法&nbsp;&nbsp;&nbsp;启动docker命令行窗口&nbsp;&nbsp;&nbsp;输入命令:docker-machine ip default&nbsp;&nbsp;&nbsp;Linux的ip地址，一般情况下这个地址是192.168.99.100&nbsp;&nbsp;&nbsp;然后在Windows的浏览器中，输入 http://IP:port 即可启用（http://192.168.99.100：8069） 3.docker与VMware不可兼容&nbsp;&nbsp;&nbsp;在Windows下安装docker，第一步就是要打开Hyper-V(打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V),开启win自带的虚拟管理技术。但是若想要使用VMware，则必须关闭Hyper-V，鱼和熊掌不可兼得呀！(′д｀ )…彡…彡 4.Windows：vmware与hyper-v不兼容,请移除hyper-v角色1、请移除hyper-v角色。（1）以管理员身份（win + x）运行命令提示符；（2）执行命令：bcdedit /set hypervisorlaunchtype off（3）重启系统，运行vm即可。2、如果想要恢复hyper启动：&nbsp;&nbsp;&nbsp;bcdedit / set hypervisorlaunchtype auto 5.docker run后接/bin/sh和接/bin/bash的区别是什么：比如我们要获取一个nginx镜像，同一镜像存在有不同的tags&nbsp;&nbsp;&nbsp;/bin/sh命令仅适用于tags带alpine标签的： nginx:1.17-alpine；&nbsp;&nbsp;&nbsp;/bin/bash命令仅适用于tags不带alpine标识的：nginx：laster，nginx:1.8… 6.docker运行MySQL服务 拉取镜像docker pull mysql:[tag] 创建并运行容器docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql：5.6 ps: -p 表示指定访问端口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e 设置环境变量，或者覆盖已存在的环境变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-d 表示以守护式方式来运行容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MYSQL_ROOT_PASSWORD=123456 声明MySQL的用户名为ROOT，密码为123456 查看容器是否启动docker ps 启动容器docker start container_id 进入容器内部,以命令行交互docker exec -it container_id /bin/bash 登录MySQLmysql -u root -p 然后在输入密码 成功表示已经成功登陆MySQL 7.最强万能公式:数据卷挂载式创建容器12345守护式：docker run -di [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine交互式：docker run -it [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine含义： a） 以-v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw 带rw(read,write)权限来将宿主机与容器进行数据卷挂载 b) docker run 以新容器名和端口号以及守护式或者交互式来创建容器 8.宿主机与docker容器权限纠纷问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它来了！问题又出现了！哭啦。数据卷挂载时，即使声明了rw权限，在宿主机中创建文件，数据共享后，容器内能够具有正常的rw权限；但在容器内新建了文件后，宿主机就只有只读权限，无法修改文件内容。 解决方案：宿主机的权限不够&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在（7）式中的万能公式中添加：docker run ··· --privileged=true ··· 9.docker配置nginx的配置文件命令：docker run --name=&quot;dnmp_nginx&quot; -p 80:80 -v /home/docker-nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/docker-nginx/log:/var/log/nginx -v /home/docker-nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -di nginx:\\[tags]&nbsp;&nbsp;&nbsp;&nbsp;第一个-v 表示将你本地的nginx.conf覆盖你要起启动的容器的nginx.conf文件，第二个表示将日志文件进行挂载，就是把nginx服务器的日志写到你docker宿主机的/home/docker-nginx/log/下面。第三个-v 表示的和第一个-v意思一样的&nbsp;&nbsp;&nbsp;&nbsp;我个人更喜欢守护式映射的方式，麻烦的是需要自己准备好nginx.conf 和default.conf文件，我是直接从容器里面复制的，然后根据自己的需要改的 我都想把它杀了，部署nginx太多坑了，不过参考了此博文，最终解决了问题，解决方法： 1.创建三个根目录根据情况创建：/docker/nginx/conf www logs docker run -d -p 80:80 --name=”nginx” --net host -v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/logs:/var/log/nginx nginx:1.17.5 2.不对配置文件进行数据挂载即 -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf 这个 3.进入容器 获取文件 docker exec -it nginx /bin/bash 4.cd /etc/nginx/ （这里主要获取配置文件路径的）,然后exit 5.数据拷贝 进入宿主机目录文件 cd /docker/nginx/conf/将已经运行成功的容器的配置文件拷贝到宿主机的配置文件目录：docker cp 容器ID:/etc/nginx/nginx.conf .（ps：“.”表示拷贝到当前目录） ps：文件copy成功后 把nginx容器先删除掉 6.创建最终的nginx容器 12345678docker run -di -p 80:80 --name nginx [--net host] :再思考一下有没有必要写，使用–net = host时,它告诉容器使用主机网络堆栈.因此无法将端口暴露给主机,因为它是主机(就网络堆栈而言).-v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf-v /docker/nginx/logs:/var/log/nginx nginx:1.17.5ps:成功后就代表部署成功 2019-11-29 新增：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里宿主机的nginx.conf其实是挂载了一个文件，docker是不推荐这样使用的，可以尝试在宿主机上创建目录为：/docker/nginx/conf/nginx.conf/nginx.conf(当前conf文件是一个具体的配置文件，不是一个目录)，这样上式就不会出现docker warning，结合此篇文章 。 PS：访问可能会403 因为/docker/nginx/www/ 里面没有index.html放进去就好了 7.权限赋予 挂载成功后，给宿主机上的www目录（或整个文件目录）增加权限，不然一直无法读写：&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod -R 777 目标目录 ：给目标目录赋予最大管理员权限&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod +/-rwx 文件名|目录 给文件或目录的赋予权限 10.docker配置MySQL，redis教程等，请点击此处链接命令:docker run -di -p 12345:3306 \\--name=&quot;mysql&quot; -v /lnmp/mysql/conf:/etc/mysql/conf.d -v /lnmp/mysql/logs:/logs -v /lnmp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456:rw mysql:5.6 命令说明：-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。--name mysql：运行服务名字-v /lnmp/mysql/conf:/etc/mysql/conf.d ：将主机/lnmp/mysql录下的conf/my.cnf 挂载到容器的 /etc/mysql/conf.d-v /lnmp/mysql/logs:/logs：将主机/lnmp/mysql目录下的 logs 目录挂载到容器的 /logs。-v /lnmp/mysql/data:/var/lib/mysql ：将主机/lnmp/mysql目录下的data目录挂载到容器的 /var/lib/mysql-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。-d mysql:5.6 : 后台程序运行mysql5.6 11.docker 容器管理工具：portainer使用 这个数据卷用于持久化Portainer数据： docker volume create portainer_data2. 创建相关portainer容器docker run -di -p 9000:9000 --name=”portainer”-v /var/run/docker.sock:/var/run/docker.sock-v portainer_data:/data portainer/portainer 12.外部Windows如何访问docker内的容器 1.基本架构：Windows，Dockers，Linux三者关系 2.相关操作 2.1 关闭Linux防火墙：systemctl stop firewalld.service 2.2 查看Linux，Docker的IP地址:ifconfig(区别于Windows的ipconfig命令) 2.3 Windows访问测试: 思想：docker作为一个容器虚拟技术，创建并启动相关的容器服务，并把端口映射到Linux系统中。比如MySQL：docker启动MySQL服务后，并映射了一个外部访问的某端口（比如还是3306），则此刻Linux就具有了3306这个一个端口=&gt;外界访问方式应该是：访问虚拟机Linux上与之相绑定docker容器映射出的端口。 2019-11-27 新增：Linux:在 windows 系统中访问 linux 中 nginx，默认不能访问的，因为防火墙问题,即我们可以有两种解决方法（1）关闭防火墙：参考上述相关操作（2）开放访问的端口号，比如80端口，操作如下： 查看开放的端口号 firewall-cmd --list-all 设置开放的端口号 firewall-cmd --add-service=http --permanentfirewall-cmd --add-port=80(或其它开放端口号)/tcp --permanent 重启防火墙 firewall-cmd --reload Ubuntu:Ubuntu与linux对于防火墙的操作存在很大的区别：注意区分1、查看端口开启状态（inactive表示已经关闭了防火墙）sudo ufw status 2、开启某个端口，比如我开启的是3306sudo ufw allow 3306 3、开启防火墙sudo ufw enable 4、关闭防火墙sudo ufw disable 5、重启防火墙sudo ufw reload 6、禁止外部某个端口比如80sudo ufw delete allow 80 7、查看端口ipnetstat -ltn————————————————","categories":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ahrilove.top/tags/docker/"},{"name":"VMware","slug":"VMware","permalink":"https://ahrilove.top/tags/VMware/"},{"name":"images","slug":"images","permalink":"https://ahrilove.top/tags/images/"},{"name":"container","slug":"container","permalink":"https://ahrilove.top/tags/container/"},{"name":"Hyper-V","slug":"Hyper-V","permalink":"https://ahrilove.top/tags/Hyper-V/"},{"name":"Linux","slug":"Linux","permalink":"https://ahrilove.top/tags/Linux/"},{"name":"交互式与守护式创建","slug":"交互式与守护式创建","permalink":"https://ahrilove.top/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%B8%8E%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%88%9B%E5%BB%BA/"}]},{"title":"Vue","slug":"Vue","date":"2019-11-07T16:00:00.000Z","updated":"2019-12-17T02:34:25.882Z","comments":true,"path":"2019/11/08/Vue/","link":"","permalink":"https://ahrilove.top/2019/11/08/Vue/","excerpt":"&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,有很好的数据双向绑定性。","text":"&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,有很好的数据双向绑定性。 1.jQuery与Vue糅合使用 1.jquery基本使用：先导入相关jQuery库包，然后按人类正常思维，就声明入口函数,然后在入口函数中书写逻辑代码 123456&lt;script&gt; $(function()&#123; ... ... &#125;);&lt;/script&gt; 但是，奇怪他个猪猪皮，即使不用声明入口函数，直接书写逻辑程序，经过多次测试，TM居然还可以正常使用 2.jQuery+Vue(若想两者结合使用，则一定不能声明入口函数，否则Vue无法使用)当你想测试Vue时，就会出现vue实例未声明的报错 &nbsp;&nbsp;1 Uncaught ReferenceError: vm is not defined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at :1:1 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"rookie\"&gt; &lt;p&gt;hello fpx&lt;/p&gt; &lt;p&gt;hello IG&lt;/p&gt; &lt;p&gt;hello kk&lt;/p&gt; &lt;pre&gt;total:&#123;&#123;number&#125;&#125;&lt;/pre&gt; &lt;h6 :class=\"&#123;box:isactive&#125;\"&gt;this is new h6&amp;nbsp;&amp;nbsp;&lt;/h6&gt; &lt;h5 :class=\"[box1,box2,box3?'luko':'']\"&gt;this is new h6&amp;nbsp;&amp;nbsp;&lt;/h5&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input number\" v-model=\"msg\" @keyup.enter=\"fn\"&gt;按键盘enter键触发:&#123;&#123;msg&#125;&#125;&lt;br&gt; &lt;input type=\"text\" placeholder=\"please click enter\" v-model=\"message\" @keyup.13=\"greet(9527)\"&gt;按键盘enter键触发&#123;&#123;message&#125;&#125;&lt;br&gt; &lt;/div&gt; &lt;script&gt; console.log($('p').length); let vm = new Vue(&#123; el:'#app', data:&#123; number:$('p').length, isactive:true, box1:'moko', box2:'boka', box3:true, msg:'', message:'', &#125;, methods:&#123; fn()&#123; alert(this.msg) &#125;, greet(hi)&#123; alert(this.message+hi) &#125; &#125;, &#125;); $('h5').append('&lt;b&gt;this is new plus increment&lt;/b&gt;'); $('h6').append('&lt;br&gt; hello world'); &lt;/script&gt;&lt;/body&gt; 2.Vue的组件 1.组件创建方式分为全局组件与局部组件： &nbsp;&nbsp;&nbsp;全局组件：可以被多个APP进行调用,在APP实例外创建;定义一个名为 button-counter 的新组件:组件名称若使用驼峰原则，引用组件时需要全部小写，并且两个单词之间用“-”连接;若不使用驼峰原则时，直接使用原组件名 全局组件创建方式一： 12345678910Vue.component('buttonCounter', &#123; data: function () &#123; // 1.组件可以有自己的data数据，组件中的data必须是一个方法，且这个方法内部必须返回一个对象才行，而实例中的data可以为一个对象 return &#123; count: 0, info: 'hello world' &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;&#123;&#123;message&#125;&#125; clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;' // 2. 全局组件有template属性 &#125;) 全局组件创建方式二：调用公共模板对象 123456789101112&lt;script&gt; let project=&#123; template:&apos;&apos;, data:function()&#123; // 组件中的data必须是一个方法 return &#123; info:&apos;hello world&apos;, message:&apos;badwoman&apos; &#125;, methods:&#123;&#125;&#125; Vue.component(&apos;组件名&apos;,project); &#125;&lt;/script&gt; 全局组件创建方式三：调用公共模板对象–其实这也是全局组件的一种创建方式，将template绑定到自身data函数中，此刻的data不同于实例中的data，此刻为一个函数 123456789101112131415161718192021222324&lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj = &#123; count: 0 &#125;; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component('counter', &#123; data: function () &#123; // return dataObj return &#123; count: 0 &#125; &#125;, template: '#tmpl', methods: &#123;&#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;) &lt;/script&gt; 3. props属性使用： 数组写法 props: [‘cmovies’, ‘cmessage’] 对象写法 12345678props: &#123; // propsName表示要传递的值 propsName: &#123; type: String, // 组件的值的类型 default: &apos;zzzzz&apos;, // 组件的默认值 required: true //在使用组件必传值 &#125;&#125; props对象写法样例如下：拓展：组件props选项的值可以为为数组类型,也可以是对象类型，props选项的对象类型可以用于对外部传递进来的参数进行数据验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script type=\"text/javascript\"&gt; Vue.component('my-component',&#123; props:&#123; // Number类型 propA: Number, // 多种类型校验: String 或 Number类型 propB: [String, Number], // 布尔类型,默认值true propC:&#123; type:Boolean, default: true &#125;, // String类型且必输 propD:&#123; type:String, required: true &#125;, // Array类型,默认返回一个数组对象 propE:&#123; type:Array, default: function () &#123; return [1,2,3] &#125; &#125;, // Object类型,默认返回一个对象 propF:&#123; type:Object, default: function () &#123; return &#123;a:1&#125; &#125; &#125;, // 自定义验证函数 propG:&#123; validator:function (value) &#123; return value &lt; 10; &#125; &#125;, &#125; &#125;); const vm = new Vue(&#123; el: '#app', data:&#123; parentInput:0 &#125; &#125;)&lt;/script&gt; 4.接受动态数据与静态数据有时候组件接收的参数是来自父组件的动态数据,需要使用v-bind动态绑定props值.下列案例此刻使用了v-blid绑定props值，即此刻绑定的message的值就是为表单中输入的值 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"parentInputText\" placeholder=\"请输入...\"&gt; &lt;my-component :message=\"parentInputText\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; Vue.component('my-component',&#123; props:['message'], template:'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;' &#125;); const vm = new Vue(&#123; el: '#app', data:&#123; parentInputText:'' &#125; &#125;)&lt;/script&gt; 在使用props对子组件传值时,如果不使用v-bind传递数字,布尔,数组,对象类型的数据，这时传递的数据都是字符串类型,由于未使用模板绑定语法,不会被编译，会被当做参数传递到模板中.下列案例此刻没有使用了v-blid绑定props值，即此刻绑定的message的值直接就是”parentInputText“ 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;my-component message=\"parentInputText\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; Vue.component('my-component',&#123; props:['message'], template:'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;' &#125;); const vm = new Vue(&#123; el: '#app', data:&#123; parentInputText:'' &#125; &#125;)&lt;/script&gt; 注意：重要的来了，必须理解┗|｀O′|┛ 嗷~~ 创建格式：Vue.component('组件名',{ /* ..组件的模板对象.. */ }) &nbsp;&nbsp;&nbsp;组件的第一个参数为组件名，而第二个参数是以对象的形式去描述一个组件。组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项 2019-12-9 新增： 5.vue实例中的method方法抽象说明假设在HTML中有这样一个语句：调用methods里面的方法时，假如有返回值时，直接在&lt;!–￼10–&gt;里面展示，注意区分@click=”methodName” 12345678910111213141516171819202122232425&lt;div class=\"box\"&gt;&#123;&#123;test(2)&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; &lt;!---这里是调用methods里面的test()方法：判断参数的数据类型 ---&gt; el:\"#app\", data:&#123;&#125;, methods:&#123; test(hi) &#123; arr = typeof(hi); switch (arr) &#123; case \"string\": return \"this type is string\"; case \"number\": console.log(\"good\"); if (hi&lt;=10 &amp;&amp; hi%2===0) &#123; return hi; &#125; else return(\"不满足条件\"); case \"object\": return(\"this type is object\"); &#125; &#125; &#125; &#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ahrilove.top/tags/Vue/"},{"name":"Jquery","slug":"Jquery","permalink":"https://ahrilove.top/tags/Jquery/"},{"name":"component","slug":"component","permalink":"https://ahrilove.top/tags/component/"}]},{"title":"python文件读read()、readline()、readlines()对比","slug":"python的read_readlines_readline","date":"2019-11-06T16:00:00.000Z","updated":"2020-02-01T09:55:04.176Z","comments":true,"path":"2019/11/07/python的read_readlines_readline/","link":"","permalink":"https://ahrilove.top/2019/11/07/python%E7%9A%84read_readlines_readline/","excerpt":"&nbsp;&nbsp;&nbsp;read():读取整个文件，将文件内容放到一个字符串变量中&nbsp;&nbsp;&nbsp;readline():每次读取一整行，包括换行符，并将其作为字符串返回&nbsp;&nbsp;&nbsp;readlines():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素）","text":"&nbsp;&nbsp;&nbsp;read():读取整个文件，将文件内容放到一个字符串变量中&nbsp;&nbsp;&nbsp;readline():每次读取一整行，包括换行符，并将其作为字符串返回&nbsp;&nbsp;&nbsp;readlines():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素） 1.readline()示例：假设需求是读取一个多行的all_term.txt文件，并列出每一个单词all_term.txt文件： 1234new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothrnobyl social impact chernobyl disastdavid r marpl st martin piano 程序源代码： 123456789101112131415161718def main(): obj = [] with open('all_term.txt', 'r', encoding='utf-8',errors=\"ignore\") as f: while True: myStr = f.readline() # 表示一次读取一行 if not myStr: # 读到数据最后跳出，结束循环。数据的最后也就是读不到数据了，mystr为空的时候 break # 指定字符串来分割目标字符串，以列表形式返回 new_list = myStr.split() # 表示将拆分好的每一行重新拼接成一个完整的数组 obj += new_list print(obj)if __name__ == '__main__': main() readline()表示读取一整行，那如果一个文件有多行数据，使用readline()函数是不是一直重复读取第一行？其实不然，使用with open()打开文件后，第一个readline()读取第一行（也包括换行符），第二个读取第二行,…,第n个读取第n行数据，这是由系统机制判定的。下面我列举一个实例： 12345678910111213141516171819\"\"\"all_term.txt:new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothnew fallout chernobyl social impact chernobyl disastdavid r marpl st martin press cloth\"\"\"# -*- coding:utf-8 -*-with open('all_term.txt', 'r', encoding='utf-8', errors='ignore') as f: a = f.readline().replace(\"\\n\", \"\") b = f.readline().replace(\"\\n\", \"\")print(\"a:\", a)print(\"b:\", b)\"\"\"结果为：a: new fallout chernobyl social impact chernobyl disastb: david r marpl st martin press cloth\"\"\" 根据结果可以得出结论： 1.第一个readline()读取第一行（也包括换行符），第二个读取第二行，…… 2.上面是我们经常看到的按行遍历一个文件方法，你可能已经注意到我在代码中写的if not myStr:部分。当readline读取到为空的时候，意味着读到了文件的结束。这个时候，问题就在这里，很多人会想，是不是遇到一个空行，也会被认为是文件的结束呢？事实上，文件的空白行并不会返回一个空行。因为在每一行的末尾还有一个或者多个分隔符，因此“空白行”至少会有一个换行符或者系统使用的其他符号。所以，即使文件中真的包含一个“空白行”，读入的行也不是空的，这就意味着在真实遍历读取到文件结束之前，程序实际上是不会停止的","categories":[{"name":"Python","slug":"Python","permalink":"https://ahrilove.top/categories/Python/"}],"tags":[{"name":"read() - readline() - readlines()","slug":"read-readline-readlines","permalink":"https://ahrilove.top/tags/read-readline-readlines/"}]},{"title":"Hexo主体设置知识点","slug":"Hexo主体设置知识点","date":"2019-10-26T13:28:53.000Z","updated":"2019-12-11T09:21:32.841Z","comments":true,"path":"2019/10/26/Hexo主体设置知识点/","link":"","permalink":"https://ahrilove.top/2019/10/26/Hexo%E4%B8%BB%E4%BD%93%E8%AE%BE%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法","text":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法 1.Hexo创建文章、标签、分类的Front-matter方法 Ⅰ&nbsp;&nbsp; Front-matter ⅡFront-matter 是md文件最上方以 — 分隔的区域，用于指定个别文件的变量 其实Front-matter就是在\\Hexo\\source_posts下的.md文件中书写文章标题，上传时间，分类名，标签名等等 字段 含义 值类型 默认值 layout 布局模版 String - title 标题 String - date 创建时间 Date 文件创建时间 description 页面描述、摘要 String - cover 是否显示封面 Bool true 2.Makedown标题页的写法 --- layout: 页面布局（配合主题文档使用） title: 文章名称 date: 文章日期 comments: 文章是否开启评论 photos: 文章封面图（仅部分主题支持） tags: - 文章标签一 - 文章标签二 categories: # 文章分类（文章分类等级） - 父分类 - 子分类 - 孙分类 description: 文章描述，即要在首页显示的摘要（仅部分主题支持） --- 这里是摘要 这里是正文 注意：description 和 方式显示摘要二选一即可，部分主题不支持description， 每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档 3.md文件的基本写法 3.1. ``` 代码段 ``` : 表示以原格式展示代码片段。比如 1234567891011121314$(function () &#123; ...... //鼠标进入的时候,其他的li标签透明度：0.5 $(&quot;.wrap li&quot;).hover(function() &#123; $(this).siblings().stop().fadeTo(400, 0.5); //.stop():停止所有在指定元素上正在运行的动画。 &#125;, function() &#123; // 鼠标离开，其他li 透明度改为 1 $(this).siblings().stop().fadeTo(400, 1); &#125;); console.log($(&apos;.attr a&apos;).prop(&apos;href&apos;)); console.log($(&apos;.attr a&apos;).prop(&apos;title&apos;)); console.log($(&apos;input:checkbox&apos;).attr(&apos;id&apos;)); console.log($(&apos;.office p:eq(0)&apos;).scrollTop());&#125;) 3.2. &lt;img src=”url” width=” “&gt; &nbsp;&nbsp;&nbsp;表示在md文件中展示图片，若不想破坏图片原格式，就只需要写width或者height其中一个，另一个会自适应变化 3.3. 文本修饰:粗体，斜体… &nbsp;&nbsp;&nbsp;粗体文本用两个*或_包含，斜体文本用一个_包含 3.4. 表格(注意其格式) 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 3.5. 颜色RGB和字体以及背景颜色 12345678910&lt;font face=\"Tahoma\"&gt;这是一串Tahoma字体&lt;/font&gt;&lt;br/&gt;&lt;font face=\"黑体\"&gt;这是一串黑体字&lt;/font&gt;&lt;br/&gt;&lt;font face=\"微软雅黑\"&gt;这是一串微软雅黑&lt;/font&gt;&lt;br/&gt;&lt;font face=\"STCAIYUN\"&gt;这是一串华文彩云&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ced1 size=7 face=\"黑体\"&gt;背景色+字体+字的size&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ffff size=72&gt;颜色设置&lt;/font&gt;&lt;br/&gt;&lt;font color=gray size=72&gt;灰色处理&lt;/font&gt;&lt;br/&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#bfe1f1&gt;背景色是：#bfe1f1&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 这是一串Tahoma字体这是一串黑体字这是一串微软雅黑这是一串华文彩云背景色+字体+字的size颜色设置灰色处理 3.6. 转义字符 &lt;br&gt; : 换行\\ : 转义字符，原生字符，不加修饰&amp;nbsp; : 空格 3.7 每一篇博文设置图片 只需要在文章前面配置 photos 关键字即可，若没有这种配置，可以选择在正文插入图片，然后使用 将图片显示在摘要里 3.8 图片可点击设置，单独出现 &lt;fancybox&gt;图片设置&lt;/fancybox&gt; 4.Hexo的搜索search功能设置问题描述： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的博客中点击search，输入相关关键字后，点击查询到的相关文章，会出现404错误 解决方法： 1.检查是否安装文档要求正确的安装了依赖包。2.检查根目录配置文件是否有search字段冲突（我的根目录配置文件中没有search字段）。3.检查我们的主题（我使用的是Material X主题）的配置文件是否开启search功能 1234567891011121314151617# 搜索配置search: enable: true service: hexo # google google_api_key: google_engine_id: # algolia algolia_app_id: algolia_api_key: algolia_index_name: # azure azure_service_name: azure_index_name: azure_query_key: # baidu baidu_api_id: 4.这是最容易忽略的，但往往也是问题出现的源头，请检查根目录配置文件中的链接是否正确，如： 1234url: https://fioralove.github.io# 这里似乎存在一个bug，推荐填写GitHub Page的访问地址，不要使用自己在阿里云以及其它的域名注册服务商所提供的地址# 比如我在阿里云所注册的https:AhriLove.top，填上依旧会出现404错误root: / 5.封面轮播图封面幻灯片轮播图片怎么引入本地的照片？？修改主题下_config.yml文件，里面有个banner改一下，多加几行即可 6.front-matter设置123456789101112131415161718192021222324252627282930313233front-matter是指两个\\---之间的内容\\---title: Javascript篇章四：快速入门// 小图标icons: [fas fa-fire accent]date: 2019-11-21toc: true #是否显示文章目录categories: #分类 - javascript// 是否显示封面 cover: truetags: #标签// 是否置顶文章top: true// 文章右边的音乐块music: enable: true # true（文章内和文章列表都显示） internal（只在文章内显示） server: netease # netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） type: song # song （单曲） album （专辑） playlist （歌单） search （搜索） id: 26664345 # 歌曲/专辑/歌单 ID// 作者相关信息块author: name: 作者 avatar: https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png url: https://baidu.commeta: header: \\[title, author, date, categories, counter, top] footer: \\[updated, tags, share]---// 文章描述&lt;!-- more --&gt;","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"https://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"front-matter","slug":"front-matter","permalink":"https://ahrilove.top/tags/front-matter/"}]},{"title":"Hello Hexo","slug":"hello-world","date":"2019-10-24T16:00:00.000Z","updated":"2019-11-10T07:53:24.497Z","comments":true,"path":"2019/10/25/hello-world/","link":"","permalink":"https://ahrilove.top/2019/10/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"初次见面，请多关照","slug":"初次见面_请多关照","date":"2019-10-20T13:01:24.000Z","updated":"2019-12-08T10:45:37.404Z","comments":true,"path":"2019/10/20/初次见面_请多关照/","link":"","permalink":"https://ahrilove.top/2019/10/20/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2_%E8%AF%B7%E5%A4%9A%E5%85%B3%E7%85%A7/","excerpt":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示","text":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示 大家好–^^__^^–，我叫陈浩东 &nbsp;&nbsp;&nbsp;作为GP-12线,滚齿磨齿操作员，目前正学习清洗包装流程、磨齿、滚齿、齿轮生产工艺以及安全生产。&nbsp;&nbsp;&nbsp;对网站开发的有关知识几乎为零，这也是我搭建好自己的不完全博客之后写的第一篇博客，刚开始搭建博客的时候自己也是网上各种百度，由于自己属于小白那种，历经了千辛万苦才弄好，所以借这个机会会一直坚持下去分析自己的知识，一起走向成功的彼岸！","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"https://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"Github Page","slug":"Github-Page","permalink":"https://ahrilove.top/tags/Github-Page/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ahrilove.top/tags/Hexo/"}]}]}