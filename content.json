{"meta":{"title":"AhriLove","subtitle":null,"description":null,"author":"陈浩东","url":"http://ahrilove.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-05T14:21:22.924Z","updated":"2019-10-25T13:08:33.249Z","comments":true,"path":"404.html","permalink":"http://ahrilove.top/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2019-11-20T07:50:39.096Z","updated":"2019-11-20T07:50:39.057Z","comments":true,"path":"about/index.html","permalink":"http://ahrilove.top/about/index.html","excerpt":"","text":"/' \\\\ //\\\\ \\\\ // `\\ \\\\ // 祝大家： .-'^'-. .' a___a `. 春节愉快 合家欢乐！ == (___) == '. ._I_. .' 心想事成 红包拿来！ ____/.`-----'.\\____ ---^^^_v_^^^--- [###(__)#### 自我介绍&nbsp;&nbsp;&nbsp;大家好，我叫陈浩东，浩东陈的陈，你也可以叫我的别名苯苯。97年的四川绵阳人，于2019年6月5日毕业于中国计量大学信息与计算科学专业。虽然口头上一直在说~不会再爱了( ﹁ ﹁ ) ~→，但是我还是忘不了那个badwoman,试问，如果不是真心喜欢，谁愿意当舔狗呢？☹ ☹ ☹ 她不是漂不漂亮的问题，她真的就是那种，很少见，很冷艳的漂亮…&nbsp;&nbsp;&nbsp;你们有可能会说：你那叫喜欢吗？你那是馋她的身子，你下贱 &nbsp;&nbsp;&nbsp;作为一个正能量，儒雅随和的知识分子，兴趣爱好当然必不可少。喜欢羽毛球、乒乓球、登山、游泳（仅能浮起来☹ ☹）、钓鱼以及英雄联盟，当然作为一个资深的土味鉴定师,文艺复兴模仿者,能够快速洞察每一个土味视频背后的正能量思想，有内味了。 2019年职业技术规划： 奋起直追：考上川大“在职”研究生 Python进阶，web框架以及爬虫框架~js逆向解密爬虫 Vue基础知识 ThinkPHP以及PHP学习 HTML+CSS+JavaScript Jquery进阶以及bootstrap Docker容器虚拟技术 Linux的Ubuntu要经常多用 数据库进阶以及存储过程 每日作息安排：1.早上7:25-7:50起床2.中午早点休息，下午一点上班3.五点下班：会寝室吃饭并休息到6:00-6:30,继续学习4.晚上10:40到11:00开始收拾收拾准备下班5.回到寝室，做10-15分钟的Keep6.周六周日特殊安排：早上9-10点起床，其余正常安排 7.周而复始，学会坚持，每天多学一点，未来会好很多，兄弟萌，不甘碌碌无为，那就，冲，杀！！ 推荐学习方法： 渗透科学学习法 晚上睡觉前，把文献放在脑袋和枕头之间，知识会从浓度较高的的书本向浓度较低的脑袋渗透。书本越多，外界知识浓度越高，夜间复习的效果越好！"},{"title":"所有分类","date":"2019-11-05T14:21:22.930Z","updated":"2019-10-25T13:05:49.103Z","comments":true,"path":"categories/index.html","permalink":"http://ahrilove.top/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-11-28T02:25:55.879Z","updated":"2019-11-28T02:25:55.807Z","comments":true,"path":"friends/index.html","permalink":"http://ahrilove.top/friends/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;欢迎大家留言分享自己发掘的优秀博文、微信文章、GitHub开源项目、二次元、摄影、运动、读书、影视…-留言请告诉我你的名称、主页、头像、标签或者简介哦～-如果想定制你的卡片颜色，也可以留言告诉我哦～（十六进制颜色码，如：#FF0000）"},{"title":"","date":"2019-11-28T02:23:55.548Z","updated":"2019-11-28T02:23:55.511Z","comments":true,"path":"mylist/index.html","permalink":"http://ahrilove.top/mylist/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;我从来不记在辞典上已经印有的东西。我的记忆力是运用来记忆书本上还没有的东西。 ——爱因斯坦&nbsp;&nbsp;在这主题页中我将分享自己收集的一些资料以及文档 优秀博客或文章 链接 RGB颜色对照表 https://www.114la.com/other/rgb.htm 比较柔和的配色表 https://www.geticsen.cn/Index/article/content/151.html Hexo的ico图标 http://www.wapadd.cn/icons/awesome/index.htm bilibili视频收藏 https://space.bilibili.com/215893581/favlist git详细教程 https://blog.csdn.net/u011535541/article/details/83379151 Django2.0详细资料文档 https://pan.baidu.com/s/1ppN8GSDdOdcd3ew0e7SxMQ 开发书籍电子版大全 https://pan.baidu.com/s/1HJtB9EieaMZPU0fSK2kgkQ docker详情mindmanage https://pan.baidu.com/s/1nUE4pfe2wThYVGMEYqADXw 网络用语大全~小鸡词典 https://jikipedia.com/ Vue-Devtools最简单的配置，有手就行 https://blog.csdn.net/weixin_38654336/article/details/80790698 Jetbrains全家桶注册码 http://www.medeming.com/ 阿里中间件团队博客 http://jm.taobao.org/ font-awesome ico小图标 https://fontawesome.com/icons?d=gallery&amp;m=free 亲测可用：navicat premium12 破解教程 https://blog.csdn.net/u013162035/article/details/89456708 小马视频码云仓库 https://gitee.com/komavideo/projects 服务端高并发分布式架构演进之路(天猫) https://segmentfault.com/a/1190000018626163 看完这篇还不了解Nginx，那我就哭了！ https://www.cnblogs.com/wcwnina/p/8728391.html#!comments Nginx笔记一 http://www.edrawsoft.cn/viewer/public/s/e194d338895116 Nginx安装配置笔记二（完整版） 链接：https://pan.baidu.com/s/1bTVdjwFl-kyd93C2GksZQQ 提取码：63x6"},{"title":"所有标签","date":"2019-11-05T14:21:22.945Z","updated":"2019-10-25T13:06:22.321Z","comments":true,"path":"tags/index.html","permalink":"http://ahrilove.top/tags/index.html","excerpt":"","text":""},{"title":"逆水行舟用力撑，一篙松劲退千寻","date":"2019-12-02T13:01:50.157Z","updated":"2019-12-02T13:01:50.084Z","comments":true,"path":"sport/index.html","permalink":"http://ahrilove.top/sport/index.html","excerpt":"","text":"Daily PLAN1.每天两则HTML，jQuery，Vue，PHP，docker，[服务器]，ThinkPHP Tomorrow’s mission：2019-11-12：数据库基础,以及python的字符串，字典，列表，元组，序列2019-11-14: 学习归纳json知识,json_decode,json_encode与thinkPHP 2019-12-2 planning: 1.pyhton的ftp库 2.python的time，datetime库 3.python的多线程，多进程 4.DBUtils管理数据库连接池 5.未完待续…"}],"posts":[{"title":"Python全栈系列章节更新（三）：数据库分批次处理和数据库通用连接函数","slug":"python的executemany方法","date":"2019-12-02T16:00:00.000Z","updated":"2019-12-03T02:44:08.119Z","comments":true,"path":"2019/12/03/python的executemany方法/","link":"","permalink":"http://ahrilove.top/2019/12/03/python%E7%9A%84executemany%E6%96%B9%E6%B3%95/","excerpt":"数据库分批次处理:execute,executemany数据库通用连接函数","text":"数据库分批次处理:execute,executemany数据库通用连接函数 1.数据库通用连接函数（连接模块视实际数据库决定，大同小异）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 2.数据分批次处理数据库分批次处理可以使用两种方法：execute()与executemany()方法 2.1 executemany()在使用executemany方法时，需要注意的几个问题： 1.在写sql语句时，不管字段为什么类型，占位符统一使用%s,且不能加上引号。例如 1sql=\"insert into tablename (id,name) values (%s,%s)\" 2.添加的数据的格式必须为元组型列表或元组型元组:list[tuple(),tuple(),tuple()]或者tuple(tuple(),tuple(),tuple())例如 123values=[(1,\"zhangsan\"),(2,\"lisi\")]#或者values=((1,\"zhangsan\"),(2,\"lisi\")) 3.最后通过executemany插入 12cursor.executemany(sql,values)cursor.commit() 2.2 execute()execute()分批次处理的原理是：循环执行批量语句，然后在commit，如下 12345for i in range(10): sql = \"insert into users(id,grand) values(i,i+10)\" cursor.execute(sql)# 批量执行数据后，然后提交 cursor.commit()","categories":[{"name":"Python","slug":"Python","permalink":"http://ahrilove.top/categories/Python/"}],"tags":[{"name":"数据库分批次处理","slug":"数据库分批次处理","permalink":"http://ahrilove.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E6%89%B9%E6%AC%A1%E5%A4%84%E7%90%86/"},{"name":"数据库通用连接函数","slug":"数据库通用连接函数","permalink":"http://ahrilove.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%94%A8%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0/"}]},{"title":"关于数据库返回值的讨论","slug":"关于数据库返回值的讨论","date":"2019-12-01T16:00:00.000Z","updated":"2019-12-02T13:55:39.070Z","comments":true,"path":"2019/12/02/关于数据库返回值的讨论/","link":"","permalink":"http://ahrilove.top/2019/12/02/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E8%AE%A8%E8%AE%BA/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;每到深夜，打开音乐，带上耳机，周围很安静，只有到这个时候我才感觉到自己是一个学者，而此刻头脑中只有两件事罢了：1.记下今天所用到的知识 2.安安静静听歌最近做一个python获取考勤数据的小脚本，一直没有怎么用到数据库，今天就来探讨一下获取数据库的返回值 关于数据库返回值的讨论python文件打开方式详解fetchall(),fetchone()","text":"&nbsp;&nbsp;&nbsp;&nbsp;每到深夜，打开音乐，带上耳机，周围很安静，只有到这个时候我才感觉到自己是一个学者，而此刻头脑中只有两件事罢了：1.记下今天所用到的知识 2.安安静静听歌最近做一个python获取考勤数据的小脚本，一直没有怎么用到数据库，今天就来探讨一下获取数据库的返回值 关于数据库返回值的讨论python文件打开方式详解fetchall(),fetchone() 1.关于数据库返回值的讨论1.1.构造简单sql语句假设存在这样一个简单的数据库,获取每一行的数据，并保存为txt格式 构造sql语句 select * from dbo.userlist where user_serial&lt;100010 1.2.python连接数据库（SQL server）1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-import pymssql# 获取考勤系统数据def demo(): server = \"\" user = \"\" password = \"\" database = \"\" conn = pymssql.connect( server=server, user=user, password=password, database=database ) # 创建游标 cursor = conn.cursor() # 构造查询sql语句 sql =\"select * from dbo.kt_dev where user_serial&lt;100010\" cursor.execute(sql) numbers = cursor.fetchall() print(numbers[0]) # 元组(100002, '0010014', '00101') print(type(numbers[0])) # tuple元组类型 # 元组访问方式与拼接 print(str(str(numbers[1][0]))+\":\"+str(numbers[1][1])) # 100002:0010002 print(type(numbers)) # list 列表 print('总列表：',numbers) cursor.execute(sql) loan_count = 0 # 获取所有的查询数据(1.区别于fetchone() 2.fetchall/fetchone()的返回值均为元组型列表，即[(第一行数据),(第二行数据),...()]) with open(\"test_demo.txt\",'a+',encoding='utf-8') as f: for number in numbers: f.write(str(number[0])+\" \"+str(number[1]) + \" \"+str(number[2]+\"\\n\")) # 元组数据number=(\"考勤卡号”，\"刷卡时间\") loan_count += 1 # 断开连接 cursor.close() conn.close() print(\"写入完成,共写入%d条数据！\" % loan_count)if __name__ == '__main__': demo() 数据库查询后返回的所有数据 12# 总列表： [(100002, '0010014', '00101'), (100002, '0010002', '00101'),..., (100006, '0010014', '00101')] 由上式案列可知：1.fetchall():表示返回查询到的所有数据；fetchone():表示返回查询到的第一行数据2.python查询返回的所有数据类型为元组型列表，即[(),(),...()]3.元组的访问方式为：元组名[&quot;index&quot;] 2.python文件打开方式详解 打开方式 详解 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。","categories":[{"name":"Database","slug":"Database","permalink":"http://ahrilove.top/categories/Database/"}],"tags":[{"name":"fetchall()","slug":"fetchall","permalink":"http://ahrilove.top/tags/fetchall/"},{"name":"fetchone()","slug":"fetchone","permalink":"http://ahrilove.top/tags/fetchone/"}]},{"title":"Python全栈系列章节更新（二）：常见库模块","slug":"python(二)常见库函数","date":"2019-11-28T16:00:00.000Z","updated":"2019-12-03T12:37:58.992Z","comments":true,"path":"2019/11/29/python(二)常见库函数/","link":"","permalink":"http://ahrilove.top/2019/11/29/python(%E4%BA%8C)%E5%B8%B8%E8%A7%81%E5%BA%93%E5%87%BD%E6%95%B0/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.DBUtils管理数据库连接池3.ftplib模块4.os模块5.datetime模块","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等 1.time模块2.DBUtils管理数据库连接池3.ftplib模块4.os模块5.datetime模块 1.time模块Unix时间戳转与时间的转换 将时间戳转换成时间，首先需要将时间戳转换成localtime，再转换成时间的具体格式： 利用localtime()函数将时间戳转化成localtime的格式利用strftime()函数重新格式化时间 123456789101112131415161718192021222324# -*- coding:utf-8 -*-import time# 将时间戳转化为目标时间格式def timestamp_datatime(value): format = '%Y-%m-%d %H:%M' # format = '%Y-%m-%d %H:%M:%S' # value 为时间戳值,如:1460073600.0 value = time.localtime(value) dt = time.strftime(format, value) return dt# 将目标时间格式转化为时间戳def datetime_timestamp(dt): newTime = time.strptime(dt, '%Y-%m-%d %H:%M') s = time.mktime(newTime) return sif __name__ == '__main__': s = timestamp_datatime(1460073600.0) print(s) # 2016-04-08 08:00 d = datetime_timestamp('2019-06-05 08:00') print(d) # 1559692800.0 按指定的格式获取当前时间利用time()获取当前时间，再利用localtime()函数转换为localtime，最后利用strftime()函数重新格式化时间。 1234567891011#coding:UTF-8import time#获取当前时间time_now = int(time.time())#转换成localtimetime_local = time.localtime(time_now)#转换成新的时间格式(2016-05-09 18:59:20),时间连接符号可改变dt = time.strftime(\"%Y-%m-%d %H:%M:%S\",time_local)print(dt) 2.DBUtils管理数据库连接池当使用多线程，多进程将海量数据存入数据库时，每次执行一个sql的时候都单独建立一个mysql连接，执行完就close掉，很明显这样的问题在于，频繁连接，断开mysql，这样是相当消耗系统资源的，而且增加了mysql连接失败的几率，所以万一哪个线程没有连接成功 这个线程也over了。 2.1 连接池原理1.在程序创建连接的时候，可以从一个空闲的连接中获取，不需要重新初始化连接，提升获取连接的速度2.关闭连接的时候，把连接放回连接池，而不是真正的关闭，所以可以减少频繁地打开和关闭连接 安装DBUtils库 pip install DBUtils 参数解释 参数 详解 creator, # 使用链接数据库的模块(必须：pymssql，pymysql，cx_oralce,…) mincached=0, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=0, # 链接池中最多闲置的链接，0和None不限制 maxshared=0, # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用 maxconnections=0, # 连接池允许的最大连接数，0和None表示不限制连接数 blocking=False, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=None, # 开始会话前执行的命令列表。如：[“set datestyle to …”, “set time zone …”] reset=True, failures=None, ping=1, # ping MySQL服务端，检查是否服务可用 数据库设置(数据库连接模块不一样，其参数名也不同) 如creator=pymysql：host=&#39;localhost&#39;, port=3306,db=&#39;mydata&#39;,user=&quot;root&quot;,passwd=&quot;123456&quot;,charset=&#39;utf8&#39; 数据库通用连接函数（连接模块视实际数据库决定） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from DBUtils import PooledDBimport pymssqlclass sqlserverManager(object): # 构造函数，初始化连接 def __init__(self, server, user, password, database, table): self.server = server self.user = user self.password = password self.database = database self.table = table self.conn = None self.cursor = None self.maxconnections = 15 # 设置最大连接数 # 保存数据到SQL server def connect_database(self): try: self.conn = PooledDB(creator=pymssql, maxconnections=self.maxconnections, server=self.server, user=self.user, password=self.password, database=self.database, charset='utf8').connection() # 创建游标 self.cursor = self.conn.cursor() print(\"sql server had connected\") except Exception as e: print(\"the connect failed:\", e) return None def dbclose(self): self.cursor.close() self.conn.close() def dbcommit(self): self.conn.commit() def execute(self, sql): print(\"-----插入数据-----\") try: self.cursor.execute(sql) except Exception as e: print('\\033[1;31;0m\\t4---插入更新失败，msg：\\033[0m', e, sql.replace(\"\\n\", \"\")) self.conn.rollback() return False return True 2.2 多线程（连接池）操作MySQL插入数据 启动线程任务 每调用一次插入函数就从连接池中取出一个链接操作,完成后关闭链接;executemany 批量操作,减少 commit 次数,提升效率; 3.ftplib操作ftp实现上传和下载的ftplib模块是系统默认安装的，实现文件的上传与下载 3.1 ftp登陆连接1234567891011121314151617181920212223242526from ftplib import FTP #加载ftp模块ftp=FTP() #设置变量ftp.set_debuglevel(2) #打开调试级别2，显示详细信息ftp.connect(\"IP\",\"port\") #连接的ftp sever和端口ftp.login(\"user\",\"password\") #连接的用户名，密码print(ftp.getwelcome()) #打印出欢迎信息bufsize=1024 #设置的缓冲区大小filename=\"filename.txt\" #需要下载的文件file_handle=open(filename,\"wb\").write #以写模式在本地打开文件ftp.retrbinaly(\"RETR filename.txt\",file_handle,bufsize) #接收服务器上文件并写入本地文件ftp.set_debuglevel(0) #关闭调试模式ftp.quit() #退出ftp # ftp相关命令操作ftp.cwd(pathname) #设置FTP当前操作的路径ftp.dir() #显示目录下所有目录信息ftp.nlst() #获取目录下的文件ftp.mkd(pathname) #新建远程目录ftp.pwd() #返回当前所在位置ftp.rmd(dirname) #删除远程目录ftp.delete(filename) #删除远程文件ftp.rename(fromname, toname)#将fromname修改名称为toname。ftp.storbinary(\"STOR filename.txt\",file_content,bufsize) #上传目标文件ftp.retrbinary(\"RETR filename.txt\",file_content,bufsize) #下载FTP文件 3.2 ftp上传或下载文件/目录4.os模块记下常用的os模块的操作指令 命令 含义 os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径,相当于shell的pwd os.chdir(“dirname”) 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: (‘.’) os.pardir 获取当前目录的父目录字符串名：(‘..’) os.makedirs(‘dirname1/dirname2’) 可生成多层递归目录 os.removedirs(‘dirname1’) 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir(‘dirname’) 生成单级目录；相当于shell中mkdir dirname os.rmdir(‘dirname’) 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir(‘dirname’) 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(“oldname”,”newname”) 重命名文件/目录 os.stat(‘path/filename’) 获取文件/目录信息 os.name 输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’ os.system(“执行的命令”) 运行shell命令，直接显示,相当于直接在cmd命令中执行 os.environ 获取系统环境变量 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path/file) 如果路径或文件存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.join(path1,path2,…,pathn) 将多个路径组合后返回 简要样例说明： 123456789101112131415161718192021222324252627&gt;&gt;&gt; os.path.split(&quot;/Users/hqs/PycharmProjects/startMyPython3.0&quot;) (&apos;/Users/hqs/PycharmProjects&apos;, &apos;startMyPython3.0&apos;)&gt;&gt;&gt; os.path.dirname(&apos;/Users/hqs/PycharmProjects/startMyPython3.0&apos;)&apos;/Users/hqs/PycharmProjects&apos;&gt;&gt;&gt;os.system(&quot;ping 127.0.0.1&quot;)正在 Ping 127.0.0.1 具有 32 字节的数据:来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64来自 127.0.0.1 的回复: 字节=32 时间&lt;1ms TTL=64127.0.0.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms &gt;&gt;&gt;os.path.abspath(__file__) 当前文件的绝对路径&gt;&gt;&gt;os.path.dirname(os.path.abspath(__file__))当前文件的上一层目录的绝对路径os.path.dirname(os.path.dirname(os.path.abspath(__file__)))当前文件的上上层目录的绝对路径 5 datetime模块1.datetime.date：表示日期的类2.datetime.datetime：表示日期时间的类3.datetime.time：表示时间的类4.datetime.timedelta：表示时间间隔，即两个时间点的间隔5.datetime.tzinfo：时区的相关信息 123456789101112131415161718&gt;&gt;&gt;datetime.datetime.now()当前系统时间：datetime.datetime(2019, 12, 3, 20, 31, 10, 740869)&gt;&gt;&gt;datetime.datetime.now().year/month/day分别为：2019，12，3&gt;&gt;&gt;datetime.datetime.now().weekday()1 表示在第几周&gt;&gt;&gt;time1 = datetime.datetime(2016, 10, 20)&gt;&gt;&gt;time2 = datetime.datetime(2015, 11, 2) &quot;&quot;&quot;计算天数差值&quot;&quot;&quot;print(time1-time2).days &quot;&quot;&quot;计算两个日期之间相隔的秒数&quot;&quot;&quot;print (time1-time2).total_seconds()","categories":[{"name":"Python","slug":"Python","permalink":"http://ahrilove.top/categories/Python/"}],"tags":[{"name":"time","slug":"time","permalink":"http://ahrilove.top/tags/time/"}]},{"title":"技术小白教你如何定位照片拍摄位置","slug":"照片的GPS信息定位","date":"2019-11-27T16:00:00.000Z","updated":"2019-11-28T06:52:43.925Z","comments":true,"path":"2019/11/28/照片的GPS信息定位/","link":"","permalink":"http://ahrilove.top/2019/11/28/%E7%85%A7%E7%89%87%E7%9A%84GPS%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动）","text":"&nbsp;&nbsp;&nbsp;&nbsp;某些情况，我们需要照片显示记录位置信息，那么当下最便捷的拍照工具就是手机。手机拍摄的照片如何记录详细的位置信息，本经验以华为Mate9为例，展示如何从手机照片定位至拍摄地点。（同时，经测试，定位精度较高，为保护隐私，请关闭手机拍照功能中记录地理信息的功能，或者保护好照片避免外泄，以免被他人用于非法活动） 1.获取GPS信息&nbsp;&nbsp;&nbsp;&nbsp;将照片复制至电脑。点击照片，右键--“右键菜单”--“属性”--“详细信息”，下拉至“GPS”，将会看到经纬度信息。如下图所示： 2.经纬度计算方法&nbsp;&nbsp;&nbsp;&nbsp;我们可以看到经纬度信息，是以度分秒的格式展示的（度分秒之间以“；”间隔），为了方便定位，我们需要将度分秒转换为度的格式。计算方法：经纬度同理（本例为32；49；49.942932000005413）经度：度+（分+秒/60）/60，即32+(49+49.9429/60)/60=32.8305; 3.测试在奥维地图上将计算后的经纬度（以英文格式书写）代入其中，就可以获得地理位置信息。","categories":[],"tags":[{"name":"定位照片拍摄位置","slug":"定位照片拍摄位置","permalink":"http://ahrilove.top/tags/%E5%AE%9A%E4%BD%8D%E7%85%A7%E7%89%87%E6%8B%8D%E6%91%84%E4%BD%8D%E7%BD%AE/"}]},{"title":"Nginx（二）：Nginx的命令和配置文件","slug":"Nginx(二)","date":"2019-11-26T16:00:00.000Z","updated":"2019-11-28T01:24:24.658Z","comments":true,"path":"2019/11/27/Nginx(二)/","link":"","permalink":"http://ahrilove.top/2019/11/27/Nginx(%E4%BA%8C)/","excerpt":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1","text":"与众不同的生活方式很累人呢，因为找不到借口 &nbsp;&nbsp;&nbsp;&nbsp;在上一章节中，我们以及了解到正向、反向代理、负载均衡和动静分离的基本概念，安装教程，而在本节中将会了解到在 本文要点：1.理清概念2.Linux下Nginx的常用命令3.Nginx的基本配置文件nginx.conf4.Nginx 配置实例-反向代理实例 1 1.理清概念docker创建Nginx容器很简单：共享数据卷，外部访问端口映射window下运行nginx，只需简单式一直点击“NEXT”安装，然后添加到环境变量即可在Linux下启动nginx相对比较麻烦，如果你采用其它两种方式，可以跳过本节，本节主要是介绍Linux下的运行命令无论哪种方式启动Nginx，其核心的配置文件以及接下来的几个配置实例都是通用的 2.Linux下Nginx的常用命令先关闭防火墙或者是开放目标端口 进入nginx目录中 cd /usr/local/nginx/sbin (前面路径有可能不同，主要是nginx内的nginx/sbin路径) 1、查看nginx版本号 ./nginx -v 2、启动nginx ./nginx 3、停止nginx ./nginx -s stop 4、重新加载nginx ./nginx -s reload 3.ginx的基本配置文件nginx.conf3.1、nginx 配置文件位置cd /usr/local/nginx/conf/nginx.conf 3.2、配置文件中的内容 包含三部分内容（1）全局块：配置服务器整体运行的配置指令 比如 worker_processes 1;处理并发数的配置 （2）events 块：影响 Nginx 服务器与用户的网络连接 比如 worker_connections 1024; 支持的最大连接数为 1024 （3）http 块 还包含两部分： http 全局块 server 块 3.3 默认的nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 4.Nginx 配置实例-反向代理实例 14.1、实现效果（1）打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到 liunx 系统 tomcat 主页 面中 4.2、准备工作（1）在 liunx 系统安装 tomcat，使用默认端口 8080 * tomcat 安装文件放到 liunx 系统中，解压 * 进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器 （2）对外开放访问的端口firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload （3）查看已经开放的端口号firewall-cmd –list-all （4）在 windows 系统中通过浏览器访问 tomcat 服务器(linux_IP + tomcat_Port) 4.3、访问过程分析 映射IP 假设域名www.123.com映射的IP为Linux上的nginx的ip地址（比如我的是192.168.17.129:80）,nginx也相当于一个分发器，将请求发送至tomcat服务器 123访问过程分析windows端 ----------&gt;Nginx（linux_IP：80）------&gt;tomcat(127.0.0.1:8080)（假设访问www.123.com） 在 nginx 进行请求转发的配置（反向代理配置） 123456789server&#123; listen 80; # 监听端口 server_name www.123.com; # 配置域名 location /&#123; proxy_pass http://127.0.0.1:8080; # 跳转到127.0.0.1：8080路径 index index.html index.htm index.jsp; &#125;&#125; 如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 www.123.com后，成功后直接跳转到tomcat主页","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"http://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://ahrilove.top/tags/nginx/"},{"name":"nginx.conf","slug":"nginx-conf","permalink":"http://ahrilove.top/tags/nginx-conf/"}]},{"title":"Nginx（一）：基本概念","slug":"Nginx","date":"2019-11-24T16:00:00.000Z","updated":"2019-11-28T00:31:56.883Z","comments":true,"path":"2019/11/25/Nginx/","link":"","permalink":"http://ahrilove.top/2019/11/25/Nginx/","excerpt":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程","text":"守住一方平安，尽力而为，问心无愧就好。 &nbsp;&nbsp;&nbsp;&nbsp;Nginx同Apache一样都是一种WEB服务器，Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。 本文要点：正向代理反向代理负载均衡动静分离Nginx安装教程 1.正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。来看个示意图（我把客户端和正向代理框在一块，同属于一个环境，后面我有介绍）：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。如图。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结来说：正向代理，”它代理的是客户端，代客户端发出请求”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正向代理的用途：（1）访问原来无法访问的资源，如Google（2） 可以做缓存，加速访问资源（3）对客户端访问授权，上网进行认证（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 2.反向代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：http://tengine.taobao.org/。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理的作用：（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网（2）负载均衡，通过反向代理服务器来优化网站的负载 3.项目场景以及两者区别通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：两者区别：图解： 在正向代理中，Proxy和Client同属于一个LAN（图中方框内），隐藏了客户端信息； 在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息； 实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了 4.负载均衡我们已经明确了所谓代理服务器的概念，那么接下来，Nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？ 这里提到的客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。 请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。 所以，将服务器接收到的请求按照规则分发的过程，称为负载均衡。 负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。Nginx支持的负载均衡调度算法方式如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。 5.动静分离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 6.nginx安装windows下安装与部署NginxLinux下安装与部署Nginx以后都推荐再docker下安装各式各样的环境Ubuntu+docker下安装与部署Nginx","categories":[{"name":"服务器架构","slug":"服务器架构","permalink":"http://ahrilove.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"apache","slug":"apache","permalink":"http://ahrilove.top/tags/apache/"},{"name":"nginx","slug":"nginx","permalink":"http://ahrilove.top/tags/nginx/"},{"name":"负载均衡","slug":"负载均衡","permalink":"http://ahrilove.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"Javascript篇章三：js数字，数组与日期","slug":"Javascript篇章三","date":"2019-11-21T16:00:00.000Z","updated":"2019-11-26T08:56:40.390Z","comments":true,"path":"2019/11/22/Javascript篇章三/","link":"","permalink":"http://ahrilove.top/2019/11/22/Javascript%E7%AF%87%E7%AB%A0%E4%B8%89/","excerpt":"关关雎鸠，在河之洲。窈窕淑女，君子好逑 本文要点：1.数值方法2.数组以及数组属性和方法3.日期","text":"关关雎鸠，在河之洲。窈窕淑女，君子好逑 本文要点：1.数值方法2.数组以及数组属性和方法3.日期 1.数值方法 number.toString():将数值型转化为字符串型 123var n = 15; console.log(typeof(n)); // 为字数值类型numbera = n.toString(); // a为字符串类型 toFixed(number) 返回保留指定小数位数的数值 12345var x = 9.656;x.toFixed(0); // 返回 10x.toFixed(2); // 返回 9.66x.toFixed(4); // 返回 9.6560x.toFixed(6); // 返回 9.656000 把变量转换为数值 这三种 JavaScript 方法可用于将变量转换为数字： Number() 方法 parseFloat(string) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，则对其进行解析直到完整取出第一个数值，并返回首个数值，如果首字符不是数字则直接返回NaN parseInt(string，radix) 方法:指定字符串的首个字符是否是数字。如果首字符为数字，将字符串取出首个完整数值，并转化为指定radix进制，如果首字符不是数字，就直接返回NaN 123456789101112parseInt(\"10.008\"); // 返回 10parseInt(\"10.33\"); // 返回 10parseInt(\"10 20 30\"); // 返回 10parseInt(\"10 years\"); // 返回 10parseInt(\"years 10\"); // 返回 NaNparseInt(\"30\",8); // 返回24，将30转化为8进制parseFloat(\"10\"); // 返回 10parseFloat(\"10.33\"); // 返回 10.33parseFloat(\"10 20 30\"); // 返回 10parseFloat(\"10 years\"); // 返回 10parseFloat(\"years 10\"); // 返回 NaN 2.数组 数组是一种特殊的变量，它能够一次存放一个以上的值。 var cars=[“Saab”,”Volov”,”BMW”]; 访问数组元素：通过索引（从0开始，下标号）来引用某个数组元素 var name=car[0] 访问数组值var car[0] = “Benz” 修改数组值，即新数组为[“Benz”,”Volov”,”BMW”] 数组属性和方法 length:返回数组元素的数目 遍历数组元素：最安全是使用for循环 123456var fruits;fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];for (i = 0; i &lt; fruits.length; i++) &#123; console.log(fruits[i]);&#125; 向数组添加新元素的最佳方法是使用 push() 方法 12let fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.push(\"Lemon\"); // 向 fruits 添加一个新元素 (Lemon),并返回数组元素个数 join() 方法也可将所有数组元素结合为一个字符串 格式：数组名.join(“指定拼接符”) 123var fruits = [\"Banana\", \"Orange\",\"Apple\", \"Mango\"];console.log(fruits.join(\" * \"));// Banana * Orange * Apple * Mango pop()从数组中删除最后一个元素,并返回该值var fruits = [“Banana”, “Orange”, “Apple”, “Mango”];var x = fruits.pop(); // x 的值是 “Mango” sort()方法以字母顺序对数组进行排序 reverse()反转数组中的元素 123var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.sort(); // 对 fruits 中的元素进行排序fruitS.reverse(); // 对数组元素进行反转 3.日期使用方法：var d = new Date();d.getDate()/d.getFullYear()… 方法 描述 getDate() 以数值返回天（1-31） getDay() 以数值获取周名（0-6） getFullYear() 获取四位的年（yyyy） getHours() 获取小时（0-23） getMilliseconds() 获取毫秒（0-999） getMinutes() 获取分（0-59） getMonth() 获取月（0-11） getSeconds() 获取秒（0-59） getTime() 获取时间（从 1970 年 1 月 1 日至今） 未完待续…","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ahrilove.top/categories/javascript/"}],"tags":[{"name":"对象","slug":"对象","permalink":"http://ahrilove.top/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"属性与方法","slug":"属性与方法","permalink":"http://ahrilove.top/tags/%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"}]},{"title":"Javascript篇章二：js计算精度丢失","slug":"Javascript篇章二","date":"2019-11-20T16:00:00.000Z","updated":"2019-11-26T08:57:12.309Z","comments":true,"path":"2019/11/21/Javascript篇章二/","link":"","permalink":"http://ahrilove.top/2019/11/21/Javascript%E7%AF%87%E7%AB%A0%E4%BA%8C/","excerpt":"若教眼底无离恨，不信人间有白头 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript中没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失。 本文要点：1.js精确度丢失缘由2.精确度丢失解决方案","text":"若教眼底无离恨，不信人间有白头 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于计算机是用二进制来存储和处理数字，不能精确表示浮点数，而JavaScript中没有相应的封装类来处理浮点数运算，直接计算会导致运算精度丢失。 本文要点：1.js精确度丢失缘由2.精确度丢失解决方案 js精确度丢失出现缘由 1.我们先看几个四舍五入的实例 12alert(Number(0.009).toFixed(2)); alert(Number(162.295).toFixed(2)); 按正常结果，应该分别弹出0.01和162.30。但实际测试结果却是在不同浏览器中得到的是不同的结果：在ie6、7、8下得到0.00和162.30，第一个数截取不正确；在firefox中得到0.01和162.29，第二个数截取不正确；在opera下得到0.01和162.29，第二个数截取不正确 2.再看有关于四则运算的实例 12345alert(1/3);//弹出: 0.3333333333333333 alert(0.1 + 0.2);//弹出: 0.30000000000000004 alert(-0.09 - 0.01);//弹出: -0.09999999999999999 alert(0.012345 * 0.000001);//弹出: 1.2344999999999999e-8 alert(0.000001 / 0.0001);//弹出: 0.009999999999999998 按正常结果，除第一行外(因为其本身就不能除尽)，其他都应该要得到精确的结果，从弹出的结果我们却发现不是我们想要的正确结果。是因为没有转换成Number类型吗？我们转换成Number后再计算看看： 12345alert(Number(1)/Number(3));//弹出: 0.3333333333333333 alert(Number(0.1) + Number(0.2));//弹出: 0.30000000000000004 alert(Number(-0.09) - Number(0.01));//弹出: -0.09999999999999999 alert(Number(0.012345) * Number(0.000001));//弹出: 1.2344999999999999e-8 alert(Number(0.000001) / Number(0.0001));//弹出: 0.009999999999999998 还是一样的结果，看来javascript默认把数字识别为number类型。为了验证这一点，我们用typeof弹出类型看看： 123alert(typeof(1));//弹出: number alert(typeof(1/3));//弹出: number alert(typeof(-0.09999999));//弹出: number 3.计算机原理 回忆一下大学时学过的计算机原理，计算机执行的是二进制算术，当十进制数不能准确转换为二进制数时，这种精度误差就在所难免。从上述的推演过程我们知道，这种误差是难免的，c#的decimal和Java的BigDecimal之所以没有出现精度差异，只是因为在其内部作了相应处理，把这种精度差异给屏蔽掉了，而javascript是一种弱类型的脚本语言，本身并没有对计算精度做相应的处理，这就需要我们另外想办法处理了 解决JS计算精确度丢失&nbsp;&nbsp;&nbsp;&nbsp;创建calc.js文件，其调用方法参考&nbsp;&nbsp;thinkphp项目调用Vue扩展函数方式 参考文章 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137Vue.prototype.calc = &#123; /** * 千分位格式化函数 * @param &#123;*&#125; number 要格式化的数字 * @param &#123;*&#125; decimals 保留几位小数 * @param &#123;*&#125; dec_point 小数点符号 * @param &#123;*&#125; thousands_sep 千分位符号 */ number_format(number, decimals, dec_point, thousands_sep) &#123; if(parseFloat(number) == 0) return \" - \"; number = (number + '').replace(/[^0-9+-Ee.]/g, ''); var n = !isFinite(+number) ? 0 : +number, decimals = (typeof decimals === 'undefined') ? 2 : decimals, prec = !isFinite(+decimals) ? 0 : Math.abs(decimals), sep = (typeof thousands_sep === 'undefined') ? ',' : thousands_sep, dec = (typeof dec_point === 'undefined') ? '.' : dec_point, s = '', toFixedFix = function (n, prec) &#123; var k = Math.pow(10, prec); return '' + Math.ceil(n * k) / k; &#125;; s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.'); var re = /(-?\\d+)(\\d&#123;3&#125;)/; while (re.test(s[0])) &#123; s[0] = s[0].replace(re, \"$1\" + sep + \"$2\"); &#125; if ((s[1] || '').length &lt; prec) &#123; s[1] = s[1] || ''; s[1] += new Array(prec - s[1].length + 1).join('0'); &#125; return s.join(dec); &#125;, /** * 加法函数，用来得到精确的加法结果 * 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 * 调用：accAdd(arg1,arg2) * 返回值：arg1加上arg2的精确结果 **/ accAdd: function(arg1, arg2) &#123; var r1, r2, m, c; try &#123; r1 = arg1.toString().split(\".\")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(\".\")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; c = Math.abs(r1 - r2); m = Math.pow(10, Math.max(r1, r2)); if (c &gt; 0) &#123; var cm = Math.pow(10, c); if (r1 &gt; r2) &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")); arg2 = Number(arg2.toString().replace(\".\", \"\")) * cm; &#125; else &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")) * cm; arg2 = Number(arg2.toString().replace(\".\", \"\")); &#125; &#125; else &#123; arg1 = Number(arg1.toString().replace(\".\", \"\")); arg2 = Number(arg2.toString().replace(\".\", \"\")); &#125; return (arg1 + arg2) / m; &#125;, /** * 减法函数，用来得到精确的减法结果 * 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。 * 调用：accSub(arg1,arg2) * 返回值：arg1加上arg2的精确结果 **/ accSub: function(arg1, arg2) &#123; var r1, r2, m, n; try &#123; r1 = arg1.toString().split(\".\")[1].length; &#125; catch (e) &#123; r1 = 0; &#125; try &#123; r2 = arg2.toString().split(\".\")[1].length; &#125; catch (e) &#123; r2 = 0; &#125; m = Math.pow(10, Math.max(r1, r2)); //last modify by deeka //动态控制精度长度 n = (r1 &gt;= r2) ? r1 : r2; return parseFloat(((arg1 * m - arg2 * m) / m).toFixed(n)); &#125;, //乘法函数，用来得到精确的乘法结果 //说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 //调用：accMul(arg1,arg2) //返回值：arg1乘以arg2的精确结果 accMul: function(arg1,arg2) &#123; var m = 0, s1 = arg1.toString(), s2 = arg2.toString(); try &#123; m += s1.split(\".\")[1].length &#125; catch (e) &#123;&#125; try &#123; m += s2.split(\".\")[1].length &#125; catch (e) &#123;&#125; return Number(s1.replace(\".\", \"\")) * Number(s2.replace(\".\", \"\")) / Math.pow(10, m); &#125;, //除法函数，用来得到精确的除法结果 //说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 //调用：accDiv(arg1,arg2) //返回值：arg1除以arg2的精确结果 accDiv: function(arg1, arg2) &#123; var t1 = 0, t2 = 0, r1, r2; try &#123; t1 = arg1.toString().split(\".\")[1].length &#125; catch (e) &#123;&#125; try &#123; t2 = arg2.toString().split(\".\")[1].length &#125; catch (e) &#123;&#125; with(Math) &#123; r1 = Number(arg1.toString().replace(\".\", \"\")); r2 = Number(arg2.toString().replace(\".\", \"\")); return (r1 / r2) * pow(10, t2 - t1); &#125; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ahrilove.top/categories/javascript/"}],"tags":[{"name":"js精确度丢失","slug":"js精确度丢失","permalink":"http://ahrilove.top/tags/js%E7%B2%BE%E7%A1%AE%E5%BA%A6%E4%B8%A2%E5%A4%B1/"}]},{"title":"Memcached","slug":"Memcache","date":"2019-11-19T16:00:00.000Z","updated":"2019-12-03T00:19:21.382Z","comments":true,"path":"2019/11/20/Memcache/","link":"","permalink":"http://ahrilove.top/2019/11/20/Memcache/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached……","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcached是一个高性能的分布式的内存对象缓存系统，全世界有不少公司采用这个缓存项目来构建大负载的网站，来分担数据库的压力。适合使用Memcached：存储验证码（图形验证码、短信验证码）、登录session等所有不是至关重要的数据(保存于内存中，关机后数据就会消失) 本文要点：1.win，Linux安装memcached2.docker创建memcached3.测试并进入容器4.telnet操作memcached…… 1.安装memcached&nbsp;&nbsp;&nbsp;Memcached是通过在内存里维护一个统一的巨大的hash表，memcached能存储各种各样的数据，包括图像、视频(但是极不推荐来保存二进制文件)、文件、以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。参考docker创建memecached容器windows下ThinkPHP3.2.3使用memcache缓存 2.创建memcached镜像docker run -di –name=”memcached” -m 256m -p 11211:11211 memcached:[tag] 123456-d是启动一个守护进程；-m是分配给Memcache使用的内存数量，单位是MB；-u是运行Memcache的用户；-l是监听的服务器IP地址，可以有多个地址；-p是设置Memcache监听的端口，，最好是1024以上的端口；-c是最大运行的并发连接数，默认是1024； 3.测试并进入docker容器 测试是否启动成功 netstat -luntp|grep 11211或者docker ps 安装telnet yum install -y telnet 或 sudo apt-get install telnet 通过telnet方式连接memcached telnet 127.0.0.1 11211 或者使用 telnet ubuntu_ip docker_memcached_port 设置值，age是key，0是标志位，900是生命周期，8代表所占字节数，回车之后的10是value set age 0 900 810 获取值 get age 退出 exitquit 4.telnet操作memcached：1.添加数据 set语法：12345678 set key flas(是否压缩,默认为0，不压缩) timeout value_length value示例： set username 0 60 7 zhiliao``` + add语法： add key flas(0) timeout value_lengthvalue示例：add username 0 60 7xiaotuoset和add的区别：add是只负责添加数据，不会去修改数据。如果添加的数据的key已经存在了，则添加失败，如果添加的key不存在，则添加成功。而set不同，如果memcached中不存在相同的key，则进行添加，如果存在，则替换。 2.获取数据：get key_name 3.删除数据：delete key_name 4.删除memcached所有数据：flush_all 5. memcached安全性memcached的操作不需要任何用户名和密码，只需要知道memcached服务器的ip地址和端口号即可。因此memcached使用的时候尤其要注意他的安全性。这里提供两种安全的解决方案。分别来进行讲解： &nbsp;&nbsp;&nbsp;&nbsp;1.使用-l参数设置为只有本地可以连接：这种方式，就只能通过本机才能连接，别的机器都不能访问，可以达到最好的安全性。&nbsp;&nbsp;&nbsp;&nbsp;2.使用防火墙，关闭11211端口，外面也不能访问 未完待续…","categories":[{"name":"Database","slug":"Database","permalink":"http://ahrilove.top/categories/Database/"}],"tags":[{"name":"Memcached","slug":"Memcached","permalink":"http://ahrilove.top/tags/Memcached/"}]},{"title":"Javascript篇章一：JavaScript基本知识","slug":"Javascript篇章一","date":"2019-11-19T16:00:00.000Z","updated":"2019-11-26T08:55:59.043Z","comments":true,"path":"2019/11/20/Javascript篇章一/","link":"","permalink":"http://ahrilove.top/2019/11/20/Javascript%E7%AF%87%E7%AB%A0%E4%B8%80/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的，一个前端项目必离不开HTML+CSS+JavaScript。 本文要点：1.变量及数据类型2.对象3.javascript小知识点","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的，一个前端项目必离不开HTML+CSS+JavaScript。 本文要点：1.变量及数据类型2.对象3.javascript小知识点 1. 变量及数据类型：JavaScript变量是数据值的容器变量修饰符：var,let,constvar car=”BMW”;var age=18; JavaScript数据类型分为：数值、字符串值、数组、对象等等 1234let length = 7; // 数字let lastName = \"Gates\"; // 字符串let cars = [\"Porsche\", \"Volvo\", \"BMW\"]; // 数组let x = &#123;firstName:\"Bill\", lastName:\"Gates\"&#125;; // 对象 2.对象对象的值以名称:值对的方式来书写（名称和值由冒号分隔） 123456789var person = &#123; //这里的person称为对象 firstName:\"Bill\", // 这是属性 lastName:\"Gates\", age:62, eyeColor:\"blue\", fullName : function() &#123; // 这就是方法 return this.firstName + \" \" + this.lastName; &#125;&#125;; JavaScript中的this关键词 12345在函数定义中，this 引用该函数的“拥有者”。在上面的例子中，this 指的是“拥有” fullName 函数的 person 对象。换言之，this.firstName 的意思是 this 对象的 firstName 属性。 案例：数据集构造12345678910111213141516let dimensions = []; //维度let source = []; //数据集let series = []; //图系列dimensions.push(\"groupcus_name\");dimensions.push(\"剩余发出商品\");for(let i=0;i&lt;response.Rows.length;i++)&#123; let obj = &#123;&#125;; obj[\"groupcus_name\"] = response.Rows[i].groupcus_name; // 对象的调用方式obj[\"key_name\"]或obj.key_name obj[\"剩余发出商品\"] = response.Rows[i].surplusp; source.push(obj); // 记住push只适用于数组的元素添加，并返回数组元素个数&#125; 3.javascript小知识点 函数语法 function function_name(param1,param2,…){code}PS:不使用 () 访问函数将返回函数声明而不是函数结果 js字符串长度 易混点：JavaScript字符串长度：str.lengthphp的字符串长度：count(string)python的字符串长度：len(string)jQuery中的length：表示query对象中元素个数 $(“div”).siblings().length=&gt;表示div标签的兄弟节点元素个数 使用\\ 转义字符 \\n表示换行 &quot;==&quot; 与&quot;===&quot;：表示值相等，数据类型也相同 &quot;==&quot;:表示值相等&quot;===&quot;:表示值相等基础上，数据类型也相同 str.slice(start，end)方法 slice() 提取字符串的某个部分并在新字符串中返回被提取的部分。 该方法设置两个参数：起始索引（开始位置），终止索引（结束位置）。 substring()方法 substring() 类似于 slice()，不同之处在于 substring() 无法接受负的索引 substr(start,length) 第二个参数规定被提取部分的长度，如果省略第二个参数，则该 substr() 将裁剪字符串的剩余部分。 str.replace(a,b) 用b替换a &#39;hello java&#39;.replace(&#39;java&#39;,&#39;python&#39;) 转换为大小写 str.toUpperCase()str.toLowerCase() str.trim(“指定字符”) trim() 方法删除字符串两端的空白符或指定字符 str.split(“指定字符”) 以指定字符切割字符串，返回数组的形式 未完待续…","categories":[{"name":"javascript","slug":"javascript","permalink":"http://ahrilove.top/categories/javascript/"}],"tags":[{"name":"clone","slug":"clone","permalink":"http://ahrilove.top/tags/clone/"},{"name":"push","slug":"push","permalink":"http://ahrilove.top/tags/push/"}]},{"title":"docker开发环境系列部署","slug":"docker开发环境部署","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-19T01:31:11.425Z","comments":true,"path":"2019/11/19/docker开发环境部署/","link":"","permalink":"http://ahrilove.top/2019/11/19/docker%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","excerpt":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡","text":"docker系列章节更新（二），这一章节主要收集并亲测docker部署各种各样的生产，开发环境。比如Nginx+Tomcat实现负载均衡，tomcat集群 搭建python3+django+mysql开发环境 Docker实现Nginx和Tomcat负载均衡 1.python3+Django+MySQL部署Django项目集群1.1 宿主机上创建工程目录site，并进入该目录1234567项目目录结构：site |__achievements |__db |__Dockerfile |__doocker-compose.yml |__requirements.txt 1.2 参考两篇优秀博文离未罔两|Docker—-搭建python3+django+mysql开发环境冰凉的枷锁lax|Docker搭建Python+Django+mysql开发环境 2. Docker实现Nginx和Tomcat负载均衡暗夜猎手-大魔王|使用docker搭建高并发网站架构实践2–Docker实现Nginx和Tomcat负载均衡 菲宇|Docker下Nginx+Tomcat实现负载均衡","categories":[{"name":"docker","slug":"docker","permalink":"http://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ahrilove.top/tags/docker/"},{"name":"python+Django+MySQL","slug":"python-Django-MySQL","permalink":"http://ahrilove.top/tags/python-Django-MySQL/"}]},{"title":"Python模拟登录淘宝(Ⅰ)","slug":"requests库模拟登录淘宝(Ⅰ)","date":"2019-11-18T05:45:34.494Z","updated":"2019-11-18T05:45:34.496Z","comments":true,"path":"2019/11/18/requests库模拟登录淘宝(Ⅰ)/","link":"","permalink":"http://ahrilove.top/2019/11/18/requests%E5%BA%93%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E6%B7%98%E5%AE%9D(%E2%85%A0)/","excerpt":"讲模拟登录淘宝之前，我们来回顾一下之前用requests库模拟登录GitHub和新浪微博的过程:这一类模拟登录是比较简单的登录，只需要在请求登录时将用户名和密码上传验证通过就成功了，也就是说一步到位！而淘宝登录就比较复杂，为什么说复杂呢？因为淘宝登录涉及参数多且请求不止一次！","text":"讲模拟登录淘宝之前，我们来回顾一下之前用requests库模拟登录GitHub和新浪微博的过程:这一类模拟登录是比较简单的登录，只需要在请求登录时将用户名和密码上传验证通过就成功了，也就是说一步到位！而淘宝登录就比较复杂，为什么说复杂呢？因为淘宝登录涉及参数多且请求不止一次！ 参考文章~裸睡的猪 淘宝系列欲更新文章内容： 第一篇：Python模拟登录淘宝，详细讲解如何使用requests库登录淘宝pc端。 第二篇：淘宝自动登录2.0，新增Cookies序列化，教大家如何将cookies保存起来。 第三篇：Python爬取淘宝商品避孕套，教大家如何爬取淘宝pc端商品信息。 第四篇：Python分析2000款避孕套，教大家如何做数据分析得出结论。 ———————————————— 1.淘宝登录流程","categories":[{"name":"Python","slug":"Python","permalink":"http://ahrilove.top/categories/Python/"}],"tags":[{"name":"Requests","slug":"Requests","permalink":"http://ahrilove.top/tags/Requests/"},{"name":"POST请求","slug":"POST请求","permalink":"http://ahrilove.top/tags/POST%E8%AF%B7%E6%B1%82/"},{"name":"token","slug":"token","permalink":"http://ahrilove.top/tags/token/"}]},{"title":"Git命令总结","slug":"git命令大全","date":"2019-11-17T16:00:00.000Z","updated":"2019-11-26T07:58:47.275Z","comments":true,"path":"2019/11/18/git命令大全/","link":"","permalink":"http://ahrilove.top/2019/11/18/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","excerpt":"总结一下自己常用的git命令","text":"总结一下自己常用的git命令 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash” git config –global user.name “Your Name”git config –global user.email “email@example.com“ cd F: (打开F盘)mkdir (创建子目录)pwd (显示当前目录) git init (把这个目录变成Git可以管理的仓库) git add git commit -m “说明” git status (仓库当前的状态) git diff (查看不同) git log [–pretty=oneline {缩略版,可选}] (查看历史记录) git reset –hard HEAD^ (回退到上一个版本,HEAD后可以是 commit_id) git reflog (用来记录你的每一次命令,找到commit_id回到未来某个版本) git diff HEAD – (查看工作区和版本库里面最新版本的区别) git checkout – (用版本库里的版本替换工作区的版本，无论工作区是修改还是删除) git reset HEAD (把暂存区的修改撤销掉（unstage），重新放回工作区. 用HEAD时，表示最新的版本) git rm (用于删除一个文件) ssh-keygen -t rsa -C “youremail@example.com“ (创建SSH Key) git remote add origin git@github.com:Bruce333/other.git (关联github远程库) git push -u origin master/git push origin master(推送到远程库,第一次用含有 -u 的命令,推送master分支的所有内容,此后用后面的命令推送最新修改) git clone git@github.com:Bruce333/other.git (克隆一个本地库) git checkout -b dev(创建dev分支，然后切换到dev分支,相当于以下两条命令:git branch dev[创建分支]/git checkout dev[切换分支]) git branch (列出所有分支，当前分支前面会标一个*号) git checkout master (切换到master分支) git merge dev (合并指定分支到当前分支) git branch -d dev (删除dev分支) git log –graph (查看分支合并图) git merge –no-ff -m “merge with no-ff” dev(通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息;–no-ff表示禁用Fast forward,用普通模式合并，合并后的历史有分支，能看出来曾经做过合并;-m参数，把commit描述写进去) git stash (把当前工作现场“储藏”起来，等以后恢复现场后继续工作) git stash list (查看工作现场) / git stash apply stash@{0} () git stash pop (恢复的同时把stash内容也删了,相当于:git stash apply[恢复]/git stash drop[删除]) git branch -D (强行删除一个没有被合并过的分支) git remote (查看远程库的信息) / git remote -v (显示更详细的信息) git checkout -b branch-name origin/branch-name (在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致) 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 git pull(把最新的提交抓下来;如果提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name) git tag &lt;commit id 可无&gt;(打一个新标签,默认标签是打在最新提交的commit上的;找到历史提交的commit id,可以给历史版本打标签) git show (查看标签信息) git tag (查看所有标签) git tag -a -m “blablabla…” (指定标签信息) git tag -s -m “blablabla…” (用PGP签名标签) git tag -d (删除标签) git push origin (推送某个标签到远程) git push origin –tags (一次性推送全部尚未推送到远程的本地标签) git tag -d (删除一个本地标签) git push origin :refs/tags/ (删除一个远程标签) git config –global color.ui true (让Git适当地显示不同的颜色) 忽略某些文件时，需要编写.gitignore；.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理 git config –global alias.st status(告诉Git，以后st就表示status,配置别名;加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用;每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面，要删除别名，直接把对应的行删掉即可;而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中)","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://ahrilove.top/tags/git/"},{"name":"git pull/push","slug":"git-pull-push","permalink":"http://ahrilove.top/tags/git-pull-push/"}]},{"title":"ThinkPHP","slug":"ThinkPHP","date":"2019-11-14T16:00:00.000Z","updated":"2019-11-20T00:12:25.841Z","comments":true,"path":"2019/11/15/ThinkPHP/","link":"","permalink":"http://ahrilove.top/2019/11/15/ThinkPHP/","excerpt":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push()js的clone()","text":"最近一直在做一个有关于ThinkPHP的前后分离的移动报表项目。记录从建彬师傅那里学到的知识以及自己遇到的一些问题 涉及到的知识点包含：jQuery、Vue、PHP、Echarts、Bootstrap、HTML+CSS+JavaScript。。。 js的push()js的clone() 1.js的clone()与push函数的一些生活纠纷 push()函数：向数组的末尾添加一个或多个元素，并返回新的长度。返回值是把指定的值添加到数组后的新长度语法：arrayObject.push(newelement1,newelement2,….) push() 方法可把它的参数顺序添加到 arrayObject（数组对象）的尾部。它直接修改 arrayObject，而不是创建一个新的数组，而是在原数组基础上修改。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能，该方法会改变数组的长度。 案例1：push() 1234567var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\"; console.log(arr);//输出原素组 ['chd','sjb','sgx']console.log(arr.push(\"badwoman\")); // 输出 4 PS:来了，push添加元素之后没有直接输出添加元素之后的数组，只显示了数组的个数（长度） 12345678// 展示push后的新数组var arr = new Array(3);arr[0] = \"chd\";arr[1] = \"sjb\";arr[2] = \"sgx\";arr.push('badwoman');console.log(arr);//输出结果为：['chd','sjb','sgx','badwoman'] js的clone()函数 js对象之间的赋值，如果直接用”=”会发现来两个对象还是同一个对象，改变其中一个另外的一个也会做出对应的改变。为了解决这个问题，可以利用java里面的clone的原理。假设有这样一个场景：当存在一个公共数组(对象型)时，一个需要加{“name”:”chd”,”age”:18}另一个需要在数组尾加上{“name”:”sgx”,”age”:108} 12345let commonCondition=[&#123;\"id\":15&#125;];let a=&#123;\"name\":\"chd\",\"age\":18&#125;;let b=&#123;\"name\":\"sgx\",\"age\":108&#125;;// 当我们利用a = commonCondition.push(a)时，此时原来的commonCondition也会跟着改变// 赋值b = commonCondition.push(b)。此时，b中也会包含a的数据，此刻js的clone函数就出现了 js的clone()函数源代码: 1234567891011121314151617181920212223function clone(Obj)&#123; var o; if (typeof obj == \"object\") &#123; if (obj === null) &#123; o = null; &#125; else &#123; if (obj instanceof Array) &#123; o = []; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; o.push(this.clone(obj[i])); // 有可能不要this &#125; &#125; else &#123; o = &#123;&#125;; for (var j in obj) &#123; o[j] = this.clone(obj[j]); // 有可能不要this &#125; &#125; &#125; &#125; else &#123; o = obj; &#125; return o; &#125; 即此刻，我们才有如下最正确的式子 1234let new_a = clone(commonCondition);a = new_a.push(a);let new_b = clone(commonCondition);b = new_b.push(b); 2. thinkphp项目调用Vue扩展函数方式2.1 导入vue扩展包.js文件 1&lt;script src=\"./cf.js\"&gt;&lt;/script&gt; 2.2 声明方法：新建一个与项目名同名的js文件，新增如下内容 123456789101112Vue.prototype.项目名 = &#123; // 这里表示扩展函数 函数名一:function(obj)&#123; ... &#125;, 函数名二:function(obj)&#123; ... &#125;, ...&#125; 2.3 调用方法：Vue实例化名. 项目名.函数名()Vue实力化名即：let app = new Vue({})中的app,经过测试后，调用方法为 项目名.函数名（） 3.thinkPHP的变量输出知识&lt;{:函数名/变量名}&gt; 中的冒号&quot;:&quot;表示引用调用函数，获取变量值 &lt;{:U(query)}&gt;:URL生成http://serverName/projectName/当前模块/当前控制器/声明的方法 123默认的模板标签为：在config.php文件下更改设置&apos;TMPL_L_DELIM&apos;=&gt;&apos;&lt;&#123;&apos;,&apos;TMPL_R_DELIM&apos;=&gt;&apos;&#125;&gt;&apos;, &lt;{:I(‘name’,’chd’)}&gt;中的I方法获取自定义参数值，不存在时，自定义默认值 I(‘get.name’); // 相当于 $_GET[‘name’]支持默认值： 4. ThinkPHP的memcached缓存机制 4.1 下载安装memcached，并启动其服务 参考docker创建memecached容器 windows下ThinkPHP3.2.3使用memcache缓存 4.2thinkphp3.2中其实已经加入了memcached缓存机制，只需要在Conf/config.php配置数据缓存类型即可使用Memcache: 1234567&lt;? php return array( &apos;DATA_CACHE_TYPE&apos; =&gt; &apos;Memcache&apos;, // 数据缓存类型 &apos;MEMCACHE_HOST&apos; =&gt; &apos;tcp://127.0.0.1:11211&apos;, &apos;DATA_CACHE_TIME&apos; =&gt; &apos;3600&apos; )?&gt;","categories":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://ahrilove.top/categories/ThinkPHP/"}],"tags":[{"name":"$.post()","slug":"post","permalink":"http://ahrilove.top/tags/post/"},{"name":"thinkPHP","slug":"thinkPHP","permalink":"http://ahrilove.top/tags/thinkPHP/"},{"name":"API","slug":"API","permalink":"http://ahrilove.top/tags/API/"},{"name":"Ajax","slug":"Ajax","permalink":"http://ahrilove.top/tags/Ajax/"},{"name":"CSS","slug":"CSS","permalink":"http://ahrilove.top/tags/CSS/"}]},{"title":"JSON通常用于与服务端交换数据,在向服务器发送数据时一般是字符串","slug":"json","date":"2019-11-13T16:00:00.000Z","updated":"2019-11-29T02:59:25.437Z","comments":true,"path":"2019/11/14/json/","link":"","permalink":"http://ahrilove.top/2019/11/14/json/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组PS:json键值对一定要用双引号包裹起来","text":"&nbsp;&nbsp;&nbsp;&nbsp;json语法规则 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组PS:json键值对一定要用双引号包裹起来 1.Python的json规则python程序中的json有一点点区别于JavaScript中的json，它是通过对象和数组的组合来表示数据 1.1 对象型数组 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它在JavaScript是使用花括号{}包裹起来的内容，数据结构为{key1:value1,key2:value2…}的键值对结构，key为对象的属性，value为对应的值。键名可以使用整数和字符串来表示，所以，一个json对象跨用写作如下格式(对象型数组) 123456789[&#123; \"name\": \"chd\", \"age\": 18, \"sex\": \"man\" &#125;,&#123; \"name\": \"Monica\", \"gender\": \"woman\", \"birthday\": \"1997-1-25\"&#125;] 调用方式:通过中括号加0索引，可以得到第一个字典元素，然后调用其键名即可得到相应的键值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式一：中括号加键名data[index][“键名”] =&gt; data[0][‘name’]，结果为‘chd’&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用方式二：get()方法传入键名，如果键名不存在，不会报错，会返回none（python中推荐使用）data[index].get(‘键名’) =&gt; data[1].get(“birthday”),结果为”1997-1-25” 1.2 键值对形式（类似于字典） 1234567891011121314&#123; \"code\": 1, \"msg\": \"success\", \"data\": &#123; \"name\": \"pig\", \"age\": \"18\", \"sex\": \"man\", \"hometown\": &#123; \"province\": \"江西省\", \"city\": \"抚州市\", \"county\": \"崇仁县\" &#125; &#125;&#125; 1.3 需要注意到点 JSON的键名和字符串都必须使用双引号引起来，而Python中单引号也可以表示为字符串，所以这是个比较容易犯的错误！Python类型与JSON相互转换的时候到底是用load//dump还是用loads\\dumps？他们之间有什么区别？什么时候该加s什么时候不该加s？这个我们可以通过查看源码找到答案：不加s的方法入参多了一个fp表示filepath，最后多了一个写入文件的操作。所以我们在记忆的时候可以这样记忆：加s表示转成字符串(str)，不加s表示转成文件。 2.javascript中的json1234567var stu = &#123;&quot;student&quot;: //stu 对象包含student的key,值为一个数组 [ //数组的每一个值为一个具体的学生对象 &#123;&quot;name&quot;: &quot;Tom&quot;,&quot;Grade&quot;:1, &quot;age&quot;:11, &quot;gender&quot;: &quot;M&quot;&#125;, //学生对象的键为名字,值为对应属性 &#123;&quot;name&quot;: &quot;Jerry&quot;, &quot;Grade&quot;:1, &quot;age&quot;:10, &quot;gender&quot;: &quot;M&quot;&#125; //每个属性对应的是一个key,value对 ], &quot;classroom&quot;: &#123;&quot;class1&quot;: &quot;room1&quot;, &quot;class2&quot;: &quot;room2&quot;&#125; //对象的值,嵌套对象 &#125;; json.parse()方法将数据转换为 JavaScript 对象 json.stringify() 方法将 JavaScript 对象转换为字符串。","categories":[{"name":"json","slug":"json","permalink":"http://ahrilove.top/categories/json/"}],"tags":[{"name":"json.parse()","slug":"json-parse","permalink":"http://ahrilove.top/tags/json-parse/"},{"name":"json.stringify()","slug":"json-stringify","permalink":"http://ahrilove.top/tags/json-stringify/"}]},{"title":"数据库存储引擎与索引,视图","slug":"mysql(二)","date":"2019-11-11T16:00:00.000Z","updated":"2019-12-02T13:06:44.920Z","comments":true,"path":"2019/11/12/mysql(二)/","link":"","permalink":"http://ahrilove.top/2019/11/12/mysql(%E4%BA%8C)/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引概述 索引作用 视图 视图的操作","text":"&nbsp;&nbsp;&nbsp;&nbsp;MySQL支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以根据需要进行选择甚至是定制自己的引擎以提高应用效率。 索引概述 索引作用 视图 视图的操作 1.索引概述索引在创建表的时候可以同时创建，也可以随时增加新的索引创建新索引的语法为:create [unique|fulltext|spatial] index index_name [using index_type] on table_name( col_name [(length)] [asc|desc])删除索引： DROP INDEX index_name on table_name 2.索引作用合理的创建索引是提高查询速度最有效的方式之一。&nbsp;&nbsp;&nbsp;&nbsp;在没有建立索引的情况下，查询一条数据的过程是这样：MySQL是从第一条记录开始查表，在某一个地方查到了匹配的数据，停止？NO，继续查询剩下的数据，直到查完整张表。 &nbsp;&nbsp;&nbsp;&nbsp;在建立合适索引的情况下，查询一条数据的过程又是这样：MySQL先根据索引快速到达一个位置去搜索数据文件，然后查出数据，而不必查看整张表的数据。tips:1、索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。2、索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。3、通过创建唯一索引，可以保证某一列的值具有唯一性。 1234567891011/*添加唯一索引：*/ALTER TABLE studentsADD UNIQUE INDEX unique_name(name);/*只添加唯一约束而不添加唯一索引：*/ALTER TABLE studentsADD CONSTRAINT unique_name UNIQUE(name); 因此，为了提高查询速度，合理建立索引是非常有必要的。 类型 描述 普通索引 基本的索引类型，允许定义索引的列中插入重复值和空值 唯一索引 索引列值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 主键索引 特殊的唯一索引，不允许有空值 全文索引 类型为FULLTEXT,支持值的全文查找，允许在索引列中插入重复值和空值 组合索引 在表的多个字段组合上创建的索引 3.视图（5.0.1提供视图功能）&nbsp;&nbsp;&nbsp;&nbsp;视图是一种虚拟存在的表，它存储的是查询语句，显示出来的是查询的结果；更直白的说就是当我们需要从表中查询一些信息时需要编写相关SQL语句，将这些SQL语句存储为视图，那么我们调用这些视图的时候就相当于执行了SQL语句，从而可以得到想要的结果eg:创建视图并执行查询操作 create view view_name as select qty,price,qty*price as value from temp; 视图有什么作用 1.视图就像是一个封装了很多功能的函数，我们把一系列复杂的查询语句存储为一个视图，这样在需要频繁使用这些语句时不必反复编写，直接使用视图代替即可 12345678如果要频繁获取表user的name和表goods的name。就应该使用以下sql语句：select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;但有了视图就不一样了，创建视图other。示例create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;创建好视图后，就可以这样获取user的name和goods的name： select * from other; 2.对数据库进行重构但仍不会影响程序运行 12345678假如因为某种需求，需要将user表拆成表usera和表userb，该两张表的结构如下： 测试表:usera有id，name，age字段 测试表:userb有id，name，sex字段这时如果程序端一直使用的sql语句是：select * from user;那就会报错提示该表不存在，这时要么去更改程序的查询语句要么就创建视图。显然，创建视图更简单，成本更低。以下sql语句创建视图：create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;以上假设name都是唯一的。这时程序端端使用的sql语句：select * from user;就不会报错。这就实现了更改数据库结构，而不用更改脚本程序的功能。 4.视图的操作 4.1 创建或修改视图 create [ or replace ] [ algorithm = { undefined | merge | temptable } ] view view_name [ (column_list) ] as select_statement [ with [ cascaded | local ] check option ] 使用了OR REPLACE可以修改视图，或者直接就CREATE OR REPLACE 替换为ALTER 即变成修改语法； UNDEFINED：未定义指定算法；MERGE：更新视图表数据的同时会更新真实表的数据（默认）；TEMPTABLE：只能查询不能更新； CASCADED(默认)：必须满足所有针对该视图的所有视图的条件才可以更新；LOCAL：只需满足本视图的条件就可以更新； WITH CHECK OPTION：需要满足相关的检查条件才能进行更新12345--常量视图create or replace view pi as select 3.1415926 as pi; --select中包含子查询create or replace view city_view as select (select city from city where city_id=1); 4.2 查看当前数据库下所有视图 show full tables where table_type like ‘view’; 5.优化SQL语句一般步骤 5.1 通过show status 查看各语句的频率 6.数据库Leetcode1.求薪水第二高，不存在就返回null 123select ifnull((select distinct(Salary) from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary; 超过5名学生的课(having用法) 1234select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5 DATEDIFF是两个日期的天数差集 123select a.Id as newIdfrom Weather a left join Weather b on datediff(a.RecordDate,b.RecordDate)=1 where a.Temperature&gt;b.Temperature","categories":[{"name":"Database","slug":"Database","permalink":"http://ahrilove.top/categories/Database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://ahrilove.top/tags/mysql/"},{"name":"InnoDB","slug":"InnoDB","permalink":"http://ahrilove.top/tags/InnoDB/"},{"name":"MyISAM","slug":"MyISAM","permalink":"http://ahrilove.top/tags/MyISAM/"}]},{"title":"MySQL数据库(一)：DDL，DML，DCL","slug":"MySQL数据库","date":"2019-11-10T16:00:00.000Z","updated":"2019-12-02T13:07:21.849Z","comments":true,"path":"2019/11/11/MySQL数据库/","link":"","permalink":"http://ahrilove.top/2019/11/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式1.两个用户在同一个应用服务器上:select * from &#39;user_name&#39;&nbsp;.&nbsp;&#39;table_name&#39;;2.两个用户不在同一个应用服务器上。。。","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近严重记忆力下降加上一直没有怎么用到数据库，好多命令都回忆不起来了，做个小笔记，mark。今天建彬师傅（他不是厉不厉害的问题，他真的就是那种，很少见，很牛逼的存在…）给我讲了一个非常有用的小知识点，使我茅塞顿开，放在摘要页，很有用：跨用户访问数据表的方式1.两个用户在同一个应用服务器上:select * from &#39;user_name&#39;&nbsp;.&nbsp;&#39;table_name&#39;;2.两个用户不在同一个应用服务器上。。。 1.启动服务net start 服务器名（Windows）service start 服务器名（linux） 2.登录与修改密码 命令 含义 mysql -u root -p -h localhost 登录MySQL（p表示密码；u表示用户名；h表示主机地址） mysqladmin -u用户名 -p旧密码 password新密码 修改用户名密码 3.基本使用 命令 含义 show databases; 用于显示所有的数据库 use 数据库名; 使用目标数据库 select database()/version()/now()/user(); 显示当前连接的信息 show tables; 用于显示选中数据库下的所有的表 desc table_Name; 查看表结构 show create table table_name \\G; 查看到创建时的SQL语句及更多详细信息 \\G使记录按照字段竖向排列，易于阅读 创建数据库并指定编码格式:create database if not exists 数据库名 character set utf8;删除数据库：drop database [if exists] 数据库名; 4.DDL&amp;DMLDDL:数据定义语言仅对数据库，表，列，索引起作用（create、drop、alter）DML:数据操纵语言仅对table中的具体数据起作用（select、insert、delete、update） 5.DDL 1.创建表 创建表 create table 表名( ​ 列名 数据类型 列级约束, ​ 列名 数据类型 列级约束 ​ )【表类型】【表字符集】【表注释】 12345678910#创建学生表，并设置表类型、字符集CREATE TABLE `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &apos;主键、学号&apos;, `psd` VARCHAR(20) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;123456&apos; COMMENT &apos;密码&apos;, `name` VARCHAR(30) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;匿名&apos; COMMENT &apos;学生姓名&apos;, `sex` VARCHAR(2) COLLATE utf8_estonian_ci NOT NULL DEFAULT &apos;男&apos; COMMENT &apos;性别&apos;, `birsday` DATETIME DEFAULT NULL, `email` VARCHAR(20) COLLATE utf8_estonian_ci DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_estonian_ci 数据类型 约束条件： not null unique primary key 主键名 foreign key (Id_P) references Persons(Id_P) :一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY default 默认值 auto increment:在每次插入新记录时，自动地创建主键字段的值 5.1主键&nbsp;&nbsp;&nbsp;&nbsp;对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 &nbsp;&nbsp;&nbsp;&nbsp;由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。&nbsp;&nbsp;&nbsp;&nbsp;使用BIGINT，会占用更大的磁盘和内存空间，内存空间毕竟有限，无效的占用会导致更多的数据换入换出，额外增加了IO的压力，对性能是不利的。因此推荐自增主键使用int unsigned类型，但不建议使用bigint。&nbsp;&nbsp;&nbsp;&nbsp;所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键,而应该使用INT UNSINGED自增或者GUID类型。主键也不应该允许NULL。可以使用多个列作为联合主键，但联合主键并不常用。&nbsp;&nbsp;&nbsp;&nbsp;如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 12345create table user( id INT UNSIGNED NOT NULL AUTO_INCREMENT primary key , /*数据类型 非空 自增 主码约束*/ name varchar(200) /*主码，外码约束条件写法二：primary key(id) */ ) 2.删除表：drop table table_name 3.修改表 命令 含义 修改表中列的数据类型 alter table table_name modify 列名 column_definition 增加表字段 alter table table_name add [column] 列名 column_definition 删除表字段表字段 alter table table_name drop [column] 列名 表的字段改名 alter table table_name change [column] old_col_name new_col_name 表字段改名同时也可修改字段类型 alter table table_name change [column] old_col_name new_col_name column_definition 更改表名 alter table table_name rename [to] new_tablename 6.DML语句 命令 含义 插入数据 insert into table_name ( field1, field2,…) values (value1,value2,….); 一次性插入多条数据 insert into table_name ( field1, field2,…) values (value1,value2,..),(value1,value2,..)…; 更新记录 update table_name set field1=value1，field2=value2，… [ WHERE CONDITION ] 删除某一项记录 delete from table_name [WHERE CONDITION ] 排序和限制 select * from table_name [ WHERE CONDITION ] [ order by field1 [ DESC\\ASC ], field2 [ DESC\\ASC], ..] 表连接 select ename,deptname from emp1 left join dept on emp1.deptno=dept.deptno; 子查询 关键字主要有in、not in、=、!=、exists、not exists,between and等等 1.可以不用指定字段名称，但此时后面的values应该与表的字段顺序保持一致2.对于某些字段允许空值、非空但是有指定的默认值、自增长等，这些字段在insert时如果没有指定value，那么将会右系统自动配置 7.DCL语句 创建数据库用户，并声明权限 创建操作数据库的专用用户，格式：grant 权限 on 数据库名.数据表名 to 用户名@主机IP IDENTIFIED BY 密码 1234说明：权限：ALL PRIVILEGES(所有权限),select,insert,update,delete,create,alter,drop主机IP： &apos;%&apos; 匹配所有主机，localhost表名： * 表示所有表 刷新权限 flush privileges 这里向大家拓展一个知识点，那就是主机IP指的是该用户只能在对应的主机IP上进行登录。例如：假如user用户设置的主机IP为localhost，那么其他人就将无法从本地以外的地方使用user用户进行登录。 8.查询记录 8.1 distinct 查询不重复的记录 select distinct id from emp1; 加distinct关键字使得查出的结果中去掉了重复记录 8.2 条件查询 判断条件可以使用=、&gt;、&lt;、&gt;=、&lt;=、!=等等，同时多个条件还可以使用and、or等进行连接 8.3 聚合 1234567891011select [ field1, field2,...,fieldn] fun_name from tablename [ where condition ] [ group by field1, field2,..., fieldn [ with rollup ] ] [ having condition ]参数说明：fun_name 聚合函数，表示要做的聚合操作，常用的有sum（求和）、count(*)（计数）、max、min等。 GROUP BY 表示对后面的字段进行分类聚合（也常叫分组）； WITH ROLLUP 可选语法，在ORDER BY 语句内出现，表示是否对分类聚合后的结果进行再汇总； HAVING 表示对分类后的结果再进行条件过滤； 同样是条件过滤，having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤。因此，为了提高聚合效率，一般先用where过滤不相干的记录后，在进行聚合，最后再用having进行二次过滤 12select gender，count(gender) from tab_teacher group by gender having gender=\"woman\";-- 含义为：按性别分组，查询出女老师人数的总数:先执行group by，再聚合函数，最后having筛选 9.注意要点 9.1 避免使用通配符“*” 实际开发中，要避免使用通配符”*”（通配符代表所有字段），因为系统要先解析出所有的字段名，将其还原为真实的名字，然后再进行操作。如果记录数据库内容特别多，会影响效率。 9.2 查询表的总记录数(推荐使用主键的方式查询) 因为主键唯一，且不能为空,此时id总数则代表总记录数select count(id) from table_teacher; 9.3 别名的用法 select count(id) as new_number from table_teacher;或者使用别名来代替表的名字select t.name,t.age from tab_teacher t; 9.4 分页查询方式 查询老师记录的前三条（从0位置开始找出3条）： limit后面有两个参数：第一个参数是起始位置，第二个参数是偏移量select * from tab_teacher limit 0,3; 未完待续……","categories":[{"name":"Database","slug":"Database","permalink":"http://ahrilove.top/categories/Database/"}],"tags":[{"name":"database","slug":"database","permalink":"http://ahrilove.top/tags/database/"},{"name":"mysql","slug":"mysql","permalink":"http://ahrilove.top/tags/mysql/"},{"name":"DDL","slug":"DDL","permalink":"http://ahrilove.top/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"http://ahrilove.top/tags/DML/"}]},{"title":"jQuery学习","slug":"jquery","date":"2019-11-10T16:00:00.000Z","updated":"2019-11-18T05:44:35.410Z","comments":true,"path":"2019/11/11/jquery/","link":"","permalink":"http://ahrilove.top/2019/11/11/jquery/","excerpt":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题","text":"简单来说，jQuery是一个js库，却极大的简化了JavaScript编程。好记性不如烂笔头，mark一下自己遇到的问题 1. 选择器id选择器 $(“#div”) 类选择器 $(“.div”) 标签选择器 $(“div”) 并集选择器 $(“selector1,selector2,…,selectN”)：使用逗号连接，以数组形式返回所有的合并元素 后代选择器 $(“div p”):div标签下的p标签，包含子孙节点 过滤选择器 $(“div:eq(n)”) :eq(index)获取给定索引值的元素 从0开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:gt(index) 匹配所有大于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:lt(index) 匹配所有小于给定索引值的元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:even 匹配所有索引值为偶数的元素，从 0 开始计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:odd 匹配所有索引值为奇数的元素，从 0 开始计数属性选择器 $(“div[attribute=”value”]”) :匹配给定的属性是某个特定值的元素 表单的选择器:$(‘input:radio/checkbox/text/password/…’),即: type值为radio、checkbox、password等的input元素 筛选选择器 : $(‘div’).eq(n) 获取第n个元素 数值从0开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.first()获取第一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.last()获取最后一个元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.parent() 选择父亲元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.siblings()选择兄弟元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.find() 查找目标元素值 PS:注意筛选选择器与过滤选择器的函数位置","categories":[{"name":"前端","slug":"前端","permalink":"http://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"API","slug":"API","permalink":"http://ahrilove.top/tags/API/"},{"name":"Ajax","slug":"Ajax","permalink":"http://ahrilove.top/tags/Ajax/"},{"name":"CSS","slug":"CSS","permalink":"http://ahrilove.top/tags/CSS/"},{"name":"jQuery","slug":"jQuery","permalink":"http://ahrilove.top/tags/jQuery/"},{"name":"选择器","slug":"选择器","permalink":"http://ahrilove.top/tags/%E9%80%89%E6%8B%A9%E5%99%A8/"}]},{"title":"Python全栈系列章节更新（一）：基本数据类型","slug":"python数据类型","date":"2019-11-10T16:00:00.000Z","updated":"2019-12-02T14:07:38.838Z","comments":true,"path":"2019/11/11/python数据类型/","link":"","permalink":"http://ahrilove.top/2019/11/11/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等字符串：len(),split(),join()…列表：append(),pop(),count()…元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。","text":"Python是一个“优雅”、“明确”、“简单”的编程语言,主要流行于网络爬虫、数据分析挖掘、机器学习、人工智能以及运维等等字符串：len(),split(),join()…列表：append(),pop(),count()…元组：与列表类似，不同之处在于元组的元素不能修改字典：是另一种可变容器模型，且可存储任意类型对象 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 1.字符串 zip()函数：将可迭代对象所包含的元素是由原列表元素组成的元组 a = [a,b,c] b = [1, 2, 3]c = [x for x in zip(a,b)]c = [(a, 1), (b, 2), (c, 3)]结果为元祖型列表 format():位置参数，参数索引从0开始，format里填写{}对应的参数值 msg = “my name is {}, and age is {}”.format(‘chd’,18)渲染结果：my name is chd, and age is 18 str.index()字符串索引: 索引值从0开始,不存在就会报错 s=’index’ s[0]=is.index(‘i’) = 0 : 查找目标字符串索引值 str.find(‘目标字符串’)查找目标字符串,不存在就返回数值1 移除指定字符串 str.strip() s = ‘ hello,world! ‘s.strip()s.lstrip()s.rstrip()s2 = &#39;hello,world!&#39;s2.strip(&#39;\\ &#39;) len(str)字符串长度 len(‘hello,world’) =&gt; 11 str.replace(a,b)替换：在字符串str中，用b来替换a ‘hello,world’.replace(‘o’,’a’) =&gt; ‘hella,warld’ str[a:b:c] 切片操作 string.capitalize() 把字符串的第一个字符大写 str.count(‘目标字符串’): 返回 str 在 string 里面出现的次数 “连接字符”.join(seq序列):返回 str 在 string 里面出现的次数 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 str.lower()/upper() 将字符串全部转换为小写/大写 “hello world”.lower()/upper() =&gt;”hello world” / “HELLO WORLD” str.split(指定字符串) 以指定字符串来分割目标字符串，以列表形式返回 1234url = \"http://www.baidu.com/python/image/123456.jpg\"#以“.” 进行分隔path =url.split(\".\")path1=['http://www', 'baidu', 'com/python/image/123456', 'jpg'] 2019-11-28 新增：当split的参数为空时，即string.split():表示以空格作为分割符，并将换行符也去掉 2.列表 列表截取（索引从0开始，且满足左闭右开原则）与拼接:从右至左取值，则索引默认从-1开始 L=[‘Google’, ‘Runoob’, ‘Taobao’]L[2]=’Taobao’ L[-1]=’Taobao’ 列表函数和方法 函数和方法 描述 len(list) 列表元素个数 list(seq) 将元组或字符串转换为列表 max/min(list) 返回列表元素最大/最小值 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) 将对象插入列表 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中某个值的第一个匹配项 list.reverse() 反向列表中元素 list.sort( key=None, reverse=False) 对原列表进行排序 2019-12-2 新增： 数组拆分：将一个含有m个数目的数组拆分成每n个一组，剩下的构成一个新数组 12345# 将obj数组分割成每100个一组numbers=[1,2,3,4,5,6,7,8,...,10000]number =[]for i in range(0, len(numbers), 100): number.append(numbers[i:i + 100]) 3.元组 3.1元组的创建 元组使用小括号，而列表使用方括号，只需要在括号中添加元素，并使用逗号隔开即可 1tup1 = ('a','b','c',336) 3.2 元组的访问使用下脚标索引来访问元组中的值，下标索引从0开始 tup1[0] =&gt; &#39;a&#39; ,tup[1] =&gt; &#39;b&#39; 3.3 元组的修改 元组中的元素是不允许修改或删除的，但我们开始对其进行拼接组合tuple(seq)：将列表转换为元组。 4.字典:可变模型，可存储任意类型对象 4.1字典的创建 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号&nbsp;&nbsp;,&nbsp;&nbsp;分割，整个字典包括在花括号 {} 1d = &#123;key1 : value1, key2 : value2 &#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258',9527:'badwoman',6394:998&#125; 4.2 字典的访问 访问方式：字典名[&quot;键名&quot;] 或者字典名.(&quot;键名&quot;,自定义数据)：当目标键名不存在时，使用自定义数据值作为默认值，注意此刻不会修改原字典 4.3 字典的更新 1234567dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; dict['Age'] = 8 # 更新dict['School'] = \"RUNOOB\" # 添加 print(\"dict['Age']: \", dict['Age'])print(\"dict['School']: \", dict['School']) 4.4 内置函数和方法 函数和方法 描述 cmp(dict1, dict2) 比较字典元素值：如果两个字典的元素相同返回0，如果字典dict1大于字典dict2返回1，如果字典dict1小于字典dict2返回-1 len() 计算字典元素个数，即键的总数 dict.items() 将字典的键值一一对应组合成一个元组，以列表的形式返回值 dict.pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 123456demo=&#123;'Name': 'Zara', 'Age': 8, 'Class': 'First', 'School': 'RUNOOB'&#125;demo.items() # dict_items([('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')])a = [x for x in demo.items()]print(a) # a=[('Name', 'Zara'), ('Age', 8), ('Class', 'First'), ('School', 'RUNOOB')] python的直接赋值，浅拷贝和深拷贝 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 解析： b = a 赋值引用，a与b都指向同一个对象，即共有同一块内存地址 123456a = &#123;1: [1, 2, 3]&#125;b = a # b = &#123;1: [1, 2, 3]&#125;# 更新a的值a[1]=[1,2,3,4]print(b) # b = &#123;1: [1, 2, 3, 4]&#125;# 即直接赋值也属于浅拷贝，共用同样一块地址 b = a.copy():浅拷贝，a与b是一个独立的对象，但他们的子对象还是指向统一对象（是引用） 12345a = &#123;1: [1,2,3]&#125;b = a.copy()print(a,b) # (&#123;1: [1, 2, 3]&#125;, &#123;1: [1, 2, 3]&#125;)a[1].append(4) # 字典更新print(a, b) #(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;) b = copy.deepcopy(a) 深拷贝：深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的,是两块独立的地址。 1234567&gt;&gt;&gt; import copy&gt;&gt;&gt; c = copy.deepcopy(a)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4]&#125;, &#123;1: [1, 2, 3, 4]&#125;)&gt;&gt;&gt; a[1].append(5)&gt;&gt;&gt; a, c(&#123;1: [1, 2, 3, 4, 5]&#125;, &#123;1: [1, 2, 3, 4]&#125;)","categories":[{"name":"Python","slug":"Python","permalink":"http://ahrilove.top/categories/Python/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://ahrilove.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"元组","slug":"元组","permalink":"http://ahrilove.top/tags/%E5%85%83%E7%BB%84/"},{"name":"列表","slug":"列表","permalink":"http://ahrilove.top/tags/%E5%88%97%E8%A1%A8/"},{"name":"字典","slug":"字典","permalink":"http://ahrilove.top/tags/%E5%AD%97%E5%85%B8/"},{"name":"数值","slug":"数值","permalink":"http://ahrilove.top/tags/%E6%95%B0%E5%80%BC/"}]},{"title":"docker容器虚拟化技术","slug":"docker容器虚拟技术","date":"2019-11-09T16:00:00.000Z","updated":"2019-11-29T14:43:11.805Z","comments":true,"path":"2019/11/10/docker容器虚拟技术/","link":"","permalink":"http://ahrilove.top/2019/11/10/docker%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/","excerpt":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题","text":"简单来说，在Windows系统下安装各种运行环境的坑简直不要太多了(●￣(ｴ)￣●)，并不仅限于docker、Nginx、PHP、Python等等，我会尽详细写出实际过程中遇到的各种各样的奇葩问题 1.docker适用环境其实docker本身也没有太多在Windows下花功夫。目前，docker仅支持Linux与Windows企业版、专业版、教育版。ps：家庭版不支持docker,并且win10下可以安装docker-for-windows,这个安装包是专门适用于win10，安装简单，而对于win7/8则可以使用Docker Toolbox下载地址 2.Windows下无法对docker容器进行端口访问（端口映射的问题）1.问题详情&nbsp;&nbsp;&nbsp;在Windows10系统服务器中安装了docker和docker-compose&nbsp;&nbsp;&nbsp;并尝试在其中运行Nginx服务，映射也做好&nbsp;&nbsp;&nbsp;问题：在主机的浏览器中，打开localhost:port无法访问对应的Web服务。2.问题解析&nbsp;&nbsp;&nbsp;原因：docker是运行在Linux上的，在Windows中运行docker，实际上还是在Windows下先安装了一个Linux环境，然后在这个系统中运行的docker。也就是说，服务中使用的localhost指的是这个Linux环境的地址，而不是我们的宿主环境Windows10。3.解决办法&nbsp;&nbsp;&nbsp;启动docker命令行窗口&nbsp;&nbsp;&nbsp;输入命令:docker-machine ip default&nbsp;&nbsp;&nbsp;Linux的ip地址，一般情况下这个地址是192.168.99.100&nbsp;&nbsp;&nbsp;然后在Windows的浏览器中，输入 http://IP:port 即可启用（http://192.168.99.100：8069） 3.docker与VMware不可兼容&nbsp;&nbsp;&nbsp;在Windows下安装docker，第一步就是要打开Hyper-V(打开控制面板 - 程序和功能 - 启用或关闭Windows功能，勾选Hyper-V),开启win自带的虚拟管理技术。但是若想要使用VMware，则必须关闭Hyper-V，鱼和熊掌不可兼得呀！(′д｀ )…彡…彡 4.Windows：vmware与hyper-v不兼容,请移除hyper-v角色1、请移除hyper-v角色。（1）以管理员身份（win + x）运行命令提示符；（2）执行命令：bcdedit /set hypervisorlaunchtype off（3）重启系统，运行vm即可。2、如果想要恢复hyper启动：&nbsp;&nbsp;&nbsp;bcdedit / set hypervisorlaunchtype auto 5.docker run后接/bin/sh和接/bin/bash的区别是什么：比如我们要获取一个nginx镜像，同一镜像存在有不同的tags&nbsp;&nbsp;&nbsp;/bin/sh命令仅适用于tags带alpine标签的： nginx:1.17-alpine；&nbsp;&nbsp;&nbsp;/bin/bash命令仅适用于tags不带alpine标识的：nginx：laster，nginx:1.8… 6.docker运行MySQL服务 拉取镜像docker pull mysql:[tag] 创建并运行容器docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql：5.6 ps: -p 表示指定访问端口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e 设置环境变量，或者覆盖已存在的环境变量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-d 表示以守护式方式来运行容器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MYSQL_ROOT_PASSWORD=123456 声明MySQL的用户名为ROOT，密码为123456 查看容器是否启动docker ps 启动容器docker start container_id 进入容器内部,以命令行交互docker exec -it container_id /bin/bash 登录MySQLmysql -u root -p 然后在输入密码 成功表示已经成功登陆MySQL 7.最强万能公式:数据卷挂载式创建容器12345守护式：docker run -di [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine交互式：docker run -it [--privileged=true] -P(或者指定端口 -p 外部port:该容器默认端口) \\--name=&quot;newNginx&quot; -v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw nginx:1.15.7-alpine含义： a） 以-v /home/chd/Desktop/entwechatapp:/var/www/EntWeChatApp:rw 带rw(read,write)权限来将宿主机与容器进行数据卷挂载 b) docker run 以新容器名和端口号以及守护式或者交互式来创建容器 8.宿主机与docker容器权限纠纷问题描述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它来了！问题又出现了！哭啦。数据卷挂载时，即使声明了rw权限，在宿主机中创建文件，数据共享后，容器内能够具有正常的rw权限；但在容器内新建了文件后，宿主机就只有只读权限，无法修改文件内容。 解决方案：宿主机的权限不够&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在（7）式中的万能公式中添加：docker run ··· --privileged=true ··· 9.docker配置nginx的配置文件命令：docker run --name=&quot;dnmp_nginx&quot; -p 80:80 -v /home/docker-nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/docker-nginx/log:/var/log/nginx -v /home/docker-nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -di nginx:\\[tags]&nbsp;&nbsp;&nbsp;&nbsp;第一个-v 表示将你本地的nginx.conf覆盖你要起启动的容器的nginx.conf文件，第二个表示将日志文件进行挂载，就是把nginx服务器的日志写到你docker宿主机的/home/docker-nginx/log/下面。第三个-v 表示的和第一个-v意思一样的&nbsp;&nbsp;&nbsp;&nbsp;我个人更喜欢守护式映射的方式，麻烦的是需要自己准备好nginx.conf 和default.conf文件，我是直接从容器里面复制的，然后根据自己的需要改的 我都想把它杀了，部署nginx太多坑了，不过参考了此博文，最终解决了问题，解决方法： 1.创建三个根目录根据情况创建：/docker/nginx/conf www logs docker run -d -p 80:80 --name=”nginx” --net host -v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/logs:/var/log/nginx nginx:1.17.5 2.不对配置文件进行数据挂载即 -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf 这个 3.进入容器 获取文件 docker exec -it nginx /bin/bash 4.cd /etc/nginx/ （这里主要获取配置文件路径的）,然后exit 5.数据拷贝 进入宿主机目录文件 cd /docker/nginx/conf/将已经运行成功的容器的配置文件拷贝到宿主机的配置文件目录：docker cp 容器ID:/etc/nginx/nginx.conf .（ps：“.”表示拷贝到当前目录） ps：文件copy成功后 把nginx容器先删除掉 6.创建最终的nginx容器 12345678docker run -di -p 80:80 --name nginx [--net host] :再思考一下有没有必要写，使用–net = host时,它告诉容器使用主机网络堆栈.因此无法将端口暴露给主机,因为它是主机(就网络堆栈而言).-v /docker/nginx/www:/usr/share/nginx/html -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf-v /docker/nginx/logs:/var/log/nginx nginx:1.17.5ps:成功后就代表部署成功 2019-11-29 新增：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里宿主机的nginx.conf其实是挂载了一个文件，docker是不推荐这样使用的，可以尝试在宿主机上创建目录为：/docker/nginx/conf/nginx.conf/nginx.conf(当前conf文件是一个具体的配置文件，不是一个目录)，这样上式就不会出现docker warning，结合此篇文章 。 PS：访问可能会403 因为/docker/nginx/www/ 里面没有index.html放进去就好了 7.权限赋予 挂载成功后，给宿主机上的www目录（或整个文件目录）增加权限，不然一直无法读写：&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod -R 777 目标目录 ：给目标目录赋予最大管理员权限&nbsp;&nbsp;&nbsp;&nbsp;sudo chmod +/-rwx 文件名|目录 给文件或目录的赋予权限 10.docker配置MySQL，redis教程等，请点击此处链接命令:docker run -di -p 12345:3306 \\--name=&quot;mysql&quot; -v /lnmp/mysql/conf:/etc/mysql/conf.d -v /lnmp/mysql/logs:/logs -v /lnmp/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456:rw mysql:5.6 命令说明：-p 12345:3306：将主机的12345端口映射到docker容器的3306端口。--name mysql：运行服务名字-v /lnmp/mysql/conf:/etc/mysql/conf.d ：将主机/lnmp/mysql录下的conf/my.cnf 挂载到容器的 /etc/mysql/conf.d-v /lnmp/mysql/logs:/logs：将主机/lnmp/mysql目录下的 logs 目录挂载到容器的 /logs。-v /lnmp/mysql/data:/var/lib/mysql ：将主机/lnmp/mysql目录下的data目录挂载到容器的 /var/lib/mysql-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。-d mysql:5.6 : 后台程序运行mysql5.6 11.外部Windows如何访问docker内的容器 1.基本架构：Windows，Dockers，Linux三者关系 2.相关操作 2.1 关闭Linux防火墙：systemctl stop firewalld.service 2.2 查看Linux，Docker的IP地址:ifconfig(区别于Windows的ipconfig命令) 2.3 Windows访问测试: 思想：docker作为一个容器虚拟技术，创建并启动相关的容器服务，并把端口映射到Linux系统中。比如MySQL：docker启动MySQL服务后，并映射了一个外部访问的某端口（比如还是3306），则此刻Linux就具有了3306这个一个端口=&gt;外界访问方式应该是：访问虚拟机Linux上与之相绑定docker容器映射出的端口。 2019-11-27 新增：在 windows 系统中访问 linux 中 nginx，默认不能访问的，因为防火墙问题,即我们可以有两种解决方法（1）关闭防火墙：参考上述相关操作（2）开放访问的端口号，比如80端口，操作如下： 查看开放的端口号 firewall-cmd --list-all 设置开放的端口号 firewall-cmd --add-service=http --permanentfirewall-cmd --add-port=80(或其它开放端口号)/tcp --permanent 重启防火墙 firewall-cmd --reload","categories":[{"name":"docker","slug":"docker","permalink":"http://ahrilove.top/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ahrilove.top/tags/docker/"},{"name":"VMware","slug":"VMware","permalink":"http://ahrilove.top/tags/VMware/"},{"name":"images","slug":"images","permalink":"http://ahrilove.top/tags/images/"},{"name":"container","slug":"container","permalink":"http://ahrilove.top/tags/container/"},{"name":"Hyper-V","slug":"Hyper-V","permalink":"http://ahrilove.top/tags/Hyper-V/"},{"name":"Linux","slug":"Linux","permalink":"http://ahrilove.top/tags/Linux/"},{"name":"交互式与守护式创建","slug":"交互式与守护式创建","permalink":"http://ahrilove.top/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%B8%8E%E5%AE%88%E6%8A%A4%E5%BC%8F%E5%88%9B%E5%BB%BA/"}]},{"title":"Vue","slug":"Vue","date":"2019-11-07T16:00:00.000Z","updated":"2019-11-19T08:40:08.204Z","comments":true,"path":"2019/11/08/Vue/","link":"","permalink":"http://ahrilove.top/2019/11/08/Vue/","excerpt":"&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,有很好的数据双向绑定性。","text":"&nbsp;&nbsp;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,有很好的数据双向绑定性。 1.jQuery与Vue糅合使用 1.jquery基本使用：先导入相关jQuery库包，然后按人类正常思维，就声明入口函数,然后在入口函数中书写逻辑代码 123456&lt;script&gt; $(function()&#123; ... ... &#125;);&lt;/script&gt; 但是，奇怪他个猪猪皮，即使不用声明入口函数，直接书写逻辑程序，经过多次测试，TM居然还可以正常使用 2.jQuery+Vue(若想两者结合使用，则一定不能声明入口函数，否则Vue无法使用)当你想测试Vue时，就会出现vue实例未声明的报错 &nbsp;&nbsp;1 Uncaught ReferenceError: vm is not defined&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;at :1:1 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"rookie\"&gt; &lt;p&gt;hello fpx&lt;/p&gt; &lt;p&gt;hello IG&lt;/p&gt; &lt;p&gt;hello kk&lt;/p&gt; &lt;pre&gt;total:&#123;&#123;number&#125;&#125;&lt;/pre&gt; &lt;h6 :class=\"&#123;box:isactive&#125;\"&gt;this is new h6&amp;nbsp;&amp;nbsp;&lt;/h6&gt; &lt;h5 :class=\"[box1,box2,box3?'luko':'']\"&gt;this is new h6&amp;nbsp;&amp;nbsp;&lt;/h5&gt; &lt;/div&gt; &lt;input type=\"text\" placeholder=\"please input number\" v-model=\"msg\" @keyup.enter=\"fn\"&gt;按键盘enter键触发:&#123;&#123;msg&#125;&#125;&lt;br&gt; &lt;input type=\"text\" placeholder=\"please click enter\" v-model=\"message\" @keyup.13=\"greet(9527)\"&gt;按键盘enter键触发&#123;&#123;message&#125;&#125;&lt;br&gt; &lt;/div&gt; &lt;script&gt; console.log($('p').length); let vm = new Vue(&#123; el:'#app', data:&#123; number:$('p').length, isactive:true, box1:'moko', box2:'boka', box3:true, msg:'', message:'', &#125;, methods:&#123; fn()&#123; alert(this.msg) &#125;, greet(hi)&#123; alert(this.message+hi) &#125; &#125;, &#125;); $('h5').append('&lt;b&gt;this is new plus increment&lt;/b&gt;'); $('h6').append('&lt;br&gt; hello world'); &lt;/script&gt;&lt;/body&gt; 2.Vue的组件 1.组件创建方式分为全局组件与局部组件： &nbsp;&nbsp;&nbsp;全局组件：可以被多个APP进行调用,在APP实例外创建;定义一个名为 button-counter 的新组件:组件名称若使用驼峰原则，引用组件时需要全部小写，并且两个单词之间用“-”连接;若不使用驼峰原则时，直接使用原组件名 全局组件创建方式一： 12345678910Vue.component('buttonCounter', &#123; data: function () &#123; // 1.组件可以有自己的data数据，组件中的data必须是一个方法，且这个方法内部必须返回一个对象才行，而实例中的data可以为一个对象 return &#123; count: 0, info: 'hello world' &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;&#123;&#123;message&#125;&#125; clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;' // 2. 全局组件有template属性 &#125;) 全局组件创建方式二：调用公共模板对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &lt;script&gt; let project=&#123; template:&apos;&apos;, data:function()&#123; // 组件中的data必须是一个方法 return &#123; info:&apos;hello world&apos;, message:&apos;badwoman&apos; &#125;, methods:&#123;&#125; ... &#125; Vue.component(&apos;组件名&apos;,project); &#125; &lt;/script&gt; ``` ### 3. vue的props属性传值```html&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--父组件，可以在引用子组件的时候，通过属性绑定（v:bind）的形式，把需要传递给子组件的数据 传递到子组件内部--&gt; &lt;com1 :parentmsg=&quot;msg&quot;&gt; &lt;/com1&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data:&#123; msg: &apos;123父组件中的数据&apos; &#125;, methods: &#123; &#125;, components:&#123; &apos;com1&apos;:&#123; //子组件中，默认无法访问到父组件中的data和methods template: &apos;&lt;h1 @click=&quot;change&quot;&gt; 这是子组件 &#123;&#123;parentmsg&#125;&#125;&lt;/h1&gt;&apos;, //注意，组件中的所有props中的数据都是通过父组件传递给子组件的 //propes中的数据是只可读 props: [&apos;parentmsg&apos;] ,// 把父组件传递过来的parentmsg属性， 数组中，定义一下，这样才能用这个数据, //注意子组件中的data数据，并不是通过父组件传递过来的，而是子组件字有的，比如：子组件通过Ajax请求回来的值，可以放到data中 //data中的数据可读可写 data()&#123; return &#123; title: &apos;123&apos;, content: &apos;qqq&apos; &#125; &#125;, methods: &#123; change()&#123; this.parentmsg=&apos;被修改&apos; // 这里不推荐使用此方法修改传递参数值，会一直报出vue warning &#125; &#125;, &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 注意：重要的来了，必须理解┗|｀O′|┛ 嗷~~ 创建格式：Vue.component('组件名',{ /* ..组件的模板对象.. */ }) &nbsp;&nbsp;&nbsp;组件的第一个参数为组件名，而第二个参数是以对象的形式去描述一个组件。组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项","categories":[{"name":"前端","slug":"前端","permalink":"http://ahrilove.top/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://ahrilove.top/tags/Vue/"},{"name":"Jquery","slug":"Jquery","permalink":"http://ahrilove.top/tags/Jquery/"},{"name":"component","slug":"component","permalink":"http://ahrilove.top/tags/component/"}]},{"title":"python文件读read()、readline()、readlines()对比","slug":"python的read_readlines_readline","date":"2019-11-06T16:00:00.000Z","updated":"2019-11-29T01:27:38.088Z","comments":true,"path":"2019/11/07/python的read_readlines_readline/","link":"","permalink":"http://ahrilove.top/2019/11/07/python%E7%9A%84read_readlines_readline/","excerpt":"&nbsp;&nbsp;&nbsp;read():读取整个文件，将文件内容放到一个字符串变量中&nbsp;&nbsp;&nbsp;readline():每次读取一整行，包括换行符，并将其作为字符串返回&nbsp;&nbsp;&nbsp;readline():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素）","text":"&nbsp;&nbsp;&nbsp;read():读取整个文件，将文件内容放到一个字符串变量中&nbsp;&nbsp;&nbsp;readline():每次读取一整行，包括换行符，并将其作为字符串返回&nbsp;&nbsp;&nbsp;readline():读取所有行然后把它们作为一个字符串型列表返回（即把每一行数据包括换行符作为一个列表元素） 1.readline()示例：假设需求是读取一个多行的all_term.txt文件，并列出每一个单词all_term.txt文件： 1234new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothrnobyl social impact chernobyl disastdavid r marpl st martin piano 程序源代码： 123456789101112131415161718def main(): obj = [] with open('all_term.txt', 'r', encoding='utf-8',errors=\"ignore\") as f: while True: myStr = f.readline() # 表示一次读取一行 if not myStr: # 读到数据最后跳出，结束循环。数据的最后也就是读不到数据了，mystr为空的时候 break # 指定字符串来分割目标字符串，以列表形式返回 new_list = myStr.split() # 表示将拆分好的每一行重新拼接成一个完整的数组 obj += new_list print(obj)if __name__ == '__main__': main() readline()表示读取一整行，那如果一个文件有多行数据，使用readline()函数是不是一直重复读取第一行？其实不然，使用with open()打开文件后，第一个readline()读取第一行（也包括换行符），第二个读取第二行,…,第n个读取第n行数据，这是由系统机制判定的。下面我列举一个实例： 12345678910111213141516171819\"\"\"all_term.txt:new fallout chernobyl social impact chernobyl disastdavid r marpl st martin press clothnew fallout chernobyl social impact chernobyl disastdavid r marpl st martin press cloth\"\"\"# -*- coding:utf-8 -*-with open('all_term.txt', 'r', encoding='utf-8', errors='ignore') as f: a = f.readline().replace(\"\\n\", \"\") b = f.readline().replace(\"\\n\", \"\")print(\"a:\", a)print(\"b:\", b)\"\"\"结果为：a: new fallout chernobyl social impact chernobyl disastb: david r marpl st martin press cloth\"\"\" 根据结果可以得出结论： 1.第一个readline()读取第一行（也包括换行符），第二个读取第二行，…… 2.上面是我们经常看到的按行遍历一个文件方法，你可能已经注意到我在代码中写的if not myStr:部分。当readline读取到为空的时候，意味着读到了文件的结束。这个时候，问题就在这里，很多人会想，是不是遇到一个空行，也会被认为是文件的结束呢？事实上，文件的空白行并不会返回一个空行。因为在每一行的末尾还有一个或者多个分隔符，因此“空白行”至少会有一个换行符或者系统使用的其他符号。所以，即使文件中真的包含一个“空白行”，读入的行也不是空的，这就意味着在真实遍历读取到文件结束之前，程序实际上是不会停止的","categories":[{"name":"Python","slug":"Python","permalink":"http://ahrilove.top/categories/Python/"}],"tags":[{"name":"read() - readline() - readlines()","slug":"read-readline-readlines","permalink":"http://ahrilove.top/tags/read-readline-readlines/"}]},{"title":"Hexo主体设置知识点","slug":"Hexo主体设置知识点","date":"2019-10-26T13:28:53.000Z","updated":"2019-11-26T06:49:36.741Z","comments":true,"path":"2019/10/26/Hexo主体设置知识点/","link":"","permalink":"http://ahrilove.top/2019/10/26/Hexo%E4%B8%BB%E4%BD%93%E8%AE%BE%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法","text":"介绍Hexo一些基本设置，比如分类，标签，作者，简要概述等等以及MarkDown的写法 1.Hexo创建文章、标签、分类的Front-matter方法 Ⅰ&nbsp;&nbsp; Front-matter ⅡFront-matter 是md文件最上方以 — 分隔的区域，用于指定个别文件的变量 其实Front-matter就是在\\Hexo\\source_posts下的.md文件中书写文章标题，上传时间，分类名，标签名等等 字段 含义 值类型 默认值 layout 布局模版 String - title 标题 String - date 创建时间 Date 文件创建时间 description 页面描述、摘要 String - cover 是否显示封面 Bool true 2.Makedown标题页的写法 --- layout: 页面布局（配合主题文档使用） title: 文章名称 date: 文章日期 comments: 文章是否开启评论 photos: 文章封面图（仅部分主题支持） tags: - 文章标签一 - 文章标签二 categories: # 文章分类（文章分类等级） - 父分类 - 子分类 - 孙分类 description: 文章描述，即要在首页显示的摘要（仅部分主题支持） --- 这里是摘要 这里是正文 注意：description 和 方式显示摘要二选一即可，部分主题不支持description， 每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档 3.md文件的基本写法 3.1. ``` 代码段 ``` : 表示以原格式展示代码片段。比如 1234567891011121314$(function () &#123; ...... //鼠标进入的时候,其他的li标签透明度：0.5 $(&quot;.wrap li&quot;).hover(function() &#123; $(this).siblings().stop().fadeTo(400, 0.5); //.stop():停止所有在指定元素上正在运行的动画。 &#125;, function() &#123; // 鼠标离开，其他li 透明度改为 1 $(this).siblings().stop().fadeTo(400, 1); &#125;); console.log($(&apos;.attr a&apos;).prop(&apos;href&apos;)); console.log($(&apos;.attr a&apos;).prop(&apos;title&apos;)); console.log($(&apos;input:checkbox&apos;).attr(&apos;id&apos;)); console.log($(&apos;.office p:eq(0)&apos;).scrollTop());&#125;) 3.2. &lt;img src=”url” width=” “&gt; &nbsp;&nbsp;&nbsp;表示在md文件中展示图片，若不想破坏图片原格式，就只需要写width或者height其中一个，另一个会自适应变化 3.3. 文本修饰:粗体，斜体… &nbsp;&nbsp;&nbsp;粗体文本用两个*或_包含，斜体文本用一个_包含 3.4. 表格(注意其格式) 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 3.5. 颜色RGB和字体以及背景颜色 12345678910&lt;font face=\"Tahoma\"&gt;这是一串Tahoma字体&lt;/font&gt;&lt;br/&gt;&lt;font face=\"黑体\"&gt;这是一串黑体字&lt;/font&gt;&lt;br/&gt;&lt;font face=\"微软雅黑\"&gt;这是一串微软雅黑&lt;/font&gt;&lt;br/&gt;&lt;font face=\"STCAIYUN\"&gt;这是一串华文彩云&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ced1 size=7 face=\"黑体\"&gt;背景色+字体+字的size&lt;/font&gt;&lt;br/&gt;&lt;font color=#00ffff size=72&gt;颜色设置&lt;/font&gt;&lt;br/&gt;&lt;font color=gray size=72&gt;灰色处理&lt;/font&gt;&lt;br/&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#bfe1f1&gt;背景色是：#bfe1f1&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3 这是一串Tahoma字体这是一串黑体字这是一串微软雅黑这是一串华文彩云背景色+字体+字的size颜色设置灰色处理 3.6. 转义字符 &lt;br&gt; : 换行\\ : 转义字符，原生字符，不加修饰&amp;nbsp; : 空格 3.7 每一篇博文设置图片 只需要在文章前面配置 photos 关键字即可，若没有这种配置，可以选择在正文插入图片，然后使用 将图片显示在摘要里 3.8 图片可点击设置，单独出现 &lt;fancybox&gt;图片设置&lt;/fancybox&gt; 4.Hexo的搜索search功能设置问题描述： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我的博客中点击search，输入相关关键字后，点击查询到的相关文章，会出现404错误 解决方法： 1.检查是否安装文档要求正确的安装了依赖包。2.检查根目录配置文件是否有search字段冲突（我的根目录配置文件中没有search字段）。3.检查我们的主题（我使用的是Material X主题）的配置文件是否开启search功能 1234567891011121314151617# 搜索配置search: enable: true service: hexo # google google_api_key: google_engine_id: # algolia algolia_app_id: algolia_api_key: algolia_index_name: # azure azure_service_name: azure_index_name: azure_query_key: # baidu baidu_api_id: 4.这是最容易忽略的，但往往也是问题出现的源头，请检查根目录配置文件中的链接是否正确，如： 1234url: https://fioralove.github.io# 这里似乎存在一个bug，推荐填写GitHub Page的访问地址，不要使用自己在阿里云以及其它的域名注册服务商所提供的地址# 比如我在阿里云所注册的https:AhriLove.top，填上依旧会出现404错误root: /","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"http://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"front-matter","slug":"front-matter","permalink":"http://ahrilove.top/tags/front-matter/"}]},{"title":"Hello Hexo","slug":"hello-world","date":"2019-10-24T16:00:00.000Z","updated":"2019-11-10T07:53:24.497Z","comments":true,"path":"2019/10/25/hello-world/","link":"","permalink":"http://ahrilove.top/2019/10/25/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"初次见面，请多关照","slug":"初次见面_请多关照","date":"2019-10-20T13:01:24.000Z","updated":"2019-11-15T13:37:12.706Z","comments":true,"path":"2019/10/20/初次见面_请多关照/","link":"","permalink":"http://ahrilove.top/2019/10/20/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2_%E8%AF%B7%E5%A4%9A%E5%85%B3%E7%85%A7/","excerpt":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示","text":"&nbsp;&nbsp;&nbsp;这是一篇有关我如何使用 Github Pages 和 Hexo 搭建属于自己独立博客的功能展示 大家好–^^__^^–，我叫陈浩东 &nbsp;&nbsp;&nbsp;本人是嘉兴双环第二分公司GP-12线,滚齿磨齿操作员，目前正学习清洗包装流程、磨齿、滚齿、齿轮生产工艺以及安全生产。&nbsp;&nbsp;&nbsp;对网站开发的有关知识几乎为零，这也是我搭建好自己的不完全博客之后写的第一篇博客，刚开始搭建博客的时候自己也是网上各种百度，由于自己属于小白那种，历经了千辛万苦才弄好，所以借这个机会会一直坚持下去分析自己的知识，一起走向成功的彼岸！","categories":[{"name":"博客Hexo","slug":"博客Hexo","permalink":"http://ahrilove.top/categories/%E5%8D%9A%E5%AE%A2Hexo/"}],"tags":[{"name":"Github Page","slug":"Github-Page","permalink":"http://ahrilove.top/tags/Github-Page/"},{"name":"Hexo","slug":"Hexo","permalink":"http://ahrilove.top/tags/Hexo/"}]}]}